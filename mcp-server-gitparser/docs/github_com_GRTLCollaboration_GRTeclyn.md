# Repository Digest: https://github.com/GRTLCollaboration/GRTeclyn

## Summary

Repository: grtlcollaboration/grteclyn
Commit: cabfdb55415afa96dbc259e7daef340788274de9
Files analyzed: 283

Estimated tokens: 370.9k

## Directory Structure

Directory structure:
└── grtlcollaboration-grteclyn/
    ├── README.md
    ├── GNUmakefile
    ├── LICENSE
    ├── run_clang_format
    ├── .clang-format
    ├── .clang-tidy
    ├── .gitlab-ci.yml
    ├── .lint-ignore
    ├── .pre-commit-config.yaml
    ├── Examples/
    │   ├── BinaryBH/
    │   │   ├── README.md
    │   │   ├── BinaryBHLevel.cpp
    │   │   ├── BinaryBHLevel.hpp
    │   │   ├── GNUmakefile
    │   │   ├── inputs.test
    │   │   ├── Main_BinaryBH.cpp
    │   │   ├── Make.package
    │   │   ├── params.txt
    │   │   ├── params_profile.txt
    │   │   ├── params_test.txt
    │   │   ├── params_two_punctures.txt
    │   │   ├── params_very_cheap.txt
    │   │   ├── SimulationParameters.hpp
    │   │   ├── StateVariables.hpp
    │   │   └── TPAMR.hpp
    │   ├── KleinGordon/
    │   │   ├── README.md
    │   │   ├── DerivedVariables.hpp
    │   │   ├── DerivedVariables.impl.hpp
    │   │   ├── GNUmakefile
    │   │   ├── KleinGordonLevel.cpp
    │   │   ├── KleinGordonLevel.hpp
    │   │   ├── KleinGordonRHS.hpp
    │   │   ├── KleinGordonRHS.impl.hpp
    │   │   ├── Main_KleinGordon.cpp
    │   │   ├── Make.package
    │   │   ├── params_test.txt
    │   │   ├── SimulationParameters.hpp
    │   │   ├── SineGordon.hpp
    │   │   ├── StateVariables.hpp
    │   │   └── Wave.hpp
    │   └── ScalarField/
    │       ├── GNUmakefile.old
    │       ├── InitialScalarData.hpp
    │       ├── Main_ScalarField.cpp
    │       ├── params.txt
    │       ├── Potential.hpp
    │       ├── ScalarFieldLevel.cpp
    │       ├── ScalarFieldLevel.hpp
    │       ├── SimulationParameters.hpp
    │       └── StateVariables.hpp
    ├── external/
    │   └── doctest/
    │       ├── doctest.h
    │       └── .clang-format
    ├── Source/
    │   ├── AMRInterpolator/
    │   │   ├── AMRInterpolator.hpp
    │   │   ├── AMRInterpolator.impl.hpp
    │   │   ├── CylindricalExtraction.hpp
    │   │   ├── CylindricalGeometry.hpp
    │   │   ├── Derivative.hpp
    │   │   ├── DerivativeSetup.hpp
    │   │   ├── IntegrationMethod.hpp
    │   │   ├── IntegrationMethodSetup.hpp
    │   │   ├── InterpolationAlgorithm.hpp
    │   │   ├── InterpolationLayout.hpp
    │   │   ├── InterpolationQuery.hpp
    │   │   ├── InterpSource.hpp
    │   │   ├── Lagrange.hpp
    │   │   ├── Lagrange.impl.hpp
    │   │   ├── Make.package
    │   │   ├── MPIContext.hpp
    │   │   ├── MPIContext.impl.hpp
    │   │   ├── MPILayout.hpp
    │   │   ├── MPILayout.impl.hpp
    │   │   ├── QuinticConvolution.hpp
    │   │   ├── QuinticConvolution.impl.hpp
    │   │   ├── SphericalExtraction.hpp
    │   │   ├── SphericalGeometry.hpp
    │   │   ├── SurfaceExtraction.hpp
    │   │   ├── SurfaceExtraction.impl.hpp
    │   │   └── WeylExtraction.hpp
    │   ├── BlackHoles/
    │   │   ├── BHAMR.hpp
    │   │   ├── BinaryBHInitialData.hpp
    │   │   ├── BinaryBHInitialData.impl.hpp
    │   │   ├── BoostedBHInitialData.hpp
    │   │   ├── BoostedBHInitialData.impl.hpp
    │   │   ├── KerrBHInitialData.hpp
    │   │   ├── KerrBHInitialData.impl.hpp
    │   │   ├── Make.package
    │   │   ├── PunctureTracker.hpp
    │   │   ├── PunctureTracker.impl.hpp
    │   │   ├── TwoPuncturesInitialData.hpp
    │   │   └── TwoPuncturesInitialData.impl.hpp
    │   ├── CCZ4/
    │   │   ├── ADMConformalVars.hpp
    │   │   ├── BSSNVars.hpp
    │   │   ├── CCZ4Geometry.hpp
    │   │   ├── CCZ4RHS.hpp
    │   │   ├── CCZ4RHS.impl.hpp
    │   │   ├── CCZ4StateVariables.hpp
    │   │   ├── CCZ4Vars.hpp
    │   │   ├── Constraints.hpp
    │   │   ├── Constraints.impl.hpp
    │   │   ├── GammaCalculator.hpp
    │   │   ├── IntegratedMovingPunctureGauge.hpp
    │   │   ├── Make.package
    │   │   ├── MovingPunctureGauge.hpp
    │   │   ├── PositiveChiAndLapse.hpp
    │   │   ├── TraceARemoval.hpp
    │   │   ├── Weyl4.hpp
    │   │   └── Weyl4.impl.hpp
    │   ├── Grids/
    │   │   ├── BCParity.hpp
    │   │   ├── BoundaryConditions.cpp
    │   │   ├── BoundaryConditions.hpp
    │   │   ├── Cell.hpp
    │   │   ├── Coordinates.hpp
    │   │   ├── DimensionDefinitions.hpp
    │   │   ├── FourthOrderDerivatives.hpp
    │   │   ├── Make.package
    │   │   ├── NullBCFill.hpp
    │   │   ├── SixthOrderDerivatives.hpp
    │   │   ├── Tensor.hpp
    │   │   └── VarsTools.hpp
    │   ├── GRTeclynCore/
    │   │   ├── AlwaysInline.hpp
    │   │   ├── AMReXParameters.hpp
    │   │   ├── ArrayTools.hpp
    │   │   ├── DefaultLevelFactory.hpp
    │   │   ├── GRAMR.cpp
    │   │   ├── GRAMR.hpp
    │   │   ├── GRAMRLevel.cpp
    │   │   ├── GRAMRLevel.hpp
    │   │   ├── GRInterval.hpp
    │   │   ├── Interval.hpp
    │   │   ├── Make.package
    │   │   ├── SetupFunctions.hpp
    │   │   ├── SimulationParametersBase.hpp
    │   │   └── VariableType.hpp
    │   ├── IO/
    │   │   ├── DebuggingTools.hpp
    │   │   ├── FilesystemTools.hpp
    │   │   ├── GRParmParse.hpp
    │   │   ├── Make.package
    │   │   ├── MultiLevelTask.hpp
    │   │   ├── SmallDataIO.cpp
    │   │   ├── SmallDataIO.hpp
    │   │   └── StateVariablesParmParse.hpp
    │   ├── Maths/
    │   │   ├── Combinatorics.hpp
    │   │   ├── CoordinateTransformations.hpp
    │   │   ├── Make.package
    │   │   ├── SphericalHarmonics.hpp
    │   │   └── TensorAlgebra.hpp
    │   ├── Matter/
    │   │   ├── CCZ4RHSWithMatter.hpp
    │   │   ├── CCZ4RHSWithMatter.impl.hpp
    │   │   ├── ConstraintsWithMatter.hpp
    │   │   ├── ConstraintsWithMatter.impl.hpp
    │   │   ├── DefaultPotential.hpp
    │   │   ├── EMTensor.hpp
    │   │   ├── EMTensor.impl.hpp
    │   │   ├── Make.package
    │   │   ├── MovingPunctureGaugeWithMatter.hpp
    │   │   ├── ScalarField.hpp
    │   │   ├── ScalarField.impl.hpp
    │   │   ├── Weyl4WithMatter.hpp
    │   │   ├── Weyl4WithMatter.impl.hpp
    │   │   └── MatterCCZ4.hpp -> MatterCCZ4RHS.hpp
    │   └── Tagging/
    │       ├── ChiTagger.hpp
    │       ├── ExtractionTagger.hpp
    │       ├── FixedGridsTagger.hpp
    │       ├── Make.package
    │       └── PunctureTagger.hpp
    ├── Tests/
    │   ├── README.md
    │   ├── GNUmakefile
    │   ├── Make.package
    │   ├── TestCases.hpp
    │   ├── Tests.cpp
    │   ├── BSSNMatterTest/
    │   │   ├── BSSNMatterTest.cpp
    │   │   ├── BSSNMatterTest.hpp
    │   │   └── Make.package
    │   ├── CCZ4GeometryUnitTests/
    │   │   ├── CCZ4GeometryMathematicaValues.hpp
    │   │   ├── CCZ4GeometryUnitTest.cpp
    │   │   ├── CCZ4GeometryUnitTest.hpp
    │   │   ├── Make.package
    │   │   └── Mathematica_comparison.nb
    │   ├── CCZ4RHSTest/
    │   │   ├── ADMConformalVars-fdf5a7a.hpp
    │   │   ├── BSSNVars-fdf5a7a.hpp
    │   │   ├── CCZ4Geometry-fdf5a7a.hpp
    │   │   ├── CCZ4RHS-fdf5a7a.hpp
    │   │   ├── CCZ4RHS-fdf5a7a.impl.hpp
    │   │   ├── CCZ4RHSTest.cpp
    │   │   ├── CCZ4RHSTest.hpp
    │   │   ├── CCZ4Vars-fdf5a7a.hpp
    │   │   ├── Cell-fdf5a7a.hpp
    │   │   ├── FourthOrderDerivatives-fdf5a7a.hpp
    │   │   ├── GRInterval-fdf5a7a.hpp
    │   │   ├── Make.package
    │   │   ├── MovingPunctureGauge-fdf5a7a.hpp
    │   │   ├── simd.hpp
    │   │   ├── simd_base.hpp
    │   │   ├── simdify.hpp
    │   │   ├── Tensor-fdf5a7a.hpp
    │   │   ├── TensorAlgebra-fdf5a7a.hpp
    │   │   ├── VarsTools-fdf5a7a.hpp
    │   │   └── x64/
    │   │       ├── avx.hpp
    │   │       ├── avx512.hpp
    │   │       ├── sse.hpp
    │   │       └── x64.hpp
    │   ├── Common/
    │   │   ├── doctestCLIArgs.hpp
    │   │   ├── doctestOutput.hpp
    │   │   ├── InitialData.hpp
    │   │   ├── Make.package
    │   │   ├── SimulationParameters.hpp
    │   │   └── StateVariables.hpp
    │   ├── ConstraintsTest/
    │   │   ├── ConstraintsGRChombo.hdf5
    │   │   ├── ConstraintsTest.cpp
    │   │   ├── ConstraintsTest.hpp
    │   │   └── Make.package
    │   ├── CoordinateTransformationsTest/
    │   │   ├── CoordinateTransformationsTest.cpp
    │   │   ├── CoordinateTransformationsTest.hpp
    │   │   └── Make.package
    │   ├── DerivativeUnitTests/
    │   │   ├── DerivativeTestsCompute.hpp
    │   │   ├── DerivativeUnitTests.cpp
    │   │   ├── DerivativeUnitTests.hpp
    │   │   └── Make.package
    │   ├── EMTensorTest/
    │   │   ├── EMTensorTest.cpp
    │   │   ├── EMTensorTest.hpp
    │   │   └── Make.package
    │   ├── PositiveChiAndLapseUnitTest/
    │   │   ├── Make.package
    │   │   ├── PositiveChiAndLapseUnitTest.cpp
    │   │   └── PositiveChiAndLapseUnitTest.hpp
    │   ├── PunctureTrackerTest/
    │   │   ├── Make.package
    │   │   ├── PunctureTrackerLevel.cpp
    │   │   ├── PunctureTrackerLevel.hpp
    │   │   ├── PunctureTrackerTest.cpp
    │   │   ├── PunctureTrackerTest.hpp
    │   │   └── test.inputs
    │   ├── SmallDataIOTest/
    │   │   ├── Make.package
    │   │   ├── SmallDataIOTest.cpp
    │   │   └── SmallDataIOTest.hpp
    │   ├── SphericalHarmonicTest/
    │   │   ├── HarmonicTest.hpp
    │   │   ├── HarmonicTest.impl.hpp
    │   │   ├── Make.package
    │   │   ├── SphericalHarmonicTest.cpp
    │   │   └── SphericalHarmonicTest.hpp
    │   ├── Weyl4Test/
    │   │   ├── Make.package
    │   │   ├── Weyl4GRChombo.hdf5
    │   │   ├── Weyl4Test.cpp
    │   │   └── Weyl4Test.hpp
    │   ├── Weyl4WithMatterTest/
    │   │   ├── Make.package
    │   │   ├── Weyl4WithMatterTest.cpp
    │   │   └── Weyl4WithMatterTest.hpp
    │   ├── .AMRInterpolatorTest/
    │   │   ├── AMRInterpolatorTest.cpp
    │   │   ├── AMRInterpolatorTest.inputs
    │   │   ├── GNUmakefile
    │   │   ├── InterpolatorTestLevel.hpp
    │   │   ├── Polynomial.hpp
    │   │   ├── SimulationParameters.hpp
    │   │   ├── StateVariables.hpp
    │   │   └── UserVariables.hpp
    │   └── .SphericalExtractionTest/
    │       ├── GNUmakefile
    │       ├── SetHarmonic.hpp
    │       ├── SetHarmonic.impl.hpp
    │       ├── SimulationParameters.hpp
    │       ├── SphericalExtractionTest.cpp
    │       ├── SphericalExtractionTest.inputs
    │       ├── SphericalExtractionTestLevel.hpp
    │       ├── StateVariables.hpp
    │       └── UserVariables.hpp
    ├── Tools/
    │   ├── CopyrightHeaders/
    │   │   ├── add_copyright_headers
    │   │   ├── check_copyright_headers
    │   │   └── copyright_header
    │   ├── Doxygen/
    │   │   ├── README
    │   │   ├── doxygen_config
    │   │   └── title_page.md
    │   └── GNUMake/
    │       ├── Make.defaults
    │       └── Make.rules
    ├── .github/
    │   ├── CODEOWNERS
    │   ├── dependabot.yml
    │   └── workflows/
    │       ├── check-changes.yml
    │       ├── gpu-build.yml
    │       ├── lint-ignore.yml
    │       ├── lint.yml
    │       ├── regression-tests-examples-template.yml
    │       ├── regression-tests.yml
    │       ├── style.yml
    │       ├── unit-tests.yml
    │       ├── regression-tests-setup/
    │       │   └── action.yml
    │       └── style/
    │           ├── check_tabs.sh
    │           └── check_trailing_whitespaces.sh
    └── .gitlab/
        ├── run-examples.sh
        └── .gitlab-ci-common.yml


## Content

================================================
FILE: README.md
================================================
# GRTeclyn

GRTeclyn (previously referred to as GRAMReX) is a new numerical relativity code developed by the [GRTL Collaboration](https://www.grtlcollaboration.org) that is currently still under development.  It is a port of the [GRChombo code](https://github.com/GRChombo/GRChombo) (based on the Chombo libraries) to the [AMReX](https://amrex-codes.github.io/) library in order to leverage AMReX's support for GPUs and ongoing active development.

The AMReX documentation can be found [here](https://amrex-codes.github.io/amrex/docs_html).

The name follows a similar pattern to GRChombo, namely "GR" + "\<Tool in a foreign language\>". In this case, "Teclyn" is a Welsh word for "Tool".

## Development status

Please consult this [documentation page](https://grtlcollaboration.github.io/GRTeclyn/#summary-of-features) for a list of the development status of specific features.

## Documentation

Documentation can be found [here](https://grtlcollaboration.github.io/GRTeclyn/) (under construction). Note that the GitHub wiki is no longer in use.

The documentation contains useful information on obtaining and building the code, prerequisities and running the binary black hole example.

## License

GRTeclyn is licensed under the BSD 3-Clause License. Please see [LICENSE](LICENSE) for details.


================================================
FILE: GNUmakefile
================================================
define SEARCH_FOR_MAKE
$(wildcard $1/*/GNUmakefile) $(wildcard $1/*/makefile) $(wildcard $1/*/Makefile)
endef

GRTECLYN_HOME = $(realpath .)

TestsDir := $(GRTECLYN_HOME)/Tests
ExampleDirsWithGNUmakefile := $(call SEARCH_FOR_MAKE, $(GRTECLYN_HOME)/Examples)
ExampleDirs := $(dir $(ExampleDirsWithGNUmakefile))
CleanExampleDirs := $(ExampleDirs:%=clean-%)
CleanConfigTestsDir := $(TestsDir:%=cleanconfig-%)
CleanConfigExampleDirs := $(ExampleDirs:%=cleanconfig-%)

.PHONY: all examples tests tests-config run clean cleanconfig $(ExampleDirs)

ECHO?=@ # set this to null on the command line to increase verbosity

tests: tests-config
	$(info ################# Making Tests #################)
	$(ECHO)$(MAKE) -C $(TestsDir) --no-print-directory

# Separate this out from the tests target just to avoid the race condition
# when doing make all (see below).
tests-config:
	$(ECHO)$(MAKE) -C $(TestsDir) --no-print-directory AMReX_Config.H
	$(ECHO)$(MAKE) -C $(TestsDir) --no-print-directory AMReX_Version.H

run: tests
	$(info ################# Running Tests #################)
	$(ECHO)$(MAKE) -C $(TestsDir) --no-print-directory run

examples: $(ExampleDirs)

all: tests examples

clean: clean-testsdir $(CleanExampleDirs)

cleanconfig: $(CleanConfigTestsDir) $(CleanConfigExampleDirs)

# We add the tests-config dependency just for the case where the build
# configuration is the same for tests and examples to avoid the race condition
# in generating AMReX_Config.H and AMReX_Version.H when doing make all.
$(ExampleDirs): tests-config
	$(info ################# Making example $@ #################)
	$(ECHO)$(MAKE) -C $@ --no-print-directory

clean-testsdir:
	$(ECHO)$(MAKE) -C $(TestsDir) --no-print-directory clean

$(CleanExampleDirs):
	$(ECHO)$(MAKE) -C $(@:clean-%=%) --no-print-directory clean 

$(CleanConfigTestsDir):
	$(ECHO)$(MAKE) -C $(@:cleanconfig-%=%) --no-print-directory cleanconfig 

$(CleanConfigExampleDirs):
	$(ECHO)$(MAKE) -C $(@:cleanconfig-%=%) --no-print-directory cleanconfig 



================================================
FILE: LICENSE
================================================
BSD 3-Clause License

Copyright (c) 2018, GRChombo
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



================================================
FILE: run_clang_format
================================================
for f in $(find . -name "*.hpp" -not -path "./External/*"); do clang-format -style=file -i $f; done
for f in $(find . -name "*.cpp" -not -path "./External/*"); do clang-format -style=file -i $f; done



================================================
FILE: .clang-format
================================================
---
Language:        Cpp
# BasedOnStyle:  LLVM
AccessModifierOffset: -2
AlignAfterOpenBracket: Align
AlignArrayOfStructures: Left
AlignConsecutiveAssignments:
  Enabled:         true
  AcrossEmptyLines: false
  AcrossComments:  false
  AlignCompound:   true
  PadOperators:    true
AlignConsecutiveBitFields:
  Enabled:         false
  AcrossEmptyLines: false
  AcrossComments:  false
  AlignCompound:   false
  PadOperators:    false
AlignConsecutiveDeclarations:
  Enabled:         false
  AcrossEmptyLines: false
  AcrossComments:  false
  AlignCompound:   false
  PadOperators:    false
AlignConsecutiveMacros:
  Enabled:         false
  AcrossEmptyLines: false
  AcrossComments:  false
  AlignCompound:   false
  PadOperators:    false
AlignEscapedNewlines: Right
AlignOperands:   Align
AlignTrailingComments: true
AllowAllArgumentsOnNextLine: true
AllowAllParametersOfDeclarationOnNextLine: true
AllowShortEnumsOnASingleLine: true
AllowShortBlocksOnASingleLine: Never
AllowShortCaseLabelsOnASingleLine: false
AllowShortFunctionsOnASingleLine: All
AllowShortLambdasOnASingleLine: All
AllowShortIfStatementsOnASingleLine: Never
AllowShortLoopsOnASingleLine: false
AlwaysBreakAfterDefinitionReturnType: None
AlwaysBreakAfterReturnType: None
AlwaysBreakBeforeMultilineStrings: false
AlwaysBreakTemplateDeclarations: MultiLine
AttributeMacros:
  - __capability
BinPackArguments: true
BinPackParameters: true
BraceWrapping:
  AfterCaseLabel:  false
  AfterClass:      false
  AfterControlStatement: Always
  AfterEnum:       false
  AfterFunction:   false
  AfterNamespace:  false
  AfterObjCDeclaration: false
  AfterStruct:     false
  AfterUnion:      false
  AfterExternBlock: false
  BeforeCatch:     false
  BeforeElse:      false
  BeforeLambdaBody: false
  BeforeWhile:     false
  IndentBraces:    false
  SplitEmptyFunction: true
  SplitEmptyRecord: true
  SplitEmptyNamespace: true
BreakBeforeBinaryOperators: None
BreakBeforeConceptDeclarations: Always
BreakBeforeBraces: Allman
BreakBeforeInheritanceComma: false
BreakInheritanceList: BeforeColon
BreakBeforeTernaryOperators: true
BreakConstructorInitializersBeforeComma: false
BreakConstructorInitializers: BeforeColon
BreakAfterJavaFieldAnnotations: false
BreakStringLiterals: true
ColumnLimit:     80
CommentPragmas:  '^ IWYU pragma:'
QualifierAlignment: Leave
CompactNamespaces: false
ConstructorInitializerIndentWidth: 4
ContinuationIndentWidth: 4
Cpp11BracedListStyle: true
DeriveLineEnding: true
DerivePointerAlignment: false
DisableFormat:   false
EmptyLineAfterAccessModifier: Leave
EmptyLineBeforeAccessModifier: LogicalBlock
ExperimentalAutoDetectBinPacking: false
PackConstructorInitializers: BinPack
BasedOnStyle:    ''
ConstructorInitializerAllOnOneLineOrOnePerLine: false
AllowAllConstructorInitializersOnNextLine: true
FixNamespaceComments: true
ForEachMacros:
  - foreach
  - Q_FOREACH
  - BOOST_FOREACH
  - FOR
  - FOR1
  - FOR2
  - FOR3
  - FOR4
  - FOR5
IfMacros:
  - KJ_IF_MAYBE
IncludeBlocks:   Preserve
IncludeCategories:
  - Regex:           '^"AMReX_'
    Priority:        4
    CaseSensitive:   false
  - Regex:           '^"(llvm|llvm-c|clang|clang-c)/'
    Priority:        2
    SortPriority:    0
    CaseSensitive:   false
  - Regex:           '^(<|"(gtest|gmock|isl|json)/)'
    Priority:        3
    SortPriority:    0
    CaseSensitive:   false
  - Regex:           '.*'
    Priority:        1
    SortPriority:    0
    CaseSensitive:   false
IncludeIsMainRegex: '(Test)?$'
IncludeIsMainSourceRegex: ''
IndentAccessModifiers: false
IndentCaseLabels: false
IndentCaseBlocks: false
IndentGotoLabels: true
IndentPPDirectives: None
IndentExternBlock: AfterExternBlock
IndentRequiresClause: true
IndentWidth:     4
IndentWrappedFunctionNames: false
InsertBraces:    false
InsertTrailingCommas: None
JavaScriptQuotes: Leave
JavaScriptWrapImports: true
KeepEmptyLinesAtTheStartOfBlocks: true
LambdaBodyIndentation: Signature
MacroBlockBegin: ''
MacroBlockEnd:   ''
MaxEmptyLinesToKeep: 1
NamespaceIndentation: None
ObjCBinPackProtocolList: Auto
ObjCBlockIndentWidth: 2
ObjCBreakBeforeNestedBlockParam: true
ObjCSpaceAfterProperty: false
ObjCSpaceBeforeProtocolList: true
PenaltyBreakAssignment: 2
PenaltyBreakBeforeFirstCallParameter: 19
PenaltyBreakComment: 300
PenaltyBreakFirstLessLess: 120
PenaltyBreakOpenParenthesis: 0
PenaltyBreakString: 1000
PenaltyBreakTemplateDeclaration: 10
PenaltyExcessCharacter: 1000000
PenaltyReturnTypeOnItsOwnLine: 60
PenaltyIndentedWhitespace: 0
PointerAlignment: Right
PPIndentWidth:   -1
ReferenceAlignment: Pointer
ReflowComments:  true
RemoveBracesLLVM: false
RequiresClausePosition: OwnLine
SeparateDefinitionBlocks: Leave
ShortNamespaceLines: 1
SortIncludes:    CaseSensitive
SortJavaStaticImport: Before
SortUsingDeclarations: true
SpaceAfterCStyleCast: false
SpaceAfterLogicalNot: false
SpaceAfterTemplateKeyword: true
SpaceBeforeAssignmentOperators: true
SpaceBeforeCaseColon: false
SpaceBeforeCpp11BracedList: false
SpaceBeforeCtorInitializerColon: true
SpaceBeforeInheritanceColon: true
SpaceBeforeParens: ControlStatements
SpaceBeforeParensOptions:
  AfterControlStatements: true
  AfterForeachMacros: true
  AfterFunctionDefinitionName: false
  AfterFunctionDeclarationName: false
  AfterIfMacros:   true
  AfterOverloadedOperator: false
  AfterRequiresInClause: false
  AfterRequiresInExpression: false
  BeforeNonEmptyParentheses: false
SpaceAroundPointerQualifiers: Default
SpaceBeforeRangeBasedForLoopColon: true
SpaceInEmptyBlock: false
SpaceInEmptyParentheses: false
SpacesBeforeTrailingComments: 1
SpacesInAngles:  Never
SpacesInConditionalStatement: false
SpacesInContainerLiterals: true
SpacesInCStyleCastParentheses: false
SpacesInLineCommentPrefix:
  Minimum:         1
  Maximum:         -1
SpacesInParentheses: false
SpacesInSquareBrackets: false
SpaceBeforeSquareBrackets: false
BitFieldColonSpacing: Both
Standard:        c++17
StatementAttributeLikeMacros:
  - Q_EMIT
StatementMacros:
  - Q_UNUSED
  - QT_REQUIRE_VERSION
TabWidth:        8
UseCRLF:         false
UseTab:          Never
WhitespaceSensitiveMacros:
  - STRINGIZE
  - PP_STRINGIZE
  - BOOST_PP_STRINGIZE
  - NS_SWIFT_NAME
  - CF_SWIFT_NAME
...




================================================
FILE: .clang-tidy
================================================
---
Checks: >
     clang-diagnostic-*,
     clang-analyzer-*,
     bugprone-*,
     cppcoreguidelines-*,
      -cppcoreguidelines-no-malloc,
      -cppcoreguidelines-avoid-magic-numbers,
      -cppcoreguidelines-pro-bounds-constant-array-index,
      -cppcoreguidelines-pro-bounds-pointer-arithmetic,
      -cppcoreguidelines-non-private-member-variables-in-classes,
     modernize-*,
      -modernize-use-trailing-return-type,
     mpi-*,
     performance-*,
      -performance-enum-size,
     readability-*,
      -readability-math-missing-parentheses,
      -readability-magic-numbers,
      -readability-avoid-const-params-in-decls,
      -readability-avoid-unconditional-preprocessor-if,
WarningsAsErrors: ''
HeaderFilterRegex: '.*\.hpp'
FormatStyle:     file
CheckOptions:
  - key:             modernize-replace-auto-ptr.IncludeStyle
    value:           llvm
  - key:             cppcoreguidelines-no-malloc.Reallocations
    value:           '::realloc'
  - key:             cppcoreguidelines-owning-memory.LegacyResourceConsumers
    value:           '::free;::realloc;::freopen;::fclose'
  - key:             readability-static-accessed-through-instance.NameSpecifierNestingThreshold
    value:           '3'
  - key:             readability-function-size.VariableThreshold
    value:           '4294967295'
  - key:             modernize-use-auto.MinTypeNameLength
    value:           '5'
  - key:             bugprone-reserved-identifier.Invert
    value:           'false'
  - key:             performance-move-const-arg.CheckTriviallyCopyableMove
    value:           'true'
  - key:             cert-dcl16-c.NewSuffixes
    value:           'L;LL;LU;LLU'
  - key:             bugprone-narrowing-conversions.WarnOnFloatingPointNarrowingConversion
    value:           'true'
  - key:             readability-identifier-naming.GetConfigPerFile
    value:           'true'
  - key:             bugprone-narrowing-conversions.PedanticMode
    value:           'false'
  - key:             readability-inconsistent-declaration-parameter-name.Strict
    value:           'false'
  - key:             cppcoreguidelines-macro-usage.CheckCapsOnly
    value:           'false'
  - key:             bugprone-unused-return-value.CheckedFunctions
    value:           '::std::async;::std::launder;::std::remove;::std::remove_if;::std::unique;::std::unique_ptr::release;::std::basic_string::empty;::std::vector::empty;::std::back_inserter;::std::distance;::std::find;::std::find_if;::std::inserter;::std::lower_bound;::std::make_pair;::std::map::count;::std::map::find;::std::map::lower_bound;::std::multimap::equal_range;::std::multimap::upper_bound;::std::set::count;::std::set::find;::std::setfill;::std::setprecision;::std::setw;::std::upper_bound;::std::vector::at;::bsearch;::ferror;::feof;::isalnum;::isalpha;::isblank;::iscntrl;::isdigit;::isgraph;::islower;::isprint;::ispunct;::isspace;::isupper;::iswalnum;::iswprint;::iswspace;::isxdigit;::memchr;::memcmp;::strcmp;::strcoll;::strncmp;::strpbrk;::strrchr;::strspn;::strstr;::wcscmp;::access;::bind;::connect;::difftime;::dlsym;::fnmatch;::getaddrinfo;::getopt;::htonl;::htons;::iconv_open;::inet_addr;::isascii;::isatty;::mmap;::newlocale;::openat;::pathconf;::pthread_equal;::pthread_getspecific;::pthread_mutex_trylock;::readdir;::readlink;::recvmsg;::regexec;::scandir;::semget;::setjmp;::shm_open;::shmget;::sigismember;::strcasecmp;::strsignal;::ttyname'
  - key:             modernize-use-default-member-init.UseAssignment
    value:           'false'
  - key:             readability-function-size.NestingThreshold
    value:           '4294967295'
  - key:             modernize-use-override.AllowOverrideAndFinal
    value:           'false'
  - key:             readability-function-size.ParameterThreshold
    value:           '4294967295'
  - key:             modernize-pass-by-value.ValuesOnly
    value:           'false'
  - key:             modernize-loop-convert.IncludeStyle
    value:           llvm
  - key:             cert-str34-c.DiagnoseSignedUnsignedCharComparisons
    value:           '0'
  - key:             bugprone-suspicious-string-compare.WarnOnLogicalNotComparison
    value:           'false'
  - key:             cppcoreguidelines-explicit-virtual-functions.AllowOverrideAndFinal
    value:           'false'
  - key:             readability-redundant-smartptr-get.IgnoreMacros
    value:           'true'
  - key:             readability-identifier-naming.AggressiveDependentMemberLookup
    value:           'false'
  - key:             bugprone-suspicious-string-compare.WarnOnImplicitComparison
    value:           'true'
  - key:             modernize-use-emplace.TupleTypes
    value:           '::std::pair;::std::tuple'
  - key:             modernize-use-emplace.TupleMakeFunctions
    value:           '::std::make_pair;::std::make_tuple'
  - key:             cppcoreguidelines-owning-memory.LegacyResourceProducers
    value:           '::malloc;::aligned_alloc;::realloc;::calloc;::fopen;::freopen;::tmpfile'
  - key:             bugprone-argument-comment.CommentNullPtrs
    value:           '0'
  - key:             bugprone-argument-comment.StrictMode
    value:           '0'
  - key:             cppcoreguidelines-init-variables.IncludeStyle
    value:           llvm
  - key:             modernize-use-nodiscard.ReplacementString
    value:           '[[nodiscard]]'
  - key:             modernize-loop-convert.MakeReverseRangeHeader
    value:           ''
  - key:             modernize-replace-random-shuffle.IncludeStyle
    value:           llvm
  - key:             cppcoreguidelines-narrowing-conversions.WarnOnFloatingPointNarrowingConversion
    value:           'true'
  - key:             modernize-use-bool-literals.IgnoreMacros
    value:           'true'
  - key:             bugprone-unhandled-self-assignment.WarnOnlyIfThisHasSuspiciousField
    value:           'true'
  - key:             google-readability-namespace-comments.ShortNamespaceLines
    value:           '10'
  - key:             bugprone-suspicious-string-compare.StringCompareLikeFunctions
    value:           ''
  - key:             modernize-avoid-bind.PermissiveParameterList
    value:           'false'
  - key:             modernize-use-override.FinalSpelling
    value:           final
  - key:             performance-move-constructor-init.IncludeStyle
    value:           llvm
  - key:             modernize-loop-convert.UseCxx20ReverseRanges
    value:           'true'
  - key:             modernize-use-noexcept.ReplacementString
    value:           ''
  - key:             modernize-use-using.IgnoreMacros
    value:           'true'
  - key:             performance-type-promotion-in-math-fn.IncludeStyle
    value:           llvm
  - key:             cppcoreguidelines-explicit-virtual-functions.FinalSpelling
    value:           final
  - key:             modernize-loop-convert.NamingStyle
    value:           CamelCase
  - key:             bugprone-suspicious-include.ImplementationFileExtensions
    value:           'c;cc;cpp;cxx'
  - key:             cppcoreguidelines-pro-type-member-init.UseAssignment
    value:           'false'
  - key:             modernize-loop-convert.MakeReverseRangeFunction
    value:           ''
  - key:             bugprone-suspicious-include.HeaderFileExtensions
    value:           ';h;hh;hpp;hxx'
  - key:             performance-no-automatic-move.AllowedTypes
    value:           ''
  - key:             performance-for-range-copy.WarnOnAllAutoCopies
    value:           'false'
  - key:             bugprone-argument-comment.CommentIntegerLiterals
    value:           '0'
  - key:             bugprone-suspicious-missing-comma.SizeThreshold
    value:           '5'
  - key:             readability-inconsistent-declaration-parameter-name.IgnoreMacros
    value:           'true'
  - key:             readability-identifier-naming.IgnoreFailedSplit
    value:           'false'
  - key:             modernize-pass-by-value.IncludeStyle
    value:           llvm
  - key:             bugprone-sizeof-expression.WarnOnSizeOfThis
    value:           'true'
  - key:             readability-qualified-auto.AddConstToQualified
    value:           'true'
  - key:             bugprone-string-constructor.WarnOnLargeLength
    value:           'true'
  - key:             bugprone-too-small-loop-variable.MagnitudeBitsUpperLimit
    value:           '16'
  - key:             readability-simplify-boolean-expr.ChainedConditionalReturn
    value:           'false'
  - key:             cppcoreguidelines-explicit-virtual-functions.OverrideSpelling
    value:           override
  - key:             readability-else-after-return.WarnOnConditionVariables
    value:           'true'
  - key:             readability-uppercase-literal-suffix.IgnoreMacros
    value:           'true'
  - key:             modernize-use-nullptr.NullMacros
    value:           'NULL'
  - key:             modernize-make-shared.IgnoreMacros
    value:           'true'
  - key:             bugprone-dynamic-static-initializers.HeaderFileExtensions
    value:           ';h;hh;hpp;hxx'
  - key:             bugprone-suspicious-enum-usage.StrictMode
    value:           'false'
  - key:             performance-unnecessary-copy-initialization.AllowedTypes
    value:           ''
  - key:             bugprone-suspicious-missing-comma.MaxConcatenatedTokens
    value:           '5'
  - key:             modernize-use-transparent-functors.SafeMode
    value:           'false'
  - key:             cppcoreguidelines-macro-usage.AllowedRegexp
    value:           '^DEBUG_*'
  - key:             modernize-make-shared.IgnoreDefaultInitialization
    value:           'true'
  - key:             bugprone-argument-comment.CommentCharacterLiterals
    value:           '0'
  - key:             cppcoreguidelines-narrowing-conversions.PedanticMode
    value:           'false'
  - key:             bugprone-not-null-terminated-result.WantToUseSafeFunctions
    value:           'true'
  - key:             modernize-make-shared.IncludeStyle
    value:           llvm
  - key:             bugprone-string-constructor.LargeLengthThreshold
    value:           '8388608'
  - key:             readability-simplify-boolean-expr.ChainedConditionalAssignment
    value:           'false'
  - key:             cppcoreguidelines-special-member-functions.AllowMissingMoveFunctions
    value:           'false'
  - key:             cert-oop54-cpp.WarnOnlyIfThisHasSuspiciousField
    value:           '0'
  - key:             bugprone-exception-escape.FunctionsThatShouldNotThrow
    value:           ''
  - key:             bugprone-signed-char-misuse.CharTypdefsToIgnore
    value:           ''
  - key:             performance-inefficient-vector-operation.EnableProto
    value:           'false'
  - key:             modernize-loop-convert.MaxCopySize
    value:           '16'
  - key:             bugprone-argument-comment.CommentFloatLiterals
    value:           '0'
  - key:             readability-function-size.LineThreshold
    value:           '4294967295'
  - key:             bugprone-argument-comment.CommentStringLiterals
    value:           '0'
  - key:             modernize-make-shared.MakeSmartPtrFunction
    value:           'std::make_shared'
  - key:             cppcoreguidelines-explicit-virtual-functions.IgnoreDestructors
    value:           'true'
  - key:             modernize-make-unique.IgnoreMacros
    value:           'true'
  - key:             performance-for-range-copy.AllowedTypes
    value:           ''
  - key:             modernize-make-shared.MakeSmartPtrFunctionHeader
    value:           '<memory>'
  - key:             modernize-use-override.IgnoreDestructors
    value:           'false'
  - key:             bugprone-sizeof-expression.WarnOnSizeOfConstant
    value:           'true'
  - key:             readability-redundant-string-init.StringNames
    value:           '::std::basic_string_view;::std::basic_string'
  - key:             modernize-make-unique.IgnoreDefaultInitialization
    value:           'true'
  - key:             modernize-use-emplace.ContainersWithPushBack
    value:           '::std::vector;::std::list;::std::deque'
  - key:             modernize-make-unique.IncludeStyle
    value:           llvm
  - key:             readability-braces-around-statements.ShortStatementLines
    value:           '0'
  - key:             bugprone-argument-comment.CommentUserDefinedLiterals
    value:           '0'
  - key:             bugprone-argument-comment.CommentBoolLiterals
    value:           '0'
  - key:             modernize-use-override.OverrideSpelling
    value:           override
  - key:             performance-inefficient-string-concatenation.StrictMode
    value:           'false'
  - key:             readability-implicit-bool-conversion.AllowPointerConditions
    value:           'false'
  - key:             readability-redundant-declaration.IgnoreMacros
    value:           'true'
  - key:             google-readability-braces-around-statements.ShortStatementLines
    value:           '1'
  - key:             modernize-make-unique.MakeSmartPtrFunction
    value:           'std::make_unique'
  - key:             cppcoreguidelines-pro-type-member-init.IgnoreArrays
    value:           'false'
  - key:             readability-else-after-return.WarnOnUnfixable
    value:           'true'
  - key:             bugprone-reserved-identifier.AllowedIdentifiers
    value:           ''
  - key:             modernize-use-emplace.IgnoreImplicitConstructors
    value:           'false'
  - key:             modernize-make-unique.MakeSmartPtrFunctionHeader
    value:           '<memory>'
  - key:             cppcoreguidelines-macro-usage.IgnoreCommandLineMacros
    value:           'true'
  - key:             modernize-use-equals-delete.IgnoreMacros
    value:           'true'
  - key:             bugprone-misplaced-widening-cast.CheckImplicitCasts
    value:           'false'
  - key:             cppcoreguidelines-non-private-member-variables-in-classes.IgnorePublicMemberVariables
    value:           'false'
  - key:             modernize-loop-convert.MinConfidence
    value:           reasonable
  - key:             performance-unnecessary-value-param.AllowedTypes
    value:           ''
  - key:             bugprone-suspicious-missing-comma.RatioThreshold
    value:           '0.200000'
  - key:             cppcoreguidelines-special-member-functions.AllowMissingMoveFunctionsWhenCopyIsDeleted
    value:           'false'
  - key:             readability-uppercase-literal-suffix.NewSuffixes
    value:           ''
  - key:             google-readability-namespace-comments.SpacesBeforeComments
    value:           '2'
  - key:             readability-function-cognitive-complexity.Threshold
    value:           '40'
  - key:             cppcoreguidelines-non-private-member-variables-in-classes.IgnoreClassesWithAllMemberVariablesBeingPublic
    value:           'true'
  - key:             bugprone-argument-comment.IgnoreSingleArgument
    value:           '0'
  - key:             cppcoreguidelines-no-malloc.Allocations
    value:           '::malloc;::calloc'
  - key:             modernize-use-noexcept.UseNoexceptFalse
    value:           'true'
  - key:             bugprone-sizeof-expression.WarnOnSizeOfIntegerExpression
    value:           'false'
  - key:             performance-faster-string-find.StringLikeClasses
    value:           '::std::basic_string;::std::basic_string_view'
  - key:             bugprone-assert-side-effect.CheckFunctionCalls
    value:           'false'
  - key:             readability-function-size.BranchThreshold
    value:           '4294967295'
  - key:             bugprone-string-constructor.StringNames
    value:           '::std::basic_string;::std::basic_string_view'
  - key:             bugprone-assert-side-effect.AssertMacros
    value:           assert
  - key:             bugprone-exception-escape.IgnoredExceptions
    value:           ''
  - key:             readability-function-size.StatementThreshold
    value:           '800'
  - key:             modernize-use-default-member-init.IgnoreMacros
    value:           'true'
  - key:             llvm-qualified-auto.AddConstToQualified
    value:           '0'
  - key:             bugprone-signed-char-misuse.DiagnoseSignedUnsignedCharComparisons
    value:           'true'
  - key:             readability-identifier-naming.IgnoreMainLikeFunctions
    value:           'false'
  - key:             readability-implicit-bool-conversion.AllowIntegerConditions
    value:           'false'
  - key:             cppcoreguidelines-init-variables.MathHeader
    value:           '<math.h>'
  - key:             google-readability-function-size.StatementThreshold
    value:           '800'
  - key:             llvm-else-after-return.WarnOnConditionVariables
    value:           '0'
  - key:             bugprone-sizeof-expression.WarnOnSizeOfCompareToConstant
    value:           'true'
  - key:             bugprone-reserved-identifier.AggressiveDependentMemberLookup
    value:           'false'
  - key:             modernize-raw-string-literal.DelimiterStem
    value:           lit
  - key:             modernize-use-equals-default.IgnoreMacros
    value:           'true'
  - key:             cppcoreguidelines-special-member-functions.AllowSoleDefaultDtor
    value:           'true'
  - key:             modernize-raw-string-literal.ReplaceShorterLiterals
    value:           'false'
  - key:             modernize-use-emplace.SmartPointers
    value:           '::std::shared_ptr;::std::unique_ptr;::std::auto_ptr;::std::weak_ptr'
  - key:             cppcoreguidelines-no-malloc.Deallocations
    value:           '::free'
  - key:             modernize-use-auto.RemoveStars
    value:           'false'
  - key:             bugprone-dangling-handle.HandleClasses
    value:           'std::basic_string_view;std::experimental::basic_string_view'
  - key:             performance-inefficient-vector-operation.VectorLikeClasses
    value:           '::std::vector'
  - key:             performance-unnecessary-value-param.IncludeStyle
    value:           llvm
  - key:             readability-redundant-member-init.IgnoreBaseInCopyConstructors
    value:           'false'
  - key:             modernize-replace-disallow-copy-and-assign-macro.MacroName
    value:           DISALLOW_COPY_AND_ASSIGN
  - key:             llvm-else-after-return.WarnOnUnfixable
    value:           '0'
  - key:             readability-simplify-subscript-expr.Types
    value:           '::std::basic_string;::std::basic_string_view;::std::vector;::std::array'
  - key:             readability-identifier-length.IgnoredParameterNames
    value:           '^([hijknr]|d?[12tuvwxyz]|i[nxyz]|pp|es|el|em)$'
  - key:             readability-identifier-length.IgnoredLoopCounterNames
    value:           '^[ijklmnpqr]$'
  - key:             readability-identifier-length.IgnoredVariableNames
    value:           '^((N|d)?[12ilmrtuvwxyz]|i[nvxyz]|N|bc|pp|r2|r|es|el|em)$'
...




================================================
FILE: .gitlab-ci.yml
================================================
include: '.gitlab/.gitlab-ci-common.yml'

csd3-a100-build:
  stage: build
  tags:
    - csd3
  script:
    - cd ${AMREX_HOME}/Tools/Plotfile
    # Build fcompare tool
    - make -j 8 COMP=gnu programs=fcompare
    - cd ${AMREX_HOME}/Tools/Postprocessing/C_Src
    # Build particle compare tool
    - make -j 8 COMP=gnu particle_compare.exe
    # Build BinaryBH example
    - cd ${HOME}/${CI_PROJECT_DIR}/Examples/BinaryBH
    - make -j 8 ${BUILD_CONFIG}
    # Build Klein Gordon example
    - cd ${HOME}/${CI_PROJECT_DIR}/Examples/KleinGordon
    - make -j 8 ${BUILD_CONFIG}
    # Build tests
    - cd ${HOME}/${CI_PROJECT_DIR}/Tests
    - make -j 8 ${BUILD_CONFIG}
    - >
      if [[ ! -d ${BINARY_DIR} ]]; then
        mkdir ${BINARY_DIR}
      fi
    - mv ${AMREX_HOME}/Tools/Plotfile/fcompare.gnu.ex ${BINARY_DIR}
    - mv ${AMREX_HOME}/Tools/Postprocessing/C_Src/particle_compare.exe ${BINARY_DIR}
    - >
      mv ${HOME}/${CI_PROJECT_DIR}/Examples/BinaryBH/main3d.gnu.DEBUG.MPI.CUDA.ex
      ${BINARY_DIR}/BinaryBH_main3d.gnu.DEBUG.MPI.CUDA.ex
    - >
      mv ${HOME}/${CI_PROJECT_DIR}/Examples/KleinGordon/main3d.gnu.DEBUG.MPI.CUDA.ex
      ${BINARY_DIR}/KleinGordon_main3d.gnu.DEBUG.MPI.CUDA.ex
    - mv ${HOME}/${CI_PROJECT_DIR}/Tests/Tests3d.gnu.DEBUG.MPI.CUDA.ex ${BINARY_DIR}

csd3-a100-test:
  stage: test
  tags:
    - csd3
  dependencies:
    - csd3-a100-build
  script:
    # Move binaries back into their original directories
    - mv ${BINARY_DIR}/Tests3d.gnu.DEBUG.MPI.CUDA.ex ${HOME}/${CI_PROJECT_DIR}/Tests
    - >
      mv ${BINARY_DIR}/BinaryBH_main3d.gnu.DEBUG.MPI.CUDA.ex
      ${HOME}/${CI_PROJECT_DIR}/Examples/BinaryBH
    - >
      mv ${BINARY_DIR}/KleinGordon_main3d.gnu.DEBUG.MPI.CUDA.ex
      ${HOME}/${CI_PROJECT_DIR}/Examples/KleinGordon
    - > # Prepare the output directory - there is a single directory for BOTH examples
      if [[ ! -d ${OUTPUT_DIR} ]]; then
        mkdir ${OUTPUT_DIR}
      fi
    - flock ${QOS_INTR_LOCK_FILE} sbatch -W ${HOME}/${CI_PROJECT_DIR}/.gitlab/run-examples.sh
    # Use fcompare to check plotfiles for correctness
    - >
      ${BINARY_DIR}/fcompare.gnu.ex ${ERR_TOL_FLAGS}
      ${OUTPUT_DIR}/BinaryBH_00008/ ${COMPARE_DIR}/BinaryBH/plt00008_compare
    - >
      ${BINARY_DIR}/fcompare.gnu.ex ${ERR_TOL_FLAGS}
      ${OUTPUT_DIR}/KleinGordon_00008/ ${COMPARE_DIR}/KleinGordon/plt00008_compare
    # Use Particle compare tool to check the punctures
    - >
      ${BINARY_DIR}/particle_compare.exe ${ERR_TOL_FLAGS}
      ${OUTPUT_DIR}/BinaryBH_00008/ ${COMPARE_DIR}/BinaryBH/plt00008_compare/ particles
  after_script:
    # This deletes BINARY_DIR but because it was defined in
    # the before_script, there is no way to access that
    # environment variable in the after_script
    - rm -rf ${HOME}/a100-build-${CI_PIPELINE_ID}
    - >
      if [[ -d ${OUTPUT_DIR} ]]; then
        rm -rf ${OUTPUT_DIR}
      fi



================================================
FILE: .lint-ignore
================================================
# This file contains a list of files/directories to be ignored by the lint
# GitHub action. These are mostly files that have yet to be ported to AMReX
# Once these files have been ported to AMReX, they should be removed from this
# file so they are linted.

# These files don't make sense on their own
*.impl.hpp
Tests/CCZ4GeometryUnitTests/CCZ4GeometryMathematicaValues.hpp
external/*

# These directories/files have yet to be ported to AMReX
Source/AMRInterpolator/*
Source/Grids/SixthOrderDerivatives.hpp
Source/CCZ4/GammaCalculator.hpp
Source/CCZ4/IntegratedMovingPunctureGauge.hpp
Source/BlackHoles/KerrBH*
Source/IO/MultiLevelTask.hpp
Examples/ScalarField/*
Tests/.*

# These are old files we don't want to change
Tests/CCZ4RHSTest/*fdf5a7a*
Tests/CCZ4RHSTest/simd*
Tests/CCZ4RHSTest/x64/*


================================================
FILE: .pre-commit-config.yaml
================================================
repos:
  # Clang format
  - repo: https://github.com/pre-commit/mirrors-clang-format
    rev: v19.1.7
    hooks:
      - id: clang-format
  # Shell format
  - repo: https://github.com/scop/pre-commit-shfmt
    rev: v3.11.0-1
    hooks:
      - id: shfmt         # prebuilt upstream executable
  # Yamllint
  - repo: https://github.com/adrienverge/yamllint.git
    rev: v1.29.0
    hooks:
      - id: yamllint
        args:
          ['-d {rules: {line-length: {max: 101, allow-non-breakable-words: true,
          allow-non-breakable-inline-mappings: true}}}']
  # trailing white space
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v6.0.0
    hooks:
    -   id: trailing-whitespace




================================================
FILE: Examples/BinaryBH/README.md
================================================
# Using TwoPunctures initial data with this example

To build this example with [TwoPunctures](https://github.com/GRChombo/TwoPunctures)
initial data, set the environment variable `TWOPUNCTURES_SOURCE` to the Source
subdirectory of the local clone of the [TwoPunctures repository](https://github.com/GRChombo/TwoPunctures)
e.g.
```bash
export TWOPUNCTURES_SOURCE=/path/to/TwoPunctures/Source
```
Then, simply build as normal e.g.
```bash
make all -j 4
```
To stop using TwoPunctures, undefine the `TWOPUNCTURES_SOURCE` environment variable:
```bash
unset TWOPUNCTURES_SOURCE
```
Alternatively, you can avoid defining an environment variable by defining it in
the make command:
```bash
make all -j 4 TWOPUNCTURES_SOURCE=/path/to/TwoPunctures/Source
```
Note that the parameter names for TwoPunctures initial data differ to that of
the vanilla example: see [params_two_punctures.txt](./params_two_punctures.txt)
for the parameter names.



================================================
FILE: Examples/BinaryBH/BinaryBHLevel.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#include "BinaryBHLevel.hpp"
#include "BinaryBHInitialData.hpp"
#include "CCZ4RHS.hpp"
#include "ChiTagger.hpp"
#include "Constraints.hpp"
#include "ExtractionTagger.hpp"
#include "PositiveChiAndLapse.hpp"
#include "PunctureTagger.hpp"
#include "PunctureTracker.hpp"
// xxxxx #include "SixthOrderDerivatives.hpp"
#include "TraceARemoval.hpp"
#include "TwoPuncturesInitialData.hpp"
#include "Weyl4.hpp"
#include "WeylExtraction.hpp"

BHAMR<BinaryBHLevel::num_punctures> *BinaryBHLevel::get_bhamr_ptr()
{
    return dynamic_cast<BHAMR<num_punctures> *>(get_gramr_ptr());
}

PunctureTracker<BinaryBHLevel::num_punctures> &
BinaryBHLevel::get_puncture_tracker()
{
    return get_bhamr_ptr()->get_puncture_tracker();
}

void BinaryBHLevel::variableSetUp()
{
    BL_PROFILE("BinaryBHLevel::variableSetUp()");

    // Set up the state variables
    stateVariableSetUp();

    Constraints::set_up(State_Type);

    Weyl4::set_up(State_Type);
}

// Things to do during the advance step after RK4 steps
void BinaryBHLevel::specificAdvance()
{
    amrex::MultiFab &S_new = get_new_data(State_Type);
    const auto &arrs       = S_new.arrays();

    // Enforce the trace free A_ij condition and positive chi and lapse
    amrex::ParallelFor(S_new,
                       [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k)
                       {
                           amrex::CellData<amrex::Real> cell =
                               arrs[box_no].cellData(i, j, k);
                           TraceARemoval()(cell);
                           PositiveChiAndLapse()(cell);
                       });
}

// This initial data uses an approximation for the metric which
// is valid for small boosts
void BinaryBHLevel::initData()
{
    BL_PROFILE("BinaryBHLevel::initialData");
    if (m_verbosity > 0)
    {
        amrex::Print() << "BinaryBHLevel::initialData " << Level() << "\n";
    }
#ifdef USE_TWOPUNCTURES
    // xxxxx USE_TWOPUNCTURES todo
    TwoPuncturesInitialData two_punctures_initial_data(
        m_dx, m_p.center, m_tp_amr.m_two_punctures);
    // Can't use simd with this initial data
    BoxLoops::loop(two_punctures_initial_data, m_state_new, m_state_new,
                   INCLUDE_GHOST_CELLS, disable_simd());
#else
    // Set up the compute class for the BinaryBH initial data
    BinaryBHInitialData binary(simParams().bh1_params, simParams().bh2_params,
                               Geom().CellSize(0));

    static_assert(std::is_trivially_copyable_v<BinaryBHInitialData>,
                  "BinaryBHInitialData needs to be device copyable");

    // First set everything to zero (to avoid undefinded values in constraints)
    // then calculate initial data
    amrex::MultiFab &state = get_new_data(State_Type);
    const auto &arrs       = state.arrays();
    amrex::ParallelFor(state, state.nGrowVect(),
                       [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k)
                       {
                           amrex::CellData<amrex::Real> cell =
                               arrs[box_no].cellData(i, j, k);
                           for (int n = 0; n < cell.nComp(); ++n)
                           {
                               cell[n] = 0.;
                           }
                           binary.init_data(i, j, k, cell);
                       });
#endif
    amrex::Gpu::streamSynchronize();

    if (simParams().puncture_tracking_enabled && Level() == 0)
    {
        // need to set the puncture coordinates as we use it for the puncture
        // tagging
        get_puncture_tracker().set_puncture_coords(
            {simParams().bh1_params.center[0], simParams().bh1_params.center[1],
             simParams().bh1_params.center[2], simParams().bh2_params.center[0],
             simParams().bh2_params.center[1],
             simParams().bh2_params.center[2]});
        // can't call start_from_initial_punctures() because we need the full
        // AMR grid first
    }
}

// Calculate RHS during RK4 substeps
void BinaryBHLevel::specificEvalRHS(amrex::MultiFab &a_soln,
                                    amrex::MultiFab &a_rhs,
                                    const double /*a_time*/)
{
    BL_PROFILE("BinaryBHLevel::specificEvalRHS()");
    const auto &soln_arrs   = a_soln.arrays();
    const auto &soln_c_arrs = a_soln.const_arrays();
    const auto &rhs_arrs    = a_rhs.arrays();

    // Enforce positive chi and lapse and trace free A
    amrex::ParallelFor(a_soln, a_soln.nGrowVect(),
                       [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k)
                       {
                           amrex::CellData<amrex::Real> cell =
                               soln_arrs[box_no].cellData(i, j, k);
                           TraceARemoval()(cell);
                           PositiveChiAndLapse()(cell);
                       });

    // Calculate CCZ4 right hand side
    if (simParams().max_spatial_derivative_order == 4)
    {
        CCZ4RHS<MovingPunctureGauge, FourthOrderDerivatives> ccz4rhs(
            simParams().ccz4_params, Geom().CellSize(0), simParams().sigma,
            simParams().formulation);
        amrex::ParallelFor(a_rhs,
                           [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k)
                           {
                               ccz4rhs.compute(i, j, k, rhs_arrs[box_no],
                                               soln_c_arrs[box_no]);
                           });
    }
    else if (simParams().max_spatial_derivative_order == 6)
    {
        amrex::Abort("xxxxx max_spatial_derivative_order == 6 todo");
#if 0
        CCZ4RHS<MovingPunctureGauge, SixthOrderDerivatives>
            ccz4rhs(simParams().ccz4_params, Geom().CellSize(0), simParams().sigma,
                    simParams().formulation);
        amrex::ParallelFor(a_rhs,
        [=] AMREX_GPU_DEVICE (int box_no, int i, int j, int k)
        {
            amrex::CellData<amrex::Real const> state = soln_c_arrs[box_no].cellData(i,j,k);
            amrex::CellData<amrex::Real> rhs = rhs_arrs[box_no].cellData(i,j,k);
            ccz4rhs.compute(rhs, state);
        });
#endif
    }

    amrex::Gpu::streamSynchronize();
}

// enforce trace removal during RK4 substeps
void BinaryBHLevel::specificUpdateODE(amrex::MultiFab &a_soln)
{
    // Enforce the trace free A_ij condition
    const auto &soln_arrs = a_soln.arrays();
    amrex::ParallelFor(a_soln, amrex::IntVect(0), // zero ghost cells
                       [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k)
                       {
                           amrex::CellData<amrex::Real> cell =
                               soln_arrs[box_no].cellData(i, j, k);
                           TraceARemoval()(cell);
                       });

    amrex::Gpu::streamSynchronize();
}

void BinaryBHLevel::pre_tag_cells()
{
    amrex::MultiFab &state_new = get_new_data(State_Type);
    const auto cur_time        = get_state_data(State_Type).curTime();

    // Just fill 2 ghosts for chi to calculate second derivatives
    const int nghost = 2;
    const int ncomp  = 1;
    FillPatch(*this, state_new, nghost, cur_time, State_Type, c_chi, ncomp);
}

void BinaryBHLevel::tag_cells(amrex::TagBoxArray &a_tag_box_array,
                              amrex::Real a_regrid_threshold)
{
    BL_PROFILE("BinaryBHLevel::tag_cells()");
    amrex::MultiFab &state_new = get_new_data(State_Type);

    const auto &tag_arrs       = a_tag_box_array.arrays();
    const auto &state_new_arrs = state_new.const_arrays();

    ChiTagger chi_tagger(Geom().CellSize(0), a_regrid_threshold);

    ExtractionTagger extraction_tagger(Geom().CellSize(0), Level(),
                                       simParams().extraction_params,
                                       simParams().activate_extraction);

    const bool puncture_tracking_enabled =
        simParams().puncture_tracking_enabled;
    constexpr auto num_puncture_coords =
        static_cast<std::size_t>(AMREX_SPACEDIM * num_punctures);
    std::array<amrex::Real, num_puncture_coords> puncture_coords{};

    if (puncture_tracking_enabled)
    {
        puncture_coords = get_puncture_tracker().get_puncture_coords();
    }

    PunctureTagger<num_punctures> puncture_tagger(
        Geom().CellSize(0), Level(), get_gramr_ptr()->maxLevel(),
        puncture_coords,
        {simParams().bh1_params.mass, simParams().bh2_params.mass});

    amrex::ParallelFor(state_new, amrex::IntVect(0),
                       // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
                       [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k)
                       {
                           const auto &tags_arr  = tag_arrs[box_no];
                           const auto &state_arr = state_new_arrs[box_no];

                           chi_tagger(i, j, k, tags_arr, state_arr);

                           extraction_tagger(i, j, k, tags_arr);

                           if (puncture_tracking_enabled)
                           {
                               puncture_tagger(i, j, k, tags_arr);
                           }
                       });
    amrex::Gpu::streamSynchronize();
}

void BinaryBHLevel::specific_post_init()
{
    BL_PROFILE("BinaryBHLevel::specific_post_init()");

    if (simParams().puncture_tracking_enabled)
    {
        get_puncture_tracker().start_from_initial_punctures();
    }
}

void BinaryBHLevel::specific_post_restart()
{
    BL_PROFILE("BinaryBHLevel::specific_post_restart()");

    if (simParams().puncture_tracking_enabled)
    {
        std::string restart_checkpoint{};
        GRParmParse pp("amr");
        pp.get("restart", restart_checkpoint);
        get_puncture_tracker().restart(restart_checkpoint);
    }
}

void BinaryBHLevel::specific_post_plotfile(const std::string &a_dir,
                                           std::ostream &a_os)
{
    if (simParams().puncture_tracking_enabled)
    {
        get_puncture_tracker().write_plotfile(a_dir);
    }
}

void BinaryBHLevel::specific_post_checkpoint(const std::string &a_chk_dir,
                                             std::ostream & /*a_os*/)
{
    if (simParams().puncture_tracking_enabled)
    {
        get_puncture_tracker().checkpoint(a_chk_dir);
    }
}

void BinaryBHLevel::specificPostTimeStep()
{
    // do puncture tracking on requested level
    if (simParams().puncture_tracking_enabled &&
        Level() == simParams().puncture_tracking_level)
    {
        BL_PROFILE("PunctureTracking");

        // only do the write out when we're at at a multiple of the
        // writeout_level
        bool write_punctures = at_level_timestep_multiple(
            simParams().puncture_tracking_writeout_level);
        amrex::Real cur_time = get_state_data(State_Type).curTime();
        amrex::Real dt       = get_gramr_ptr()->dtLevel(Level());
        get_puncture_tracker().track(cur_time, dt, write_punctures);
    }
#if 0
//xxxxx specificPostTimeStep
    BL_PROFILE("BinaryBHLevel::specificPostTimeStep");

    bool first_step =
        (m_time == 0.); // this form is used when 'specificPostTimeStep' was
                        // called during setup at t=0 from Main
    // bool first_step = (m_time == m_dt); // if not called in Main

    if (m_p.activate_extraction == 1)
    {
        int min_level = m_p.extraction_params.min_extraction_level();
        bool calculate_weyl = at_level_timestep_multiple(min_level);
        if (calculate_weyl)
        {
            // Populate the Weyl Scalar values on the grid
            fillAllGhosts();
            BoxLoops::loop(
                Weyl4(m_p.extraction_params.center, m_dx, m_p.formulation),
                m_state_new, m_state_diagnostics, EXCLUDE_GHOST_CELLS);

            // Do the extraction on the min extraction level
            if (m_level == min_level)
            {
                BL_PROFILE("WeylExtraction");
                // Now refresh the interpolator and do the interpolation
                // fill ghosts manually to minimise communication
                bool fill_ghosts = false;
                m_gr_amr.m_interpolator->refresh(fill_ghosts);
                m_gr_amr.fill_multilevel_ghosts(
                    VariableType::derived, Interval(c_Weyl4_Re, c_Weyl4_Im),
                    min_level);
                WeylExtraction my_extraction(m_p.extraction_params, m_dt,
                                             m_time, first_step,
                                             m_restart_time);
                my_extraction.execute_query(m_gr_amr.m_interpolator);
            }
        }
    }

    if (m_p.calculate_constraint_norms)
    {
        fillAllGhosts();
        BoxLoops::loop(Constraints(m_dx, c_Ham, Interval(c_Mom1, c_Mom3)),
                       m_state_new, m_state_diagnostics, EXCLUDE_GHOST_CELLS);
        if (m_level == 0)
        {
            AMRReductions<VariableType::derived> amr_reductions(m_gr_amr);
            double L2_Ham = amr_reductions.norm(c_Ham);
            double L2_Mom = amr_reductions.norm(Interval(c_Mom1, c_Mom3));
            SmallDataIO constraints_file(m_p.data_path + "constraint_norms",
                                         m_dt, m_time, m_restart_time,
                                         SmallDataIO::APPEND, first_step);
            constraints_file.remove_duplicate_time_data();
            if (first_step)
            {
                constraints_file.write_header_line({"L^2_Ham", "L^2_Mom"});
            }
            constraints_file.write_time_data_line({L2_Ham, L2_Mom});
        }
    }

#endif
}



================================================
FILE: Examples/BinaryBH/BinaryBHLevel.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef BINARYBHLEVEL_HPP_
#define BINARYBHLEVEL_HPP_

#include "DefaultLevelFactory.hpp"
#include "GRAMRLevel.hpp"
// TPAMR.hpp includes BHAMR.hpp
#include "TPAMR.hpp"

class BinaryBHLevel : public GRAMRLevel
{
  public:
    static void variableSetUp();

    // Inherit the contructors from GRAMRLevel
    using GRAMRLevel::GRAMRLevel;

    static constexpr int num_punctures = 2;

    BHAMR<num_punctures> *get_bhamr_ptr();

    /// Get a reference to the PunctureTracker object stored by BHAMR
    PunctureTracker<num_punctures> &get_puncture_tracker();

    /// Things to do at every full timestep
    ///(might include several substeps, e.g. in RK4)
    void specificAdvance() override;

    /// Initial data calculation
    void initData() override;

    /// Calculation of the right hand side for the time stepping
    void specificEvalRHS(amrex::MultiFab &a_soln, amrex::MultiFab &a_rhs,
                         const double a_time) override;

    /// Things to do after dt*rhs has been added to the solution
    void specificUpdateODE(amrex::MultiFab &a_soln) override;

    // to do post each time step on every level
    void specificPostTimeStep() override;

    /// Things to do before tagging cells for regridding
    void pre_tag_cells() final;

    /// Tag cells for regridding
    void tag_cells(amrex::TagBoxArray &a_tag_box_array,
                   amrex::Real a_regrid_threshold) final;

    //! Things to do after a restart
    void specific_post_restart() override;

    //! Things to do after init
    void specific_post_init() override;

    //! Things to do after writing a plotfile
    void specific_post_plotfile(const std::string &a_dir,
                                std::ostream & /*a_os*/) override;

    //! Things to do after writing a checkpoint
    void specific_post_checkpoint(const std::string &a_dir,
                                  std::ostream & /*a_os*/) override;
};

#endif /* BINARYBHLEVEL_HPP_ */



================================================
FILE: Examples/BinaryBH/GNUmakefile
================================================
GRTECLYN_HOME = $(realpath ../..)

include $(GRTECLYN_HOME)/Tools/GNUMake/Make.defaults

# We use particles for the puncture tracking
USE_PARTICLES = TRUE

AMREX_HOME ?= $(realpath ../../../amrex)

include $(AMREX_HOME)/Tools/GNUMake/Make.defs

include ./Make.package
include $(AMREX_HOME)/Src/Base/Make.package
include $(AMREX_HOME)/Src/Boundary/Make.package
include $(AMREX_HOME)/Src/AmrCore/Make.package
include $(AMREX_HOME)/Src/Amr/Make.package
include $(AMREX_HOME)/Src/Particle/Make.package

GRTECLYN_HOME = $(realpath ../..)
GRTECLYN_SOURCE = $(GRTECLYN_HOME)/Source

src_dirs := $(GRTECLYN_SOURCE)/AMRInterpolator \
            $(GRTECLYN_SOURCE)/BlackHoles \
            $(GRTECLYN_SOURCE)/CCZ4 \
            $(GRTECLYN_SOURCE)/Grids \
            $(GRTECLYN_SOURCE)/GRTeclynCore \
            $(GRTECLYN_SOURCE)/IO \
            $(GRTECLYN_SOURCE)/Maths \
            $(GRTECLYN_SOURCE)/Tagging


src_pack := $(foreach dir, $(src_dirs), $(dir)/Make.package)
include $(src_pack)
CEXE_sources += $(GRTECLYN_CEXE_sources)
CEXE_headers += $(GRTECLYN_CEXE_headers)
VPATH_LOCATIONS += $(src_dirs)
INCLUDE_LOCATIONS += $(realpath .) $(src_dirs)

include $(GRTECLYN_HOME)/Tools/GNUMake/Make.rules


================================================
FILE: Examples/BinaryBH/inputs.test
================================================
# See the wiki page for an explanation of the params!
# https://github.com/GRChombo/GRChombo/wiki/Guide-to-parameters

#################################################
# Filesystem parameters

verbosity = 0

# location / naming of output files
# output_path = "" # Main path for all files. Must exist!
chk_prefix = BinaryBH_
plot_prefix = BinaryBHPlot_
# restart_file = BinaryBH_000360.3d.hdf5

# HDF5files are written every dt = L/N*dt_multiplier*checkpoint_interval
checkpoint_interval = 1
# set to 0 to turn off plot files (except at t=0 and t=stop_time)
# set to -1 to never ever print plotfiles
plot_interval = 1
num_plot_vars = 4
plot_vars = chi Ham Weyl4_Re Weyl4_Im

# subpaths - specific directories for hdf5, pout, extraction data
# (these are created at runtime)
hdf5_subpath = "hdf5"
pout_subpath = "pout"
data_subpath = "data"

# change the name of output files
# pout_prefix = "pout"
print_progress_only_to_rank_0 = 1

# ignore_checkpoint_name_mismatch = 0
# write_plot_ghosts = 0

#################################################
# Initial Data parameters

# provide 'offset' or 'center'

massA = 0.5
massB = 0.5

offsetA = -2 0 0
offsetB =  2 0 0
# centerA =  6 8 8
# centerB = 10 8 8

momentumA = 0.0 -0.1 0.0
momentumB = 0.0  0.1 0.0

#################################################
# Grid parameters

# 'N' is the number of subdivisions in each direction of a cubic box
# 'L' is the length of the longest side of the box, dx_coarsest = L/N
# NB - If you use reflective BC and want to specify the subdivisions and side
# of the box were there are no symmetries, specify 'N_full' and 'L_full' instead
# NB - if you have a non-cubic grid, you can specify 'N1' or 'N1_full',
# 'N2' or 'N2_full' and 'N3' or 'N3_full' ( then dx_coarsest = L/N(max) )
# NB - the N values need to be multiples of the block_factor
N_full = 32
L_full = 16

# Maximum number of times you can regrid above coarsest level
max_level = 2 # There are (max_level+1) grids, so min is zero

# need max_level entries for regrid interval
# Level Regridding: 0   1   2   3   4   5
regrid_interval =   2   2   2   2   0   0
regrid_threshold = 0.3

# Max and min box sizes
max_box_size = 32
min_box_size = 8

# tag_buffer_size = 3
# grid_buffer_size = 8
# fill_ratio = 0.7
# num_ghosts = 3
# center = 8 8 8 # defaults to center of the grid

#################################################
# Boundary Conditions parameters

# Periodic directions - 0 = false, 1 = true
isPeriodic = 0 0 0
# if not periodic, then specify the boundary type
# 0 = static, 1 = sommerfeld, 2 = reflective
# (see BoundaryConditions.hpp for details)
hi_boundary = 1 1 1
lo_boundary = 1 1 2

# if sommerfeld boundaries selected, must select
# non zero asymptotic values
num_nonzero_asymptotic_vars = 5
nonzero_asymptotic_vars = chi h11 h22 h33 lapse
nonzero_asymptotic_values = 1.0 1.0 1.0 1.0 1.0

# if you are using extrapolating BC:
# extrapolation_order = 1
# num_extrapolating_vars = -1
# extrapolating_vars =

#################################################
# Evolution parameters

# dt will be dx*dt_multiplier on each grid level
dt_multiplier = 0.25
stop_time = 10.0
# max_steps = 100

# Spatial derivative order (only affects CCZ4 RHS)
max_spatial_derivative_order = 4 # can be 4 or 6

nan_check = 1

# Lapse evolution
lapse_advec_coeff = 1.0
lapse_coeff = 2.0
lapse_power = 1.0

# Shift evolution
shift_advec_coeff = 0.0 # Usually no advection for beta
shift_Gamma_coeff = 0.75
eta = 1.0 # eta of gamma driver, should be of order ~1/M_ADM of spacetime

# CCZ4 parameters
formulation = 0 # 1 for BSSN, 0 for CCZ4
kappa1 = 0.1
kappa2 = 0.
kappa3 = 1.
covariantZ4 = 1 # 0: keep kappa1; 1 [default]: replace kappa1 -> kappa1/lapse

# coefficient for KO numerical dissipation
sigma = 0.3

puncture_tracking.enabled = 1
puncture_tracking.level = 1

# calculate_constraint_norms = 0

# min_chi = 1.e-4
# min_lapse = 1.e-4

#################################################
# Extraction parameters

# extraction_center = 8 8 8 # defaults to center
activate_extraction = 1
num_extraction_radii = 1
extraction_radii = 6.0
extraction_levels = 0
num_points_phi = 24
num_points_theta = 37
num_modes = 3
modes = 2 0 \
        2 1 \
        2 2
# integral_file_prefix = "Weyl4_mode_"

# write_extraction = 0
# extraction_subpath = "data/extraction" # directory for 'write_extraction = 1'
# extraction_file_prefix = "Weyl4_extraction_"

#################################################

output_path = foo
verbosity = 1
amrex.fpe_trap_invalid=1
amrex.fpe_trap_zero=1
amrex.fpe_trap_overflow=1

amr.plot_vars = chi # The default is to plot all state variables
amr.derive_plot_vars = constraints # The default is none for derived variables.



================================================
FILE: Examples/BinaryBH/Main_BinaryBH.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// Our includes
#include "DefaultLevelFactory.hpp"
#include "GRParmParse.hpp"
#include "MultiLevelTask.hpp"
#include "SetupFunctions.hpp"
#include "SimulationParameters.hpp"
// TPAMR.hpp includes BHAMR.hpp
#include "TPAMR.hpp" // TPAMR code conditional compiled on USE_TWOPUNCTURES

// Problem specific includes:
#include "BinaryBHLevel.hpp"

// System includes
#include <chrono>
#include <iostream>

// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
int runGRTeclyn(int /*argc*/, char * /*argv*/[])
{
    BL_PROFILE("runGRTeclyn()");

    // Load the parameter file and construct the SimulationParameter class
    // To add more parameters edit the SimulationParameters file.
    GRParmParse pp; // NOLINT(readability-identifier-length)
    SimulationParameters sim_params(pp);

    if (sim_params.just_check_params)
    {
        return 0;
    }

    GRAMR::set_simulation_parameters(sim_params);

    DefaultLevelFactory<BinaryBHLevel> bh_level_bld;

#ifdef USE_TWOPUNCTURES
    TPAMR bh_amr;
    bh_amr.set_two_punctures_parameters(sim_params.tp_params);
    // Run TwoPunctures solver
    bh_amr.m_two_punctures.Run();
#else
    BHAMR<BinaryBHLevel::num_punctures> bh_amr(&bh_level_bld);
#endif

    bh_amr.init(0., sim_params.stop_time);

    while (
        (bh_amr.okToContinue() != 0) &&
        (bh_amr.levelSteps(0) < sim_params.max_steps ||
         sim_params.max_steps < 0) &&
        (bh_amr.cumTime() < sim_params.stop_time || sim_params.stop_time < 0.0))
    {
        bh_amr.coarseTimeStep(sim_params.stop_time);
    }

    // Write final checkpoint and plotfile
    if (bh_amr.stepOfLastCheckPoint() < bh_amr.levelSteps(0) &&
        sim_params.checkpoint_interval >= 0)
    {
        bh_amr.checkPoint();
    }

    if (bh_amr.stepOfLastPlotFile() < bh_amr.levelSteps(0) &&
        sim_params.plot_interval >= 0)
    {
        bh_amr.writePlotFile();
    }

    return 0;
}

int main(int argc, char *argv[])
{
    mainSetup(argc, argv);

    int status = runGRTeclyn(argc, argv);

    if (status == 0)
    {
        amrex::Print() << "GRChombo finished."
                       << "\n";
    }
    else
    {
        amrex::Print() << "GRChombo failed with return code " << status << "\n";
    }

    mainFinalize();
    return status;
}



================================================
FILE: Examples/BinaryBH/Make.package
================================================
GRTECLYN_CEXE_sources += BinaryBHLevel.cpp Main_BinaryBH.cpp

GRTECLYN_CEXE_headers += BinaryBHLevel.hpp  SimulationParameters.hpp  TPAMR.hpp  StateVariables.hpp





================================================
FILE: Examples/BinaryBH/params.txt
================================================
# See the wiki page for an explanation of the params!
# https://github.com/GRChombo/GRChombo/wiki/Guide-to-parameters
# and a guide to this specific example at
# https://github.com/GRChombo/GRChombo/wiki/Running-the-BBH-example

#################################################
# Filesystem parameters

verbosity = 0

# location / naming of output files
# output_path = "" # Main path for all files. Must exist!
chk_prefix = BinaryBHChk_
plot_prefix = BinaryBHPlot_
# restart_file = BinaryBHChk_000000.3d.hdf5

# HDF5files are written every dt = L/N*dt_multiplier*checkpoint_interval
checkpoint_interval = 100
# set to 0 to turn off plot files (except at t=0 and t=stop_time)
# set to -1 to never ever print plotfiles
plot_interval = 10
num_plot_vars = 3
plot_vars = chi Weyl4_Re Weyl4_Im

# subpaths - specific directories for hdf5, pout, extraction data
# (these are created at runtime)
hdf5_subpath = "hdf5"
pout_subpath = "pout"
data_subpath = "data"

# change the name of output files
# pout_prefix = "pout"
print_progress_only_to_rank_0 = 1

# ignore_checkpoint_name_mismatch = 0
# write_plot_ghosts = 0

#################################################
# Initial Data parameters

# provide 'offset' or 'center'

massA = 0.48847892320123
massB = 0.48847892320123

offsetA = 0.0 6.10679 0.0
offsetB = 0.0 -6.10679 0.0
# centerA = 256 232 256
# centerB = 256 250 256

momentumA = -0.0841746 -0.000510846 0.0
momentumB =  0.0841746  0.000510846 0.0

#################################################
# Grid parameters

# 'N' is the number of subdivisions in each direction of a cubic box
# 'L' is the length of the longest side of the box, dx_coarsest = L/N
# NB - If you use reflective BC and want to specify the subdivisions and side
# of the box were there are no symmetries, specify 'N_full' and 'L_full' instead
# NB - if you have a non-cubic grid, you can specify 'N1' or 'N1_full',
# 'N2' or 'N2_full' and 'N3' or 'N3_full' ( then dx_coarsest = L/N(max) )
# NB - the N values need to be multiples of the block_factor
N_full = 64
L_full = 512

# Maximum number of times you can regrid above coarsest level
max_level = 9 # There are (max_level+1) grids, so min is zero

# Frequency of regridding at each level and thresholds on the tagging
# Need one for each level except the top one, ie max_level items
# Generally you do not need to regrid frequently on every level
# Level Regridding: 0   1   2   3   4   5   6   7   8
regrid_interval =   0   0   0   64  64  64  64  64  64
regrid_threshold = 0.05

# Max and min box sizes
max_box_size = 16
min_box_size = 16

# tag_buffer_size = 3
# grid_buffer_size = 8
# fill_ratio = 0.7
# num_ghosts = 3
# center = 256.0 256.0 256.0 # defaults to center of the grid

#################################################
# Boundary Conditions parameters

# Periodic directions - 0 = false, 1 = true
isPeriodic = 0 0 0
# if not periodic, then specify the boundary type
# 0 = static, 1 = sommerfeld, 2 = reflective
# (see BoundaryConditions.hpp for details)
hi_boundary = 1 1 1
lo_boundary = 1 1 2

# if sommerfeld boundaries selected, must select
# asymptotic values
nonzero_asymptotic_vars = chi h11 h22 h33 lapse
nonzero_asymptotic_values = 1.0 1.0 1.0 1.0 1.0

# if you are using extrapolating BC:
# extrapolation_order = 1
# extrapolating_vars =

#################################################
# Evolution parameters

# dt will be dx*dt_multiplier on each grid level
dt_multiplier = 0.25
stop_time = 2200.0
# max_steps = 100

# Spatial derivative order (only affects CCZ4 RHS)
max_spatial_derivative_order = 4 # can be 4 or 6

nan_check = 1

# Lapse evolution
lapse_advec_coeff = 1.0
lapse_coeff = 2.0
lapse_power = 1.0

# Shift evolution
shift_advec_coeff = 0.0 # Usually no advection for beta
shift_Gamma_coeff = 0.75
eta = 1.0 # eta of gamma driver, should be of order ~1/M_ADM of spacetime

# CCZ4 parameters
formulation = 0 # 1 for BSSN, 0 for CCZ4
kappa1 = 0.1
kappa2 = 0.
kappa3 = 1.
covariantZ4 = 1 # 0: keep kappa1; 1 [default]: replace kappa1 -> kappa1/lapse

# coefficient for KO numerical dissipation
sigma = 1.0

puncture_tracking.enabled = 1
puncture_tracking.level = 5

# calculate_constraint_norms = 0

# min_chi = 1.e-4
# min_lapse = 1.e-4

#################################################
# Extraction parameters

# extraction_center = 256 256 256 # defaults to center
activate_extraction = 1
num_extraction_radii = 2
extraction_radii = 50.0 100.0
extraction_levels = 2 1
num_points_phi = 24
num_points_theta = 37
num_modes = 8
modes = 2 0 # l m for spherical harmonics
        2 1
        2 2
        4 0
        4 1
        4 2
        4 3
        4 4

# integral_file_prefix = "Weyl4_mode_"

# write_extraction = 0
# extraction_subpath = "data/extraction" # directory for 'write_extraction = 1'
# extraction_file_prefix = "Weyl4_extraction_"

#################################################




================================================
FILE: Examples/BinaryBH/params_profile.txt
================================================
# Based on the q1-d12 configuration of https://inspirehep.net/literature/1994195

# Many of the commented out parameters are relics from GRChombo and may not be
# implemented here.

#################################################
# Filesystem parameters

verbosity = 1

output_path = .
amr.check_file = BinaryBHChk_
amr.plot_file = BinaryBHPlt_
# amr.restart = BinaryBHChk_00100
# amr.file_name_digits = 5

checkpoint_interval = 100
plot_interval = 5

#################################################
# Initial Data parameters

# provide 'offset' or 'center'

massA = 0.48847892320123
massB = 0.48847892320123

offsetA = 0.0 6.10679 0.0
offsetB =  0.0 -6.10679 0.0
# centerA = 512  518.10679 512
# centerB = 512 -505.89321 512

momentumA = -0.0841746 -0.000510846 0.0
momentumB = 0.0841746  0.000510846 0.0

#################################################
# Grid parameters

N_full = 128
L_full = 1024

max_level = 9 # There are (max_level+1) grids, so min is zero

# -1 disables regridding
regrid_interval = -1 -1 1 -1 -1 -1 -1 -1 -1 -1
regrid_threshold = 0.02

# Max and min box sizes
max_grid_size = 32
block_factor = 16

# Tag buffer size
amr.n_error_buf = 4 4 4
# num_ghosts = 3
# center = 8 8 8 # defaults to center of the grid

#################################################
# Boundary Conditions parameters

# Periodic directions - 0 = false, 1 = true
isPeriodic = 0 0 0
# if not periodic, then specify the boundary type
# 0 = static, 1 = sommerfeld, 2 = reflective
# (see BoundaryConditions.hpp for details)
hi_boundary = 1 1 1
lo_boundary = 1 1 2

# if sommerfeld boundaries selected, must select
# non zero asymptotic values
nonzero_asymptotic_vars = chi h11 h22 h33 lapse
nonzero_asymptotic_values = 1.0 1.0 1.0 1.0 1.0

# if you are using extrapolating BC:
# extrapolation_order = 1
# extrapolating_vars =

#################################################
# Evolution parameters

# dt will be dx*dt_multiplier on each grid level
dt_multiplier = 0.25
# stop_time = 2.0
max_steps = 1

# Spatial derivative order (only affects CCZ4 RHS)
max_spatial_derivative_order = 4 # only 4 currently implemented

nan_check = 1

# Lapse evolution
lapse_advec_coeff = 1.0
lapse_coeff = 2.0
lapse_power = 1.0

# Shift evolution
shift_advec_coeff = 1.0
shift_Gamma_coeff = 0.75
eta = 1.0 # eta of gamma driver

# CCZ4 parameters
formulation = 0 # 1 for BSSN, 0 for CCZ4
kappa1 = 0.1
kappa2 = 0.
kappa3 = 1.
covariantZ4 = 1 # 0: keep kappa1; 1 [default]: replace kappa1 -> kappa1/lapse

# coefficient for KO numerical dissipation
sigma = 0.5

# min_chi = 1.e-4
# min_lapse = 1.e-4

#################################################
# Extraction parameters

# We don't have any extraction yet but the extraction spheres are used for
# tagging cells
activate_extraction = 1
num_extraction_radii = 2
extraction_radii = 110.0 150.0
extraction_levels = 3 2
num_points_phi = 32
num_points_theta = 48
write_extraction = 0
num_modes = 3
modes = 2 0  2 1  2 2



================================================
FILE: Examples/BinaryBH/params_test.txt
================================================
# GRAMReX BinaryBH parameter file for GitHub Action regression test

#################################################
# Filesystem parameters

verbosity = 1

output_path = .
# amr.check_file = chk
# amr.plot_file = plt
# amr.restart = chk00000
# amr.file_name_digits = 5

amr.check_int = 0
checkpoint_interval = 0
amr.plot_int = 8
plot_interval = 8
amr.derive_plot_vars = ALL

#################################################
# BH Initial Data parameters

massA = 0.5
massB = 0.5

offsetA = -2 0 0
offsetB =  2 0 0

momentumA = 0.0 -0.1 0.0
momentumB = 0.0  0.1 0.0

#################################################
# Grid parameters

N_full = 32
L_full = 8

max_level = 0 # There are (max_level+1) levels

regrid_interval = 0 # no point regridding with no AMR

max_grid_size = 16
block_factor = 16

# tag_buffer_size = 3
# num_ghosts = 3
# center = 8 8 8 # defaults to center of the grid

#################################################
# Boundary Conditions parameters

# Periodic directions - 0 = false, 1 = true
isPeriodic = 0 0 0
# if not periodic, then specify the boundary type
# 0 = static, 1 = sommerfeld, 2 = reflective
# (see BoundaryConditions.hpp for details)
hi_boundary = 1 1 1
lo_boundary = 1 1 2

# if sommerfeld boundaries selected, must select
# non zero asymptotic values
nonzero_asymptotic_vars = chi h11 h22 h33 lapse
nonzero_asymptotic_values = 1.0 1.0 1.0 1.0 1.0

# if you are using extrapolating BC:
# extrapolation_order = 1

# extrapolating_vars =

#################################################
# Evolution parameters

# dt will be dx*dt_multiplier on each grid level
dt_multiplier = 0.25
# stop_time = 1.0
max_steps = 8

# max_spatial_derivative_order = 4 # only 4 implemented at the moment

nan_check = true

# Lapse evolution
lapse_advec_coeff = 1.0
lapse_coeff = 2.0
lapse_power = 1.0

# Shift evolution
shift_advec_coeff = 1.0
shift_Gamma_coeff = 0.75
eta = 1.0

# CCZ4 parameters
formulation = 0 # 1 for BSSN, 0 for CCZ4
kappa1 = 0.1
kappa2 = 0.
kappa3 = 1.
covariantZ4 = 1 # 0: keep kappa1; 1 [default]: replace kappa1 -> kappa1/lapse

# coefficient for KO numerical dissipation
sigma = 0.5

# min_chi = 1.e-4
# min_lapse = 1.e-4

#################################################
# Extraction parameters

# extraction_center = 4 4 0 # defaults to center
activate_extraction = true
# num_extraction_radii = 2
# extraction_radii = 2.0 3.0
# extraction_levels = 2 1
# num_points_phi = 24
# num_points_theta = 37
# num_modes = 8
# modes = 2 0  2 1  2 2  4 0  4 1  4 2  4 3  4 4

#################################################
# Puncture Tracking parameters

puncture_tracking.enabled = 1
puncture_tracking.level = 0



================================================
FILE: Examples/BinaryBH/params_two_punctures.txt
================================================
# See the wiki page for an explanation of the params!
# https://github.com/GRChombo/GRChombo/wiki/Guide-to-parameters

#################################################
# Filesystem parameters

verbosity = 0

# location / naming of output files
# output_path = "" # Main path for all files. Must exist!
chk_prefix = BinaryBHChk_
plot_prefix = BinaryBHPlot_
# restart_file = BinaryBHChk_000000.3d.hdf5

# HDF5files are written every dt = L/N*dt_multiplier*checkpoint_interval
checkpoint_interval = 100
# set to 0 to turn off plot files (except at t=0 and t=stop_time)
# set to -1 to never ever print plotfiles
plot_interval = 10
num_plot_vars = 3
plot_vars = chi Weyl4_Re Weyl4_Im

# subpaths - specific directories for hdf5, pout, extraction data
# (these are created at runtime)
hdf5_subpath = "hdf5"
pout_subpath = "pout"
data_subpath = "data"

# change the name of output files
# pout_prefix = "pout"
print_progress_only_to_rank_0 = 1

# ignore_checkpoint_name_mismatch = 0
# write_plot_ghosts = 0

#################################################
# Initial Data parameters

# provide 'offset' or 'center'

massA = 0.48847892320123
massB = 0.48847892320123

offsetA = 0.0 6.10679 0.0
offsetB = 0.0 -6.10679 0.0
# centerA = 256 232 256
# centerB = 256 250 256

momentumA = -0.0841746 -0.000510846 0.0
momentumB =  0.0841746  0.000510846 0.0

#################################################
# Grid parameters

# 'N' is the number of subdivisions in each direction of a cubic box
# 'L' is the length of the longest side of the box, dx_coarsest = L/N
# NB - If you use reflective BC and want to specify the subdivisions and side
# of the box were there are no symmetries, specify 'N_full' and 'L_full' instead
# NB - if you have a non-cubic grid, you can specify 'N1' or 'N1_full',
# 'N2' or 'N2_full' and 'N3' or 'N3_full' ( then dx_coarsest = L/N(max) )
# NB - the N values need to be multiples of the block_factor
N_full = 64
L_full = 512

# Maximum number of times you can regrid above coarsest level
max_level = 9 # There are (max_level+1) grids, so min is zero

# need max_level entries for regrid interval
# Level Regridding: 0   1   2   3   4   5   6   7   8
regrid_interval =   0   0   0   64  64  64  64  64  64
regrid_threshold = 0.05

# Max and min box sizes
max_box_size = 16
min_box_size = 16

# tag_buffer_size = 3
# grid_buffer_size = 8
# fill_ratio = 0.7
# num_ghosts = 3
# center = 256.0 256.0 256.0 # defaults to center of the grid

#################################################
# Boundary Conditions parameters

# Periodic directions - 0 = false, 1 = true
isPeriodic = 0 0 0
# if not periodic, then specify the boundary type
# 0 = static, 1 = sommerfeld, 2 = reflective
# (see BoundaryConditions.hpp for details)
hi_boundary = 1 1 1
lo_boundary = 1 1 2

# if sommerfeld boundaries selected, must select
# asymptotic values
nonzero_asymptotic_vars = chi h11 h22 h33 lapse
nonzero_asymptotic_values = 1.0 1.0 1.0 1.0 1.0

# if you are using extrapolating BC:
# extrapolation_order = 1
# extrapolating_vars =

#################################################
# Evolution parameters

# dt will be dx*dt_multiplier on each grid level
dt_multiplier = 0.25
stop_time = 2200.0
# max_steps = 100

# Spatial derivative order (only affects CCZ4 RHS)
max_spatial_derivative_order = 4 # can be 4 or 6

nan_check = 1

# Lapse evolution
lapse_advec_coeff = 1.0
lapse_coeff = 2.0
lapse_power = 1.0

# Shift evolution
shift_advec_coeff = 0.0 # Usually no advection for beta
shift_Gamma_coeff = 0.75
eta = 1.0 # eta of gamma driver, should be of order ~1/M_ADM of spacetime

# CCZ4 parameters
formulation = 0 # 1 for BSSN, 0 for CCZ4
kappa1 = 0.1
kappa2 = 0.
kappa3 = 1.
covariantZ4 = 1 # 0: keep kappa1; 1 [default]: replace kappa1 -> kappa1/lapse

# coefficient for KO numerical dissipation
sigma = 1.0

puncture_tracking.enabled = 1
puncture_tracking.level = 5

# calculate_constraint_norms = 0

# min_chi = 1.e-4
# min_lapse = 1.e-4

#################################################
# Extraction parameters

# extraction_center = 256 256 256 # defaults to center
activate_extraction = 1
num_extraction_radii = 2
extraction_radii = 50.0 100.0
extraction_levels = 2 1
num_points_phi = 24
num_points_theta = 37
num_modes = 8
modes = 2 0 # l m for spherical harmonics
        2 1
        2 2
        4 0
        4 1
        4 2
        4 3
        4 4

# integral_file_prefix = "Weyl4_mode_"

# write_extraction = 0
# extraction_subpath = "data/extraction" # directory for 'write_extraction = 1'
# extraction_file_prefix = "Weyl4_extraction_"

#################################################
# Two Punctures parameters

# Main BH params
# Either calculate target masses or set bare masses explicitly below
TP_calculate_target_masses = true
TP_target_mass_plus = 0.5
TP_target_mass_minus = 0.5
# TP_adm_tol = 1e-10
# TP_mass_plus = 0.48847892320123
# TP_mass_minus = 0.48847892320123
# offset in x direction (or z if TP_swap_xz set true)
TP_offset_plus = 6.10679
TP_offset_minus = -6.10679
#TP_swap_xz = false
TP_momentum_plus = -0.000510846 0.0841746 0.0
TP_momentum_minus = 0.000510846 -0.0841746 0.0
TP_spin_plus = 0.0 0.0 0.0
TP_spin_minus = 0.0 0.0 0.0

# Solver params
# TP_npoints_A = 30
# TP_npoints_B = 30
# TP_npoints_phi = 16;
# TP_Newton_tol = 1e-10
# TP_Newton_maxit = 5
TP_epsilon = 1e-6
# TP_Tiny = 0.0
# TP_Extend_Radius = 0.0

# Initial data params
TP_use_spectral_interpolation = true
TP_initial_lapse = psi^n
TP_initial_lapse_psi_exponent = -2.0

# Debug output
# TP_do_residuum_debug_output = false
# TP_do_initial_debug_output = false

#################################################



================================================
FILE: Examples/BinaryBH/params_very_cheap.txt
================================================
# See the wiki page for an explanation of the params!
# https://github.com/GRChombo/GRChombo/wiki/Guide-to-parameters

#################################################
# Filesystem parameters

verbosity = 0

# location / naming of output files
# output_path = "" # Main path for all files. Must exist!
chk_prefix = BinaryBH_
plot_prefix = BinaryBHPlot_
# restart_file = BinaryBH_000360.3d.hdf5

# HDF5files are written every dt = L/N*dt_multiplier*checkpoint_interval
checkpoint_interval = 1
# set to 0 to turn off plot files (except at t=0 and t=stop_time)
# set to -1 to never ever print plotfiles
plot_interval = 1
num_plot_vars = 4
plot_vars = chi Ham Weyl4_Re Weyl4_Im

# subpaths - specific directories for hdf5, pout, extraction data
# (these are created at runtime)
hdf5_subpath = "hdf5"
pout_subpath = "pout"
data_subpath = "data"

# change the name of output files
# pout_prefix = "pout"
print_progress_only_to_rank_0 = 1

# ignore_checkpoint_name_mismatch = 0
# write_plot_ghosts = 0

#################################################
# Initial Data parameters

# provide 'offset' or 'center'

massA = 0.5
massB = 0.5

offsetA = -2 0 0
offsetB =  2 0 0
# centerA =  6 8 8
# centerB = 10 8 8

momentumA = 0.0 -0.1 0.0
momentumB = 0.0  0.1 0.0

#################################################
# Grid parameters

# 'N' is the number of subdivisions in each direction of a cubic box
# 'L' is the length of the longest side of the box, dx_coarsest = L/N
# NB - If you use reflective BC and want to specify the subdivisions and side
# of the box were there are no symmetries, specify 'N_full' and 'L_full' instead
# NB - if you have a non-cubic grid, you can specify 'N1' or 'N1_full',
# 'N2' or 'N2_full' and 'N3' or 'N3_full' ( then dx_coarsest = L/N(max) )
# NB - the N values need to be multiples of the block_factor
N_full = 32
L_full = 16

# Maximum number of times you can regrid above coarsest level
max_level = 2 # There are (max_level+1) grids, so min is zero

# need max_level entries for regrid interval
# Level Regridding: 0   1   2   3   4   5
regrid_interval =   1   1   1   1   0   0
regrid_threshold = 0.3

# Max and min box sizes
max_box_size = 32
min_box_size = 8

# tag_buffer_size = 3
# grid_buffer_size = 8
# fill_ratio = 0.7
# num_ghosts = 3
# center = 8 8 8 # defaults to center of the grid

#################################################
# Boundary Conditions parameters

# Periodic directions - 0 = false, 1 = true
isPeriodic = 0 0 0
# if not periodic, then specify the boundary type
# 0 = static, 1 = sommerfeld, 2 = reflective
# (see BoundaryConditions.hpp for details)
hi_boundary = 1 1 1
lo_boundary = 1 1 2

# if sommerfeld boundaries selected, must select
# non zero asymptotic values
nonzero_asymptotic_vars = chi h11 h22 h33 lapse
nonzero_asymptotic_values = 1.0 1.0 1.0 1.0 1.0

# if you are using extrapolating BC:
# extrapolation_order = 1
# extrapolating_vars =

#################################################
# Evolution parameters

# dt will be dx*dt_multiplier on each grid level
dt_multiplier = 0.25
stop_time = 10.0
# max_steps = 100

# Spatial derivative order (only affects CCZ4 RHS)
max_spatial_derivative_order = 4 # can be 4 or 6

nan_check = 1

# Lapse evolution
lapse_advec_coeff = 1.0
lapse_coeff = 2.0
lapse_power = 1.0

# Shift evolution
shift_advec_coeff = 0.0 # Usually no advection for beta
shift_Gamma_coeff = 0.75
eta = 1.0 # eta of gamma driver, should be of order ~1/M_ADM of spacetime

# CCZ4 parameters
formulation = 0 # 1 for BSSN, 0 for CCZ4
kappa1 = 0.1
kappa2 = 0.
kappa3 = 1.
covariantZ4 = 1 # 0: keep kappa1; 1 [default]: replace kappa1 -> kappa1/lapse

# coefficient for KO numerical dissipation
sigma = 0.3

puncture_tracking.enabled = 1
puncture_tracking.level = 1

# calculate_constraint_norms = 0

# min_chi = 1.e-4
# min_lapse = 1.e-4

#################################################
# Extraction parameters

# extraction_center = 8 8 8 # defaults to center
activate_extraction = 1
num_extraction_radii = 1
extraction_radii = 6.0
extraction_levels = 0
num_points_phi = 24
num_points_theta = 37
num_modes = 3
modes = 2 0 # l m for spherical harmonics
        2 1
        2 2
# integral_file_prefix = "Weyl4_mode_"

# write_extraction = 0
# extraction_subpath = "data/extraction" # directory for 'write_extraction = 1'
# extraction_file_prefix = "Weyl4_extraction_"

#################################################




================================================
FILE: Examples/BinaryBH/SimulationParameters.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SIMULATIONPARAMETERS_HPP
#define SIMULATIONPARAMETERS_HPP

// General includes
#include "GRParmParse.hpp"
#include "SimulationParametersBase.hpp"

// Problem specific includes:
#include "ArrayTools.hpp"
#include "BoostedBHInitialData.hpp"
#ifdef USE_TWOPUNCTURES
#include "TP_Parameters.hpp"
#endif

class SimulationParameters : public SimulationParametersBase
{
  public:
    // NOLINTNEXTLINE(readability-identifier-length)
    SimulationParameters(GRParmParse &pp) : SimulationParametersBase(pp)
    {
        read_shared_params(pp);
#ifdef USE_TWOPUNCTURES
        read_tp_params(pp);
#else
        read_bh_params(pp);
#endif
        check_params();
    }

    /// Read shared parameters
    // NOLINTNEXTLINE(readability-identifier-length)
    void read_shared_params(GRParmParse &pp)
    {
        // Do we want puncture tracking and constraint norm calculation?
        pp.load("puncture_tracking.enabled", puncture_tracking_enabled, false);
        pp.load("puncture_tracking.level", puncture_tracking_level, max_level);
        pp.load("puncture_tracking.writeout_level",
                puncture_tracking_writeout_level, 0);
        pp.load("calculate_constraint_norms", calculate_constraint_norms,
                false);
    }

#ifdef USE_TWOPUNCTURES
    void read_tp_params(GRParmParse &pp)
    {
        tp_params.verbose = (verbosity > 0);
        // check whether to calculate the target ADM masses or use provided bare
        // masses
        bool calculate_target_masses;
        pp.load("TP_calculate_target_masses", calculate_target_masses, false);
        tp_params.give_bare_mass = !calculate_target_masses;

        // masses
        if (calculate_target_masses)
        {
            pp.load("TP_target_mass_plus", tp_params.target_M_plus);
            pp.load("TP_target_mass_minus", tp_params.target_M_minus);
            pp.load("TP_adm_tol", tp_params.adm_tol, 1e-10);
            amrex::Print() << "The black holes have target ADM masses of "
                           << tp_params.target_M_plus << " and "
                           << tp_params.target_M_minus << "\n";
            bh1_params.mass = tp_params.target_M_minus;
            bh2_params.mass = tp_params.target_M_plus;
        }
        else
        {
            pp.load("TP_mass_plus", tp_params.par_m_plus);
            pp.load("TP_mass_minus", tp_params.par_m_minus);
            bh1_params.mass = tp_params.par_m_plus;
            bh2_params.mass = tp_params.par_m_minus;
            amrex::Print() << "The black holes have bare masses of "
                           << std::setprecision(16) << tp_params.par_m_plus
                           << " and " << tp_params.par_m_minus << "\n";
            // reset precision
            amrex::Print() << std::setprecision(6);
        }

        // BH spin and momenta
        std::array<double, AMREX_SPACEDIM> spin_minus, spin_plus;
        pp.load("TP_momentum_minus", bh1_params.momentum);
        pp.load("TP_momentum_plus", bh2_params.momentum);
        pp.load("TP_spin_plus", spin_plus);
        pp.load("TP_spin_minus", spin_minus);
        FOR (i)
        {
            tp_params.par_P_minus[i] = bh1_params.momentum[i];
            tp_params.par_P_plus[i]  = bh2_params.momentum[i];
            tp_params.par_S_minus[i] = spin_minus[i];
            tp_params.par_S_plus[i]  = spin_plus[i];
        }

        amrex::Print() << "The corresponding momenta are:";
        amrex::Print() << "\nP_plus = ";
        FOR (i)
        {
            amrex::Print() << tp_params.par_P_plus[i] << " ";
        }
        amrex::Print() << "\nP_minus = ";
        FOR (i)
        {
            amrex::Print() << tp_params.par_P_minus[i] << " ";
        }

        amrex::Print() << "\nThe corresponding spins are:";
        amrex::Print() << "\nS_plus = ";
        FOR (i)
        {
            amrex::Print() << tp_params.par_S_plus[i] << " ";
        }
        amrex::Print() << "\nS_minus = ";
        FOR (i)
        {
            amrex::Print() << tp_params.par_S_minus[i] << " ";
        }
        amrex::Print() << "\n";

        // interpolation type
        bool use_spectral_interpolation;
        pp.load("TP_use_spectral_interpolation", use_spectral_interpolation,
                false);
        tp_params.grid_setup_method =
            (use_spectral_interpolation) ? "evaluation" : "Taylor expansion";

        // initial_lapse (default to psi^n)
        pp.load("TP_initial_lapse", tp_params.initial_lapse,
                std::string("psi^n"));
        if (tp_params.initial_lapse != "twopunctures-antisymmetric" &&
            tp_params.initial_lapse != "twopunctures-averaged" &&
            tp_params.initial_lapse != "psi^n" &&
            tp_params.initial_lapse != "brownsville")
        {
            std::string message  = "Parameter: TP_initial_lapse: ";
            message             += tp_params.initial_lapse;
            message             += " invalid";
            amrex::Abort(message.c_str());
        }
        if (tp_params.initial_lapse == "psi^n")
        {
            pp.load("TP_initial_lapse_psi_exponent",
                    tp_params.initial_lapse_psi_exponent, -2.0);
        }

        // Spectral grid parameters
        pp.load("TP_npoints_A", tp_params.npoints_A, 30);
        pp.load("TP_npoints_B", tp_params.npoints_B, 30);
        pp.load("TP_npoints_phi", tp_params.npoints_phi, 16);
        if (tp_params.npoints_phi % 4 != 0)
        {
            amrex::Abort("TP_npoints_phi must be a multiple of 4");
        }

        // Solver parameters and tolerances
        pp.load("TP_Newton_tol", tp_params.Newton_tol, 1e-10);
        pp.load("TP_Newton_maxit", tp_params.Newton_maxit, 5);
        pp.load("TP_epsilon", tp_params.TP_epsilon, 1e-6);
        pp.load("TP_Tiny", tp_params.TP_Tiny, 0.0);
        pp.load("TP_Extend_Radius", tp_params.TP_Extend_Radius, 0.0);

        // BH positions
        pp.load("TP_offset_minus", tp_offset_minus);
        pp.load("TP_offset_plus", tp_offset_plus);
        bh1_params.center           = center;
        bh2_params.center           = center;
        bh1_params.center[0]       += tp_offset_minus;
        bh2_params.center[0]       += tp_offset_plus;
        double center_offset_x      = 0.5 * (tp_offset_plus + tp_offset_minus);
        tp_params.center_offset[0]  = center_offset_x;
        // par_b is half the distance between BH_minus and BH_plus
        tp_params.par_b = 0.5 * (tp_offset_plus - tp_offset_minus);
        pp.load("TP_swap_xz", tp_params.swap_xz, false);

        // Debug output
        pp.load("TP_do_residuum_debug_output",
                tp_params.do_residuum_debug_output, false);
        pp.load("TP_do_initial_debug_output", tp_params.do_initial_debug_output,
                false);

        // Irrelevant parameters set to default value
        tp_params.keep_u_around                   = false;
        tp_params.use_sources                     = false;
        tp_params.rescale_sources                 = true;
        tp_params.use_external_initial_guess      = false;
        tp_params.multiply_old_lapse              = false;
        tp_params.schedule_in_ADMBase_InitialData = true;
        tp_params.solve_momentum_constraint       = false;
        tp_params.metric_type                     = "something else";
        tp_params.conformal_storage               = "not conformal at all";
        tp_params.conformal_state                 = 0;
        tp_params.mp                              = 0;
        tp_params.mm                              = 0;
        tp_params.mp_adm                          = 0;
        tp_params.mm_adm                          = 0;
    }
#else
    /// Read BH parameters if not using two punctures
    // NOLINTNEXTLINE(readability-identifier-length)
    void read_bh_params(GRParmParse &pp)
    {
        // Initial data
        pp.load("massA", bh1_params.mass);
        pp.load("momentumA", bh1_params.momentum);
        pp.load("massB", bh2_params.mass);
        pp.load("momentumB", bh2_params.momentum);

        // Get the centers of the BHs either explicitly or as
        // an offset (not both, or they will be offset from center
        // provided)
        std::array<double, AMREX_SPACEDIM> centerA{};
        std::array<double, AMREX_SPACEDIM> centerB{};
        std::array<double, AMREX_SPACEDIM> offsetA{};
        std::array<double, AMREX_SPACEDIM> offsetB{};
        pp.load("centerA", centerA, center);
        pp.load("centerB", centerB, center);
        pp.load("offsetA", offsetA, {0.0, 0.0, 0.0});
        pp.load("offsetB", offsetB, {0.0, 0.0, 0.0});
        FOR (idir)
        {
            bh1_params.center[idir] = centerA[idir] + offsetA[idir];
            bh2_params.center[idir] = centerB[idir] + offsetB[idir];
        }
    }
#endif /* USE_TWOPUNCTURES */

    void check_params()
    {
#ifdef USE_TWOPUNCTURES
        // These checks are mostly taken from the Einstein Toolkit thorn
        // documentation:
        // https://einsteintoolkit.org/thornguide/EinsteinInitialData/TwoPunctures/documentation.html
        std::string mass_plus_name, mass_minus_name;
        if (tp_params.give_bare_mass)
        {
            mass_minus_name = "TP_mass_minus";
            mass_plus_name  = "TP_mass_plus";
        }
        else
        {
            mass_minus_name = "TP_target_mass_minus";
            mass_plus_name  = "TP_target_mass_plus";
            check_parameter("TP_adm_tol", tp_params.adm_tol,
                            tp_params.adm_tol > 0., "must be > 0.0");
        }
        check_parameter(mass_minus_name, bh1_params.mass, bh1_params.mass >= 0.,
                        "mustd be >= 0.0");
        check_parameter(mass_plus_name, bh2_params.mass, bh2_params.mass >= 0.,
                        "must be >= 0.0");

        int offset_dir = (!tp_params.swap_xz) ? 0 : 2;
        warn_parameter("TP_offset_minus", tp_offset_minus,
                       tp_offset_minus < (ivN[offset_dir] + 1) * coarsest_dx -
                                             center[offset_dir],
                       "should be within the computational domain");
        warn_parameter("TP_offset_plus", tp_offset_plus,
                       tp_offset_plus < (ivN[offset_dir] + 1) * coarsest_dx -
                                            center[offset_dir],
                       "should be within the computational domain");
        check_parameter("TP_npoints_A", tp_params.npoints_A,
                        tp_params.npoints_A >= 4, "must be >= 4");
        check_parameter("TP_npoints_B", tp_params.npoints_B,
                        tp_params.npoints_B >= 4, "must be >= 4");
        check_parameter("TP_npoints_phi", tp_params.npoints_phi,
                        tp_params.npoints_phi >= 4 &&
                            tp_params.npoints_phi % 2 == 0,
                        "must be >= 4 and divisible by 2");
        check_parameter("TP_Newton_maxit", tp_params.Newton_maxit,
                        tp_params.Newton_maxit >= 0, "must be >= 0");
        check_parameter("TP_Newton_tol", tp_params.Newton_tol,
                        tp_params.Newton_tol >= 0., "must be >= 0.0");
        check_parameter("TP_epsilon", tp_params.TP_epsilon,
                        tp_params.TP_epsilon >= 0., "must be >= 0.0");
        check_parameter("TP_Tiny", tp_params.TP_Tiny, tp_params.TP_Tiny >= 0.,
                        "must be >= 0.0");
        check_parameter("TP_Extend_Radius", tp_params.TP_Extend_Radius,
                        tp_params.TP_Extend_Radius >= 0., "must be >= 0.0");
#else
        warn_parameter("massA", bh1_params.mass, bh1_params.mass >= 0,
                       "should be >= 0");
        warn_parameter("massB", bh2_params.mass, bh2_params.mass >= 0,
                       "should be >= 0");
        warn_array_parameter(
            "momentumA", bh1_params.momentum,
            std::sqrt(ArrayTools::norm2(bh1_params.momentum)) <
                0.3 * bh1_params.mass,
            "approximation used for boosted BH only valid for small boosts");
        warn_array_parameter(
            "momentumB", bh2_params.momentum,
            std::sqrt(ArrayTools::norm2(bh2_params.momentum)) <
                0.3 * bh1_params.mass,
            "approximation used for boosted BH only valid for small boosts");
        FOR (idir)
        {
            std::string nameA   = "centerA[" + std::to_string(idir) + "]";
            std::string nameB   = "centerB[" + std::to_string(idir) + "]";
            double center_A_dir = bh1_params.center[idir];
            double center_B_dir = bh2_params.center[idir];
            warn_parameter(nameA, center_A_dir,
                           (center_A_dir >= 0.0) &&
                               (center_A_dir <= (ivN[idir] + 1) * coarsest_dx),
                           "should be within the computational domain");
            warn_parameter(nameB, center_B_dir,
                           (center_B_dir >= 0.0) &&
                               (center_B_dir <= (ivN[idir] + 1) * coarsest_dx),
                           "should be within the computational domain");
        }
#endif /* USE_TWOPUNCTURES */
        check_parameter("puncture_tracking_level", puncture_tracking_level,
                        (puncture_tracking_level >= 0) &&
                            (puncture_tracking_level <= max_level),
                        "must be between 0 and max_level (inclusive)");
    }

    bool puncture_tracking_enabled{};
    int puncture_tracking_level{};
    int puncture_tracking_writeout_level{};
    bool calculate_constraint_norms{};

    // Collection of parameters necessary for initial conditions
    // Set these even in the case of TwoPunctures as they are used elsewhere
    // e.g. for puncture tracking/tagging
    BoostedBHInitialData::params_t bh2_params{};
    BoostedBHInitialData::params_t bh1_params{};

#ifdef USE_TWOPUNCTURES
    double tp_offset_plus, tp_offset_minus;
    TP::Parameters tp_params;
#endif
};

#endif /* SIMULATIONPARAMETERS_HPP */



================================================
FILE: Examples/BinaryBH/StateVariables.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef STATEVARIABLES_HPP
#define STATEVARIABLES_HPP

#include "ArrayTools.hpp"
#include "BCParity.hpp"
#include "CCZ4StateVariables.hpp"

/// This enum gives the index of every variable stored in the grid
enum
{
    // Note that it is important that the first enum value is set to 1 more than
    // the last CCZ4 var enum
    NUM_VARS = NUM_CCZ4_VARS,
};

namespace StateVariables
{
static const amrex::Vector<std::string> names = CCZ4StateVariables::names;

static const std::array<BCParity, NUM_VARS> parities =
    CCZ4StateVariables::parities;
} // namespace StateVariables

#endif /* STATEVARIABLES_HPP */



================================================
FILE: Examples/BinaryBH/TPAMR.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef TPAMR_HPP_
#define TPAMR_HPP_

// Even if USE_TWOPUNCTURES is not defined, this file will include BHAMR.hpp
#include "BHAMR.hpp"

#ifdef USE_TWOPUNCTURES
#include "TwoPunctures.hpp"

/// A descendent of Chombo's AMR class to interface with tools which require
/// access to the whole AMR hierarchy, and those of GRAMR
/**
 * This object inherits from BHAMR and adds members relevant to TwoPunctures
 * initial data
 */
class TPAMR : public BHAMR
{
  public:
    TP::TwoPunctures m_two_punctures;

    void set_two_punctures_parameters(const TP::Parameters &params)
    {
        // explicitly invoke copy constructor of base Parameters class
        m_two_punctures.Parameters::operator=(params);
    }
};

#endif /* USE_TWOPUNCTURES */

#endif /* TPAMR_HPP_ */



================================================
FILE: Examples/KleinGordon/README.md
================================================
# Klein-Gordon Solver

This example solves the Klein-Gordon equation in the absense of GR. Please note that this example does not have a dynamical metric, and simply assumes a Minkowski-flat background metric. It is intended to provide a simple example that implements a real scalar wave equation, showing how different initial data, diagnostics and parameters can be set.
```math
\frac{\partial^2 \phi}{\partial t^2} = \nabla^2 \phi + V(\phi),
```

In the example parameter file, `params_test.ini`, you will find a section of parameters prefaced by `klein_gordon` - these control the behaviour of the Klein-Gordon simulation. 
The most important one of these is `klein_gordon.model`, for which you will need to enter a string to select the particular model being simulated. The model string must be one of the following:  
#### Wave  
This will solve the wave equation:
```math
\frac{\partial^2 \phi}{\partial t^2} = \nabla^2 \phi + \frac{1}{2} m^2 \phi^2
```
Without the potential term, the analytic solution is:
```math
$$ \phi (\bf{r},t) = \exp\left[i(\bf{k_r \cdot \bf{r}} - \omega t)\right] $$
```
We also assume $\omega = k_r$ since $c=1$.

#### SineGordon1D 
This will solve the 1D Sine Gordon equation:
```math
\frac{\partial^2 \phi}{\partial t^2} = \frac{\partial^2 \phi}{\partial x^2} - \sin \phi
```
The analytic breather solution is:
```math
\phi(x,t) = 4 \arctan \left(\frac{\beta \cos(\alpha t)}{\alpha \cosh(\beta x)} \right)
```
where $\beta = \sqrt{1-\alpha^2}$
Note that it is a 1D solution embedded in a 3D simulation volume so `AMREX_SPACEDIM` is still set to 3.
#### SineGordon3D
This will solve the 3D Sine Gordon  equation:
```math
\frac{\partial^2 \phi}{\partial t^2} = \nabla^2 \phi - \sin \phi
```
The analytic pseudo-breather solution is
```math
\phi(x,y,z,t) = 4 \arctan \left(\frac{\beta \cos(\alpha t)}{\alpha \cosh(\beta x)} \right) \times
                4 \arctan \left(\frac{\beta \cos(\alpha t)}{\alpha \cosh(\beta y)} \right) \times
                4 \arctan \left(\frac{\beta \cos(\alpha t)}{\alpha \cosh(\beta z)} \right)

```

Other settings in the parameter file:
* `klein_gordon.alpha` - (only for `SineGordon` models) controls the frequency of the breather mode and must be less than 1.
* `klein_gordon.scalar_mass` - (only for `Wave` model) mass of the scalar field in the potential
* `klein_gordon.wave_vector` - (only for the `Wave` model) this is the characteristic wave number, $$k_r$$, in the above equations. 
* `klein_gordon.initial_time` - starting time for the initial conditions, this is important for the analytic solution to match up to numerical solution.

There are three derived parameters available: 
* `phi_analytic` - the analytic solution to the field value at each cell
* `Pi_analytic` - the analytic solution to the first derivative of the field value at each cell
* `rho` - the value of the energy density at each cell.

Note that the analytic solution to the wave equation assumes no potential, i.e. $$m=0$$.

These will be outputted to the plot files if `amr.derive_plot_vars` is set with the name of the variable. Use `amr.derive_plot_vars = ALL` to print all the derived variables. 



================================================
FILE: Examples/KleinGordon/DerivedVariables.hpp
================================================
#ifndef DERIVEDVARIABLES_HPP_
#define DERIVEDVARIABLES_HPP_

// AMReX includes
#include <AMReX_BLFort.H>
#include <AMReX_FArrayBox.H>
#include <AMReX_Geometry.H>
#include <AMReX_ParmParse.H>

// GRTeclyn includes
#include "Coordinates.hpp"
#include "VarsTools.hpp"

// KleinGordon includes
#include "KleinGordonRHS.hpp"
#include "SineGordon.hpp"
#include "Wave.hpp"

// For unused variables in the function signature, you don't have to name them
// and it is best practice to comment them out. However, they must still be
// included in any derived variable function definition because AMReX expects a
// certain function signature

// NB: The analytic solution doesn't use the input MultiFab mf_in - if you want
// to use the current state variables, you will need to uncomment this.
AMREX_FORCE_INLINE void
calc_analytic_solution(amrex::MultiFab &mf_out, int dcomp, int /*numcomp*/,
                       const amrex::MultiFab & /*mf_in*/,
                       const amrex::Geometry &geom, const amrex::Real time,
                       const int * /*bcomp*/, int /*scomp*/);

template <typename model_t>
AMREX_FORCE_INLINE void
calc_energy_density(amrex::MultiFab &mf_out, int dcomp, int /*numcomp*/,
                    const amrex::MultiFab &mf_in,
                    const amrex::Geometry /*&geom*/, const amrex::Real /*time*/,
                    const int * /*bcomp*/, int /*scomp*/);

template <typename model_t>
AMREX_FORCE_INLINE void calc_analytic_mf_3d(amrex::MultiFab &mf_out, int dcomp,
                                            const amrex::Geometry &geom,
                                            const amrex::Real time);

template <typename model_t>
AMREX_FORCE_INLINE void calc_analytic_mf_1d(amrex::MultiFab &mf_out, int dcomp,
                                            const amrex::Geometry &geom,
                                            const amrex::Real time);

// This needs to be a .hpp file because there is a template definition inside
// The template arguments are expanded inline by the compiler in the .hpp file.
#include "DerivedVariables.impl.hpp"

#endif // DERIVEDVARIABLES_HPP_



================================================
FILE: Examples/KleinGordon/DerivedVariables.impl.hpp
================================================
#if !defined(DERIVEDVARIABLES_HPP_)
#error "This file should only be included through DerivedVariables.hpp"
#endif

#ifndef DERIVEDVARIABLES_IMPL_HPP_
#define DERIVEDVARIABLES_IMPL_HPP_

AMREX_FORCE_INLINE void
calc_analytic_solution(amrex::MultiFab &mf_out, int dcomp, int /*numcomp*/,
                       const amrex::MultiFab & /*mf_in*/,
                       const amrex::Geometry &geom, const amrex::Real time,
                       const int * /*bcomp*/, int /*scomp*/)
{
    amrex::ParmParse pp("klein_gordon");
    std::string model{};
    pp.query("model", model);

    amrex::Real scalar_mass{0.0};
    pp.query("scalar_mass", scalar_mass);

    if (model == "SineGordon1D")
    {
        calc_analytic_mf_1d<SineGordon>(mf_out, dcomp, geom, time);
    }
    if (model == "SineGordon3D")
    {
        calc_analytic_mf_3d<SineGordon>(mf_out, dcomp, geom, time);
    }
    // This is a special case because the analytic solution assumes no potential
    // If a potential is given then fill the analytic solution with zeros
    if (model == "Wave" && scalar_mass == 0)
    {
        calc_analytic_mf_3d<Wave>(mf_out, dcomp, geom, time);
    }
}

template <typename model_t>
AMREX_FORCE_INLINE void
calc_energy_density(amrex::MultiFab &mf_out, int dcomp, int /*numcomp*/,
                    const amrex::MultiFab &mf_in,
                    const amrex::Geometry /*&geom*/, const amrex::Real /*time*/,
                    const int * /*bcomp*/, int /*scomp*/)
{

    const auto &arrs_out = mf_out.arrays();
    const auto &arrs_in =
        mf_in.const_arrays(); // do not alter the original values

    model_t model;

    amrex::ParallelFor(
        mf_out, mf_out.nGrowVect(),
        [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k) noexcept
        {
            const auto field_values = arrs_in[box_no].cellData(i, j, k);

            // You can also access any state variables like this:
            // amrex::Real phi = arrs_in[box_no](i, j, k, c_phi);
            // amrex::Real Pi = arrs_in[box_no](i, j, k, c_Pi);

            amrex::Real V_of_phi = 0.0;
            amrex::Real dVdphi   = 0.0;

            model.compute_potential(V_of_phi, dVdphi, field_values[c_phi]);

            arrs_out[box_no](i, j, k, dcomp) =
                0.5 * field_values[c_Pi] * field_values[c_Pi] - V_of_phi;
        });
    amrex::Gpu::streamSynchronize();
}

template <typename model_t>
AMREX_FORCE_INLINE void calc_analytic_mf_3d(amrex::MultiFab &mf_out, int dcomp,
                                            const amrex::Geometry &geom,
                                            const amrex::Real time)
{
    amrex::ParmParse pp;

    // Get the geometry of the simulation
    const auto dx = geom.CellSizeArray();

    std::array<amrex::Real, AMREX_SPACEDIM> center{};
    pp.query("center", center);

    model_t model;

    auto const &arrs = mf_out.arrays();

    amrex::ParallelFor(
        mf_out, mf_out.nGrowVect(),
        [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k) noexcept
        {
            amrex::IntVect grid_pos(i, j, k);
            Coordinates pos(grid_pos, dx[0], center);

            arrs[box_no](i, j, k, dcomp) =
                model.calculate(pos.x, pos.y, pos.z, time);
            arrs[box_no](i, j, k, dcomp + 1) =
                model.calculate_time_derivative(pos.x, pos.y, pos.z, time);
        });
    amrex::Gpu::streamSynchronize();
};

template <typename model_t>
AMREX_FORCE_INLINE void calc_analytic_mf_1d(amrex::MultiFab &mf_out, int dcomp,
                                            const amrex::Geometry &geom,
                                            const amrex::Real time)
{
    amrex::ParmParse pp;

    // Get the geometry of the simulation
    const auto dx = geom.CellSizeArray();

    std::array<amrex::Real, AMREX_SPACEDIM> center{};
    pp.query("center", center);

    model_t model;

    auto const &arrs = mf_out.arrays();

    amrex::ParallelFor(
        mf_out, mf_out.nGrowVect(),
        [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k) noexcept
        {
            amrex::IntVect grid_pos(i, j, k);
            Coordinates pos(grid_pos, dx[0], center);

            arrs[box_no](i, j, k, dcomp) = model.calculate(pos.x, time);
            arrs[box_no](i, j, k, dcomp + 1) =
                model.calculate_time_derivative(pos.x, time);
        });
    amrex::Gpu::streamSynchronize();
};

#endif // DERIVEDVARIABLES_IMPL_HPP_



================================================
FILE: Examples/KleinGordon/GNUmakefile
================================================
GRTECLYN_HOME = $(realpath ../..)

include $(GRTECLYN_HOME)/Tools/GNUMake/Make.defaults

AMREX_HOME ?= $(realpath ../../../amrex)


include $(AMREX_HOME)/Tools/GNUMake/Make.defs

include ./Make.package
include $(AMREX_HOME)/Src/Base/Make.package
include $(AMREX_HOME)/Src/Boundary/Make.package
include $(AMREX_HOME)/Src/AmrCore/Make.package
include $(AMREX_HOME)/Src/Amr/Make.package

include $(GRTECLYN_HOME)/Tools/GNUMake/Make.rules

GRTECLYN_SOURCE = $(GRTECLYN_HOME)/Source

src_dirs := $(GRTECLYN_SOURCE)/AMRInterpolator \
            $(GRTECLYN_SOURCE)/Grids \
            $(GRTECLYN_SOURCE)/GRTeclynCore \
            $(GRTECLYN_SOURCE)/IO \
            $(GRTECLYN_SOURCE)/Maths \
            $(GRTECLYN_SOURCE)/Tagging


src_pack := $(foreach dir, $(src_dirs), $(dir)/Make.package)
include $(src_pack)
CEXE_sources += $(GRTECLYN_CEXE_sources)
CEXE_headers += $(GRTECLYN_CEXE_headers)
VPATH_LOCATIONS += $(src_dirs)
INCLUDE_LOCATIONS += $(realpath .) $(src_dirs)

include $(GRTECLYN_HOME)/Tools/GNUMake/Make.rules





================================================
FILE: Examples/KleinGordon/KleinGordonLevel.cpp
================================================
#include "KleinGordonLevel.hpp"
#include "FixedGridsTagger.hpp"
#include "FourthOrderDerivatives.hpp"
#include "KleinGordonRHS.hpp"
#include <numeric>

void KleinGordonLevel::variableSetUp()
{
    BL_PROFILE("KleinGordonLevel::variableSetUp()");

    // Set up the state variables
    stateVariableSetUp();

    // The first two derived variables calculate the analytic solution
    //  for phi and Pi

    const std::string &comp_type                = {"analytic_soln"};
    const amrex::Vector<std::string> comp_names = {"phi_analytic",
                                                   "Pi_analytic"};

    int ncomp_analytic{
        static_cast<int>(comp_names.size())}; // how many derived variables

    derive_lst.add(
        comp_type, amrex::IndexType::TheCellType(), ncomp_analytic, comp_names,
        calc_analytic_solution, [=](const amrex::Box &box) { return box; },
        &amrex::cell_quartic_interp);
    derive_lst.addComponent("analytic_soln", desc_lst, State_Type, 0, 1);

    // The following is an example of how to use the current state to compute a
    // new derived variable that depends on the state variables and the
    // potential

    amrex::ParmParse pp("klein_gordon");
    std::string model{};
    pp.query("model", model);

    const int ncomp_rho{1}; // only one component associated with energy density
    const int nghosts_rho{2};

    if (model == "Wave")
    {
        derive_lst.add(
            "rho", amrex::IndexType::TheCellType(), ncomp_rho,
            calc_energy_density<Wave>, [=](const amrex::Box &box)
            { return amrex::grow(box, nghosts_rho); },
            &amrex::cell_quartic_interp);
    }

    if (model.find("SineGordon") == 0)
    {
        derive_lst.add(
            "rho", amrex::IndexType::TheCellType(), ncomp_rho,
            calc_energy_density<SineGordon>, [=](const amrex::Box &box)
            { return amrex::grow(box, nghosts_rho); },
            &amrex::cell_quartic_interp);
    }

    derive_lst.addComponent("rho", desc_lst, State_Type, 0, NUM_VARS);
}

void KleinGordonLevel::initData()
{
    BL_PROFILE("KleinGordonLevel::initData()");

    std::array<double, AMREX_SPACEDIM> center{};
    std::string model{};
    amrex::Real initial_time{0.0};

    amrex::ParmParse pp;
    pp.query("center", center);
    pp.query("klein_gordon.model", model);
    pp.query("klein_gordon.initial_time", initial_time);

    amrex::MultiFab &state_new = get_new_data(State_Type);
    auto const &array_new      = state_new.arrays();

    int dcomp{0};
    const amrex::Real current_time{
        0.0}; // initial time is an internal parameter
              // to the model class so the actual
              // simulation time is what we want here

    // NB: the analytic solutions are defined in InitialConditions.cpp
    // The functions below are defined in DerivedVariables.cpp
    if (model == "Wave")
    {
        calc_analytic_mf_3d<Wave>(state_new, dcomp, geom, current_time);
    }
    else if (model == "SineGordon1D")
    {
        calc_analytic_mf_1d<SineGordon>(state_new, dcomp, geom, current_time);
    }
    else
    {
        calc_analytic_mf_3d<SineGordon>(state_new, dcomp, geom, current_time);
    }
}

// NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
void KleinGordonLevel::specificEvalRHS(amrex::MultiFab &a_soln,
                                       amrex::MultiFab &a_rhs,
                                       const double a_time)
{
    BL_PROFILE("KleinGordonLevel::specificEvalRHS()");

    auto const &soln_arrs = a_soln.const_arrays();
    auto const &rhs_arrs  = a_rhs.arrays();

    amrex::ParmParse pp("klein_gordon");

    std::string model{};

    pp.query("model", model);

    if (model == "Wave")
    {
        eval_model_specific_rhs<Wave>(a_soln, a_rhs);
    }
    else
    {
        eval_model_specific_rhs<SineGordon>(a_soln, a_rhs);
    }

    amrex::Gpu::streamSynchronize();
}

// NOLINTBEGIN(bugprone-easily-swappable-parameters)
template <class model_t>
void KleinGordonLevel::eval_model_specific_rhs(amrex::MultiFab &a_soln,
                                               amrex::MultiFab &a_rhs)
// NOLINTEND(bugprone-easily-swappable-parameters)
{

    const auto dx         = Geom().CellSize(0);
    const auto &soln_arrs = a_soln.const_arrays();
    const auto &rhs_arrs  = a_rhs.arrays();

    model_t my_model;
    KleinGordonRHS rhs(simParams().sigma, dx, my_model);

    amrex::ParallelFor(
        a_soln, [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k) noexcept
        { rhs.compute(i, j, k, soln_arrs[box_no], rhs_arrs[box_no]); });
}

void KleinGordonLevel::tag_cells(amrex::TagBoxArray &tags,
                                 amrex::Real a_regrid_threshold)
{

    // This is an example of how to apply a tagging criterion to mark cells for
    // further refinement.

    // The FixedGridsTagger used here will always tag the inner
    // L/4 cells of the simulation volume, regardless of the
    // field values. You can also ask that the cells be tagged
    // when the field value or its derivative reaches a certain value.

    BL_PROFILE("KleinGordonLevel::tag_cells()");

    amrex::MultiFab &state_new = get_new_data(State_Type);

    const auto &tag_arrs   = tags.arrays();
    const auto &state_arrs = state_new.arrays();

    const amrex::Real dx         = Geom().CellSize(0);
    const int current_level      = Level();
    const amrex::Real box_length = Geom().ProbLength(0);
    std::array<double, AMREX_SPACEDIM> center{AMREX_D_DECL(0., 0., 0.)};
    GRParmParse pp;
    pp.query("center", center);

    FixedGridsTagger my_tagging_criterion{dx, current_level, box_length,
                                          center};

    amrex::ParallelFor(tags,
                       [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k)
                       { my_tagging_criterion(i, j, k, tag_arrs[box_no]); });
    amrex::Gpu::streamSynchronize();
}



================================================
FILE: Examples/KleinGordon/KleinGordonLevel.hpp
================================================
#ifndef KLEINGORDONLEVEL_HPP_
#define KLEINGORDONLEVEL_HPP_

#include "DefaultLevelFactory.hpp"
#include "DerivedVariables.hpp"
#include "GRAMRLevel.hpp"
#include "KleinGordonRHS.hpp"
#include "VarsTools.hpp"

class KleinGordonLevel : public GRAMRLevel
{
  public:
    using GRAMRLevel::GRAMRLevel;

    //! Define data descriptors.
    static void variableSetUp();
    //    static void variableCleanUp ();

    //! Initialize data at problem start-up.
    void initData() override;

    //! Advance this level for one step

    void specificEvalRHS(amrex::MultiFab &a_soln, amrex::MultiFab &a_rhs,
                         const double a_time) override;

    /// Things to do after dt*rhs has been added to the solution
    void specificUpdateODE(amrex::MultiFab &a_soln) override {};

    // to do post each time step on every level
    void specificPostTimeStep() override {};

    //! Error estimation for regridding.
    void tag_cells(amrex::TagBoxArray &tags,
                   amrex::Real a_regrid_threshold) override;

    template <class model_t>
    void eval_model_specific_rhs(amrex::MultiFab &a_soln,
                                 amrex::MultiFab &a_rhs);

  private:

    KleinGordonLevel &getLevel(int lev)
    {
        return dynamic_cast<KleinGordonLevel &>(parent->getLevel(lev));
    }
};

#endif /* KLEINGORDONLEVEL_HPP_ */



================================================
FILE: Examples/KleinGordon/KleinGordonRHS.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef KLEINGORDONRHS_HPP_
#define KLEINGORDONRHS_HPP_

// GRTeclyn includes
#include "Cell.hpp"
#include "FourthOrderDerivatives.hpp"
#include "TensorAlgebra.hpp"
#include "VarsTools.hpp"

// Problem specific includes
#include "StateVariables.hpp"

template <class model_t, class deriv_t = FourthOrderDerivatives>
class KleinGordonRHS
{
  public:

    // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
    KleinGordonRHS(amrex::Real a_sigma, amrex::Real a_dx, model_t a_model)
        : m_sigma(a_sigma), m_deriv(a_dx), m_model(a_model) {};

    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
    compute(int i, int j, int k, const amrex::Array4<amrex::Real const> &input,
            const amrex::Array4<amrex::Real> &output) const;

  private:
    amrex::Real m_sigma;
    deriv_t m_deriv;
    model_t m_model;

    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void rhs_equation(
        const amrex::CellData<amrex::Real const> &input_cell_data,
        const amrex::CellData<amrex::Real> &output_cell_data,
        const amrex::Array1D<amrex::Real, 0, AMREX_SPACEDIM> &d2phi) const;
};

#include "KleinGordonRHS.impl.hpp"

#endif



================================================
FILE: Examples/KleinGordon/KleinGordonRHS.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(KLEINGORDONRHS_HPP_)
#error "This file should only be included through KleinGordonRHS.hpp"
#endif

#ifndef KLEINGORDONRHS_IMPL_HPP_
#define KLEINGORDONRHS_IMPL_HPP_

#include "KleinGordonRHS.hpp"

template <class model_t, class deriv_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
KleinGordonRHS<model_t, deriv_t>::compute(
    int i, int j, int k, const amrex::Array4<amrex::Real const> &input,
    const amrex::Array4<amrex::Real> &output) const

{
    const auto *input_ptr_ijk = input.ptr(i, j, k);
    amrex::Array1D<amrex::Real, 0, AMREX_SPACEDIM>
        d2phi{}; // no cross second order derivatives needed
    amrex::Array1D<int, 0, AMREX_SPACEDIM> strides{AMREX_D_DECL(
        1, static_cast<int>(input.jstride), static_cast<int>(input.kstride))};

    FOR (i)
    {
        d2phi(i) =
            m_deriv.diff2(input_ptr_ijk + c_phi * input.nstride, 0, strides(i));
    }

    rhs_equation(input.cellData(i, j, k), output.cellData(i, j, k), d2phi);

    // add dissipation term
    amrex::Real phi_dissipation = 0.0;
    amrex::Real Pi_dissipation  = 0.0;

    FOR (i)
    {

        phi_dissipation +=
            m_sigma * m_deriv.dissipation_term(
                          input_ptr_ijk + c_phi * input.nstride, 0, strides(i));

        Pi_dissipation +=
            m_sigma * m_deriv.dissipation_term(
                          input_ptr_ijk + c_Pi * input.nstride, 0, strides(i));
    }

    output.cellData(i, j, k)[c_phi] += phi_dissipation;
    output.cellData(i, j, k)[c_Pi]  += Pi_dissipation;
}

template <class model_t, class deriv_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
KleinGordonRHS<model_t, deriv_t>::rhs_equation(
    const amrex::CellData<amrex::Real const> &input_cell_data,
    const amrex::CellData<amrex::Real> &output_cell_data,
    const amrex::Array1D<amrex::Real, 0, AMREX_SPACEDIM> &d2phi) const
{
    output_cell_data[c_phi] = input_cell_data[c_Pi];

    output_cell_data[c_Pi] = d2phi.sum();

    // add on the potential
    amrex::Real V_of_phi = 0.0;
    amrex::Real dVdphi   = 0.0;

    m_model.compute_potential(V_of_phi, dVdphi, input_cell_data[c_phi]);

    output_cell_data[c_Pi] += dVdphi;
}

#endif // KLEINGORDONRHS_IMPL_HPP_



================================================
FILE: Examples/KleinGordon/Main_KleinGordon.cpp
================================================
/* GRChombo
 * Copyright 2012 The GRChombo collaboration.
 * Please refer to LICENSE in GRChombo's root directory.
 */

// Our includes
#include "DefaultLevelFactory.hpp"
#include "GRParmParse.hpp"
#include "SetupFunctions.hpp"
#include "SimulationParameters.hpp"

// Problem specific includes:
#include "KleinGordonLevel.hpp"

// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
int runGRTeclyn(int /*argc*/, char * /*argv*/[])
{
    BL_PROFILE("runGRTeclyn()");

    // Load the parameter file and construct the SimulationParameter class
    // To add more parameters edit the SimulationParameters file.
    GRParmParse pp; // NOLINT(readability-identifier-length)
    SimulationParameters sim_params(pp);

    if (sim_params.just_check_params)
    {
        return 0;
    }

    GRAMR::set_simulation_parameters(sim_params);

    amrex::Print() << "Now running " << sim_params.model << " simulation"
                   << "\n";

    DefaultLevelFactory<KleinGordonLevel> KleinGordon_level_bld;

    GRAMR amr(&KleinGordon_level_bld);

    amr.init(0., sim_params.stop_time);

    while ((amr.okToContinue() != 0) &&
           (amr.levelSteps(0) < sim_params.max_steps ||
            sim_params.max_steps < 0) &&
           (amr.cumTime() < sim_params.stop_time || sim_params.stop_time < 0.0))
    {
        amr.coarseTimeStep(sim_params.stop_time);
    }

    // Write final checkpoint and plotfile
    if (amr.stepOfLastCheckPoint() < amr.levelSteps(0) &&
        sim_params.checkpoint_interval >= 0)
    {
        amr.checkPoint();
    }

    if (amr.stepOfLastPlotFile() < amr.levelSteps(0) &&
        sim_params.plot_interval >= 0)
    {
        amr.writePlotFile();
    }

    return 0;
}

int main(int argc, char *argv[])
{
    mainSetup(argc, argv);

    int status = runGRTeclyn(argc, argv);

    if (status == 0)
    {
        amrex::Print() << "GRTeclyn finished.\n";
    }
    else
    {
        amrex::Print() << "GRTeclyn failed with return code " << status << "\n";
    }

    mainFinalize();
    return status;
}



================================================
FILE: Examples/KleinGordon/Make.package
================================================
CEXE_sources += KleinGordonLevel.cpp \
                Main_KleinGordon.cpp

CEXE_headers += DerivedVariables.hpp \
                DerivedVariables.impl.hpp \
                KleinGordonLevel.hpp \
                KleinGordonRHS.hpp \
                SimulationParameters.hpp \
                SineGordon.hpp \
                StateVariables.hpp \
                Wave.hpp



================================================
FILE: Examples/KleinGordon/params_test.txt
================================================
max_steps = 8
stop_time = 2

#################################################
# Geometry and Boundary Conditions parameters

# Periodic directions - 0 = false, 1 = true
isPeriodic          =  1   1   1
center              =  16 16 16

L_full              =  32     # geometric extent (same for all directions)
N_full              =  64     # size of coarse grid


#################################################
# AMR parameters

verbosity           =  1
max_level           =  0     # maximum level number allowed
regrid_interval     =  2     # must be defined even if single level
max_box_size        =  64    # maximum allowed grid size
block_factor        =  16    # block factor

amr.v = 1



##################################################

output_path = "."           # not used right now
amr.plot_files_output = 1   # write plot files or not (overrides all other plot file commands)
#How often to write plot files, can use either
plot_interval = 1           # (hold over from GRChombo)
amr.plot_int = 1            # (AMReX variable)
checkpoint_interval = 8

amr.checkpoint_files_output = 1  # write checkpoint files or not (overrides all other checkpoint options)
amr.check_int = 8

amr.plot_vars = ALL
amr.derive_plot_vars = ALL   #also write out derived parameters
amr.plot_file = plt
amr.check_file =chk


rk_order = 4
dt_multiplier = 0.2
sigma = 0.3 #coefficient for KO dissipation
nan_check=True

tag_buffer_size=1

#Klein Gordon Parameters
# Choose from "Wave" or "SineGordon1D" or "SineGordon3D"

# Example parameters for SineGordon models
# NB: alpha must be defined
# If SineGordon3D is specified then the initial time
# can't be 0 because then the solution is uniformly 0

klein_gordon.model = SineGordon3D
klein_gordon.alpha = 0.7
klein_gordon.initial_time = -5.4;


# Example parameters for Wave model
# NB: wave_vector must be defined
#klein_gordon.model = Wave
#klein_gordon.wave_vector = 10.
#klein_gordon.scalar_mass = 1      # potential is scalar_mass^2 phi^2 - only relevant for Wave models



================================================
FILE: Examples/KleinGordon/SimulationParameters.hpp
================================================
/* GRChombo
 * Copyright 2012 The GRChombo collaboration.
 * Please refer to LICENSE in GRChombo's root directory.
 */

#ifndef SIMULATIONPARAMETERS_HPP
#define SIMULATIONPARAMETERS_HPP

// General includes
#include "AMReXParameters.hpp"
#include "GRParmParse.hpp"

// Problem specific includes:
#include "ArrayTools.hpp"

class SimulationParameters : public AMReXParameters
{
  public:
    // NOLINTNEXTLINE(readability-identifier-length)
    SimulationParameters(GRParmParse &pp) : AMReXParameters(pp)
    {
        // These parameters normally get read in inside SimulationParametersBase
        // but as this example doesn't use a lot of the other (CCZ4) parameters
        // this particular SimulationParameters class doesn't inherit from it.

        pp.queryAdd("sigma", sigma);

        pp.queryAdd("nan_check", nan_check);

        read_klein_gordon_params(pp);
    }

    // NOLINTNEXTLINE(readability-identifier-length)
    void read_klein_gordon_params(GRParmParse &pp)
    {
        // If the wave number isn't found in the params file
        // (so not wave ICs), look for the alpha parameter
        // (assume Sine-Gordon instead).

        pp.queryAdd("klein_gordon.model", model);
        pp.queryAdd("klein_gordon.initial_time", t0);

        if (model == "Wave")
        {

            pp.queryAdd("klein_gordon.wave_vector", k_r);
            // Only wave example has the scalar mass as a parameter
            // SineGordon potential does not have a mass
            // associated with it.

            pp.queryAdd(
                "klein_gordon.scalar_mass",
                scalar_mass); // What is the mass of the scalar particle?
        }
        else if (model.find("SineGordon") ==
                 0) // this is for Sine-Gordon ICs only
        {
            // These are parameters specfic to the Sine Gordon example
            pp.queryAdd("klein_gordon.alpha", alpha);
        }
        else
        {
            amrex::Abort(
                "SimulationParameters: Klein Gordon model option not "
                "recognized. Choose from Wave, SineGordon1D or SineGordon3D.");
        }
    }

    static const int ncomp{2};

    amrex::Real alpha{1.0};
    amrex::Real k_r{1.0};
    amrex::Real scalar_mass{0.0};
    amrex::Real sigma{0.0};
    amrex::Real t0{0.0};

    std::string model{"Wave"};
    bool nan_check{true};
};

#endif /* SIMULATIONPARAMETERS_HPP */



================================================
FILE: Examples/KleinGordon/SineGordon.hpp
================================================
#ifndef SINEGORDON_HPP_
#define SINEGORDON_HPP_

// C++ std lib includes
#include <cmath>
// AMReX includes
#include <AMReX_MultiFab.H>
#include <AMReX_ParmParse.H>
// KleinGordon includes
#include "StateVariables.hpp"

class SineGordon
{
  public:
    amrex::Real m_alpha{0.7};
    amrex::Real m_t0{0.0};

    SineGordon()
    {
        amrex::ParmParse pp("klein_gordon");
        pp.query("alpha", m_alpha);
        pp.query("initial_time", m_t0);
    };

    // NOLINTBEGIN(bugprone-easily-swappable-parameters)
    [[nodiscard]] AMREX_GPU_DEVICE AMREX_FORCE_INLINE amrex::Real
    calculate(const amrex::Real x, const amrex::Real t) const
    // NOLINTEND(bugprone-easily-swappable-parameters)
    {
        // Sine Gordon 1D breather solution
        amrex::Real beta = std::sqrt(1.0 - m_alpha * m_alpha);

        return 4.0 * std::atan(beta * std::cos(m_alpha * (t + m_t0)) / m_alpha /
                               std::cosh(beta * x));
    };
    [[nodiscard]] AMREX_GPU_DEVICE AMREX_FORCE_INLINE amrex::Real
    // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
    calculate_time_derivative(const amrex::Real x, const amrex::Real t) const
    {
        amrex::Real beta = std::sqrt(1.0 - m_alpha * m_alpha);

        // First derivative of Sine Gordon 1D breather solution

        // Using cosh^2 (beta*x) = 1/2(1+cosh(2*beta*x)) and
        // cos^2(beta*t) = 0.5*(1+cos(2*beta*t))

        amrex::Real numerator =
            m_alpha * std::sin(m_alpha * (t + m_t0)) * std::cosh(beta * x);
        amrex::Real denominator =
            0.5 * m_alpha * m_alpha * (1.0 + std::cosh(2.0 * beta * x)) +
            0.5 * beta * beta * (1.0 + std::cos(2.0 * beta * t));

        return -4.0 * m_alpha * beta * numerator / denominator;
    };

    // NOLINTBEGIN(bugprone-easily-swappable-parameters)
    [[nodiscard]] AMREX_GPU_DEVICE AMREX_FORCE_INLINE amrex::Real
    calculate(const amrex::Real x, const amrex::Real y, const amrex::Real z,
              const amrex::Real t) const
    // NOLINTEND(bugprone-easily-swappable-parameters)
    {
        amrex::Real beta = std::sqrt(1.0 - m_alpha * m_alpha);

        amrex::Real numerator = m_alpha * std::sin(beta * (t + m_t0)) / beta;

        // Sine Gordon 3D psuedo-breather solution

        return 4.0 * 4.0 * 4.0 * std::atan(numerator / std::cosh(m_alpha * x)) *
               std::atan(numerator / std::cosh(m_alpha * y)) *
               std::atan(numerator / std::cosh(m_alpha * z));
    };

    // NOLINTBEGIN(bugprone-easily-swappable-parameters
    [[nodiscard]] AMREX_GPU_DEVICE AMREX_FORCE_INLINE amrex::Real
    calculate_time_derivative(const amrex::Real x, const amrex::Real y,
                              const amrex::Real z, const amrex::Real t) const
    // NOLINTEND(bugprone-easily-swappable-parameters
    {
        // Sine Gordon 3D psuedo-breather solution

        amrex::Real beta = std::sqrt(1.0 - m_alpha * m_alpha);

        // Define these repeated calculations for convenience
        amrex::Real beta_time  = beta * (t + m_t0);
        amrex::Real sine_time  = m_alpha * std::sin(beta_time) / beta;
        amrex::Real cos_time   = m_alpha * beta * beta * std::cos(beta_time);
        amrex::Real cos_2_time = 1.0 - std::cos(2.0 * beta_time);

        amrex::Real x_term = std::atan(sine_time / std::cosh(m_alpha * x));
        amrex::Real y_term = std::atan(sine_time / std::cosh(m_alpha * y));
        amrex::Real z_term = std::atan(sine_time / std::cosh(m_alpha * z));

        amrex::Real dxdt_term = cos_time * std::cosh(m_alpha * x);
        dxdt_term /= (0.5 * beta * beta * (1.0 + std::cosh(2.0 * m_alpha * x)) +
                      0.5 * m_alpha * m_alpha * cos_2_time);

        amrex::Real dydt_term = cos_time * std::cosh(m_alpha * y);
        dydt_term /= (0.5 * beta * beta * (1.0 + std::cosh(2.0 * m_alpha * y)) +
                      0.5 * m_alpha * m_alpha * cos_2_time);

        amrex::Real dzdt_term = cos_time * std::cosh(m_alpha * z);
        dzdt_term /= (0.5 * beta * beta * (1.0 + std::cosh(2.0 * m_alpha * z)) +
                      0.5 * m_alpha * m_alpha * cos_2_time);

        return 64.0 *
               (dxdt_term * y_term * z_term + x_term * dydt_term * z_term +
                x_term * y_term * dzdt_term);
    };

    // NOLINTBEGIN(bugprone-easily-swappable-parameters)
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void static compute_potential(
        amrex::Real &V_of_phi, amrex::Real &dVdphi, const amrex::Real &phi)
    // NOLINTEND(bugprone-easily-swappable-parameters)
    {
        V_of_phi = std::sin(phi);

        dVdphi = std::cos(phi);
    }
};
#endif // SINEGORDON_HPP_



================================================
FILE: Examples/KleinGordon/StateVariables.hpp
================================================
/* GRChombo
 * Copyright 2012 The GRChombo collaboration.
 * Please refer to LICENSE in GRChombo's root directory.
 */

#ifndef STATEVARIABLES_HPP
#define STATEVARIABLES_HPP

#include "ArrayTools.hpp"
#include "BCParity.hpp"

// assign an enum to each variable
enum
{
    c_phi,
    c_Pi,

    NUM_VARS,
};

namespace StateVariables
{
static const amrex::Vector<std::string> names{"phi", "Pi"};

static const std::array<BCParity, NUM_VARS> parities = {BCParity::even,
                                                        BCParity::even};
// The example parameter file uses periodic boundary conditions, in which the
// parities aren't used but must be defined. However you could use reflective
// boundary conditions with the above parity definitions.

} // namespace StateVariables

#endif /* STATEVARIABLES_HPP */



================================================
FILE: Examples/KleinGordon/Wave.hpp
================================================
#ifndef WAVE_HPP_
#define WAVE_HPP_

// C++ std lib includes
#include <cmath>
// AMReX includes
#include <AMReX_MultiFab.H>
#include <AMReX_ParmParse.H>
// KleinGordon includes
#include "StateVariables.hpp"

class Wave
{
  public:
    amrex::Real m_k_r{1.0};
    amrex::Real m_mass{0.0};
    amrex::Real m_t0{0.0};

    // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
    Wave()
    {
        amrex::ParmParse pp("klein_gordon");
        pp.query("wave_vector", m_k_r);
        pp.query("scalar_mass", m_mass);
        pp.query("initial_time", m_t0);
    };

    // NOLINTBEGIN(bugprone-easily-swappable-parameters)
    [[nodiscard]] AMREX_GPU_DEVICE AMREX_FORCE_INLINE amrex::Real
    calculate(const amrex::Real x, const amrex::Real y, const amrex::Real z,
              const amrex::Real t) const
    // NOLINTEND(bugprone-easily-swappable-parameters)
    {
        amrex::Real omega = m_k_r;

        // for the wave to be at the center of the grid, need to pass in
        // (x-x_midpt), (y-y_midpt) and (z-z_midpt)
        amrex::Real rr2 = x * x + y * y + z * z; // this is the radius

        return std::cos(m_k_r * rr2 - omega * (t + m_t0));
    };

    // NOLINTBEGIN(bugprone-easily-swappable-parameters)
    [[nodiscard]] AMREX_GPU_DEVICE AMREX_FORCE_INLINE amrex::Real
    calculate_time_derivative(const amrex::Real x, const amrex::Real y,
                              const amrex::Real z, const amrex::Real t) const
    // NOLINTEND(bugprone-easily-swappable-parameters)
    {
        amrex::Real omega = m_k_r;

        // for the wave to be at the center of the grid, need to pass in
        // (x-x_midpt), (y-y_midpt) and (z-z_midpt)
        amrex::Real rr2 = x * x + y * y + z * z; // this is the radius

        return omega * std::sin(m_k_r * rr2 - omega * (t + m_t0));
    };

    // NOLINTBEGIN(bugprone-easily-swappable-parameters)
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
    compute_potential(amrex::Real &V_of_phi, amrex::Real &dVdphi,
                      const amrex::Real &phi) const
    // NOLINTEND(bugprone-easily-swappable-parameters)
    {

        V_of_phi = 0.5 * m_mass * m_mass * phi * phi;

        dVdphi = m_mass * m_mass * phi;
    }
};

#endif // WAVE_HPP_



================================================
FILE: Examples/ScalarField/GNUmakefile.old
================================================
# -*- Mode: Makefile -*-

### This makefile produces an executable for each name in the `ebase'
###  variable using the libraries named in the `LibNames' variable.

# Included makefiles need an absolute path to the Chombo installation
# CHOMBO_HOME := Please set the CHOMBO_HOME locally (e.g. export CHOMBO_HOME=... in bash)

GRCHOMBO_SOURCE = ../../Source

ebase := Main_ScalarField

LibNames := AMRTimeDependent AMRTools BoxTools

src_dirs := $(GRCHOMBO_SOURCE)/utils \
            $(GRCHOMBO_SOURCE)/simd  \
            $(GRCHOMBO_SOURCE)/CCZ4  \
            $(GRCHOMBO_SOURCE)/Matter  \
            $(GRCHOMBO_SOURCE)/BoxUtils  \
            $(GRCHOMBO_SOURCE)/GRChomboCore  \
            $(GRCHOMBO_SOURCE)/TaggingCriteria  \
            $(GRCHOMBO_SOURCE)/AMRInterpolator  \
            $(GRCHOMBO_SOURCE)/InitialConditions/BlackHoles

include $(CHOMBO_HOME)/mk/Make.test



================================================
FILE: Examples/ScalarField/InitialScalarData.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef INITIALSCALARDATA_HPP_
#define INITIALSCALARDATA_HPP_

#include "Cell.hpp"
#include "Coordinates.hpp"
#include "MatterCCZ4RHS.hpp"
#include "ScalarField.hpp"
#include "StateVariables.hpp" //This files needs NUM_VARS - total no. components
#include "Tensor.hpp"
#include "VarsTools.hpp"
#include "simd.hpp"

//! Class which sets the initial scalar field matter config
class InitialScalarData
{
  public:
    //! A structure for the input params for scalar field properties and initial
    //! conditions
    struct params_t
    {
        double amplitude; //!< Amplitude of bump in initial SF bubble
        std::array<double, AMREX_SPACEDIM>
            center;   //!< Centre of perturbation in initial SF bubble
        double width; //!< Width of bump in initial SF bubble
    };

    //! The constructor
    InitialScalarData(params_t a_params, double a_dx)
        : m_dx(a_dx), m_params(a_params)
    {
    }

    //! Function to compute the value of all the initial vars on the grid
    template <class data_t> void compute(Cell<data_t> current_cell) const
    {
        // where am i?
        Coordinates<data_t> coords(current_cell, m_dx, m_params.center);
        data_t rr  = coords.get_radius();
        data_t rr2 = rr * rr;

        // calculate the field value
        data_t phi = m_params.amplitude *
                     (1.0 + 0.01 * rr2 * exp(-pow(rr / m_params.width, 2.0)));

        // store the vars
        current_cell.store_vars(phi, c_phi);
        current_cell.store_vars(0.0, c_Pi);
    }

  protected:
    double m_dx;
    const params_t m_params; //!< The matter initial condition params
};

#endif /* INITIALSCALARDATA_HPP_ */



================================================
FILE: Examples/ScalarField/Main_ScalarField.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// Chombo includes
#include "parstream.H" //Gives us amrex::Print()

// System includes
#include <iostream>

// Our general includes
#include "DefaultLevelFactory.hpp"
#include "GRAMR.hpp"
#include "GRParmParse.hpp"
#include "SetupFunctions.hpp"
#include "SimulationParameters.hpp"

// Problem specific includes:
#include "ScalarFieldLevel.hpp"

// Chombo namespace
#include "UsingNamespace.H"

int runGRTeclyn(int argc, char *argv[])
{
    // Load the parameter file and construct the SimulationParameter class
    // To add more parameters edit the SimulationParameters file.
    char *in_file = argv[1];
    GRParmParse pp(argc - 2, argv + 2, NULL, in_file);
    SimulationParameters sim_params(pp);

    if (sim_params.just_check_params)
        return 0;

    // The line below selects the problem that is simulated
    // (To simulate a different problem, define a new child of AMRLevel
    // and an associated LevelFactory)
    GRAMR gr_amr;
    DefaultLevelFactory<ScalarFieldLevel> scalar_field_level_fact(gr_amr,
                                                                  sim_params);
    setupAMRObject(gr_amr, scalar_field_level_fact);

    // Engage! Run the evolution
    gr_amr.run(sim_params.stop_time, sim_params.max_steps);
    gr_amr.conclude();

    return 0;
}

int main(int argc, char *argv[])
{
    mainSetup(argc, argv);

    int status = runGRTeclyn(argc, argv);

    if (status == 0)
        amrex::Print() << "GRChombo finished." << std::endl;
    else
        amrex::Print() << "GRChombo failed with return code " << status
                       << std::endl;

    mainFinalize();
    return status;
}



================================================
FILE: Examples/ScalarField/params.txt
================================================
# See the wiki page for an explanation of the params!
# https://github.com/GRChombo/GRChombo/wiki/Guide-to-parameters

#################################################
# Filesystem parameters

verbosity = 0

# location / naming of output files
# output_path = "" # Main path for all files. Must exist!
chk_prefix = ScalarField_
plot_prefix = ScalarFieldp_
# restart_file = ScalarField_000000.3d.hdf5

# HDF5files are written every dt = L/N*dt_multiplier*checkpoint_interval
checkpoint_interval = 500
# set to 0 to turn off plot files (except at t=0 and t=stop_time)
# set to -1 to never ever print plotfiles
plot_interval = 1
num_plot_vars = 2
plot_vars = chi phi

# subpaths - specific directories for hdf5, pout, extraction data
# (these are created at runtime)
hdf5_subpath = "hdf5"
pout_subpath = "pout"
data_subpath = "data"

# change the name of output files
# pout_prefix = "pout"
print_progress_only_to_rank_0 = 1

# ignore_checkpoint_name_mismatch = 0
# write_plot_ghosts = 0

#################################################
# Initial Data parameters

# Change the gravitational constant of the Universe!
# Default is 1.0, for standard geometric units
# Here we decouple the evolution so the scalar evolved on the
# metric background without backreaction (this avoids the need
# to solve the constaints)
G_Newton = 0.0

# Scalar field initial data
scalar_amplitude = 0.1
scalar_width = 5.0
scalar_mass = 0.2

# Kerr BH data
kerr_mass = 1.0
kerr_spin = 0.0

#################################################
# Grid parameters

# 'N' is the number of subdivisions in each direction of a cubic box
# 'L' is the length of the longest side of the box, dx_coarsest = L/N
# NB - If you use reflective BC and want to specify the subdivisions and side
# of the box were there are no symmetries, specify 'N_full' and 'L_full' instead
# NB - if you have a non-cubic grid, you can specify 'N1' or 'N1_full',
# 'N2' or 'N2_full' and 'N3' or 'N3_full' ( then dx_coarsest = L/N(max) )
# NB - the N values need to be multiples of the block_factor
N_full = 128
L_full = 256

# Maximum number of times you can regrid above coarsest level
max_level = 6 # There are (max_level+1) grids, so min is zero

# Frequency of regridding at each level and thresholds on the tagging
# Need one for each level except the top one, ie max_level items
# Generally you do not need to regrid frequently on every level
# in this example turn off regridding on all levels
# Level Regridding: 0   1   2   3   4   5
regrid_interval   = 0   0   0   0   0   0
# regrid_threshold  = 0.5

regrid_interval = 0 0 0 0 0 0

# Max and min box sizes
max_box_size = 16
min_box_size = 16

tag_buffer_size = 0 # this example uses a fixed grid

# grid_buffer_size = 8
# fill_ratio = 0.7
# num_ghosts = 3
# center = 256.0 256.0 256.0 # defaults to center of the grid

#################################################
# Boundary Conditions parameters

#Periodic directions - 0 = false, 1 = true
isPeriodic = 0 0 0
# if not periodic, then specify the boundary type
# 0 = static, 1 = sommerfeld, 2 = reflective
# 3 = extrapolating, 4 = mixed
# (see BoundaryConditions.hpp for details)
hi_boundary = 4 4 4
lo_boundary = 2 2 2

# if sommerfeld boundaries selected, must select
# non zero asymptotic values
nonzero_asymptotic_vars = chi h11 h22 h33 lapse
nonzero_asymptotic_values = 1.0 1.0 1.0 1.0 1.0

# if you are using extrapolating BC:
extrapolation_order = 1
extrapolating_vars = phi Pi

#################################################
# Evolution parameters

# dt will be dx*dt_multiplier on each grid level
dt_multiplier = 0.25
stop_time = 100.0
# max_steps = 4

# Spatial derivative order (only affects CCZ4 RHS)
max_spatial_derivative_order = 4 # can be 4 or 6

nan_check = 1

# Lapse evolution
lapse_advec_coeff = 1.0
lapse_coeff = 2.0
lapse_power = 1.0

# Shift evolution
shift_advec_coeff = 0.0 # Usually no advection for beta
shift_Gamma_coeff = 0.75
eta = 1.0 # eta of gamma driver, should be of order ~1/M_ADM of spacetime

# CCZ4 parameters
formulation = 1 # 1 for BSSN, 0 for CCZ4
kappa1 = 0.
kappa2 = 0.
kappa3 = 0.
covariantZ4 = 1 # 0: keep kappa1; 1 [default]: replace kappa1 -> kappa1/lapse

# coefficient for KO numerical dissipation
sigma = 0.3

# min_chi = 1.e-4
# min_lapse = 1.e-4

#################################################



================================================
FILE: Examples/ScalarField/Potential.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef POTENTIAL_HPP_
#define POTENTIAL_HPP_

#include "simd.hpp"

class Potential
{
  public:
    struct params_t
    {
        double scalar_mass;
    };

  private:
    params_t m_params;

  public:
    //! The constructor
    Potential(params_t a_params) : m_params(a_params) {}

    //! Set the potential function for the scalar field here
    template <class data_t, template <typename> class vars_t>
    void compute_potential(data_t &V_of_phi, data_t &dVdphi,
                           const vars_t<data_t> &vars) const
    {
        // The potential value at phi
        // 1/2 m^2 phi^2
        V_of_phi = 0.5 * pow(m_params.scalar_mass * vars.phi, 2.0);

        // The potential gradient at phi
        // m^2 phi
        dVdphi = pow(m_params.scalar_mass, 2.0) * vars.phi;
    }
};

#endif /* POTENTIAL_HPP_ */



================================================
FILE: Examples/ScalarField/ScalarFieldLevel.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// General includes common to most GR problems
#include "ScalarFieldLevel.hpp"
#include "BoxLoops.hpp"
#include "NanCheck.hpp"
#include "PositiveChiAndAlpha.hpp"
#include "SixthOrderDerivatives.hpp"
#include "TraceARemoval.hpp"

// For RHS update
#include "MatterCCZ4RHS.hpp"

// For constraints calculation
#include "NewMatterConstraints.hpp"

// For tag cells
#include "FixedGridsTaggingCriterion.hpp"

// Problem specific includes
#include "ComputePack.hpp"
#include "GammaCalculator.hpp"
#include "InitialScalarData.hpp"
#include "KerrBH.hpp"
#include "Potential.hpp"
#include "ScalarField.hpp"
#include "SetValue.hpp"

// Things to do at each advance step, after the RK4 is calculated
void ScalarFieldLevel::specificAdvance()
{
    // Enforce trace free A_ij and positive chi and alpha
    BoxLoops::loop(
        make_compute_pack(TraceARemoval(),
                          PositiveChiAndAlpha(m_p.min_chi, m_p.min_lapse)),
        m_state_new, m_state_new, INCLUDE_GHOST_CELLS);

    // Check for nan's
    if (m_p.nan_check)
        BoxLoops::loop(NanCheck(), m_state_new, m_state_new,
                       EXCLUDE_GHOST_CELLS, disable_simd());
}

// Initial data for field and metric variables
void ScalarFieldLevel::initialData()
{
    BL_PROFILE("ScalarFieldLevel::initialData");
    if (m_verbosity)
        amrex::Print() << "ScalarFieldLevel::initialData " << m_level << endl;

    // First set everything to zero then initial conditions for scalar field -
    // here a Kerr BH and a scalar field profile
    BoxLoops::loop(
        make_compute_pack(SetValue(0.), KerrBH(m_p.kerr_params, m_dx),
                          InitialScalarData(m_p.initial_params, m_dx)),
        m_state_new, m_state_new, INCLUDE_GHOST_CELLS);

    fillAllGhosts();
    BoxLoops::loop(GammaCalculator(m_dx), m_state_new, m_state_new,
                   EXCLUDE_GHOST_CELLS);
}

// Things to do in RHS update, at each RK4 step
void ScalarFieldLevel::specificEvalRHS(GRLevelData &a_soln, GRLevelData &a_rhs,
                                       const double a_time)
{
    // Enforce trace free A_ij and positive chi and alpha
    BoxLoops::loop(
        make_compute_pack(TraceARemoval(),
                          PositiveChiAndAlpha(m_p.min_chi, m_p.min_lapse)),
        a_soln, a_soln, INCLUDE_GHOST_CELLS);

    // Calculate MatterCCZ4 right hand side with matter_t = ScalarField
    Potential potential(m_p.potential_params);
    ScalarFieldWithPotential scalar_field(potential);
    if (m_p.max_spatial_derivative_order == 4)
    {
        MatterCCZ4RHS<ScalarFieldWithPotential, MovingPunctureGauge,
                      FourthOrderDerivatives>
            my_ccz4_matter(scalar_field, m_p.ccz4_params, m_dx, m_p.sigma,
                           m_p.formulation, m_p.G_Newton);
        BoxLoops::loop(my_ccz4_matter, a_soln, a_rhs, EXCLUDE_GHOST_CELLS);
    }
    else if (m_p.max_spatial_derivative_order == 6)
    {
        MatterCCZ4RHS<ScalarFieldWithPotential, MovingPunctureGauge,
                      SixthOrderDerivatives>
            my_ccz4_matter(scalar_field, m_p.ccz4_params, m_dx, m_p.sigma,
                           m_p.formulation, m_p.G_Newton);
        BoxLoops::loop(my_ccz4_matter, a_soln, a_rhs, EXCLUDE_GHOST_CELLS);
    }
}

// Things to do at ODE update, after soln + rhs
void ScalarFieldLevel::specificUpdateODE(GRLevelData &a_soln,
                                         const GRLevelData &a_rhs, Real a_dt)
{
    // Enforce trace free A_ij
    BoxLoops::loop(TraceARemoval(), a_soln, a_soln, INCLUDE_GHOST_CELLS);
}

void ScalarFieldLevel::preTagCells()
{
    // we don't need any ghosts filled for the fixed grids tagging criterion
    // used here so don't fill any
}

void ScalarFieldLevel::computeTaggingCriterion(FArrayBox &tagging_criterion,
                                               const FArrayBox &current_state)
{
    BoxLoops::loop(
        FixedGridsTaggingCriterion(m_dx, m_level, 2.0 * m_p.L, m_p.center),
        current_state, tagging_criterion);
}



================================================
FILE: Examples/ScalarField/ScalarFieldLevel.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SCALARFIELDLEVEL_HPP_
#define SCALARFIELDLEVEL_HPP_

#include "DefaultLevelFactory.hpp"
#include "GRAMRLevel.hpp"
// Problem specific includes
#include "Potential.hpp"
#include "ScalarField.hpp"

//!  A class for the evolution of a scalar field, minimally coupled to gravity
/*!
     The class takes some initial data for a scalar field (variables phi and Pi)
     and evolves it using the CCZ4 equations. It is possible to specify an
   initial period of relaxation for the conformal factor chi, for non analytic
   initial conditions (for example, a general field configuration at a moment of
   time symmetry assuming conformal flatness). \sa MatterCCZ4(),
   ConstraintsMatter(), ScalarField(), RelaxationChi()
*/
class ScalarFieldLevel : public GRAMRLevel
{
    friend class DefaultLevelFactory<ScalarFieldLevel>;
    // Inherit the contructors from GRAMRLevel
    using GRAMRLevel::GRAMRLevel;

    // Typedef for scalar field
    typedef ScalarField<Potential> ScalarFieldWithPotential;

    //! Things to do at the end of the advance step, after RK4 calculation
    virtual void specificAdvance();

    //! Initialize data for the field and metric variables
    virtual void initialData();

    //! RHS routines used at each RK4 step
    virtual void specificEvalRHS(GRLevelData &a_soln, GRLevelData &a_rhs,
                                 const double a_time);

    //! Things to do in UpdateODE step, after soln + rhs update
    virtual void specificUpdateODE(GRLevelData &a_soln,
                                   const GRLevelData &a_rhs, Real a_dt);

    /// Things to do before tagging cells (i.e. filling ghosts)
    virtual void preTagCells() override;

    //! Tell Chombo how to tag cells for regridding
    virtual void computeTaggingCriterion(FArrayBox &tagging_criterion,
                                         const FArrayBox &current_state);
};

#endif /* SCALARFIELDLEVEL_HPP_ */



================================================
FILE: Examples/ScalarField/SimulationParameters.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SIMULATIONPARAMETERS_HPP_
#define SIMULATIONPARAMETERS_HPP_

// General includes
#include "GRParmParse.hpp"
#include "SimulationParametersBase.hpp"

// Problem specific includes:
#include "InitialScalarData.hpp"
#include "KerrBH.hpp"
#include "Potential.hpp"

class SimulationParameters : public SimulationParametersBase
{
  public:
    SimulationParameters(GRParmParse &pp) : SimulationParametersBase(pp)
    {
        // read the problem specific params
        read_params(pp);
        check_params();
    }

    void read_params(GRParmParse &pp)
    {
        // Initial scalar field data
        initial_params.center =
            center; // already read in SimulationParametersBase
        pp.load("G_Newton", G_Newton,
                0.0); // for now the example neglects backreaction
        pp.load("scalar_amplitude", initial_params.amplitude, 0.1);
        pp.load("scalar_width", initial_params.width, 1.0);
        pp.load("scalar_mass", potential_params.scalar_mass, 0.1);

        // Initial Kerr data
        pp.load("kerr_mass", kerr_params.mass, 1.0);
        pp.load("kerr_spin", kerr_params.spin, 0.0);
        pp.load("kerr_center", kerr_params.center, center);
    }

    void check_params()
    {
        warn_parameter("scalar_mass", potential_params.scalar_mass,
                       potential_params.scalar_mass <
                           0.2 / coarsest_dx / dt_multiplier,
                       "oscillations of scalar field do not appear to be "
                       "resolved on coarsest level");
        warn_parameter("scalar_width", initial_params.width,
                       initial_params.width < 0.5 * L,
                       "is greater than half the domain size");
        warn_parameter("kerr_mass", kerr_params.mass, kerr_params.mass >= 0.0,
                       "should be >= 0.0");
        check_parameter("kerr_spin", kerr_params.spin,
                        std::abs(kerr_params.spin) <= kerr_params.mass,
                        "must satisfy |a| <= M = " +
                            std::to_string(kerr_params.mass));
        FOR (idir)
        {
            std::string name = "kerr_center[" + std::to_string(idir) + "]";
            warn_parameter(
                name, kerr_params.center[idir],
                (kerr_params.center[idir] >= 0) &&
                    (kerr_params.center[idir] <= (ivN[idir] + 1) * coarsest_dx),
                "should be within the computational domain");
        }
    }

    // Initial data for matter and potential and BH
    double G_Newton;
    InitialScalarData::params_t initial_params;
    Potential::params_t potential_params;
    KerrBH::params_t kerr_params;
};

#endif /* SIMULATIONPARAMETERS_HPP_ */



================================================
FILE: Examples/ScalarField/StateVariables.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef STATEVARIABLES_HPP
#define STATEVARIABLES_HPP

#include "ArrayTools.hpp"
#include "CCZ4StateVariables.hpp"

// assign an enum to each variable
enum
{
    // Note that it is important that the first enum value is set to 1 more than
    // the last CCZ4 var enum
    c_phi = NUM_CCZ4_VARS, // matter field added
    c_Pi,                  //(minus) conjugate momentum

    NUM_VARS
};

namespace StateVariables
{
static const amrex::Vector<std::string> additional_names = {"phi", "Pi"};

static const amrex::Vector<std::string> names =
    ArrayTools::concatenate(CCZ4StateVariables::names, additional_names);
} // namespace StateVariables

#endif /* STATEVARIABLES_HPP */



================================================
FILE: external/doctest/doctest.h
================================================
// ====================================================================== lgtm [cpp/missing-header-guard]
// == DO NOT MODIFY THIS FILE BY HAND - IT IS AUTO GENERATED BY CMAKE! ==
// ======================================================================
//
// doctest.h - the lightest feature-rich C++ single-header testing framework for unit tests and TDD
//
// Copyright (c) 2016-2023 Viktor Kirilov
//
// Distributed under the MIT Software License
// See accompanying file LICENSE.txt or copy at
// https://opensource.org/licenses/MIT
//
// The documentation can be found at the library's page:
// https://github.com/doctest/doctest/blob/master/doc/markdown/readme.md
//
// =================================================================================================
// =================================================================================================
// =================================================================================================
//
// The library is heavily influenced by Catch - https://github.com/catchorg/Catch2
// which uses the Boost Software License - Version 1.0
// see here - https://github.com/catchorg/Catch2/blob/master/LICENSE.txt
//
// The concept of subcases (sections in Catch) and expression decomposition are from there.
// Some parts of the code are taken directly:
// - stringification - the detection of "ostream& operator<<(ostream&, const T&)" and StringMaker<>
// - the Approx() helper class for floating point comparison
// - colors in the console
// - breaking into a debugger
// - signal / SEH handling
// - timer
// - XmlWriter class - thanks to Phil Nash for allowing the direct reuse (AKA copy/paste)
//
// The expression decomposing templates are taken from lest - https://github.com/martinmoene/lest
// which uses the Boost Software License - Version 1.0
// see here - https://github.com/martinmoene/lest/blob/master/LICENSE.txt
//
// =================================================================================================
// =================================================================================================
// =================================================================================================

#ifndef DOCTEST_LIBRARY_INCLUDED
#define DOCTEST_LIBRARY_INCLUDED

// =================================================================================================
// == VERSION ======================================================================================
// =================================================================================================

#define DOCTEST_VERSION_MAJOR 2
#define DOCTEST_VERSION_MINOR 4
#define DOCTEST_VERSION_PATCH 11

// util we need here
#define DOCTEST_TOSTR_IMPL(x) #x
#define DOCTEST_TOSTR(x) DOCTEST_TOSTR_IMPL(x)

#define DOCTEST_VERSION_STR                                                                        \
    DOCTEST_TOSTR(DOCTEST_VERSION_MAJOR) "."                                                       \
    DOCTEST_TOSTR(DOCTEST_VERSION_MINOR) "."                                                       \
    DOCTEST_TOSTR(DOCTEST_VERSION_PATCH)

#define DOCTEST_VERSION                                                                            \
    (DOCTEST_VERSION_MAJOR * 10000 + DOCTEST_VERSION_MINOR * 100 + DOCTEST_VERSION_PATCH)

// =================================================================================================
// == COMPILER VERSION =============================================================================
// =================================================================================================

// ideas for the version stuff are taken from here: https://github.com/cxxstuff/cxx_detect

#ifdef _MSC_VER
#define DOCTEST_CPLUSPLUS _MSVC_LANG
#else
#define DOCTEST_CPLUSPLUS __cplusplus
#endif

#define DOCTEST_COMPILER(MAJOR, MINOR, PATCH) ((MAJOR)*10000000 + (MINOR)*100000 + (PATCH))

// GCC/Clang and GCC/MSVC are mutually exclusive, but Clang/MSVC are not because of clang-cl...
#if defined(_MSC_VER) && defined(_MSC_FULL_VER)
#if _MSC_VER == _MSC_FULL_VER / 10000
#define DOCTEST_MSVC DOCTEST_COMPILER(_MSC_VER / 100, _MSC_VER % 100, _MSC_FULL_VER % 10000)
#else // MSVC
#define DOCTEST_MSVC                                                                               \
    DOCTEST_COMPILER(_MSC_VER / 100, (_MSC_FULL_VER / 100000) % 100, _MSC_FULL_VER % 100000)
#endif // MSVC
#endif // MSVC
#if defined(__clang__) && defined(__clang_minor__) && defined(__clang_patchlevel__)
#define DOCTEST_CLANG DOCTEST_COMPILER(__clang_major__, __clang_minor__, __clang_patchlevel__)
#elif defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__) &&              \
        !defined(__INTEL_COMPILER)
#define DOCTEST_GCC DOCTEST_COMPILER(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
#endif // GCC
#if defined(__INTEL_COMPILER)
#define DOCTEST_ICC DOCTEST_COMPILER(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, 0)
#endif // ICC

#ifndef DOCTEST_MSVC
#define DOCTEST_MSVC 0
#endif // DOCTEST_MSVC
#ifndef DOCTEST_CLANG
#define DOCTEST_CLANG 0
#endif // DOCTEST_CLANG
#ifndef DOCTEST_GCC
#define DOCTEST_GCC 0
#endif // DOCTEST_GCC
#ifndef DOCTEST_ICC
#define DOCTEST_ICC 0
#endif // DOCTEST_ICC

// =================================================================================================
// == COMPILER WARNINGS HELPERS ====================================================================
// =================================================================================================

#if DOCTEST_CLANG && !DOCTEST_ICC
#define DOCTEST_PRAGMA_TO_STR(x) _Pragma(#x)
#define DOCTEST_CLANG_SUPPRESS_WARNING_PUSH _Pragma("clang diagnostic push")
#define DOCTEST_CLANG_SUPPRESS_WARNING(w) DOCTEST_PRAGMA_TO_STR(clang diagnostic ignored w)
#define DOCTEST_CLANG_SUPPRESS_WARNING_POP _Pragma("clang diagnostic pop")
#define DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(w)                                                \
    DOCTEST_CLANG_SUPPRESS_WARNING_PUSH DOCTEST_CLANG_SUPPRESS_WARNING(w)
#else // DOCTEST_CLANG
#define DOCTEST_CLANG_SUPPRESS_WARNING_PUSH
#define DOCTEST_CLANG_SUPPRESS_WARNING(w)
#define DOCTEST_CLANG_SUPPRESS_WARNING_POP
#define DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(w)
#endif // DOCTEST_CLANG

#if DOCTEST_GCC
#define DOCTEST_PRAGMA_TO_STR(x) _Pragma(#x)
#define DOCTEST_GCC_SUPPRESS_WARNING_PUSH _Pragma("GCC diagnostic push")
#define DOCTEST_GCC_SUPPRESS_WARNING(w) DOCTEST_PRAGMA_TO_STR(GCC diagnostic ignored w)
#define DOCTEST_GCC_SUPPRESS_WARNING_POP _Pragma("GCC diagnostic pop")
#define DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(w)                                                  \
    DOCTEST_GCC_SUPPRESS_WARNING_PUSH DOCTEST_GCC_SUPPRESS_WARNING(w)
#else // DOCTEST_GCC
#define DOCTEST_GCC_SUPPRESS_WARNING_PUSH
#define DOCTEST_GCC_SUPPRESS_WARNING(w)
#define DOCTEST_GCC_SUPPRESS_WARNING_POP
#define DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(w)
#endif // DOCTEST_GCC

#if DOCTEST_MSVC
#define DOCTEST_MSVC_SUPPRESS_WARNING_PUSH __pragma(warning(push))
#define DOCTEST_MSVC_SUPPRESS_WARNING(w) __pragma(warning(disable : w))
#define DOCTEST_MSVC_SUPPRESS_WARNING_POP __pragma(warning(pop))
#define DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(w)                                                 \
    DOCTEST_MSVC_SUPPRESS_WARNING_PUSH DOCTEST_MSVC_SUPPRESS_WARNING(w)
#else // DOCTEST_MSVC
#define DOCTEST_MSVC_SUPPRESS_WARNING_PUSH
#define DOCTEST_MSVC_SUPPRESS_WARNING(w)
#define DOCTEST_MSVC_SUPPRESS_WARNING_POP
#define DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(w)
#endif // DOCTEST_MSVC

// =================================================================================================
// == COMPILER WARNINGS ============================================================================
// =================================================================================================

// both the header and the implementation suppress all of these,
// so it only makes sense to aggregate them like so
#define DOCTEST_SUPPRESS_COMMON_WARNINGS_PUSH                                                      \
    DOCTEST_CLANG_SUPPRESS_WARNING_PUSH                                                            \
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wunknown-pragmas")                                            \
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wweak-vtables")                                               \
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wpadded")                                                     \
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-prototypes")                                         \
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wc++98-compat")                                               \
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wc++98-compat-pedantic")                                      \
                                                                                                   \
    DOCTEST_GCC_SUPPRESS_WARNING_PUSH                                                              \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wunknown-pragmas")                                              \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wpragmas")                                                      \
    DOCTEST_GCC_SUPPRESS_WARNING("-Weffc++")                                                       \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wstrict-overflow")                                              \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wstrict-aliasing")                                              \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wmissing-declarations")                                         \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wuseless-cast")                                                 \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wnoexcept")                                                     \
                                                                                                   \
    DOCTEST_MSVC_SUPPRESS_WARNING_PUSH                                                             \
    /* these 4 also disabled globally via cmake: */                                                \
    DOCTEST_MSVC_SUPPRESS_WARNING(4514) /* unreferenced inline function has been removed */        \
    DOCTEST_MSVC_SUPPRESS_WARNING(4571) /* SEH related */                                          \
    DOCTEST_MSVC_SUPPRESS_WARNING(4710) /* function not inlined */                                 \
    DOCTEST_MSVC_SUPPRESS_WARNING(4711) /* function selected for inline expansion*/                \
    /* common ones */                                                                              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4616) /* invalid compiler warning */                             \
    DOCTEST_MSVC_SUPPRESS_WARNING(4619) /* invalid compiler warning */                             \
    DOCTEST_MSVC_SUPPRESS_WARNING(4996) /* The compiler encountered a deprecated declaration */    \
    DOCTEST_MSVC_SUPPRESS_WARNING(4706) /* assignment within conditional expression */             \
    DOCTEST_MSVC_SUPPRESS_WARNING(4512) /* 'class' : assignment operator could not be generated */ \
    DOCTEST_MSVC_SUPPRESS_WARNING(4127) /* conditional expression is constant */                   \
    DOCTEST_MSVC_SUPPRESS_WARNING(4820) /* padding */                                              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4625) /* copy constructor was implicitly deleted */              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4626) /* assignment operator was implicitly deleted */           \
    DOCTEST_MSVC_SUPPRESS_WARNING(5027) /* move assignment operator implicitly deleted */          \
    DOCTEST_MSVC_SUPPRESS_WARNING(5026) /* move constructor was implicitly deleted */              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4640) /* construction of local static object not thread-safe */  \
    DOCTEST_MSVC_SUPPRESS_WARNING(5045) /* Spectre mitigation for memory load */                   \
    DOCTEST_MSVC_SUPPRESS_WARNING(5264) /* 'variable-name': 'const' variable is not used */        \
    /* static analysis */                                                                          \
    DOCTEST_MSVC_SUPPRESS_WARNING(26439) /* Function may not throw. Declare it 'noexcept' */       \
    DOCTEST_MSVC_SUPPRESS_WARNING(26495) /* Always initialize a member variable */                 \
    DOCTEST_MSVC_SUPPRESS_WARNING(26451) /* Arithmetic overflow ... */                             \
    DOCTEST_MSVC_SUPPRESS_WARNING(26444) /* Avoid unnamed objects with custom ctor and dtor... */  \
    DOCTEST_MSVC_SUPPRESS_WARNING(26812) /* Prefer 'enum class' over 'enum' */

#define DOCTEST_SUPPRESS_COMMON_WARNINGS_POP                                                       \
    DOCTEST_CLANG_SUPPRESS_WARNING_POP                                                             \
    DOCTEST_GCC_SUPPRESS_WARNING_POP                                                               \
    DOCTEST_MSVC_SUPPRESS_WARNING_POP

DOCTEST_SUPPRESS_COMMON_WARNINGS_PUSH

DOCTEST_CLANG_SUPPRESS_WARNING_PUSH
DOCTEST_CLANG_SUPPRESS_WARNING("-Wnon-virtual-dtor")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wdeprecated")

DOCTEST_GCC_SUPPRESS_WARNING_PUSH
DOCTEST_GCC_SUPPRESS_WARNING("-Wctor-dtor-privacy")
DOCTEST_GCC_SUPPRESS_WARNING("-Wnon-virtual-dtor")
DOCTEST_GCC_SUPPRESS_WARNING("-Wsign-promo")

DOCTEST_MSVC_SUPPRESS_WARNING_PUSH
DOCTEST_MSVC_SUPPRESS_WARNING(4623) // default constructor was implicitly defined as deleted

#define DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_BEGIN                                 \
    DOCTEST_MSVC_SUPPRESS_WARNING_PUSH                                                             \
    DOCTEST_MSVC_SUPPRESS_WARNING(4548) /* before comma no effect; expected side - effect */       \
    DOCTEST_MSVC_SUPPRESS_WARNING(4265) /* virtual functions, but destructor is not virtual */     \
    DOCTEST_MSVC_SUPPRESS_WARNING(4986) /* exception specification does not match previous */      \
    DOCTEST_MSVC_SUPPRESS_WARNING(4350) /* 'member1' called instead of 'member2' */                \
    DOCTEST_MSVC_SUPPRESS_WARNING(4668) /* not defined as a preprocessor macro */                  \
    DOCTEST_MSVC_SUPPRESS_WARNING(4365) /* signed/unsigned mismatch */                             \
    DOCTEST_MSVC_SUPPRESS_WARNING(4774) /* format string not a string literal */                   \
    DOCTEST_MSVC_SUPPRESS_WARNING(4820) /* padding */                                              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4625) /* copy constructor was implicitly deleted */              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4626) /* assignment operator was implicitly deleted */           \
    DOCTEST_MSVC_SUPPRESS_WARNING(5027) /* move assignment operator implicitly deleted */          \
    DOCTEST_MSVC_SUPPRESS_WARNING(5026) /* move constructor was implicitly deleted */              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4623) /* default constructor was implicitly deleted */           \
    DOCTEST_MSVC_SUPPRESS_WARNING(5039) /* pointer to pot. throwing function passed to extern C */ \
    DOCTEST_MSVC_SUPPRESS_WARNING(5045) /* Spectre mitigation for memory load */                   \
    DOCTEST_MSVC_SUPPRESS_WARNING(5105) /* macro producing 'defined' has undefined behavior */     \
    DOCTEST_MSVC_SUPPRESS_WARNING(4738) /* storing float result in memory, loss of performance */  \
    DOCTEST_MSVC_SUPPRESS_WARNING(5262) /* implicit fall-through */

#define DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_END DOCTEST_MSVC_SUPPRESS_WARNING_POP

// =================================================================================================
// == FEATURE DETECTION ============================================================================
// =================================================================================================

// general compiler feature support table: https://en.cppreference.com/w/cpp/compiler_support
// MSVC C++11 feature support table: https://msdn.microsoft.com/en-us/library/hh567368.aspx
// GCC C++11 feature support table: https://gcc.gnu.org/projects/cxx-status.html
// MSVC version table:
// https://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B#Internal_version_numbering
// MSVC++ 14.3 (17) _MSC_VER == 1930 (Visual Studio 2022)
// MSVC++ 14.2 (16) _MSC_VER == 1920 (Visual Studio 2019)
// MSVC++ 14.1 (15) _MSC_VER == 1910 (Visual Studio 2017)
// MSVC++ 14.0      _MSC_VER == 1900 (Visual Studio 2015)
// MSVC++ 12.0      _MSC_VER == 1800 (Visual Studio 2013)
// MSVC++ 11.0      _MSC_VER == 1700 (Visual Studio 2012)
// MSVC++ 10.0      _MSC_VER == 1600 (Visual Studio 2010)
// MSVC++ 9.0       _MSC_VER == 1500 (Visual Studio 2008)
// MSVC++ 8.0       _MSC_VER == 1400 (Visual Studio 2005)

// Universal Windows Platform support
#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
#define DOCTEST_CONFIG_NO_WINDOWS_SEH
#endif // WINAPI_FAMILY
#if DOCTEST_MSVC && !defined(DOCTEST_CONFIG_WINDOWS_SEH)
#define DOCTEST_CONFIG_WINDOWS_SEH
#endif // MSVC
#if defined(DOCTEST_CONFIG_NO_WINDOWS_SEH) && defined(DOCTEST_CONFIG_WINDOWS_SEH)
#undef DOCTEST_CONFIG_WINDOWS_SEH
#endif // DOCTEST_CONFIG_NO_WINDOWS_SEH

#if !defined(_WIN32) && !defined(__QNX__) && !defined(DOCTEST_CONFIG_POSIX_SIGNALS) &&             \
        !defined(__EMSCRIPTEN__) && !defined(__wasi__)
#define DOCTEST_CONFIG_POSIX_SIGNALS
#endif // _WIN32
#if defined(DOCTEST_CONFIG_NO_POSIX_SIGNALS) && defined(DOCTEST_CONFIG_POSIX_SIGNALS)
#undef DOCTEST_CONFIG_POSIX_SIGNALS
#endif // DOCTEST_CONFIG_NO_POSIX_SIGNALS

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
#if !defined(__cpp_exceptions) && !defined(__EXCEPTIONS) && !defined(_CPPUNWIND)                   \
        || defined(__wasi__)
#define DOCTEST_CONFIG_NO_EXCEPTIONS
#endif // no exceptions
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS

#ifdef DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS
#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
#define DOCTEST_CONFIG_NO_EXCEPTIONS
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS

#if defined(DOCTEST_CONFIG_NO_EXCEPTIONS) && !defined(DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS)
#define DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS && !DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS

#ifdef __wasi__
#define DOCTEST_CONFIG_NO_MULTITHREADING
#endif

#if defined(DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN) && !defined(DOCTEST_CONFIG_IMPLEMENT)
#define DOCTEST_CONFIG_IMPLEMENT
#endif // DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN

#if defined(_WIN32) || defined(__CYGWIN__)
#if DOCTEST_MSVC
#define DOCTEST_SYMBOL_EXPORT __declspec(dllexport)
#define DOCTEST_SYMBOL_IMPORT __declspec(dllimport)
#else // MSVC
#define DOCTEST_SYMBOL_EXPORT __attribute__((dllexport))
#define DOCTEST_SYMBOL_IMPORT __attribute__((dllimport))
#endif // MSVC
#else  // _WIN32
#define DOCTEST_SYMBOL_EXPORT __attribute__((visibility("default")))
#define DOCTEST_SYMBOL_IMPORT
#endif // _WIN32

#ifdef DOCTEST_CONFIG_IMPLEMENTATION_IN_DLL
#ifdef DOCTEST_CONFIG_IMPLEMENT
#define DOCTEST_INTERFACE DOCTEST_SYMBOL_EXPORT
#else // DOCTEST_CONFIG_IMPLEMENT
#define DOCTEST_INTERFACE DOCTEST_SYMBOL_IMPORT
#endif // DOCTEST_CONFIG_IMPLEMENT
#else  // DOCTEST_CONFIG_IMPLEMENTATION_IN_DLL
#define DOCTEST_INTERFACE
#endif // DOCTEST_CONFIG_IMPLEMENTATION_IN_DLL

// needed for extern template instantiations
// see https://github.com/fmtlib/fmt/issues/2228
#if DOCTEST_MSVC
#define DOCTEST_INTERFACE_DECL
#define DOCTEST_INTERFACE_DEF DOCTEST_INTERFACE
#else // DOCTEST_MSVC
#define DOCTEST_INTERFACE_DECL DOCTEST_INTERFACE
#define DOCTEST_INTERFACE_DEF
#endif // DOCTEST_MSVC

#define DOCTEST_EMPTY

#if DOCTEST_MSVC
#define DOCTEST_NOINLINE __declspec(noinline)
#define DOCTEST_UNUSED
#define DOCTEST_ALIGNMENT(x)
#elif DOCTEST_CLANG && DOCTEST_CLANG < DOCTEST_COMPILER(3, 5, 0)
#define DOCTEST_NOINLINE
#define DOCTEST_UNUSED
#define DOCTEST_ALIGNMENT(x)
#else
#define DOCTEST_NOINLINE __attribute__((noinline))
#define DOCTEST_UNUSED __attribute__((unused))
#define DOCTEST_ALIGNMENT(x) __attribute__((aligned(x)))
#endif

#ifdef DOCTEST_CONFIG_NO_CONTRADICTING_INLINE
#define DOCTEST_INLINE_NOINLINE inline
#else
#define DOCTEST_INLINE_NOINLINE inline DOCTEST_NOINLINE
#endif

#ifndef DOCTEST_NORETURN
#if DOCTEST_MSVC && (DOCTEST_MSVC < DOCTEST_COMPILER(19, 0, 0))
#define DOCTEST_NORETURN
#else // DOCTEST_MSVC
#define DOCTEST_NORETURN [[noreturn]]
#endif // DOCTEST_MSVC
#endif // DOCTEST_NORETURN

#ifndef DOCTEST_NOEXCEPT
#if DOCTEST_MSVC && (DOCTEST_MSVC < DOCTEST_COMPILER(19, 0, 0))
#define DOCTEST_NOEXCEPT
#else // DOCTEST_MSVC
#define DOCTEST_NOEXCEPT noexcept
#endif // DOCTEST_MSVC
#endif // DOCTEST_NOEXCEPT

#ifndef DOCTEST_CONSTEXPR
#if DOCTEST_MSVC && (DOCTEST_MSVC < DOCTEST_COMPILER(19, 0, 0))
#define DOCTEST_CONSTEXPR const
#define DOCTEST_CONSTEXPR_FUNC inline
#else // DOCTEST_MSVC
#define DOCTEST_CONSTEXPR constexpr
#define DOCTEST_CONSTEXPR_FUNC constexpr
#endif // DOCTEST_MSVC
#endif // DOCTEST_CONSTEXPR

#ifndef DOCTEST_NO_SANITIZE_INTEGER
#if DOCTEST_CLANG >= DOCTEST_COMPILER(3, 7, 0)
#define DOCTEST_NO_SANITIZE_INTEGER __attribute__((no_sanitize("integer")))
#else
#define DOCTEST_NO_SANITIZE_INTEGER
#endif
#endif // DOCTEST_NO_SANITIZE_INTEGER

// =================================================================================================
// == FEATURE DETECTION END ========================================================================
// =================================================================================================

#define DOCTEST_DECLARE_INTERFACE(name)                                                            \
    virtual ~name();                                                                               \
    name() = default;                                                                              \
    name(const name&) = delete;                                                                    \
    name(name&&) = delete;                                                                         \
    name& operator=(const name&) = delete;                                                         \
    name& operator=(name&&) = delete;

#define DOCTEST_DEFINE_INTERFACE(name)                                                             \
    name::~name() = default;

// internal macros for string concatenation and anonymous variable name generation
#define DOCTEST_CAT_IMPL(s1, s2) s1##s2
#define DOCTEST_CAT(s1, s2) DOCTEST_CAT_IMPL(s1, s2)
#ifdef __COUNTER__ // not standard and may be missing for some compilers
#define DOCTEST_ANONYMOUS(x) DOCTEST_CAT(x, __COUNTER__)
#else // __COUNTER__
#define DOCTEST_ANONYMOUS(x) DOCTEST_CAT(x, __LINE__)
#endif // __COUNTER__

#ifndef DOCTEST_CONFIG_ASSERTION_PARAMETERS_BY_VALUE
#define DOCTEST_REF_WRAP(x) x&
#else // DOCTEST_CONFIG_ASSERTION_PARAMETERS_BY_VALUE
#define DOCTEST_REF_WRAP(x) x
#endif // DOCTEST_CONFIG_ASSERTION_PARAMETERS_BY_VALUE

// not using __APPLE__ because... this is how Catch does it
#ifdef __MAC_OS_X_VERSION_MIN_REQUIRED
#define DOCTEST_PLATFORM_MAC
#elif defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
#define DOCTEST_PLATFORM_IPHONE
#elif defined(_WIN32)
#define DOCTEST_PLATFORM_WINDOWS
#elif defined(__wasi__)
#define DOCTEST_PLATFORM_WASI
#else // DOCTEST_PLATFORM
#define DOCTEST_PLATFORM_LINUX
#endif // DOCTEST_PLATFORM

namespace doctest { namespace detail {
    static DOCTEST_CONSTEXPR int consume(const int*, int) noexcept { return 0; }
}}

#define DOCTEST_GLOBAL_NO_WARNINGS(var, ...)                                                         \
    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wglobal-constructors")                                \
    static const int var = doctest::detail::consume(&var, __VA_ARGS__);                              \
    DOCTEST_CLANG_SUPPRESS_WARNING_POP

#ifndef DOCTEST_BREAK_INTO_DEBUGGER
// should probably take a look at https://github.com/scottt/debugbreak
#ifdef DOCTEST_PLATFORM_LINUX
#if defined(__GNUC__) && (defined(__i386) || defined(__x86_64))
// Break at the location of the failing check if possible
#define DOCTEST_BREAK_INTO_DEBUGGER() __asm__("int $3\n" : :) // NOLINT(hicpp-no-assembler)
#else
#include <signal.h>
#define DOCTEST_BREAK_INTO_DEBUGGER() raise(SIGTRAP)
#endif
#elif defined(DOCTEST_PLATFORM_MAC)
#if defined(__x86_64) || defined(__x86_64__) || defined(__amd64__) || defined(__i386)
#define DOCTEST_BREAK_INTO_DEBUGGER() __asm__("int $3\n" : :) // NOLINT(hicpp-no-assembler)
#elif defined(__ppc__) || defined(__ppc64__)
// https://www.cocoawithlove.com/2008/03/break-into-debugger.html
#define DOCTEST_BREAK_INTO_DEBUGGER() __asm__("li r0, 20\nsc\nnop\nli r0, 37\nli r4, 2\nsc\nnop\n": : : "memory","r0","r3","r4") // NOLINT(hicpp-no-assembler)
#else
#define DOCTEST_BREAK_INTO_DEBUGGER() __asm__("brk #0"); // NOLINT(hicpp-no-assembler)
#endif
#elif DOCTEST_MSVC
#define DOCTEST_BREAK_INTO_DEBUGGER() __debugbreak()
#elif defined(__MINGW32__)
DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wredundant-decls")
extern "C" __declspec(dllimport) void __stdcall DebugBreak();
DOCTEST_GCC_SUPPRESS_WARNING_POP
#define DOCTEST_BREAK_INTO_DEBUGGER() ::DebugBreak()
#else // linux
#define DOCTEST_BREAK_INTO_DEBUGGER() (static_cast<void>(0))
#endif // linux
#endif // DOCTEST_BREAK_INTO_DEBUGGER

// this is kept here for backwards compatibility since the config option was changed
#ifdef DOCTEST_CONFIG_USE_IOSFWD
#ifndef DOCTEST_CONFIG_USE_STD_HEADERS
#define DOCTEST_CONFIG_USE_STD_HEADERS
#endif
#endif // DOCTEST_CONFIG_USE_IOSFWD

// for clang - always include ciso646 (which drags some std stuff) because
// we want to check if we are using libc++ with the _LIBCPP_VERSION macro in
// which case we don't want to forward declare stuff from std - for reference:
// https://github.com/doctest/doctest/issues/126
// https://github.com/doctest/doctest/issues/356
#if DOCTEST_CLANG
#include <ciso646>
#endif // clang

#ifdef _LIBCPP_VERSION
#ifndef DOCTEST_CONFIG_USE_STD_HEADERS
#define DOCTEST_CONFIG_USE_STD_HEADERS
#endif
#endif // _LIBCPP_VERSION

#ifdef DOCTEST_CONFIG_USE_STD_HEADERS
#ifndef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
#define DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_BEGIN
#include <cstddef>
#include <ostream>
#include <istream>
DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_END
#else // DOCTEST_CONFIG_USE_STD_HEADERS

// Forward declaring 'X' in namespace std is not permitted by the C++ Standard.
DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4643)

namespace std { // NOLINT(cert-dcl58-cpp)
typedef decltype(nullptr) nullptr_t; // NOLINT(modernize-use-using)
typedef decltype(sizeof(void*)) size_t; // NOLINT(modernize-use-using)
template <class charT>
struct char_traits;
template <>
struct char_traits<char>;
template <class charT, class traits>
class basic_ostream; // NOLINT(fuchsia-virtual-inheritance)
typedef basic_ostream<char, char_traits<char>> ostream; // NOLINT(modernize-use-using)
template<class traits>
// NOLINTNEXTLINE
basic_ostream<char, traits>& operator<<(basic_ostream<char, traits>&, const char*);
template <class charT, class traits>
class basic_istream;
typedef basic_istream<char, char_traits<char>> istream; // NOLINT(modernize-use-using)
template <class... Types>
class tuple;
#if DOCTEST_MSVC >= DOCTEST_COMPILER(19, 20, 0)
// see this issue on why this is needed: https://github.com/doctest/doctest/issues/183
template <class Ty>
class allocator;
template <class Elem, class Traits, class Alloc>
class basic_string;
using string = basic_string<char, char_traits<char>, allocator<char>>;
#endif // VS 2019
} // namespace std

DOCTEST_MSVC_SUPPRESS_WARNING_POP

#endif // DOCTEST_CONFIG_USE_STD_HEADERS

#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
#include <type_traits>
#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS

namespace doctest {

using std::size_t;

DOCTEST_INTERFACE extern bool is_running_in_test;

#ifndef DOCTEST_CONFIG_STRING_SIZE_TYPE
#define DOCTEST_CONFIG_STRING_SIZE_TYPE unsigned
#endif

// A 24 byte string class (can be as small as 17 for x64 and 13 for x86) that can hold strings with length
// of up to 23 chars on the stack before going on the heap - the last byte of the buffer is used for:
// - "is small" bit - the highest bit - if "0" then it is small - otherwise its "1" (128)
// - if small - capacity left before going on the heap - using the lowest 5 bits
// - if small - 2 bits are left unused - the second and third highest ones
// - if small - acts as a null terminator if strlen() is 23 (24 including the null terminator)
//              and the "is small" bit remains "0" ("as well as the capacity left") so its OK
// Idea taken from this lecture about the string implementation of facebook/folly - fbstring
// https://www.youtube.com/watch?v=kPR8h4-qZdk
// TODO:
// - optimizations - like not deleting memory unnecessarily in operator= and etc.
// - resize/reserve/clear
// - replace
// - back/front
// - iterator stuff
// - find & friends
// - push_back/pop_back
// - assign/insert/erase
// - relational operators as free functions - taking const char* as one of the params
class DOCTEST_INTERFACE String
{
public:
    using size_type = DOCTEST_CONFIG_STRING_SIZE_TYPE;

private:
    static DOCTEST_CONSTEXPR size_type len  = 24;      //!OCLINT avoid private static members
    static DOCTEST_CONSTEXPR size_type last = len - 1; //!OCLINT avoid private static members

    struct view // len should be more than sizeof(view) - because of the final byte for flags
    {
        char*    ptr;
        size_type size;
        size_type capacity;
    };

    union
    {
        char buf[len]; // NOLINT(*-avoid-c-arrays)
        view data;
    };

    char* allocate(size_type sz);

    bool isOnStack() const noexcept { return (buf[last] & 128) == 0; }
    void setOnHeap() noexcept;
    void setLast(size_type in = last) noexcept;
    void setSize(size_type sz) noexcept;

    void copy(const String& other);

public:
    static DOCTEST_CONSTEXPR size_type npos = static_cast<size_type>(-1);

    String() noexcept;
    ~String();

    // cppcheck-suppress noExplicitConstructor
    String(const char* in);
    String(const char* in, size_type in_size);

    String(std::istream& in, size_type in_size);

    String(const String& other);
    String& operator=(const String& other);

    String& operator+=(const String& other);

    String(String&& other) noexcept;
    String& operator=(String&& other) noexcept;

    char  operator[](size_type i) const;
    char& operator[](size_type i);

    // the only functions I'm willing to leave in the interface - available for inlining
    const char* c_str() const { return const_cast<String*>(this)->c_str(); } // NOLINT
    char*       c_str() {
        if (isOnStack()) {
            return reinterpret_cast<char*>(buf);
        }
        return data.ptr;
    }

    size_type size() const;
    size_type capacity() const;

    String substr(size_type pos, size_type cnt = npos) &&;
    String substr(size_type pos, size_type cnt = npos) const &;

    size_type find(char ch, size_type pos = 0) const;
    size_type rfind(char ch, size_type pos = npos) const;

    int compare(const char* other, bool no_case = false) const;
    int compare(const String& other, bool no_case = false) const;

friend DOCTEST_INTERFACE std::ostream& operator<<(std::ostream& s, const String& in);
};

DOCTEST_INTERFACE String operator+(const String& lhs, const String& rhs);

DOCTEST_INTERFACE bool operator==(const String& lhs, const String& rhs);
DOCTEST_INTERFACE bool operator!=(const String& lhs, const String& rhs);
DOCTEST_INTERFACE bool operator<(const String& lhs, const String& rhs);
DOCTEST_INTERFACE bool operator>(const String& lhs, const String& rhs);
DOCTEST_INTERFACE bool operator<=(const String& lhs, const String& rhs);
DOCTEST_INTERFACE bool operator>=(const String& lhs, const String& rhs);

class DOCTEST_INTERFACE Contains {
public:
    explicit Contains(const String& string);

    bool checkWith(const String& other) const;

    String string;
};

DOCTEST_INTERFACE String toString(const Contains& in);

DOCTEST_INTERFACE bool operator==(const String& lhs, const Contains& rhs);
DOCTEST_INTERFACE bool operator==(const Contains& lhs, const String& rhs);
DOCTEST_INTERFACE bool operator!=(const String& lhs, const Contains& rhs);
DOCTEST_INTERFACE bool operator!=(const Contains& lhs, const String& rhs);

namespace Color {
    enum Enum
    {
        None = 0,
        White,
        Red,
        Green,
        Blue,
        Cyan,
        Yellow,
        Grey,

        Bright = 0x10,

        BrightRed   = Bright | Red,
        BrightGreen = Bright | Green,
        LightGrey   = Bright | Grey,
        BrightWhite = Bright | White
    };

    DOCTEST_INTERFACE std::ostream& operator<<(std::ostream& s, Color::Enum code);
} // namespace Color

namespace assertType {
    enum Enum
    {
        // macro traits

        is_warn    = 1,
        is_check   = 2 * is_warn,
        is_require = 2 * is_check,

        is_normal      = 2 * is_require,
        is_throws      = 2 * is_normal,
        is_throws_as   = 2 * is_throws,
        is_throws_with = 2 * is_throws_as,
        is_nothrow     = 2 * is_throws_with,

        is_false = 2 * is_nothrow,
        is_unary = 2 * is_false, // not checked anywhere - used just to distinguish the types

        is_eq = 2 * is_unary,
        is_ne = 2 * is_eq,

        is_lt = 2 * is_ne,
        is_gt = 2 * is_lt,

        is_ge = 2 * is_gt,
        is_le = 2 * is_ge,

        // macro types

        DT_WARN    = is_normal | is_warn,
        DT_CHECK   = is_normal | is_check,
        DT_REQUIRE = is_normal | is_require,

        DT_WARN_FALSE    = is_normal | is_false | is_warn,
        DT_CHECK_FALSE   = is_normal | is_false | is_check,
        DT_REQUIRE_FALSE = is_normal | is_false | is_require,

        DT_WARN_THROWS    = is_throws | is_warn,
        DT_CHECK_THROWS   = is_throws | is_check,
        DT_REQUIRE_THROWS = is_throws | is_require,

        DT_WARN_THROWS_AS    = is_throws_as | is_warn,
        DT_CHECK_THROWS_AS   = is_throws_as | is_check,
        DT_REQUIRE_THROWS_AS = is_throws_as | is_require,

        DT_WARN_THROWS_WITH    = is_throws_with | is_warn,
        DT_CHECK_THROWS_WITH   = is_throws_with | is_check,
        DT_REQUIRE_THROWS_WITH = is_throws_with | is_require,

        DT_WARN_THROWS_WITH_AS    = is_throws_with | is_throws_as | is_warn,
        DT_CHECK_THROWS_WITH_AS   = is_throws_with | is_throws_as | is_check,
        DT_REQUIRE_THROWS_WITH_AS = is_throws_with | is_throws_as | is_require,

        DT_WARN_NOTHROW    = is_nothrow | is_warn,
        DT_CHECK_NOTHROW   = is_nothrow | is_check,
        DT_REQUIRE_NOTHROW = is_nothrow | is_require,

        DT_WARN_EQ    = is_normal | is_eq | is_warn,
        DT_CHECK_EQ   = is_normal | is_eq | is_check,
        DT_REQUIRE_EQ = is_normal | is_eq | is_require,

        DT_WARN_NE    = is_normal | is_ne | is_warn,
        DT_CHECK_NE   = is_normal | is_ne | is_check,
        DT_REQUIRE_NE = is_normal | is_ne | is_require,

        DT_WARN_GT    = is_normal | is_gt | is_warn,
        DT_CHECK_GT   = is_normal | is_gt | is_check,
        DT_REQUIRE_GT = is_normal | is_gt | is_require,

        DT_WARN_LT    = is_normal | is_lt | is_warn,
        DT_CHECK_LT   = is_normal | is_lt | is_check,
        DT_REQUIRE_LT = is_normal | is_lt | is_require,

        DT_WARN_GE    = is_normal | is_ge | is_warn,
        DT_CHECK_GE   = is_normal | is_ge | is_check,
        DT_REQUIRE_GE = is_normal | is_ge | is_require,

        DT_WARN_LE    = is_normal | is_le | is_warn,
        DT_CHECK_LE   = is_normal | is_le | is_check,
        DT_REQUIRE_LE = is_normal | is_le | is_require,

        DT_WARN_UNARY    = is_normal | is_unary | is_warn,
        DT_CHECK_UNARY   = is_normal | is_unary | is_check,
        DT_REQUIRE_UNARY = is_normal | is_unary | is_require,

        DT_WARN_UNARY_FALSE    = is_normal | is_false | is_unary | is_warn,
        DT_CHECK_UNARY_FALSE   = is_normal | is_false | is_unary | is_check,
        DT_REQUIRE_UNARY_FALSE = is_normal | is_false | is_unary | is_require,
    };
} // namespace assertType

DOCTEST_INTERFACE const char* assertString(assertType::Enum at);
DOCTEST_INTERFACE const char* failureString(assertType::Enum at);
DOCTEST_INTERFACE const char* skipPathFromFilename(const char* file);

struct DOCTEST_INTERFACE TestCaseData
{
    String      m_file;       // the file in which the test was registered (using String - see #350)
    unsigned    m_line;       // the line where the test was registered
    const char* m_name;       // name of the test case
    const char* m_test_suite; // the test suite in which the test was added
    const char* m_description;
    bool        m_skip;
    bool        m_no_breaks;
    bool        m_no_output;
    bool        m_may_fail;
    bool        m_should_fail;
    int         m_expected_failures;
    double      m_timeout;
};

struct DOCTEST_INTERFACE AssertData
{
    // common - for all asserts
    const TestCaseData* m_test_case;
    assertType::Enum    m_at;
    const char*         m_file;
    int                 m_line;
    const char*         m_expr;
    bool                m_failed;

    // exception-related - for all asserts
    bool   m_threw;
    String m_exception;

    // for normal asserts
    String m_decomp;

    // for specific exception-related asserts
    bool           m_threw_as;
    const char*    m_exception_type;

    class DOCTEST_INTERFACE StringContains {
        private:
            Contains content;
            bool isContains;

        public:
            StringContains(const String& str) : content(str), isContains(false) { }
            StringContains(Contains cntn) : content(static_cast<Contains&&>(cntn)), isContains(true) { }

            bool check(const String& str) { return isContains ? (content == str) : (content.string == str); }

            operator const String&() const { return content.string; }

            const char* c_str() const { return content.string.c_str(); }
    } m_exception_string;

    AssertData(assertType::Enum at, const char* file, int line, const char* expr,
        const char* exception_type, const StringContains& exception_string);
};

struct DOCTEST_INTERFACE MessageData
{
    String           m_string;
    const char*      m_file;
    int              m_line;
    assertType::Enum m_severity;
};

struct DOCTEST_INTERFACE SubcaseSignature
{
    String      m_name;
    const char* m_file;
    int         m_line;

    bool operator==(const SubcaseSignature& other) const;
    bool operator<(const SubcaseSignature& other) const;
};

struct DOCTEST_INTERFACE IContextScope
{
    DOCTEST_DECLARE_INTERFACE(IContextScope)
    virtual void stringify(std::ostream*) const = 0;
};

namespace detail {
    struct DOCTEST_INTERFACE TestCase;
} // namespace detail

struct ContextOptions //!OCLINT too many fields
{
    std::ostream* cout = nullptr; // stdout stream
    String        binary_name;    // the test binary name

    const detail::TestCase* currentTest = nullptr;

    // == parameters from the command line
    String   out;       // output filename
    String   order_by;  // how tests should be ordered
    unsigned rand_seed; // the seed for rand ordering

    unsigned first; // the first (matching) test to be executed
    unsigned last;  // the last (matching) test to be executed

    int abort_after;           // stop tests after this many failed assertions
    int subcase_filter_levels; // apply the subcase filters for the first N levels

    bool success;              // include successful assertions in output
    bool case_sensitive;       // if filtering should be case sensitive
    bool exit;                 // if the program should be exited after the tests are ran/whatever
    bool duration;             // print the time duration of each test case
    bool minimal;              // minimal console output (only test failures)
    bool quiet;                // no console output
    bool no_throw;             // to skip exceptions-related assertion macros
    bool no_exitcode;          // if the framework should return 0 as the exitcode
    bool no_run;               // to not run the tests at all (can be done with an "*" exclude)
    bool no_intro;             // to not print the intro of the framework
    bool no_version;           // to not print the version of the framework
    bool no_colors;            // if output to the console should be colorized
    bool force_colors;         // forces the use of colors even when a tty cannot be detected
    bool no_breaks;            // to not break into the debugger
    bool no_skip;              // don't skip test cases which are marked to be skipped
    bool gnu_file_line;        // if line numbers should be surrounded with :x: and not (x):
    bool no_path_in_filenames; // if the path to files should be removed from the output
    bool no_line_numbers;      // if source code line numbers should be omitted from the output
    bool no_debug_output;      // no output in the debug console when a debugger is attached
    bool no_skipped_summary;   // don't print "skipped" in the summary !!! UNDOCUMENTED !!!
    bool no_time_in_output;    // omit any time/timestamps from output !!! UNDOCUMENTED !!!

    bool help;             // to print the help
    bool version;          // to print the version
    bool count;            // if only the count of matching tests is to be retrieved
    bool list_test_cases;  // to list all tests matching the filters
    bool list_test_suites; // to list all suites matching the filters
    bool list_reporters;   // lists all registered reporters
};

namespace detail {
    namespace types {
#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
        using namespace std;
#else
        template <bool COND, typename T = void>
        struct enable_if { };

        template <typename T>
        struct enable_if<true, T> { using type = T; };

        struct true_type { static DOCTEST_CONSTEXPR bool value = true; };
        struct false_type { static DOCTEST_CONSTEXPR bool value = false; };

        template <typename T> struct remove_reference { using type = T; };
        template <typename T> struct remove_reference<T&> { using type = T; };
        template <typename T> struct remove_reference<T&&> { using type = T; };

        template <typename T> struct is_rvalue_reference : false_type { };
        template <typename T> struct is_rvalue_reference<T&&> : true_type { };

        template<typename T> struct remove_const { using type = T; };
        template <typename T> struct remove_const<const T> { using type = T; };

        // Compiler intrinsics
        template <typename T> struct is_enum { static DOCTEST_CONSTEXPR bool value = __is_enum(T); };
        template <typename T> struct underlying_type { using type = __underlying_type(T); };

        template <typename T> struct is_pointer : false_type { };
        template <typename T> struct is_pointer<T*> : true_type { };

        template <typename T> struct is_array : false_type { };
        // NOLINTNEXTLINE(*-avoid-c-arrays)
        template <typename T, size_t SIZE> struct is_array<T[SIZE]> : true_type { };
#endif
    }

    // <utility>
    template <typename T>
    T&& declval();

    template <class T>
    DOCTEST_CONSTEXPR_FUNC T&& forward(typename types::remove_reference<T>::type& t) DOCTEST_NOEXCEPT {
        return static_cast<T&&>(t);
    }

    template <class T>
    DOCTEST_CONSTEXPR_FUNC T&& forward(typename types::remove_reference<T>::type&& t) DOCTEST_NOEXCEPT {
        return static_cast<T&&>(t);
    }

    template <typename T>
    struct deferred_false : types::false_type { };

// MSVS 2015 :(
#if !DOCTEST_CLANG && defined(_MSC_VER) && _MSC_VER <= 1900
    template <typename T, typename = void>
    struct has_global_insertion_operator : types::false_type { };

    template <typename T>
    struct has_global_insertion_operator<T, decltype(::operator<<(declval<std::ostream&>(), declval<const T&>()), void())> : types::true_type { };

    template <typename T, typename = void>
    struct has_insertion_operator { static DOCTEST_CONSTEXPR bool value = has_global_insertion_operator<T>::value; };

    template <typename T, bool global>
    struct insert_hack;

    template <typename T>
    struct insert_hack<T, true> {
        static void insert(std::ostream& os, const T& t) { ::operator<<(os, t); }
    };

    template <typename T>
    struct insert_hack<T, false> {
        static void insert(std::ostream& os, const T& t) { operator<<(os, t); }
    };

    template <typename T>
    using insert_hack_t = insert_hack<T, has_global_insertion_operator<T>::value>;
#else
    template <typename T, typename = void>
    struct has_insertion_operator : types::false_type { };
#endif

    template <typename T>
    struct has_insertion_operator<T, decltype(operator<<(declval<std::ostream&>(), declval<const T&>()), void())> : types::true_type { };

    template <typename T>
    struct should_stringify_as_underlying_type {
        static DOCTEST_CONSTEXPR bool value = detail::types::is_enum<T>::value && !doctest::detail::has_insertion_operator<T>::value;
    };

    DOCTEST_INTERFACE std::ostream* tlssPush();
    DOCTEST_INTERFACE String tlssPop();

    template <bool C>
    struct StringMakerBase {
        template <typename T>
        static String convert(const DOCTEST_REF_WRAP(T)) {
#ifdef DOCTEST_CONFIG_REQUIRE_STRINGIFICATION_FOR_ALL_USED_TYPES
            static_assert(deferred_false<T>::value, "No stringification detected for type T. See string conversion manual");
#endif
            return "{?}";
        }
    };

    template <typename T>
    struct filldata;

    template <typename T>
    void filloss(std::ostream* stream, const T& in) {
        filldata<T>::fill(stream, in);
    }

    template <typename T, size_t N>
    void filloss(std::ostream* stream, const T (&in)[N]) { // NOLINT(*-avoid-c-arrays)
        // T[N], T(&)[N], T(&&)[N] have same behaviour.
        // Hence remove reference.
        filloss<typename types::remove_reference<decltype(in)>::type>(stream, in);
    }

    template <typename T>
    String toStream(const T& in) {
        std::ostream* stream = tlssPush();
        filloss(stream, in);
        return tlssPop();
    }

    template <>
    struct StringMakerBase<true> {
        template <typename T>
        static String convert(const DOCTEST_REF_WRAP(T) in) {
            return toStream(in);
        }
    };
} // namespace detail

template <typename T>
struct StringMaker : public detail::StringMakerBase<
    detail::has_insertion_operator<T>::value || detail::types::is_pointer<T>::value || detail::types::is_array<T>::value>
{};

#ifndef DOCTEST_STRINGIFY
#ifdef DOCTEST_CONFIG_DOUBLE_STRINGIFY
#define DOCTEST_STRINGIFY(...) toString(toString(__VA_ARGS__))
#else
#define DOCTEST_STRINGIFY(...) toString(__VA_ARGS__)
#endif
#endif

template <typename T>
String toString() {
#if DOCTEST_CLANG == 0 && DOCTEST_GCC == 0 && DOCTEST_ICC == 0
    String ret = __FUNCSIG__; // class doctest::String __cdecl doctest::toString<TYPE>(void)
    String::size_type beginPos = ret.find('<');
    return ret.substr(beginPos + 1, ret.size() - beginPos - static_cast<String::size_type>(sizeof(">(void)")));
#else
    String ret = __PRETTY_FUNCTION__; // doctest::String toString() [with T = TYPE]
    String::size_type begin = ret.find('=') + 2;
    return ret.substr(begin, ret.size() - begin - 1);
#endif
}

template <typename T, typename detail::types::enable_if<!detail::should_stringify_as_underlying_type<T>::value, bool>::type = true>
String toString(const DOCTEST_REF_WRAP(T) value) {
    return StringMaker<T>::convert(value);
}

#ifdef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
DOCTEST_INTERFACE String toString(const char* in);
#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING

#if DOCTEST_MSVC >= DOCTEST_COMPILER(19, 20, 0)
// see this issue on why this is needed: https://github.com/doctest/doctest/issues/183
DOCTEST_INTERFACE String toString(const std::string& in);
#endif // VS 2019

DOCTEST_INTERFACE String toString(String in);

DOCTEST_INTERFACE String toString(std::nullptr_t);

DOCTEST_INTERFACE String toString(bool in);

DOCTEST_INTERFACE String toString(float in);
DOCTEST_INTERFACE String toString(double in);
DOCTEST_INTERFACE String toString(double long in);

DOCTEST_INTERFACE String toString(char in);
DOCTEST_INTERFACE String toString(char signed in);
DOCTEST_INTERFACE String toString(char unsigned in);
DOCTEST_INTERFACE String toString(short in);
DOCTEST_INTERFACE String toString(short unsigned in);
DOCTEST_INTERFACE String toString(signed in);
DOCTEST_INTERFACE String toString(unsigned in);
DOCTEST_INTERFACE String toString(long in);
DOCTEST_INTERFACE String toString(long unsigned in);
DOCTEST_INTERFACE String toString(long long in);
DOCTEST_INTERFACE String toString(long long unsigned in);

template <typename T, typename detail::types::enable_if<detail::should_stringify_as_underlying_type<T>::value, bool>::type = true>
String toString(const DOCTEST_REF_WRAP(T) value) {
    using UT = typename detail::types::underlying_type<T>::type;
    return (DOCTEST_STRINGIFY(static_cast<UT>(value)));
}

namespace detail {
    template <typename T>
    struct filldata
    {
        static void fill(std::ostream* stream, const T& in) {
#if defined(_MSC_VER) && _MSC_VER <= 1900
        insert_hack_t<T>::insert(*stream, in);
#else
        operator<<(*stream, in);
#endif
        }
    };

DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4866)
// NOLINTBEGIN(*-avoid-c-arrays)
    template <typename T, size_t N>
    struct filldata<T[N]> {
        static void fill(std::ostream* stream, const T(&in)[N]) {
            *stream << "[";
            for (size_t i = 0; i < N; i++) {
                if (i != 0) { *stream << ", "; }
                *stream << (DOCTEST_STRINGIFY(in[i]));
            }
            *stream << "]";
        }
    };
// NOLINTEND(*-avoid-c-arrays)
DOCTEST_MSVC_SUPPRESS_WARNING_POP

    // Specialized since we don't want the terminating null byte!
// NOLINTBEGIN(*-avoid-c-arrays)
    template <size_t N>
    struct filldata<const char[N]> {
        static void fill(std::ostream* stream, const char (&in)[N]) {
            *stream << String(in, in[N - 1] ? N : N - 1);
        } // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks)
    };
// NOLINTEND(*-avoid-c-arrays)

    template <>
    struct filldata<const void*> {
        static void fill(std::ostream* stream, const void* in);
    };

    template <typename T>
    struct filldata<T*> {
DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4180)
        static void fill(std::ostream* stream, const T* in) {
DOCTEST_MSVC_SUPPRESS_WARNING_POP
DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wmicrosoft-cast")
            filldata<const void*>::fill(stream,
#if DOCTEST_GCC == 0 || DOCTEST_GCC >= DOCTEST_COMPILER(4, 9, 0)
                reinterpret_cast<const void*>(in)
#else
                *reinterpret_cast<const void* const*>(&in)
#endif
            );
DOCTEST_CLANG_SUPPRESS_WARNING_POP
        }
    };
}

struct DOCTEST_INTERFACE Approx
{
    Approx(double value);

    Approx operator()(double value) const;

#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
    template <typename T>
    explicit Approx(const T& value,
                    typename detail::types::enable_if<std::is_constructible<double, T>::value>::type* =
                            static_cast<T*>(nullptr)) {
        *this = static_cast<double>(value);
    }
#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS

    Approx& epsilon(double newEpsilon);

#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
    template <typename T>
    typename std::enable_if<std::is_constructible<double, T>::value, Approx&>::type epsilon(
            const T& newEpsilon) {
        m_epsilon = static_cast<double>(newEpsilon);
        return *this;
    }
#endif //  DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS

    Approx& scale(double newScale);

#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
    template <typename T>
    typename std::enable_if<std::is_constructible<double, T>::value, Approx&>::type scale(
            const T& newScale) {
        m_scale = static_cast<double>(newScale);
        return *this;
    }
#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS

    // clang-format off
    DOCTEST_INTERFACE friend bool operator==(double lhs, const Approx & rhs);
    DOCTEST_INTERFACE friend bool operator==(const Approx & lhs, double rhs);
    DOCTEST_INTERFACE friend bool operator!=(double lhs, const Approx & rhs);
    DOCTEST_INTERFACE friend bool operator!=(const Approx & lhs, double rhs);
    DOCTEST_INTERFACE friend bool operator<=(double lhs, const Approx & rhs);
    DOCTEST_INTERFACE friend bool operator<=(const Approx & lhs, double rhs);
    DOCTEST_INTERFACE friend bool operator>=(double lhs, const Approx & rhs);
    DOCTEST_INTERFACE friend bool operator>=(const Approx & lhs, double rhs);
    DOCTEST_INTERFACE friend bool operator< (double lhs, const Approx & rhs);
    DOCTEST_INTERFACE friend bool operator< (const Approx & lhs, double rhs);
    DOCTEST_INTERFACE friend bool operator> (double lhs, const Approx & rhs);
    DOCTEST_INTERFACE friend bool operator> (const Approx & lhs, double rhs);

#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
#define DOCTEST_APPROX_PREFIX \
    template <typename T> friend typename std::enable_if<std::is_constructible<double, T>::value, bool>::type

    DOCTEST_APPROX_PREFIX operator==(const T& lhs, const Approx& rhs) { return operator==(static_cast<double>(lhs), rhs); }
    DOCTEST_APPROX_PREFIX operator==(const Approx& lhs, const T& rhs) { return operator==(rhs, lhs); }
    DOCTEST_APPROX_PREFIX operator!=(const T& lhs, const Approx& rhs) { return !operator==(lhs, rhs); }
    DOCTEST_APPROX_PREFIX operator!=(const Approx& lhs, const T& rhs) { return !operator==(rhs, lhs); }
    DOCTEST_APPROX_PREFIX operator<=(const T& lhs, const Approx& rhs) { return static_cast<double>(lhs) < rhs.m_value || lhs == rhs; }
    DOCTEST_APPROX_PREFIX operator<=(const Approx& lhs, const T& rhs) { return lhs.m_value < static_cast<double>(rhs) || lhs == rhs; }
    DOCTEST_APPROX_PREFIX operator>=(const T& lhs, const Approx& rhs) { return static_cast<double>(lhs) > rhs.m_value || lhs == rhs; }
    DOCTEST_APPROX_PREFIX operator>=(const Approx& lhs, const T& rhs) { return lhs.m_value > static_cast<double>(rhs) || lhs == rhs; }
    DOCTEST_APPROX_PREFIX operator< (const T& lhs, const Approx& rhs) { return static_cast<double>(lhs) < rhs.m_value && lhs != rhs; }
    DOCTEST_APPROX_PREFIX operator< (const Approx& lhs, const T& rhs) { return lhs.m_value < static_cast<double>(rhs) && lhs != rhs; }
    DOCTEST_APPROX_PREFIX operator> (const T& lhs, const Approx& rhs) { return static_cast<double>(lhs) > rhs.m_value && lhs != rhs; }
    DOCTEST_APPROX_PREFIX operator> (const Approx& lhs, const T& rhs) { return lhs.m_value > static_cast<double>(rhs) && lhs != rhs; }
#undef DOCTEST_APPROX_PREFIX
#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS

    // clang-format on

    double m_epsilon;
    double m_scale;
    double m_value;
};

DOCTEST_INTERFACE String toString(const Approx& in);

DOCTEST_INTERFACE const ContextOptions* getContextOptions();

template <typename F>
struct DOCTEST_INTERFACE_DECL IsNaN
{
    F value; bool flipped;
    IsNaN(F f, bool flip = false) : value(f), flipped(flip) { }
    IsNaN<F> operator!() const { return { value, !flipped }; }
    operator bool() const;
};
#ifndef __MINGW32__
extern template struct DOCTEST_INTERFACE_DECL IsNaN<float>;
extern template struct DOCTEST_INTERFACE_DECL IsNaN<double>;
extern template struct DOCTEST_INTERFACE_DECL IsNaN<long double>;
#endif
DOCTEST_INTERFACE String toString(IsNaN<float> in);
DOCTEST_INTERFACE String toString(IsNaN<double> in);
DOCTEST_INTERFACE String toString(IsNaN<double long> in);

#ifndef DOCTEST_CONFIG_DISABLE

namespace detail {
    // clang-format off
#ifdef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
    template<class T>               struct decay_array       { using type = T; };
    template<class T, unsigned N>   struct decay_array<T[N]> { using type = T*; };
    template<class T>               struct decay_array<T[]>  { using type = T*; };

    template<class T>   struct not_char_pointer              { static DOCTEST_CONSTEXPR int value = 1; };
    template<>          struct not_char_pointer<char*>       { static DOCTEST_CONSTEXPR int value = 0; };
    template<>          struct not_char_pointer<const char*> { static DOCTEST_CONSTEXPR int value = 0; };

    template<class T> struct can_use_op : public not_char_pointer<typename decay_array<T>::type> {};
#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
    // clang-format on

    struct DOCTEST_INTERFACE TestFailureException
    {
    };

    DOCTEST_INTERFACE bool checkIfShouldThrow(assertType::Enum at);

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
    DOCTEST_NORETURN
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS
    DOCTEST_INTERFACE void throwException();

    struct DOCTEST_INTERFACE Subcase
    {
        SubcaseSignature m_signature;
        bool             m_entered = false;

        Subcase(const String& name, const char* file, int line);
        Subcase(const Subcase&) = delete;
        Subcase(Subcase&&) = delete;
        Subcase& operator=(const Subcase&) = delete;
        Subcase& operator=(Subcase&&) = delete;
        ~Subcase();

        operator bool() const;

        private:
            bool checkFilters();
    };

    template <typename L, typename R>
    String stringifyBinaryExpr(const DOCTEST_REF_WRAP(L) lhs, const char* op,
                               const DOCTEST_REF_WRAP(R) rhs) {
        return (DOCTEST_STRINGIFY(lhs)) + op + (DOCTEST_STRINGIFY(rhs));
    }

#if DOCTEST_CLANG && DOCTEST_CLANG < DOCTEST_COMPILER(3, 6, 0)
DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wunused-comparison")
#endif

// This will check if there is any way it could find a operator like member or friend and uses it.
// If not it doesn't find the operator or if the operator at global scope is defined after
// this template, the template won't be instantiated due to SFINAE. Once the template is not
// instantiated it can look for global operator using normal conversions.
#ifdef __NVCC__
#define SFINAE_OP(ret,op) ret
#else
#define SFINAE_OP(ret,op) decltype((void)(doctest::detail::declval<L>() op doctest::detail::declval<R>()),ret{})
#endif

#define DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(op, op_str, op_macro)                              \
    template <typename R>                                                                          \
    DOCTEST_NOINLINE SFINAE_OP(Result,op) operator op(R&& rhs) {                                   \
    bool res = op_macro(doctest::detail::forward<const L>(lhs), doctest::detail::forward<R>(rhs)); \
        if(m_at & assertType::is_false)                                                            \
            res = !res;                                                                            \
        if(!res || doctest::getContextOptions()->success)                                          \
            return Result(res, stringifyBinaryExpr(lhs, op_str, rhs));                             \
        return Result(res);                                                                        \
    }

    // more checks could be added - like in Catch:
    // https://github.com/catchorg/Catch2/pull/1480/files
    // https://github.com/catchorg/Catch2/pull/1481/files
#define DOCTEST_FORBIT_EXPRESSION(rt, op)                                                          \
    template <typename R>                                                                          \
    rt& operator op(const R&) {                                                                    \
        static_assert(deferred_false<R>::value,                                                    \
                      "Expression Too Complex Please Rewrite As Binary Comparison!");              \
        return *this;                                                                              \
    }

    struct DOCTEST_INTERFACE Result // NOLINT(*-member-init)
    {
        bool   m_passed;
        String m_decomp;

        Result() = default; // TODO: Why do we need this? (To remove NOLINT)
        Result(bool passed, const String& decomposition = String());

        // forbidding some expressions based on this table: https://en.cppreference.com/w/cpp/language/operator_precedence
        DOCTEST_FORBIT_EXPRESSION(Result, &)
        DOCTEST_FORBIT_EXPRESSION(Result, ^)
        DOCTEST_FORBIT_EXPRESSION(Result, |)
        DOCTEST_FORBIT_EXPRESSION(Result, &&)
        DOCTEST_FORBIT_EXPRESSION(Result, ||)
        DOCTEST_FORBIT_EXPRESSION(Result, ==)
        DOCTEST_FORBIT_EXPRESSION(Result, !=)
        DOCTEST_FORBIT_EXPRESSION(Result, <)
        DOCTEST_FORBIT_EXPRESSION(Result, >)
        DOCTEST_FORBIT_EXPRESSION(Result, <=)
        DOCTEST_FORBIT_EXPRESSION(Result, >=)
        DOCTEST_FORBIT_EXPRESSION(Result, =)
        DOCTEST_FORBIT_EXPRESSION(Result, +=)
        DOCTEST_FORBIT_EXPRESSION(Result, -=)
        DOCTEST_FORBIT_EXPRESSION(Result, *=)
        DOCTEST_FORBIT_EXPRESSION(Result, /=)
        DOCTEST_FORBIT_EXPRESSION(Result, %=)
        DOCTEST_FORBIT_EXPRESSION(Result, <<=)
        DOCTEST_FORBIT_EXPRESSION(Result, >>=)
        DOCTEST_FORBIT_EXPRESSION(Result, &=)
        DOCTEST_FORBIT_EXPRESSION(Result, ^=)
        DOCTEST_FORBIT_EXPRESSION(Result, |=)
    };

#ifndef DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION

    DOCTEST_CLANG_SUPPRESS_WARNING_PUSH
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wsign-conversion")
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wsign-compare")
    //DOCTEST_CLANG_SUPPRESS_WARNING("-Wdouble-promotion")
    //DOCTEST_CLANG_SUPPRESS_WARNING("-Wconversion")
    //DOCTEST_CLANG_SUPPRESS_WARNING("-Wfloat-equal")

    DOCTEST_GCC_SUPPRESS_WARNING_PUSH
    DOCTEST_GCC_SUPPRESS_WARNING("-Wsign-conversion")
    DOCTEST_GCC_SUPPRESS_WARNING("-Wsign-compare")
    //DOCTEST_GCC_SUPPRESS_WARNING("-Wdouble-promotion")
    //DOCTEST_GCC_SUPPRESS_WARNING("-Wconversion")
    //DOCTEST_GCC_SUPPRESS_WARNING("-Wfloat-equal")

    DOCTEST_MSVC_SUPPRESS_WARNING_PUSH
    // https://stackoverflow.com/questions/39479163 what's the difference between 4018 and 4389
    DOCTEST_MSVC_SUPPRESS_WARNING(4388) // signed/unsigned mismatch
    DOCTEST_MSVC_SUPPRESS_WARNING(4389) // 'operator' : signed/unsigned mismatch
    DOCTEST_MSVC_SUPPRESS_WARNING(4018) // 'expression' : signed/unsigned mismatch
    //DOCTEST_MSVC_SUPPRESS_WARNING(4805) // 'operation' : unsafe mix of type 'type' and type 'type' in operation

#endif // DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION

    // clang-format off
#ifndef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
#define DOCTEST_COMPARISON_RETURN_TYPE bool
#else // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
#define DOCTEST_COMPARISON_RETURN_TYPE typename types::enable_if<can_use_op<L>::value || can_use_op<R>::value, bool>::type
    inline bool eq(const char* lhs, const char* rhs) { return String(lhs) == String(rhs); }
    inline bool ne(const char* lhs, const char* rhs) { return String(lhs) != String(rhs); }
    inline bool lt(const char* lhs, const char* rhs) { return String(lhs) <  String(rhs); }
    inline bool gt(const char* lhs, const char* rhs) { return String(lhs) >  String(rhs); }
    inline bool le(const char* lhs, const char* rhs) { return String(lhs) <= String(rhs); }
    inline bool ge(const char* lhs, const char* rhs) { return String(lhs) >= String(rhs); }
#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
    // clang-format on

#define DOCTEST_RELATIONAL_OP(name, op)                                                            \
    template <typename L, typename R>                                                              \
    DOCTEST_COMPARISON_RETURN_TYPE name(const DOCTEST_REF_WRAP(L) lhs,                             \
                                        const DOCTEST_REF_WRAP(R) rhs) {                           \
        return lhs op rhs;                                                                         \
    }

    DOCTEST_RELATIONAL_OP(eq, ==)
    DOCTEST_RELATIONAL_OP(ne, !=)
    DOCTEST_RELATIONAL_OP(lt, <)
    DOCTEST_RELATIONAL_OP(gt, >)
    DOCTEST_RELATIONAL_OP(le, <=)
    DOCTEST_RELATIONAL_OP(ge, >=)

#ifndef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
#define DOCTEST_CMP_EQ(l, r) l == r
#define DOCTEST_CMP_NE(l, r) l != r
#define DOCTEST_CMP_GT(l, r) l > r
#define DOCTEST_CMP_LT(l, r) l < r
#define DOCTEST_CMP_GE(l, r) l >= r
#define DOCTEST_CMP_LE(l, r) l <= r
#else // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
#define DOCTEST_CMP_EQ(l, r) eq(l, r)
#define DOCTEST_CMP_NE(l, r) ne(l, r)
#define DOCTEST_CMP_GT(l, r) gt(l, r)
#define DOCTEST_CMP_LT(l, r) lt(l, r)
#define DOCTEST_CMP_GE(l, r) ge(l, r)
#define DOCTEST_CMP_LE(l, r) le(l, r)
#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING

    template <typename L>
    // cppcheck-suppress copyCtorAndEqOperator
    struct Expression_lhs
    {
        L                lhs;
        assertType::Enum m_at;

        explicit Expression_lhs(L&& in, assertType::Enum at)
                : lhs(static_cast<L&&>(in))
                , m_at(at) {}

        DOCTEST_NOINLINE operator Result() {
// this is needed only for MSVC 2015
DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4800) // 'int': forcing value to bool
            bool res = static_cast<bool>(lhs);
DOCTEST_MSVC_SUPPRESS_WARNING_POP
            if(m_at & assertType::is_false) { //!OCLINT bitwise operator in conditional
                res = !res;
            }

            if(!res || getContextOptions()->success) {
                return { res, (DOCTEST_STRINGIFY(lhs)) };
            }
            return { res };
        }

        /* This is required for user-defined conversions from Expression_lhs to L */
        operator L() const { return lhs; }

        // clang-format off
        DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(==, " == ", DOCTEST_CMP_EQ) //!OCLINT bitwise operator in conditional
        DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(!=, " != ", DOCTEST_CMP_NE) //!OCLINT bitwise operator in conditional
        DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(>,  " >  ", DOCTEST_CMP_GT) //!OCLINT bitwise operator in conditional
        DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(<,  " <  ", DOCTEST_CMP_LT) //!OCLINT bitwise operator in conditional
        DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(>=, " >= ", DOCTEST_CMP_GE) //!OCLINT bitwise operator in conditional
        DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(<=, " <= ", DOCTEST_CMP_LE) //!OCLINT bitwise operator in conditional
        // clang-format on

        // forbidding some expressions based on this table: https://en.cppreference.com/w/cpp/language/operator_precedence
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, &)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, ^)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, |)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, &&)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, ||)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, =)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, +=)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, -=)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, *=)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, /=)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, %=)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, <<=)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, >>=)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, &=)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, ^=)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, |=)
        // these 2 are unfortunate because they should be allowed - they have higher precedence over the comparisons, but the
        // ExpressionDecomposer class uses the left shift operator to capture the left operand of the binary expression...
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, <<)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, >>)
    };

#ifndef DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION

    DOCTEST_CLANG_SUPPRESS_WARNING_POP
    DOCTEST_MSVC_SUPPRESS_WARNING_POP
    DOCTEST_GCC_SUPPRESS_WARNING_POP

#endif // DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION

#if DOCTEST_CLANG && DOCTEST_CLANG < DOCTEST_COMPILER(3, 6, 0)
DOCTEST_CLANG_SUPPRESS_WARNING_POP
#endif

    struct DOCTEST_INTERFACE ExpressionDecomposer
    {
        assertType::Enum m_at;

        ExpressionDecomposer(assertType::Enum at);

        // The right operator for capturing expressions is "<=" instead of "<<" (based on the operator precedence table)
        // but then there will be warnings from GCC about "-Wparentheses" and since "_Pragma()" is problematic this will stay for now...
        // https://github.com/catchorg/Catch2/issues/870
        // https://github.com/catchorg/Catch2/issues/565
        template <typename L>
        Expression_lhs<L> operator<<(L&& operand) {
            return Expression_lhs<L>(static_cast<L&&>(operand), m_at);
        }

        template <typename L,typename types::enable_if<!doctest::detail::types::is_rvalue_reference<L>::value,void >::type* = nullptr>
        Expression_lhs<const L&> operator<<(const L &operand) {
            return Expression_lhs<const L&>(operand, m_at);
        }
    };

    struct DOCTEST_INTERFACE TestSuite
    {
        const char* m_test_suite = nullptr;
        const char* m_description = nullptr;
        bool        m_skip = false;
        bool        m_no_breaks = false;
        bool        m_no_output = false;
        bool        m_may_fail = false;
        bool        m_should_fail = false;
        int         m_expected_failures = 0;
        double      m_timeout = 0;

        TestSuite& operator*(const char* in);

        template <typename T>
        TestSuite& operator*(const T& in) {
            in.fill(*this);
            return *this;
        }
    };

    using funcType = void (*)();

    struct DOCTEST_INTERFACE TestCase : public TestCaseData
    {
        funcType m_test; // a function pointer to the test case

        String m_type; // for templated test cases - gets appended to the real name
        int m_template_id; // an ID used to distinguish between the different versions of a templated test case
        String m_full_name; // contains the name (only for templated test cases!) + the template type

        TestCase(funcType test, const char* file, unsigned line, const TestSuite& test_suite,
                 const String& type = String(), int template_id = -1);

        TestCase(const TestCase& other);
        TestCase(TestCase&&) = delete;

        DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(26434) // hides a non-virtual function
        TestCase& operator=(const TestCase& other);
        DOCTEST_MSVC_SUPPRESS_WARNING_POP

        TestCase& operator=(TestCase&&) = delete;

        TestCase& operator*(const char* in);

        template <typename T>
        TestCase& operator*(const T& in) {
            in.fill(*this);
            return *this;
        }

        bool operator<(const TestCase& other) const;

        ~TestCase() = default;
    };

    // forward declarations of functions used by the macros
    DOCTEST_INTERFACE int  regTest(const TestCase& tc);
    DOCTEST_INTERFACE int  setTestSuite(const TestSuite& ts);
    DOCTEST_INTERFACE bool isDebuggerActive();

    template<typename T>
    int instantiationHelper(const T&) { return 0; }

    namespace binaryAssertComparison {
        enum Enum
        {
            eq = 0,
            ne,
            gt,
            lt,
            ge,
            le
        };
    } // namespace binaryAssertComparison

    // clang-format off
    template <int, class L, class R> struct RelationalComparator     { bool operator()(const DOCTEST_REF_WRAP(L),     const DOCTEST_REF_WRAP(R)    ) const { return false;        } };

#define DOCTEST_BINARY_RELATIONAL_OP(n, op) \
    template <class L, class R> struct RelationalComparator<n, L, R> { bool operator()(const DOCTEST_REF_WRAP(L) lhs, const DOCTEST_REF_WRAP(R) rhs) const { return op(lhs, rhs); } };
    // clang-format on

    DOCTEST_BINARY_RELATIONAL_OP(0, doctest::detail::eq)
    DOCTEST_BINARY_RELATIONAL_OP(1, doctest::detail::ne)
    DOCTEST_BINARY_RELATIONAL_OP(2, doctest::detail::gt)
    DOCTEST_BINARY_RELATIONAL_OP(3, doctest::detail::lt)
    DOCTEST_BINARY_RELATIONAL_OP(4, doctest::detail::ge)
    DOCTEST_BINARY_RELATIONAL_OP(5, doctest::detail::le)

    struct DOCTEST_INTERFACE ResultBuilder : public AssertData
    {
        ResultBuilder(assertType::Enum at, const char* file, int line, const char* expr,
                      const char* exception_type = "", const String& exception_string = "");

        ResultBuilder(assertType::Enum at, const char* file, int line, const char* expr,
                      const char* exception_type, const Contains& exception_string);

        void setResult(const Result& res);

        template <int comparison, typename L, typename R>
        DOCTEST_NOINLINE bool binary_assert(const DOCTEST_REF_WRAP(L) lhs,
                                            const DOCTEST_REF_WRAP(R) rhs) {
            m_failed = !RelationalComparator<comparison, L, R>()(lhs, rhs);
            if (m_failed || getContextOptions()->success) {
                m_decomp = stringifyBinaryExpr(lhs, ", ", rhs);
            }
            return !m_failed;
        }

        template <typename L>
        DOCTEST_NOINLINE bool unary_assert(const DOCTEST_REF_WRAP(L) val) {
            m_failed = !val;

            if (m_at & assertType::is_false) { //!OCLINT bitwise operator in conditional
                m_failed = !m_failed;
            }

            if (m_failed || getContextOptions()->success) {
                m_decomp = (DOCTEST_STRINGIFY(val));
            }

            return !m_failed;
        }

        void translateException();

        bool log();
        void react() const;
    };

    namespace assertAction {
        enum Enum
        {
            nothing     = 0,
            dbgbreak    = 1,
            shouldthrow = 2
        };
    } // namespace assertAction

    DOCTEST_INTERFACE void failed_out_of_a_testing_context(const AssertData& ad);

    DOCTEST_INTERFACE bool decomp_assert(assertType::Enum at, const char* file, int line,
                                         const char* expr, const Result& result);

#define DOCTEST_ASSERT_OUT_OF_TESTS(decomp)                                                        \
    do {                                                                                           \
        if(!is_running_in_test) {                                                                  \
            if(failed) {                                                                           \
                ResultBuilder rb(at, file, line, expr);                                            \
                rb.m_failed = failed;                                                              \
                rb.m_decomp = decomp;                                                              \
                failed_out_of_a_testing_context(rb);                                               \
                if(isDebuggerActive() && !getContextOptions()->no_breaks)                          \
                    DOCTEST_BREAK_INTO_DEBUGGER();                                                 \
                if(checkIfShouldThrow(at))                                                         \
                    throwException();                                                              \
            }                                                                                      \
            return !failed;                                                                        \
        }                                                                                          \
    } while(false)

#define DOCTEST_ASSERT_IN_TESTS(decomp)                                                            \
    ResultBuilder rb(at, file, line, expr);                                                        \
    rb.m_failed = failed;                                                                          \
    if(rb.m_failed || getContextOptions()->success)                                                \
        rb.m_decomp = decomp;                                                                      \
    if(rb.log())                                                                                   \
        DOCTEST_BREAK_INTO_DEBUGGER();                                                             \
    if(rb.m_failed && checkIfShouldThrow(at))                                                      \
    throwException()

    template <int comparison, typename L, typename R>
    DOCTEST_NOINLINE bool binary_assert(assertType::Enum at, const char* file, int line,
                                        const char* expr, const DOCTEST_REF_WRAP(L) lhs,
                                        const DOCTEST_REF_WRAP(R) rhs) {
        bool failed = !RelationalComparator<comparison, L, R>()(lhs, rhs);

        // ###################################################################################
        // IF THE DEBUGGER BREAKS HERE - GO 1 LEVEL UP IN THE CALLSTACK FOR THE FAILING ASSERT
        // THIS IS THE EFFECT OF HAVING 'DOCTEST_CONFIG_SUPER_FAST_ASSERTS' DEFINED
        // ###################################################################################
        DOCTEST_ASSERT_OUT_OF_TESTS(stringifyBinaryExpr(lhs, ", ", rhs));
        DOCTEST_ASSERT_IN_TESTS(stringifyBinaryExpr(lhs, ", ", rhs));
        return !failed;
    }

    template <typename L>
    DOCTEST_NOINLINE bool unary_assert(assertType::Enum at, const char* file, int line,
                                       const char* expr, const DOCTEST_REF_WRAP(L) val) {
        bool failed = !val;

        if(at & assertType::is_false) //!OCLINT bitwise operator in conditional
            failed = !failed;

        // ###################################################################################
        // IF THE DEBUGGER BREAKS HERE - GO 1 LEVEL UP IN THE CALLSTACK FOR THE FAILING ASSERT
        // THIS IS THE EFFECT OF HAVING 'DOCTEST_CONFIG_SUPER_FAST_ASSERTS' DEFINED
        // ###################################################################################
        DOCTEST_ASSERT_OUT_OF_TESTS((DOCTEST_STRINGIFY(val)));
        DOCTEST_ASSERT_IN_TESTS((DOCTEST_STRINGIFY(val)));
        return !failed;
    }

    struct DOCTEST_INTERFACE IExceptionTranslator
    {
        DOCTEST_DECLARE_INTERFACE(IExceptionTranslator)
        virtual bool translate(String&) const = 0;
    };

    template <typename T>
    class ExceptionTranslator : public IExceptionTranslator //!OCLINT destructor of virtual class
    {
    public:
        explicit ExceptionTranslator(String (*translateFunction)(T))
                : m_translateFunction(translateFunction) {}

        bool translate(String& res) const override {
#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
            try {
                throw; // lgtm [cpp/rethrow-no-exception]
                // cppcheck-suppress catchExceptionByValue
            } catch(const T& ex) {
                res = m_translateFunction(ex); //!OCLINT parameter reassignment
                return true;
            } catch(...) {}         //!OCLINT -  empty catch statement
#endif                              // DOCTEST_CONFIG_NO_EXCEPTIONS
            static_cast<void>(res); // to silence -Wunused-parameter
            return false;
        }

    private:
        String (*m_translateFunction)(T);
    };

    DOCTEST_INTERFACE void registerExceptionTranslatorImpl(const IExceptionTranslator* et);

    // ContextScope base class used to allow implementing methods of ContextScope
    // that don't depend on the template parameter in doctest.cpp.
    struct DOCTEST_INTERFACE ContextScopeBase : public IContextScope {
        ContextScopeBase(const ContextScopeBase&) = delete;

        ContextScopeBase& operator=(const ContextScopeBase&) = delete;
        ContextScopeBase& operator=(ContextScopeBase&&) = delete;

        ~ContextScopeBase() override = default;

    protected:
        ContextScopeBase();
        ContextScopeBase(ContextScopeBase&& other) noexcept;

        void destroy();
        bool need_to_destroy{true};
    };

    template <typename L> class ContextScope : public ContextScopeBase
    {
        L lambda_;

    public:
        explicit ContextScope(const L &lambda) : lambda_(lambda) {}
        explicit ContextScope(L&& lambda) : lambda_(static_cast<L&&>(lambda)) { }

        ContextScope(const ContextScope&) = delete;
        ContextScope(ContextScope&&) noexcept = default;

        ContextScope& operator=(const ContextScope&) = delete;
        ContextScope& operator=(ContextScope&&) = delete;

        void stringify(std::ostream* s) const override { lambda_(s); }

        ~ContextScope() override {
            if (need_to_destroy) {
                destroy();
            }
        }
    };

    struct DOCTEST_INTERFACE MessageBuilder : public MessageData
    {
        std::ostream* m_stream;
        bool          logged = false;

        MessageBuilder(const char* file, int line, assertType::Enum severity);

        MessageBuilder(const MessageBuilder&) = delete;
        MessageBuilder(MessageBuilder&&) = delete;

        MessageBuilder& operator=(const MessageBuilder&) = delete;
        MessageBuilder& operator=(MessageBuilder&&) = delete;

        ~MessageBuilder();

        // the preferred way of chaining parameters for stringification
DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4866)
        template <typename T>
        MessageBuilder& operator,(const T& in) {
            *m_stream << (DOCTEST_STRINGIFY(in));
            return *this;
        }
DOCTEST_MSVC_SUPPRESS_WARNING_POP

        // kept here just for backwards-compatibility - the comma operator should be preferred now
        template <typename T>
        MessageBuilder& operator<<(const T& in) { return this->operator,(in); }

        // the `,` operator has the lowest operator precedence - if `<<` is used by the user then
        // the `,` operator will be called last which is not what we want and thus the `*` operator
        // is used first (has higher operator precedence compared to `<<`) so that we guarantee that
        // an operator of the MessageBuilder class is called first before the rest of the parameters
        template <typename T>
        MessageBuilder& operator*(const T& in) { return this->operator,(in); }

        bool log();
        void react();
    };

    template <typename L>
    ContextScope<L> MakeContextScope(const L &lambda) {
        return ContextScope<L>(lambda);
    }
} // namespace detail

#define DOCTEST_DEFINE_DECORATOR(name, type, def)                                                  \
    struct name                                                                                    \
    {                                                                                              \
        type data;                                                                                 \
        name(type in = def)                                                                        \
                : data(in) {}                                                                      \
        void fill(detail::TestCase& state) const { state.DOCTEST_CAT(m_, name) = data; }           \
        void fill(detail::TestSuite& state) const { state.DOCTEST_CAT(m_, name) = data; }          \
    }

DOCTEST_DEFINE_DECORATOR(test_suite, const char*, "");
DOCTEST_DEFINE_DECORATOR(description, const char*, "");
DOCTEST_DEFINE_DECORATOR(skip, bool, true);
DOCTEST_DEFINE_DECORATOR(no_breaks, bool, true);
DOCTEST_DEFINE_DECORATOR(no_output, bool, true);
DOCTEST_DEFINE_DECORATOR(timeout, double, 0);
DOCTEST_DEFINE_DECORATOR(may_fail, bool, true);
DOCTEST_DEFINE_DECORATOR(should_fail, bool, true);
DOCTEST_DEFINE_DECORATOR(expected_failures, int, 0);

template <typename T>
int registerExceptionTranslator(String (*translateFunction)(T)) {
    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wexit-time-destructors")
    static detail::ExceptionTranslator<T> exceptionTranslator(translateFunction);
    DOCTEST_CLANG_SUPPRESS_WARNING_POP
    detail::registerExceptionTranslatorImpl(&exceptionTranslator);
    return 0;
}

} // namespace doctest

// in a separate namespace outside of doctest because the DOCTEST_TEST_SUITE macro
// introduces an anonymous namespace in which getCurrentTestSuite gets overridden
namespace doctest_detail_test_suite_ns {
DOCTEST_INTERFACE doctest::detail::TestSuite& getCurrentTestSuite();
} // namespace doctest_detail_test_suite_ns

namespace doctest {
#else  // DOCTEST_CONFIG_DISABLE
template <typename T>
int registerExceptionTranslator(String (*)(T)) {
    return 0;
}
#endif // DOCTEST_CONFIG_DISABLE

namespace detail {
    using assert_handler = void (*)(const AssertData&);
    struct ContextState;
} // namespace detail

class DOCTEST_INTERFACE Context
{
    detail::ContextState* p;

    void parseArgs(int argc, const char* const* argv, bool withDefaults = false);

public:
    explicit Context(int argc = 0, const char* const* argv = nullptr);

    Context(const Context&) = delete;
    Context(Context&&) = delete;

    Context& operator=(const Context&) = delete;
    Context& operator=(Context&&) = delete;

    ~Context(); // NOLINT(performance-trivially-destructible)

    void applyCommandLine(int argc, const char* const* argv);

    void addFilter(const char* filter, const char* value);
    void clearFilters();
    void setOption(const char* option, bool value);
    void setOption(const char* option, int value);
    void setOption(const char* option, const char* value);

    bool shouldExit();

    void setAsDefaultForAssertsOutOfTestCases();

    void setAssertHandler(detail::assert_handler ah);

    void setCout(std::ostream* out);

    int run();
};

namespace TestCaseFailureReason {
    enum Enum
    {
        None                     = 0,
        AssertFailure            = 1,   // an assertion has failed in the test case
        Exception                = 2,   // test case threw an exception
        Crash                    = 4,   // a crash...
        TooManyFailedAsserts     = 8,   // the abort-after option
        Timeout                  = 16,  // see the timeout decorator
        ShouldHaveFailedButDidnt = 32,  // see the should_fail decorator
        ShouldHaveFailedAndDid   = 64,  // see the should_fail decorator
        DidntFailExactlyNumTimes = 128, // see the expected_failures decorator
        FailedExactlyNumTimes    = 256, // see the expected_failures decorator
        CouldHaveFailedAndDid    = 512  // see the may_fail decorator
    };
} // namespace TestCaseFailureReason

struct DOCTEST_INTERFACE CurrentTestCaseStats
{
    int    numAssertsCurrentTest;
    int    numAssertsFailedCurrentTest;
    double seconds;
    int    failure_flags; // use TestCaseFailureReason::Enum
    bool   testCaseSuccess;
};

struct DOCTEST_INTERFACE TestCaseException
{
    String error_string;
    bool   is_crash;
};

struct DOCTEST_INTERFACE TestRunStats
{
    unsigned numTestCases;
    unsigned numTestCasesPassingFilters;
    unsigned numTestSuitesPassingFilters;
    unsigned numTestCasesFailed;
    int      numAsserts;
    int      numAssertsFailed;
};

struct QueryData
{
    const TestRunStats*  run_stats = nullptr;
    const TestCaseData** data      = nullptr;
    unsigned             num_data  = 0;
};

struct DOCTEST_INTERFACE IReporter
{
    // The constructor has to accept "const ContextOptions&" as a single argument
    // which has most of the options for the run + a pointer to the stdout stream
    // Reporter(const ContextOptions& in)

    // called when a query should be reported (listing test cases, printing the version, etc.)
    virtual void report_query(const QueryData&) = 0;

    // called when the whole test run starts
    virtual void test_run_start() = 0;
    // called when the whole test run ends (caching a pointer to the input doesn't make sense here)
    virtual void test_run_end(const TestRunStats&) = 0;

    // called when a test case is started (safe to cache a pointer to the input)
    virtual void test_case_start(const TestCaseData&) = 0;
    // called when a test case is reentered because of unfinished subcases (safe to cache a pointer to the input)
    virtual void test_case_reenter(const TestCaseData&) = 0;
    // called when a test case has ended
    virtual void test_case_end(const CurrentTestCaseStats&) = 0;

    // called when an exception is thrown from the test case (or it crashes)
    virtual void test_case_exception(const TestCaseException&) = 0;

    // called whenever a subcase is entered (don't cache pointers to the input)
    virtual void subcase_start(const SubcaseSignature&) = 0;
    // called whenever a subcase is exited (don't cache pointers to the input)
    virtual void subcase_end() = 0;

    // called for each assert (don't cache pointers to the input)
    virtual void log_assert(const AssertData&) = 0;
    // called for each message (don't cache pointers to the input)
    virtual void log_message(const MessageData&) = 0;

    // called when a test case is skipped either because it doesn't pass the filters, has a skip decorator
    // or isn't in the execution range (between first and last) (safe to cache a pointer to the input)
    virtual void test_case_skipped(const TestCaseData&) = 0;

    DOCTEST_DECLARE_INTERFACE(IReporter)

    // can obtain all currently active contexts and stringify them if one wishes to do so
    static int                         get_num_active_contexts();
    static const IContextScope* const* get_active_contexts();

    // can iterate through contexts which have been stringified automatically in their destructors when an exception has been thrown
    static int           get_num_stringified_contexts();
    static const String* get_stringified_contexts();
};

namespace detail {
    using reporterCreatorFunc =  IReporter* (*)(const ContextOptions&);

    DOCTEST_INTERFACE void registerReporterImpl(const char* name, int prio, reporterCreatorFunc c, bool isReporter);

    template <typename Reporter>
    IReporter* reporterCreator(const ContextOptions& o) {
        return new Reporter(o);
    }
} // namespace detail

template <typename Reporter>
int registerReporter(const char* name, int priority, bool isReporter) {
    detail::registerReporterImpl(name, priority, detail::reporterCreator<Reporter>, isReporter);
    return 0;
}
} // namespace doctest

#ifdef DOCTEST_CONFIG_ASSERTS_RETURN_VALUES
#define DOCTEST_FUNC_EMPTY [] { return false; }()
#else
#define DOCTEST_FUNC_EMPTY (void)0
#endif

// if registering is not disabled
#ifndef DOCTEST_CONFIG_DISABLE

#ifdef DOCTEST_CONFIG_ASSERTS_RETURN_VALUES
#define DOCTEST_FUNC_SCOPE_BEGIN [&]
#define DOCTEST_FUNC_SCOPE_END ()
#define DOCTEST_FUNC_SCOPE_RET(v) return v
#else
#define DOCTEST_FUNC_SCOPE_BEGIN do
#define DOCTEST_FUNC_SCOPE_END while(false)
#define DOCTEST_FUNC_SCOPE_RET(v) (void)0
#endif

// common code in asserts - for convenience
#define DOCTEST_ASSERT_LOG_REACT_RETURN(b)                                                         \
    if(b.log()) DOCTEST_BREAK_INTO_DEBUGGER();                                                     \
    b.react();                                                                                     \
    DOCTEST_FUNC_SCOPE_RET(!b.m_failed)

#ifdef DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS
#define DOCTEST_WRAP_IN_TRY(x) x;
#else // DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS
#define DOCTEST_WRAP_IN_TRY(x)                                                                     \
    try {                                                                                          \
        x;                                                                                         \
    } catch(...) { DOCTEST_RB.translateException(); }
#endif // DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS

#ifdef DOCTEST_CONFIG_VOID_CAST_EXPRESSIONS
#define DOCTEST_CAST_TO_VOID(...)                                                                  \
    DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wuseless-cast")                                       \
    static_cast<void>(__VA_ARGS__);                                                                \
    DOCTEST_GCC_SUPPRESS_WARNING_POP
#else // DOCTEST_CONFIG_VOID_CAST_EXPRESSIONS
#define DOCTEST_CAST_TO_VOID(...) __VA_ARGS__;
#endif // DOCTEST_CONFIG_VOID_CAST_EXPRESSIONS

// registers the test by initializing a dummy var with a function
#define DOCTEST_REGISTER_FUNCTION(global_prefix, f, decorators)                                    \
    global_prefix DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(DOCTEST_ANON_VAR_), /* NOLINT */    \
            doctest::detail::regTest(                                                              \
                    doctest::detail::TestCase(                                                     \
                            f, __FILE__, __LINE__,                                                 \
                            doctest_detail_test_suite_ns::getCurrentTestSuite()) *                 \
                    decorators))

#define DOCTEST_IMPLEMENT_FIXTURE(der, base, func, decorators)                                     \
    namespace { /* NOLINT */                                                                       \
        struct der : public base                                                                   \
        {                                                                                          \
            void f();                                                                              \
        };                                                                                         \
        static DOCTEST_INLINE_NOINLINE void func() {                                               \
            der v;                                                                                 \
            v.f();                                                                                 \
        }                                                                                          \
        DOCTEST_REGISTER_FUNCTION(DOCTEST_EMPTY, func, decorators)                                 \
    }                                                                                              \
    DOCTEST_INLINE_NOINLINE void der::f() // NOLINT(misc-definitions-in-headers)

#define DOCTEST_CREATE_AND_REGISTER_FUNCTION(f, decorators)                                        \
    static void f();                                                                               \
    DOCTEST_REGISTER_FUNCTION(DOCTEST_EMPTY, f, decorators)                                        \
    static void f()

#define DOCTEST_CREATE_AND_REGISTER_FUNCTION_IN_CLASS(f, proxy, decorators)                        \
    static doctest::detail::funcType proxy() { return f; }                                         \
    DOCTEST_REGISTER_FUNCTION(inline, proxy(), decorators)                                         \
    static void f()

// for registering tests
#define DOCTEST_TEST_CASE(decorators)                                                              \
    DOCTEST_CREATE_AND_REGISTER_FUNCTION(DOCTEST_ANONYMOUS(DOCTEST_ANON_FUNC_), decorators)

// for registering tests in classes - requires C++17 for inline variables!
#if DOCTEST_CPLUSPLUS >= 201703L
#define DOCTEST_TEST_CASE_CLASS(decorators)                                                        \
    DOCTEST_CREATE_AND_REGISTER_FUNCTION_IN_CLASS(DOCTEST_ANONYMOUS(DOCTEST_ANON_FUNC_),           \
                                                  DOCTEST_ANONYMOUS(DOCTEST_ANON_PROXY_),          \
                                                  decorators)
#else // DOCTEST_TEST_CASE_CLASS
#define DOCTEST_TEST_CASE_CLASS(...)                                                               \
    TEST_CASES_CAN_BE_REGISTERED_IN_CLASSES_ONLY_IN_CPP17_MODE_OR_WITH_VS_2017_OR_NEWER
#endif // DOCTEST_TEST_CASE_CLASS

// for registering tests with a fixture
#define DOCTEST_TEST_CASE_FIXTURE(c, decorators)                                                   \
    DOCTEST_IMPLEMENT_FIXTURE(DOCTEST_ANONYMOUS(DOCTEST_ANON_CLASS_), c,                           \
                              DOCTEST_ANONYMOUS(DOCTEST_ANON_FUNC_), decorators)

// for converting types to strings without the <typeinfo> header and demangling
#define DOCTEST_TYPE_TO_STRING_AS(str, ...)                                                        \
    namespace doctest {                                                                            \
        template <>                                                                                \
        inline String toString<__VA_ARGS__>() {                                                    \
            return str;                                                                            \
        }                                                                                          \
    }                                                                                              \
    static_assert(true, "")

#define DOCTEST_TYPE_TO_STRING(...) DOCTEST_TYPE_TO_STRING_AS(#__VA_ARGS__, __VA_ARGS__)

#define DOCTEST_TEST_CASE_TEMPLATE_DEFINE_IMPL(dec, T, iter, func)                                 \
    template <typename T>                                                                          \
    static void func();                                                                            \
    namespace { /* NOLINT */                                                                       \
        template <typename Tuple>                                                                  \
        struct iter;                                                                               \
        template <typename Type, typename... Rest>                                                 \
        struct iter<std::tuple<Type, Rest...>>                                                     \
        {                                                                                          \
            iter(const char* file, unsigned line, int index) {                                     \
                doctest::detail::regTest(doctest::detail::TestCase(func<Type>, file, line,         \
                                            doctest_detail_test_suite_ns::getCurrentTestSuite(),   \
                                            doctest::toString<Type>(),                             \
                                            int(line) * 1000 + index)                              \
                                         * dec);                                                   \
                iter<std::tuple<Rest...>>(file, line, index + 1);                                  \
            }                                                                                      \
        };                                                                                         \
        template <>                                                                                \
        struct iter<std::tuple<>>                                                                  \
        {                                                                                          \
            iter(const char*, unsigned, int) {}                                                    \
        };                                                                                         \
    }                                                                                              \
    template <typename T>                                                                          \
    static void func()

#define DOCTEST_TEST_CASE_TEMPLATE_DEFINE(dec, T, id)                                              \
    DOCTEST_TEST_CASE_TEMPLATE_DEFINE_IMPL(dec, T, DOCTEST_CAT(id, ITERATOR),                      \
                                           DOCTEST_ANONYMOUS(DOCTEST_ANON_TMP_))

#define DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(id, anon, ...)                                 \
    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_CAT(anon, DUMMY), /* NOLINT(cert-err58-cpp, fuchsia-statically-constructed-objects) */ \
        doctest::detail::instantiationHelper(                                                      \
            DOCTEST_CAT(id, ITERATOR)<__VA_ARGS__>(__FILE__, __LINE__, 0)))

#define DOCTEST_TEST_CASE_TEMPLATE_INVOKE(id, ...)                                                 \
    DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(id, DOCTEST_ANONYMOUS(DOCTEST_ANON_TMP_), std::tuple<__VA_ARGS__>) \
    static_assert(true, "")

#define DOCTEST_TEST_CASE_TEMPLATE_APPLY(id, ...)                                                  \
    DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(id, DOCTEST_ANONYMOUS(DOCTEST_ANON_TMP_), __VA_ARGS__) \
    static_assert(true, "")

#define DOCTEST_TEST_CASE_TEMPLATE_IMPL(dec, T, anon, ...)                                         \
    DOCTEST_TEST_CASE_TEMPLATE_DEFINE_IMPL(dec, T, DOCTEST_CAT(anon, ITERATOR), anon);             \
    DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(anon, anon, std::tuple<__VA_ARGS__>)               \
    template <typename T>                                                                          \
    static void anon()

#define DOCTEST_TEST_CASE_TEMPLATE(dec, T, ...)                                                    \
    DOCTEST_TEST_CASE_TEMPLATE_IMPL(dec, T, DOCTEST_ANONYMOUS(DOCTEST_ANON_TMP_), __VA_ARGS__)

// for subcases
#define DOCTEST_SUBCASE(name)                                                                      \
    if(const doctest::detail::Subcase & DOCTEST_ANONYMOUS(DOCTEST_ANON_SUBCASE_) DOCTEST_UNUSED =  \
               doctest::detail::Subcase(name, __FILE__, __LINE__))

// for grouping tests in test suites by using code blocks
#define DOCTEST_TEST_SUITE_IMPL(decorators, ns_name)                                               \
    namespace ns_name { namespace doctest_detail_test_suite_ns {                                   \
            static DOCTEST_NOINLINE doctest::detail::TestSuite& getCurrentTestSuite() noexcept {   \
                DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4640)                                      \
                DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wexit-time-destructors")                \
                DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wmissing-field-initializers")             \
                static doctest::detail::TestSuite data{};                                          \
                static bool                       inited = false;                                  \
                DOCTEST_MSVC_SUPPRESS_WARNING_POP                                                  \
                DOCTEST_CLANG_SUPPRESS_WARNING_POP                                                 \
                DOCTEST_GCC_SUPPRESS_WARNING_POP                                                   \
                if(!inited) {                                                                      \
                    data* decorators;                                                              \
                    inited = true;                                                                 \
                }                                                                                  \
                return data;                                                                       \
            }                                                                                      \
        }                                                                                          \
    }                                                                                              \
    namespace ns_name

#define DOCTEST_TEST_SUITE(decorators)                                                             \
    DOCTEST_TEST_SUITE_IMPL(decorators, DOCTEST_ANONYMOUS(DOCTEST_ANON_SUITE_))

// for starting a testsuite block
#define DOCTEST_TEST_SUITE_BEGIN(decorators)                                                       \
    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(DOCTEST_ANON_VAR_), /* NOLINT(cert-err58-cpp) */  \
            doctest::detail::setTestSuite(doctest::detail::TestSuite() * decorators))              \
    static_assert(true, "")

// for ending a testsuite block
#define DOCTEST_TEST_SUITE_END                                                                     \
    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(DOCTEST_ANON_VAR_), /* NOLINT(cert-err58-cpp) */  \
            doctest::detail::setTestSuite(doctest::detail::TestSuite() * ""))                      \
    using DOCTEST_ANONYMOUS(DOCTEST_ANON_FOR_SEMICOLON_) = int

// for registering exception translators
#define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR_IMPL(translatorName, signature)                      \
    inline doctest::String translatorName(signature);                                              \
    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(DOCTEST_ANON_TRANSLATOR_), /* NOLINT(cert-err58-cpp) */ \
            doctest::registerExceptionTranslator(translatorName))                                  \
    doctest::String translatorName(signature)

#define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR(signature)                                           \
    DOCTEST_REGISTER_EXCEPTION_TRANSLATOR_IMPL(DOCTEST_ANONYMOUS(DOCTEST_ANON_TRANSLATOR_),        \
                                               signature)

// for registering reporters
#define DOCTEST_REGISTER_REPORTER(name, priority, reporter)                                        \
    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(DOCTEST_ANON_REPORTER_), /* NOLINT(cert-err58-cpp) */ \
            doctest::registerReporter<reporter>(name, priority, true))                             \
    static_assert(true, "")

// for registering listeners
#define DOCTEST_REGISTER_LISTENER(name, priority, reporter)                                        \
    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(DOCTEST_ANON_REPORTER_), /* NOLINT(cert-err58-cpp) */ \
            doctest::registerReporter<reporter>(name, priority, false))                            \
    static_assert(true, "")

// clang-format off
// for logging - disabling formatting because it's important to have these on 2 separate lines - see PR #557
#define DOCTEST_INFO(...)                                                                          \
    DOCTEST_INFO_IMPL(DOCTEST_ANONYMOUS(DOCTEST_CAPTURE_),                                         \
                      DOCTEST_ANONYMOUS(DOCTEST_CAPTURE_OTHER_),                                   \
                      __VA_ARGS__)
// clang-format on

#define DOCTEST_INFO_IMPL(mb_name, s_name, ...)                                       \
    auto DOCTEST_ANONYMOUS(DOCTEST_CAPTURE_) = doctest::detail::MakeContextScope(                  \
        [&](std::ostream* s_name) {                                                                \
        doctest::detail::MessageBuilder mb_name(__FILE__, __LINE__, doctest::assertType::is_warn); \
        mb_name.m_stream = s_name;                                                                 \
        mb_name * __VA_ARGS__;                                                                     \
    })

#define DOCTEST_CAPTURE(x) DOCTEST_INFO(#x " := ", x)

#define DOCTEST_ADD_AT_IMPL(type, file, line, mb, ...)                                             \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        doctest::detail::MessageBuilder mb(file, line, doctest::assertType::type);                 \
        mb * __VA_ARGS__;                                                                          \
        if(mb.log())                                                                               \
            DOCTEST_BREAK_INTO_DEBUGGER();                                                         \
        mb.react();                                                                                \
    } DOCTEST_FUNC_SCOPE_END

// clang-format off
#define DOCTEST_ADD_MESSAGE_AT(file, line, ...) DOCTEST_ADD_AT_IMPL(is_warn, file, line, DOCTEST_ANONYMOUS(DOCTEST_MESSAGE_), __VA_ARGS__)
#define DOCTEST_ADD_FAIL_CHECK_AT(file, line, ...) DOCTEST_ADD_AT_IMPL(is_check, file, line, DOCTEST_ANONYMOUS(DOCTEST_MESSAGE_), __VA_ARGS__)
#define DOCTEST_ADD_FAIL_AT(file, line, ...) DOCTEST_ADD_AT_IMPL(is_require, file, line, DOCTEST_ANONYMOUS(DOCTEST_MESSAGE_), __VA_ARGS__)
// clang-format on

#define DOCTEST_MESSAGE(...) DOCTEST_ADD_MESSAGE_AT(__FILE__, __LINE__, __VA_ARGS__)
#define DOCTEST_FAIL_CHECK(...) DOCTEST_ADD_FAIL_CHECK_AT(__FILE__, __LINE__, __VA_ARGS__)
#define DOCTEST_FAIL(...) DOCTEST_ADD_FAIL_AT(__FILE__, __LINE__, __VA_ARGS__)

#define DOCTEST_TO_LVALUE(...) __VA_ARGS__ // Not removed to keep backwards compatibility.

#ifndef DOCTEST_CONFIG_SUPER_FAST_ASSERTS

#define DOCTEST_ASSERT_IMPLEMENT_2(assert_type, ...)                                               \
    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Woverloaded-shift-op-parentheses")                  \
    /* NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks) */                                  \
    doctest::detail::ResultBuilder DOCTEST_RB(doctest::assertType::assert_type, __FILE__,          \
                                               __LINE__, #__VA_ARGS__);                            \
    DOCTEST_WRAP_IN_TRY(DOCTEST_RB.setResult(                                                      \
            doctest::detail::ExpressionDecomposer(doctest::assertType::assert_type)                \
            << __VA_ARGS__)) /* NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks) */         \
    DOCTEST_ASSERT_LOG_REACT_RETURN(DOCTEST_RB)                                                    \
    DOCTEST_CLANG_SUPPRESS_WARNING_POP

#define DOCTEST_ASSERT_IMPLEMENT_1(assert_type, ...)                                               \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        DOCTEST_ASSERT_IMPLEMENT_2(assert_type, __VA_ARGS__);                                      \
    } DOCTEST_FUNC_SCOPE_END // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks)

#define DOCTEST_BINARY_ASSERT(assert_type, comp, ...)                                              \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        doctest::detail::ResultBuilder DOCTEST_RB(doctest::assertType::assert_type, __FILE__,      \
                                                   __LINE__, #__VA_ARGS__);                        \
        DOCTEST_WRAP_IN_TRY(                                                                       \
                DOCTEST_RB.binary_assert<doctest::detail::binaryAssertComparison::comp>(           \
                        __VA_ARGS__))                                                              \
        DOCTEST_ASSERT_LOG_REACT_RETURN(DOCTEST_RB);                                               \
    } DOCTEST_FUNC_SCOPE_END

#define DOCTEST_UNARY_ASSERT(assert_type, ...)                                                     \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        doctest::detail::ResultBuilder DOCTEST_RB(doctest::assertType::assert_type, __FILE__,      \
                                                   __LINE__, #__VA_ARGS__);                        \
        DOCTEST_WRAP_IN_TRY(DOCTEST_RB.unary_assert(__VA_ARGS__))                                  \
        DOCTEST_ASSERT_LOG_REACT_RETURN(DOCTEST_RB);                                               \
    } DOCTEST_FUNC_SCOPE_END

#else // DOCTEST_CONFIG_SUPER_FAST_ASSERTS

// necessary for <ASSERT>_MESSAGE
#define DOCTEST_ASSERT_IMPLEMENT_2 DOCTEST_ASSERT_IMPLEMENT_1

#define DOCTEST_ASSERT_IMPLEMENT_1(assert_type, ...)                                               \
    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Woverloaded-shift-op-parentheses")                  \
    doctest::detail::decomp_assert(                                                                \
            doctest::assertType::assert_type, __FILE__, __LINE__, #__VA_ARGS__,                    \
            doctest::detail::ExpressionDecomposer(doctest::assertType::assert_type)                \
                    << __VA_ARGS__) DOCTEST_CLANG_SUPPRESS_WARNING_POP

#define DOCTEST_BINARY_ASSERT(assert_type, comparison, ...)                                        \
    doctest::detail::binary_assert<doctest::detail::binaryAssertComparison::comparison>(           \
            doctest::assertType::assert_type, __FILE__, __LINE__, #__VA_ARGS__, __VA_ARGS__)

#define DOCTEST_UNARY_ASSERT(assert_type, ...)                                                     \
    doctest::detail::unary_assert(doctest::assertType::assert_type, __FILE__, __LINE__,            \
                                  #__VA_ARGS__, __VA_ARGS__)

#endif // DOCTEST_CONFIG_SUPER_FAST_ASSERTS

#define DOCTEST_WARN(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_WARN, __VA_ARGS__)
#define DOCTEST_CHECK(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_CHECK, __VA_ARGS__)
#define DOCTEST_REQUIRE(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_REQUIRE, __VA_ARGS__)
#define DOCTEST_WARN_FALSE(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_WARN_FALSE, __VA_ARGS__)
#define DOCTEST_CHECK_FALSE(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_CHECK_FALSE, __VA_ARGS__)
#define DOCTEST_REQUIRE_FALSE(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_REQUIRE_FALSE, __VA_ARGS__)

// clang-format off
#define DOCTEST_WARN_MESSAGE(cond, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_WARN, cond); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_MESSAGE(cond, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_CHECK, cond); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_MESSAGE(cond, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_REQUIRE, cond); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_WARN_FALSE_MESSAGE(cond, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_WARN_FALSE, cond); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_FALSE_MESSAGE(cond, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_CHECK_FALSE, cond); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_FALSE_MESSAGE(cond, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_REQUIRE_FALSE, cond); } DOCTEST_FUNC_SCOPE_END
// clang-format on

#define DOCTEST_WARN_EQ(...) DOCTEST_BINARY_ASSERT(DT_WARN_EQ, eq, __VA_ARGS__)
#define DOCTEST_CHECK_EQ(...) DOCTEST_BINARY_ASSERT(DT_CHECK_EQ, eq, __VA_ARGS__)
#define DOCTEST_REQUIRE_EQ(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_EQ, eq, __VA_ARGS__)
#define DOCTEST_WARN_NE(...) DOCTEST_BINARY_ASSERT(DT_WARN_NE, ne, __VA_ARGS__)
#define DOCTEST_CHECK_NE(...) DOCTEST_BINARY_ASSERT(DT_CHECK_NE, ne, __VA_ARGS__)
#define DOCTEST_REQUIRE_NE(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_NE, ne, __VA_ARGS__)
#define DOCTEST_WARN_GT(...) DOCTEST_BINARY_ASSERT(DT_WARN_GT, gt, __VA_ARGS__)
#define DOCTEST_CHECK_GT(...) DOCTEST_BINARY_ASSERT(DT_CHECK_GT, gt, __VA_ARGS__)
#define DOCTEST_REQUIRE_GT(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_GT, gt, __VA_ARGS__)
#define DOCTEST_WARN_LT(...) DOCTEST_BINARY_ASSERT(DT_WARN_LT, lt, __VA_ARGS__)
#define DOCTEST_CHECK_LT(...) DOCTEST_BINARY_ASSERT(DT_CHECK_LT, lt, __VA_ARGS__)
#define DOCTEST_REQUIRE_LT(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_LT, lt, __VA_ARGS__)
#define DOCTEST_WARN_GE(...) DOCTEST_BINARY_ASSERT(DT_WARN_GE, ge, __VA_ARGS__)
#define DOCTEST_CHECK_GE(...) DOCTEST_BINARY_ASSERT(DT_CHECK_GE, ge, __VA_ARGS__)
#define DOCTEST_REQUIRE_GE(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_GE, ge, __VA_ARGS__)
#define DOCTEST_WARN_LE(...) DOCTEST_BINARY_ASSERT(DT_WARN_LE, le, __VA_ARGS__)
#define DOCTEST_CHECK_LE(...) DOCTEST_BINARY_ASSERT(DT_CHECK_LE, le, __VA_ARGS__)
#define DOCTEST_REQUIRE_LE(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_LE, le, __VA_ARGS__)

#define DOCTEST_WARN_UNARY(...) DOCTEST_UNARY_ASSERT(DT_WARN_UNARY, __VA_ARGS__)
#define DOCTEST_CHECK_UNARY(...) DOCTEST_UNARY_ASSERT(DT_CHECK_UNARY, __VA_ARGS__)
#define DOCTEST_REQUIRE_UNARY(...) DOCTEST_UNARY_ASSERT(DT_REQUIRE_UNARY, __VA_ARGS__)
#define DOCTEST_WARN_UNARY_FALSE(...) DOCTEST_UNARY_ASSERT(DT_WARN_UNARY_FALSE, __VA_ARGS__)
#define DOCTEST_CHECK_UNARY_FALSE(...) DOCTEST_UNARY_ASSERT(DT_CHECK_UNARY_FALSE, __VA_ARGS__)
#define DOCTEST_REQUIRE_UNARY_FALSE(...) DOCTEST_UNARY_ASSERT(DT_REQUIRE_UNARY_FALSE, __VA_ARGS__)

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS

#define DOCTEST_ASSERT_THROWS_AS(expr, assert_type, message, ...)                                  \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        if(!doctest::getContextOptions()->no_throw) {                                              \
            doctest::detail::ResultBuilder DOCTEST_RB(doctest::assertType::assert_type, __FILE__,  \
                                                       __LINE__, #expr, #__VA_ARGS__, message);    \
            try {                                                                                  \
                DOCTEST_CAST_TO_VOID(expr)                                                         \
            } catch(const typename doctest::detail::types::remove_const<                           \
                    typename doctest::detail::types::remove_reference<__VA_ARGS__>::type>::type&) {\
                DOCTEST_RB.translateException();                                                   \
                DOCTEST_RB.m_threw_as = true;                                                      \
            } catch(...) { DOCTEST_RB.translateException(); }                                      \
            DOCTEST_ASSERT_LOG_REACT_RETURN(DOCTEST_RB);                                           \
        } else { /* NOLINT(*-else-after-return) */                                                 \
            DOCTEST_FUNC_SCOPE_RET(false);                                                         \
        }                                                                                          \
    } DOCTEST_FUNC_SCOPE_END

#define DOCTEST_ASSERT_THROWS_WITH(expr, expr_str, assert_type, ...)                               \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        if(!doctest::getContextOptions()->no_throw) {                                              \
            doctest::detail::ResultBuilder DOCTEST_RB(doctest::assertType::assert_type, __FILE__,  \
                                                       __LINE__, expr_str, "", __VA_ARGS__);       \
            try {                                                                                  \
                DOCTEST_CAST_TO_VOID(expr)                                                         \
            } catch(...) { DOCTEST_RB.translateException(); }                                      \
            DOCTEST_ASSERT_LOG_REACT_RETURN(DOCTEST_RB);                                           \
        } else { /* NOLINT(*-else-after-return) */                                                 \
           DOCTEST_FUNC_SCOPE_RET(false);                                                          \
        }                                                                                          \
    } DOCTEST_FUNC_SCOPE_END

#define DOCTEST_ASSERT_NOTHROW(assert_type, ...)                                                   \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        doctest::detail::ResultBuilder DOCTEST_RB(doctest::assertType::assert_type, __FILE__,      \
                                                   __LINE__, #__VA_ARGS__);                        \
        try {                                                                                      \
            DOCTEST_CAST_TO_VOID(__VA_ARGS__)                                                      \
        } catch(...) { DOCTEST_RB.translateException(); }                                          \
        DOCTEST_ASSERT_LOG_REACT_RETURN(DOCTEST_RB);                                               \
    } DOCTEST_FUNC_SCOPE_END

// clang-format off
#define DOCTEST_WARN_THROWS(...) DOCTEST_ASSERT_THROWS_WITH((__VA_ARGS__), #__VA_ARGS__, DT_WARN_THROWS, "")
#define DOCTEST_CHECK_THROWS(...) DOCTEST_ASSERT_THROWS_WITH((__VA_ARGS__), #__VA_ARGS__, DT_CHECK_THROWS, "")
#define DOCTEST_REQUIRE_THROWS(...) DOCTEST_ASSERT_THROWS_WITH((__VA_ARGS__), #__VA_ARGS__, DT_REQUIRE_THROWS, "")

#define DOCTEST_WARN_THROWS_AS(expr, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_WARN_THROWS_AS, "", __VA_ARGS__)
#define DOCTEST_CHECK_THROWS_AS(expr, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_CHECK_THROWS_AS, "", __VA_ARGS__)
#define DOCTEST_REQUIRE_THROWS_AS(expr, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_REQUIRE_THROWS_AS, "", __VA_ARGS__)

#define DOCTEST_WARN_THROWS_WITH(expr, ...) DOCTEST_ASSERT_THROWS_WITH(expr, #expr, DT_WARN_THROWS_WITH, __VA_ARGS__)
#define DOCTEST_CHECK_THROWS_WITH(expr, ...) DOCTEST_ASSERT_THROWS_WITH(expr, #expr, DT_CHECK_THROWS_WITH, __VA_ARGS__)
#define DOCTEST_REQUIRE_THROWS_WITH(expr, ...) DOCTEST_ASSERT_THROWS_WITH(expr, #expr, DT_REQUIRE_THROWS_WITH, __VA_ARGS__)

#define DOCTEST_WARN_THROWS_WITH_AS(expr, message, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_WARN_THROWS_WITH_AS, message, __VA_ARGS__)
#define DOCTEST_CHECK_THROWS_WITH_AS(expr, message, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_CHECK_THROWS_WITH_AS, message, __VA_ARGS__)
#define DOCTEST_REQUIRE_THROWS_WITH_AS(expr, message, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_REQUIRE_THROWS_WITH_AS, message, __VA_ARGS__)

#define DOCTEST_WARN_NOTHROW(...) DOCTEST_ASSERT_NOTHROW(DT_WARN_NOTHROW, __VA_ARGS__)
#define DOCTEST_CHECK_NOTHROW(...) DOCTEST_ASSERT_NOTHROW(DT_CHECK_NOTHROW, __VA_ARGS__)
#define DOCTEST_REQUIRE_NOTHROW(...) DOCTEST_ASSERT_NOTHROW(DT_REQUIRE_NOTHROW, __VA_ARGS__)

#define DOCTEST_WARN_THROWS_MESSAGE(expr, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_THROWS(expr); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_THROWS_MESSAGE(expr, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_THROWS(expr); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_THROWS_MESSAGE(expr, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_THROWS(expr); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_THROWS_AS(expr, ex); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_THROWS_AS(expr, ex); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_THROWS_AS(expr, ex); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_THROWS_WITH(expr, with); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_THROWS_WITH(expr, with); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_THROWS_WITH(expr, with); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_THROWS_WITH_AS(expr, with, ex); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_THROWS_WITH_AS(expr, with, ex); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, ex); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_WARN_NOTHROW_MESSAGE(expr, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_NOTHROW(expr); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_NOTHROW_MESSAGE(expr, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_NOTHROW(expr); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_NOTHROW(expr); } DOCTEST_FUNC_SCOPE_END
// clang-format on

#endif // DOCTEST_CONFIG_NO_EXCEPTIONS

// =================================================================================================
// == WHAT FOLLOWS IS VERSIONS OF THE MACROS THAT DO NOT DO ANY REGISTERING!                      ==
// == THIS CAN BE ENABLED BY DEFINING DOCTEST_CONFIG_DISABLE GLOBALLY!                            ==
// =================================================================================================
#else // DOCTEST_CONFIG_DISABLE

#define DOCTEST_IMPLEMENT_FIXTURE(der, base, func, name)                                           \
    namespace /* NOLINT */ {                                                                       \
        template <typename DOCTEST_UNUSED_TEMPLATE_TYPE>                                           \
        struct der : public base                                                                   \
        { void f(); };                                                                             \
    }                                                                                              \
    template <typename DOCTEST_UNUSED_TEMPLATE_TYPE>                                               \
    inline void der<DOCTEST_UNUSED_TEMPLATE_TYPE>::f()

#define DOCTEST_CREATE_AND_REGISTER_FUNCTION(f, name)                                              \
    template <typename DOCTEST_UNUSED_TEMPLATE_TYPE>                                               \
    static inline void f()

// for registering tests
#define DOCTEST_TEST_CASE(name)                                                                    \
    DOCTEST_CREATE_AND_REGISTER_FUNCTION(DOCTEST_ANONYMOUS(DOCTEST_ANON_FUNC_), name)

// for registering tests in classes
#define DOCTEST_TEST_CASE_CLASS(name)                                                              \
    DOCTEST_CREATE_AND_REGISTER_FUNCTION(DOCTEST_ANONYMOUS(DOCTEST_ANON_FUNC_), name)

// for registering tests with a fixture
#define DOCTEST_TEST_CASE_FIXTURE(x, name)                                                         \
    DOCTEST_IMPLEMENT_FIXTURE(DOCTEST_ANONYMOUS(DOCTEST_ANON_CLASS_), x,                           \
                              DOCTEST_ANONYMOUS(DOCTEST_ANON_FUNC_), name)

// for converting types to strings without the <typeinfo> header and demangling
#define DOCTEST_TYPE_TO_STRING_AS(str, ...) static_assert(true, "")
#define DOCTEST_TYPE_TO_STRING(...) static_assert(true, "")

// for typed tests
#define DOCTEST_TEST_CASE_TEMPLATE(name, type, ...)                                                \
    template <typename type>                                                                       \
    inline void DOCTEST_ANONYMOUS(DOCTEST_ANON_TMP_)()

#define DOCTEST_TEST_CASE_TEMPLATE_DEFINE(name, type, id)                                          \
    template <typename type>                                                                       \
    inline void DOCTEST_ANONYMOUS(DOCTEST_ANON_TMP_)()

#define DOCTEST_TEST_CASE_TEMPLATE_INVOKE(id, ...) static_assert(true, "")
#define DOCTEST_TEST_CASE_TEMPLATE_APPLY(id, ...) static_assert(true, "")

// for subcases
#define DOCTEST_SUBCASE(name)

// for a testsuite block
#define DOCTEST_TEST_SUITE(name) namespace // NOLINT

// for starting a testsuite block
#define DOCTEST_TEST_SUITE_BEGIN(name) static_assert(true, "")

// for ending a testsuite block
#define DOCTEST_TEST_SUITE_END using DOCTEST_ANONYMOUS(DOCTEST_ANON_FOR_SEMICOLON_) = int

#define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR(signature)                                           \
    template <typename DOCTEST_UNUSED_TEMPLATE_TYPE>                                               \
    static inline doctest::String DOCTEST_ANONYMOUS(DOCTEST_ANON_TRANSLATOR_)(signature)

#define DOCTEST_REGISTER_REPORTER(name, priority, reporter)
#define DOCTEST_REGISTER_LISTENER(name, priority, reporter)

#define DOCTEST_INFO(...) (static_cast<void>(0))
#define DOCTEST_CAPTURE(x) (static_cast<void>(0))
#define DOCTEST_ADD_MESSAGE_AT(file, line, ...) (static_cast<void>(0))
#define DOCTEST_ADD_FAIL_CHECK_AT(file, line, ...) (static_cast<void>(0))
#define DOCTEST_ADD_FAIL_AT(file, line, ...) (static_cast<void>(0))
#define DOCTEST_MESSAGE(...) (static_cast<void>(0))
#define DOCTEST_FAIL_CHECK(...) (static_cast<void>(0))
#define DOCTEST_FAIL(...) (static_cast<void>(0))

#if defined(DOCTEST_CONFIG_EVALUATE_ASSERTS_EVEN_WHEN_DISABLED)                                    \
 && defined(DOCTEST_CONFIG_ASSERTS_RETURN_VALUES)

#define DOCTEST_WARN(...) [&] { return __VA_ARGS__; }()
#define DOCTEST_CHECK(...) [&] { return __VA_ARGS__; }()
#define DOCTEST_REQUIRE(...) [&] { return __VA_ARGS__; }()
#define DOCTEST_WARN_FALSE(...) [&] { return !(__VA_ARGS__); }()
#define DOCTEST_CHECK_FALSE(...) [&] { return !(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_FALSE(...) [&] { return !(__VA_ARGS__); }()

#define DOCTEST_WARN_MESSAGE(cond, ...) [&] { return cond; }()
#define DOCTEST_CHECK_MESSAGE(cond, ...) [&] { return cond; }()
#define DOCTEST_REQUIRE_MESSAGE(cond, ...) [&] { return cond; }()
#define DOCTEST_WARN_FALSE_MESSAGE(cond, ...) [&] { return !(cond); }()
#define DOCTEST_CHECK_FALSE_MESSAGE(cond, ...) [&] { return !(cond); }()
#define DOCTEST_REQUIRE_FALSE_MESSAGE(cond, ...) [&] { return !(cond); }()

namespace doctest {
namespace detail {
#define DOCTEST_RELATIONAL_OP(name, op)                                                            \
    template <typename L, typename R>                                                              \
    bool name(const DOCTEST_REF_WRAP(L) lhs, const DOCTEST_REF_WRAP(R) rhs) { return lhs op rhs; }

    DOCTEST_RELATIONAL_OP(eq, ==)
    DOCTEST_RELATIONAL_OP(ne, !=)
    DOCTEST_RELATIONAL_OP(lt, <)
    DOCTEST_RELATIONAL_OP(gt, >)
    DOCTEST_RELATIONAL_OP(le, <=)
    DOCTEST_RELATIONAL_OP(ge, >=)
} // namespace detail
} // namespace doctest

#define DOCTEST_WARN_EQ(...) [&] { return doctest::detail::eq(__VA_ARGS__); }()
#define DOCTEST_CHECK_EQ(...) [&] { return doctest::detail::eq(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_EQ(...) [&] { return doctest::detail::eq(__VA_ARGS__); }()
#define DOCTEST_WARN_NE(...) [&] { return doctest::detail::ne(__VA_ARGS__); }()
#define DOCTEST_CHECK_NE(...) [&] { return doctest::detail::ne(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_NE(...) [&] { return doctest::detail::ne(__VA_ARGS__); }()
#define DOCTEST_WARN_LT(...) [&] { return doctest::detail::lt(__VA_ARGS__); }()
#define DOCTEST_CHECK_LT(...) [&] { return doctest::detail::lt(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_LT(...) [&] { return doctest::detail::lt(__VA_ARGS__); }()
#define DOCTEST_WARN_GT(...) [&] { return doctest::detail::gt(__VA_ARGS__); }()
#define DOCTEST_CHECK_GT(...) [&] { return doctest::detail::gt(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_GT(...) [&] { return doctest::detail::gt(__VA_ARGS__); }()
#define DOCTEST_WARN_LE(...) [&] { return doctest::detail::le(__VA_ARGS__); }()
#define DOCTEST_CHECK_LE(...) [&] { return doctest::detail::le(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_LE(...) [&] { return doctest::detail::le(__VA_ARGS__); }()
#define DOCTEST_WARN_GE(...) [&] { return doctest::detail::ge(__VA_ARGS__); }()
#define DOCTEST_CHECK_GE(...) [&] { return doctest::detail::ge(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_GE(...) [&] { return doctest::detail::ge(__VA_ARGS__); }()
#define DOCTEST_WARN_UNARY(...) [&] { return __VA_ARGS__; }()
#define DOCTEST_CHECK_UNARY(...) [&] { return __VA_ARGS__; }()
#define DOCTEST_REQUIRE_UNARY(...) [&] { return __VA_ARGS__; }()
#define DOCTEST_WARN_UNARY_FALSE(...) [&] { return !(__VA_ARGS__); }()
#define DOCTEST_CHECK_UNARY_FALSE(...) [&] { return !(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_UNARY_FALSE(...) [&] { return !(__VA_ARGS__); }()

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS

#define DOCTEST_WARN_THROWS_WITH(expr, with, ...) [] { static_assert(false, "Exception translation is not available when doctest is disabled."); return false; }()
#define DOCTEST_CHECK_THROWS_WITH(expr, with, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_REQUIRE_THROWS_WITH(expr, with, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_WARN_THROWS_WITH_AS(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_CHECK_THROWS_WITH_AS(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH(,,)

#define DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH(,,)

#define DOCTEST_WARN_THROWS(...) [&] { try { __VA_ARGS__; return false; } catch (...) { return true; } }()
#define DOCTEST_CHECK_THROWS(...) [&] { try { __VA_ARGS__; return false; } catch (...) { return true; } }()
#define DOCTEST_REQUIRE_THROWS(...) [&] { try { __VA_ARGS__; return false; } catch (...) { return true; } }()
#define DOCTEST_WARN_THROWS_AS(expr, ...) [&] { try { expr; } catch (__VA_ARGS__) { return true; } catch (...) { } return false; }()
#define DOCTEST_CHECK_THROWS_AS(expr, ...) [&] { try { expr; } catch (__VA_ARGS__) { return true; } catch (...) { } return false; }()
#define DOCTEST_REQUIRE_THROWS_AS(expr, ...) [&] { try { expr; } catch (__VA_ARGS__) { return true; } catch (...) { } return false; }()
#define DOCTEST_WARN_NOTHROW(...) [&] { try { __VA_ARGS__; return true; } catch (...) { return false; } }()
#define DOCTEST_CHECK_NOTHROW(...) [&] { try { __VA_ARGS__; return true; } catch (...) { return false; } }()
#define DOCTEST_REQUIRE_NOTHROW(...) [&] { try { __VA_ARGS__; return true; } catch (...) { return false; } }()

#define DOCTEST_WARN_THROWS_MESSAGE(expr, ...) [&] { try { __VA_ARGS__; return false; } catch (...) { return true; } }()
#define DOCTEST_CHECK_THROWS_MESSAGE(expr, ...) [&] { try { __VA_ARGS__; return false; } catch (...) { return true; } }()
#define DOCTEST_REQUIRE_THROWS_MESSAGE(expr, ...) [&] { try { __VA_ARGS__; return false; } catch (...) { return true; } }()
#define DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, ...) [&] { try { expr; } catch (__VA_ARGS__) { return true; } catch (...) { } return false; }()
#define DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, ...) [&] { try { expr; } catch (__VA_ARGS__) { return true; } catch (...) { } return false; }()
#define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) [&] { try { expr; } catch (__VA_ARGS__) { return true; } catch (...) { } return false; }()
#define DOCTEST_WARN_NOTHROW_MESSAGE(expr, ...) [&] { try { __VA_ARGS__; return true; } catch (...) { return false; } }()
#define DOCTEST_CHECK_NOTHROW_MESSAGE(expr, ...) [&] { try { __VA_ARGS__; return true; } catch (...) { return false; } }()
#define DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, ...) [&] { try { __VA_ARGS__; return true; } catch (...) { return false; } }()

#endif // DOCTEST_CONFIG_NO_EXCEPTIONS

#else // DOCTEST_CONFIG_EVALUATE_ASSERTS_EVEN_WHEN_DISABLED

#define DOCTEST_WARN(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_FALSE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_FALSE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_FALSE(...) DOCTEST_FUNC_EMPTY

#define DOCTEST_WARN_MESSAGE(cond, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_MESSAGE(cond, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_MESSAGE(cond, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_FALSE_MESSAGE(cond, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_FALSE_MESSAGE(cond, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_FALSE_MESSAGE(cond, ...) DOCTEST_FUNC_EMPTY

#define DOCTEST_WARN_EQ(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_EQ(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_EQ(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_NE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_NE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_NE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_GT(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_GT(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_GT(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_LT(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_LT(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_LT(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_GE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_GE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_GE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_LE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_LE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_LE(...) DOCTEST_FUNC_EMPTY

#define DOCTEST_WARN_UNARY(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_UNARY(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_UNARY(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_UNARY_FALSE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_UNARY_FALSE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_UNARY_FALSE(...) DOCTEST_FUNC_EMPTY

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS

#define DOCTEST_WARN_THROWS(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_THROWS_AS(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_AS(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_AS(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_THROWS_WITH(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_WITH(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_WITH(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_THROWS_WITH_AS(expr, with, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_WITH_AS(expr, with, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_NOTHROW(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_NOTHROW(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_NOTHROW(...) DOCTEST_FUNC_EMPTY

#define DOCTEST_WARN_THROWS_MESSAGE(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_MESSAGE(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_MESSAGE(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_NOTHROW_MESSAGE(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_NOTHROW_MESSAGE(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, ...) DOCTEST_FUNC_EMPTY

#endif // DOCTEST_CONFIG_NO_EXCEPTIONS

#endif // DOCTEST_CONFIG_EVALUATE_ASSERTS_EVEN_WHEN_DISABLED

#endif // DOCTEST_CONFIG_DISABLE

#ifdef DOCTEST_CONFIG_NO_EXCEPTIONS

#ifdef DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS
#define DOCTEST_EXCEPTION_EMPTY_FUNC DOCTEST_FUNC_EMPTY
#else // DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS
#define DOCTEST_EXCEPTION_EMPTY_FUNC [] { static_assert(false, "Exceptions are disabled! " \
    "Use DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS if you want to compile with exceptions disabled."); return false; }()

#undef DOCTEST_REQUIRE
#undef DOCTEST_REQUIRE_FALSE
#undef DOCTEST_REQUIRE_MESSAGE
#undef DOCTEST_REQUIRE_FALSE_MESSAGE
#undef DOCTEST_REQUIRE_EQ
#undef DOCTEST_REQUIRE_NE
#undef DOCTEST_REQUIRE_GT
#undef DOCTEST_REQUIRE_LT
#undef DOCTEST_REQUIRE_GE
#undef DOCTEST_REQUIRE_LE
#undef DOCTEST_REQUIRE_UNARY
#undef DOCTEST_REQUIRE_UNARY_FALSE

#define DOCTEST_REQUIRE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_FALSE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_MESSAGE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_FALSE_MESSAGE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_EQ DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_NE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_GT DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_LT DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_GE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_LE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_UNARY DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_UNARY_FALSE DOCTEST_EXCEPTION_EMPTY_FUNC

#endif // DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS

#define DOCTEST_WARN_THROWS(...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS(...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS(...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_THROWS_AS(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_AS(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_AS(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_THROWS_WITH(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_WITH(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_WITH(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_THROWS_WITH_AS(expr, with, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_WITH_AS(expr, with, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_NOTHROW(...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_NOTHROW(...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_NOTHROW(...) DOCTEST_EXCEPTION_EMPTY_FUNC

#define DOCTEST_WARN_THROWS_MESSAGE(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_MESSAGE(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_MESSAGE(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_NOTHROW_MESSAGE(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_NOTHROW_MESSAGE(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC

#endif // DOCTEST_CONFIG_NO_EXCEPTIONS

// clang-format off
// KEPT FOR BACKWARDS COMPATIBILITY - FORWARDING TO THE RIGHT MACROS
#define DOCTEST_FAST_WARN_EQ             DOCTEST_WARN_EQ
#define DOCTEST_FAST_CHECK_EQ            DOCTEST_CHECK_EQ
#define DOCTEST_FAST_REQUIRE_EQ          DOCTEST_REQUIRE_EQ
#define DOCTEST_FAST_WARN_NE             DOCTEST_WARN_NE
#define DOCTEST_FAST_CHECK_NE            DOCTEST_CHECK_NE
#define DOCTEST_FAST_REQUIRE_NE          DOCTEST_REQUIRE_NE
#define DOCTEST_FAST_WARN_GT             DOCTEST_WARN_GT
#define DOCTEST_FAST_CHECK_GT            DOCTEST_CHECK_GT
#define DOCTEST_FAST_REQUIRE_GT          DOCTEST_REQUIRE_GT
#define DOCTEST_FAST_WARN_LT             DOCTEST_WARN_LT
#define DOCTEST_FAST_CHECK_LT            DOCTEST_CHECK_LT
#define DOCTEST_FAST_REQUIRE_LT          DOCTEST_REQUIRE_LT
#define DOCTEST_FAST_WARN_GE             DOCTEST_WARN_GE
#define DOCTEST_FAST_CHECK_GE            DOCTEST_CHECK_GE
#define DOCTEST_FAST_REQUIRE_GE          DOCTEST_REQUIRE_GE
#define DOCTEST_FAST_WARN_LE             DOCTEST_WARN_LE
#define DOCTEST_FAST_CHECK_LE            DOCTEST_CHECK_LE
#define DOCTEST_FAST_REQUIRE_LE          DOCTEST_REQUIRE_LE

#define DOCTEST_FAST_WARN_UNARY          DOCTEST_WARN_UNARY
#define DOCTEST_FAST_CHECK_UNARY         DOCTEST_CHECK_UNARY
#define DOCTEST_FAST_REQUIRE_UNARY       DOCTEST_REQUIRE_UNARY
#define DOCTEST_FAST_WARN_UNARY_FALSE    DOCTEST_WARN_UNARY_FALSE
#define DOCTEST_FAST_CHECK_UNARY_FALSE   DOCTEST_CHECK_UNARY_FALSE
#define DOCTEST_FAST_REQUIRE_UNARY_FALSE DOCTEST_REQUIRE_UNARY_FALSE

#define DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE(id, ...) DOCTEST_TEST_CASE_TEMPLATE_INVOKE(id,__VA_ARGS__)
// clang-format on

// BDD style macros
// clang-format off
#define DOCTEST_SCENARIO(name) DOCTEST_TEST_CASE("  Scenario: " name)
#define DOCTEST_SCENARIO_CLASS(name) DOCTEST_TEST_CASE_CLASS("  Scenario: " name)
#define DOCTEST_SCENARIO_TEMPLATE(name, T, ...)  DOCTEST_TEST_CASE_TEMPLATE("  Scenario: " name, T, __VA_ARGS__)
#define DOCTEST_SCENARIO_TEMPLATE_DEFINE(name, T, id) DOCTEST_TEST_CASE_TEMPLATE_DEFINE("  Scenario: " name, T, id)

#define DOCTEST_GIVEN(name)     DOCTEST_SUBCASE("   Given: " name)
#define DOCTEST_WHEN(name)      DOCTEST_SUBCASE("    When: " name)
#define DOCTEST_AND_WHEN(name)  DOCTEST_SUBCASE("And when: " name)
#define DOCTEST_THEN(name)      DOCTEST_SUBCASE("    Then: " name)
#define DOCTEST_AND_THEN(name)  DOCTEST_SUBCASE("     And: " name)
// clang-format on

// == SHORT VERSIONS OF THE MACROS
#ifndef DOCTEST_CONFIG_NO_SHORT_MACRO_NAMES

#define TEST_CASE(name) DOCTEST_TEST_CASE(name)
#define TEST_CASE_CLASS(name) DOCTEST_TEST_CASE_CLASS(name)
#define TEST_CASE_FIXTURE(x, name) DOCTEST_TEST_CASE_FIXTURE(x, name)
#define TYPE_TO_STRING_AS(str, ...) DOCTEST_TYPE_TO_STRING_AS(str, __VA_ARGS__)
#define TYPE_TO_STRING(...) DOCTEST_TYPE_TO_STRING(__VA_ARGS__)
#define TEST_CASE_TEMPLATE(name, T, ...) DOCTEST_TEST_CASE_TEMPLATE(name, T, __VA_ARGS__)
#define TEST_CASE_TEMPLATE_DEFINE(name, T, id) DOCTEST_TEST_CASE_TEMPLATE_DEFINE(name, T, id)
#define TEST_CASE_TEMPLATE_INVOKE(id, ...) DOCTEST_TEST_CASE_TEMPLATE_INVOKE(id, __VA_ARGS__)
#define TEST_CASE_TEMPLATE_APPLY(id, ...) DOCTEST_TEST_CASE_TEMPLATE_APPLY(id, __VA_ARGS__)
#define SUBCASE(name) DOCTEST_SUBCASE(name)
#define TEST_SUITE(decorators) DOCTEST_TEST_SUITE(decorators)
#define TEST_SUITE_BEGIN(name) DOCTEST_TEST_SUITE_BEGIN(name)
#define TEST_SUITE_END DOCTEST_TEST_SUITE_END
#define REGISTER_EXCEPTION_TRANSLATOR(signature) DOCTEST_REGISTER_EXCEPTION_TRANSLATOR(signature)
#define REGISTER_REPORTER(name, priority, reporter) DOCTEST_REGISTER_REPORTER(name, priority, reporter)
#define REGISTER_LISTENER(name, priority, reporter) DOCTEST_REGISTER_LISTENER(name, priority, reporter)
#define INFO(...) DOCTEST_INFO(__VA_ARGS__)
#define CAPTURE(x) DOCTEST_CAPTURE(x)
#define ADD_MESSAGE_AT(file, line, ...) DOCTEST_ADD_MESSAGE_AT(file, line, __VA_ARGS__)
#define ADD_FAIL_CHECK_AT(file, line, ...) DOCTEST_ADD_FAIL_CHECK_AT(file, line, __VA_ARGS__)
#define ADD_FAIL_AT(file, line, ...) DOCTEST_ADD_FAIL_AT(file, line, __VA_ARGS__)
#define MESSAGE(...) DOCTEST_MESSAGE(__VA_ARGS__)
#define FAIL_CHECK(...) DOCTEST_FAIL_CHECK(__VA_ARGS__)
#define FAIL(...) DOCTEST_FAIL(__VA_ARGS__)
#define TO_LVALUE(...) DOCTEST_TO_LVALUE(__VA_ARGS__)

#define WARN(...) DOCTEST_WARN(__VA_ARGS__)
#define WARN_FALSE(...) DOCTEST_WARN_FALSE(__VA_ARGS__)
#define WARN_THROWS(...) DOCTEST_WARN_THROWS(__VA_ARGS__)
#define WARN_THROWS_AS(expr, ...) DOCTEST_WARN_THROWS_AS(expr, __VA_ARGS__)
#define WARN_THROWS_WITH(expr, ...) DOCTEST_WARN_THROWS_WITH(expr, __VA_ARGS__)
#define WARN_THROWS_WITH_AS(expr, with, ...) DOCTEST_WARN_THROWS_WITH_AS(expr, with, __VA_ARGS__)
#define WARN_NOTHROW(...) DOCTEST_WARN_NOTHROW(__VA_ARGS__)
#define CHECK(...) DOCTEST_CHECK(__VA_ARGS__)
#define CHECK_FALSE(...) DOCTEST_CHECK_FALSE(__VA_ARGS__)
#define CHECK_THROWS(...) DOCTEST_CHECK_THROWS(__VA_ARGS__)
#define CHECK_THROWS_AS(expr, ...) DOCTEST_CHECK_THROWS_AS(expr, __VA_ARGS__)
#define CHECK_THROWS_WITH(expr, ...) DOCTEST_CHECK_THROWS_WITH(expr, __VA_ARGS__)
#define CHECK_THROWS_WITH_AS(expr, with, ...) DOCTEST_CHECK_THROWS_WITH_AS(expr, with, __VA_ARGS__)
#define CHECK_NOTHROW(...) DOCTEST_CHECK_NOTHROW(__VA_ARGS__)
#define REQUIRE(...) DOCTEST_REQUIRE(__VA_ARGS__)
#define REQUIRE_FALSE(...) DOCTEST_REQUIRE_FALSE(__VA_ARGS__)
#define REQUIRE_THROWS(...) DOCTEST_REQUIRE_THROWS(__VA_ARGS__)
#define REQUIRE_THROWS_AS(expr, ...) DOCTEST_REQUIRE_THROWS_AS(expr, __VA_ARGS__)
#define REQUIRE_THROWS_WITH(expr, ...) DOCTEST_REQUIRE_THROWS_WITH(expr, __VA_ARGS__)
#define REQUIRE_THROWS_WITH_AS(expr, with, ...) DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, __VA_ARGS__)
#define REQUIRE_NOTHROW(...) DOCTEST_REQUIRE_NOTHROW(__VA_ARGS__)

#define WARN_MESSAGE(cond, ...) DOCTEST_WARN_MESSAGE(cond, __VA_ARGS__)
#define WARN_FALSE_MESSAGE(cond, ...) DOCTEST_WARN_FALSE_MESSAGE(cond, __VA_ARGS__)
#define WARN_THROWS_MESSAGE(expr, ...) DOCTEST_WARN_THROWS_MESSAGE(expr, __VA_ARGS__)
#define WARN_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, __VA_ARGS__)
#define WARN_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, __VA_ARGS__)
#define WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, __VA_ARGS__)
#define WARN_NOTHROW_MESSAGE(expr, ...) DOCTEST_WARN_NOTHROW_MESSAGE(expr, __VA_ARGS__)
#define CHECK_MESSAGE(cond, ...) DOCTEST_CHECK_MESSAGE(cond, __VA_ARGS__)
#define CHECK_FALSE_MESSAGE(cond, ...) DOCTEST_CHECK_FALSE_MESSAGE(cond, __VA_ARGS__)
#define CHECK_THROWS_MESSAGE(expr, ...) DOCTEST_CHECK_THROWS_MESSAGE(expr, __VA_ARGS__)
#define CHECK_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, __VA_ARGS__)
#define CHECK_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, __VA_ARGS__)
#define CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, __VA_ARGS__)
#define CHECK_NOTHROW_MESSAGE(expr, ...) DOCTEST_CHECK_NOTHROW_MESSAGE(expr, __VA_ARGS__)
#define REQUIRE_MESSAGE(cond, ...) DOCTEST_REQUIRE_MESSAGE(cond, __VA_ARGS__)
#define REQUIRE_FALSE_MESSAGE(cond, ...) DOCTEST_REQUIRE_FALSE_MESSAGE(cond, __VA_ARGS__)
#define REQUIRE_THROWS_MESSAGE(expr, ...) DOCTEST_REQUIRE_THROWS_MESSAGE(expr, __VA_ARGS__)
#define REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, __VA_ARGS__)
#define REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, __VA_ARGS__)
#define REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, __VA_ARGS__)
#define REQUIRE_NOTHROW_MESSAGE(expr, ...) DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, __VA_ARGS__)

#define SCENARIO(name) DOCTEST_SCENARIO(name)
#define SCENARIO_CLASS(name) DOCTEST_SCENARIO_CLASS(name)
#define SCENARIO_TEMPLATE(name, T, ...) DOCTEST_SCENARIO_TEMPLATE(name, T, __VA_ARGS__)
#define SCENARIO_TEMPLATE_DEFINE(name, T, id) DOCTEST_SCENARIO_TEMPLATE_DEFINE(name, T, id)
#define GIVEN(name) DOCTEST_GIVEN(name)
#define WHEN(name) DOCTEST_WHEN(name)
#define AND_WHEN(name) DOCTEST_AND_WHEN(name)
#define THEN(name) DOCTEST_THEN(name)
#define AND_THEN(name) DOCTEST_AND_THEN(name)

#define WARN_EQ(...) DOCTEST_WARN_EQ(__VA_ARGS__)
#define CHECK_EQ(...) DOCTEST_CHECK_EQ(__VA_ARGS__)
#define REQUIRE_EQ(...) DOCTEST_REQUIRE_EQ(__VA_ARGS__)
#define WARN_NE(...) DOCTEST_WARN_NE(__VA_ARGS__)
#define CHECK_NE(...) DOCTEST_CHECK_NE(__VA_ARGS__)
#define REQUIRE_NE(...) DOCTEST_REQUIRE_NE(__VA_ARGS__)
#define WARN_GT(...) DOCTEST_WARN_GT(__VA_ARGS__)
#define CHECK_GT(...) DOCTEST_CHECK_GT(__VA_ARGS__)
#define REQUIRE_GT(...) DOCTEST_REQUIRE_GT(__VA_ARGS__)
#define WARN_LT(...) DOCTEST_WARN_LT(__VA_ARGS__)
#define CHECK_LT(...) DOCTEST_CHECK_LT(__VA_ARGS__)
#define REQUIRE_LT(...) DOCTEST_REQUIRE_LT(__VA_ARGS__)
#define WARN_GE(...) DOCTEST_WARN_GE(__VA_ARGS__)
#define CHECK_GE(...) DOCTEST_CHECK_GE(__VA_ARGS__)
#define REQUIRE_GE(...) DOCTEST_REQUIRE_GE(__VA_ARGS__)
#define WARN_LE(...) DOCTEST_WARN_LE(__VA_ARGS__)
#define CHECK_LE(...) DOCTEST_CHECK_LE(__VA_ARGS__)
#define REQUIRE_LE(...) DOCTEST_REQUIRE_LE(__VA_ARGS__)
#define WARN_UNARY(...) DOCTEST_WARN_UNARY(__VA_ARGS__)
#define CHECK_UNARY(...) DOCTEST_CHECK_UNARY(__VA_ARGS__)
#define REQUIRE_UNARY(...) DOCTEST_REQUIRE_UNARY(__VA_ARGS__)
#define WARN_UNARY_FALSE(...) DOCTEST_WARN_UNARY_FALSE(__VA_ARGS__)
#define CHECK_UNARY_FALSE(...) DOCTEST_CHECK_UNARY_FALSE(__VA_ARGS__)
#define REQUIRE_UNARY_FALSE(...) DOCTEST_REQUIRE_UNARY_FALSE(__VA_ARGS__)

// KEPT FOR BACKWARDS COMPATIBILITY
#define FAST_WARN_EQ(...) DOCTEST_FAST_WARN_EQ(__VA_ARGS__)
#define FAST_CHECK_EQ(...) DOCTEST_FAST_CHECK_EQ(__VA_ARGS__)
#define FAST_REQUIRE_EQ(...) DOCTEST_FAST_REQUIRE_EQ(__VA_ARGS__)
#define FAST_WARN_NE(...) DOCTEST_FAST_WARN_NE(__VA_ARGS__)
#define FAST_CHECK_NE(...) DOCTEST_FAST_CHECK_NE(__VA_ARGS__)
#define FAST_REQUIRE_NE(...) DOCTEST_FAST_REQUIRE_NE(__VA_ARGS__)
#define FAST_WARN_GT(...) DOCTEST_FAST_WARN_GT(__VA_ARGS__)
#define FAST_CHECK_GT(...) DOCTEST_FAST_CHECK_GT(__VA_ARGS__)
#define FAST_REQUIRE_GT(...) DOCTEST_FAST_REQUIRE_GT(__VA_ARGS__)
#define FAST_WARN_LT(...) DOCTEST_FAST_WARN_LT(__VA_ARGS__)
#define FAST_CHECK_LT(...) DOCTEST_FAST_CHECK_LT(__VA_ARGS__)
#define FAST_REQUIRE_LT(...) DOCTEST_FAST_REQUIRE_LT(__VA_ARGS__)
#define FAST_WARN_GE(...) DOCTEST_FAST_WARN_GE(__VA_ARGS__)
#define FAST_CHECK_GE(...) DOCTEST_FAST_CHECK_GE(__VA_ARGS__)
#define FAST_REQUIRE_GE(...) DOCTEST_FAST_REQUIRE_GE(__VA_ARGS__)
#define FAST_WARN_LE(...) DOCTEST_FAST_WARN_LE(__VA_ARGS__)
#define FAST_CHECK_LE(...) DOCTEST_FAST_CHECK_LE(__VA_ARGS__)
#define FAST_REQUIRE_LE(...) DOCTEST_FAST_REQUIRE_LE(__VA_ARGS__)

#define FAST_WARN_UNARY(...) DOCTEST_FAST_WARN_UNARY(__VA_ARGS__)
#define FAST_CHECK_UNARY(...) DOCTEST_FAST_CHECK_UNARY(__VA_ARGS__)
#define FAST_REQUIRE_UNARY(...) DOCTEST_FAST_REQUIRE_UNARY(__VA_ARGS__)
#define FAST_WARN_UNARY_FALSE(...) DOCTEST_FAST_WARN_UNARY_FALSE(__VA_ARGS__)
#define FAST_CHECK_UNARY_FALSE(...) DOCTEST_FAST_CHECK_UNARY_FALSE(__VA_ARGS__)
#define FAST_REQUIRE_UNARY_FALSE(...) DOCTEST_FAST_REQUIRE_UNARY_FALSE(__VA_ARGS__)

#define TEST_CASE_TEMPLATE_INSTANTIATE(id, ...) DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE(id, __VA_ARGS__)

#endif // DOCTEST_CONFIG_NO_SHORT_MACRO_NAMES

#ifndef DOCTEST_CONFIG_DISABLE

// this is here to clear the 'current test suite' for the current translation unit - at the top
DOCTEST_TEST_SUITE_END();

#endif // DOCTEST_CONFIG_DISABLE

DOCTEST_CLANG_SUPPRESS_WARNING_POP
DOCTEST_MSVC_SUPPRESS_WARNING_POP
DOCTEST_GCC_SUPPRESS_WARNING_POP

DOCTEST_SUPPRESS_COMMON_WARNINGS_POP

#endif // DOCTEST_LIBRARY_INCLUDED

#ifndef DOCTEST_SINGLE_HEADER
#define DOCTEST_SINGLE_HEADER
#endif // DOCTEST_SINGLE_HEADER

#if defined(DOCTEST_CONFIG_IMPLEMENT) || !defined(DOCTEST_SINGLE_HEADER)

#ifndef DOCTEST_SINGLE_HEADER
#include "doctest_fwd.h"
#endif // DOCTEST_SINGLE_HEADER

DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wunused-macros")

#ifndef DOCTEST_LIBRARY_IMPLEMENTATION
#define DOCTEST_LIBRARY_IMPLEMENTATION

DOCTEST_CLANG_SUPPRESS_WARNING_POP

DOCTEST_SUPPRESS_COMMON_WARNINGS_PUSH

DOCTEST_CLANG_SUPPRESS_WARNING_PUSH
DOCTEST_CLANG_SUPPRESS_WARNING("-Wglobal-constructors")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wexit-time-destructors")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wsign-conversion")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wshorten-64-to-32")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-variable-declarations")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wswitch")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wswitch-enum")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wcovered-switch-default")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-noreturn")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wdisabled-macro-expansion")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-braces")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-field-initializers")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wunused-member-function")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wnonportable-system-include-path")

DOCTEST_GCC_SUPPRESS_WARNING_PUSH
DOCTEST_GCC_SUPPRESS_WARNING("-Wconversion")
DOCTEST_GCC_SUPPRESS_WARNING("-Wsign-conversion")
DOCTEST_GCC_SUPPRESS_WARNING("-Wmissing-field-initializers")
DOCTEST_GCC_SUPPRESS_WARNING("-Wmissing-braces")
DOCTEST_GCC_SUPPRESS_WARNING("-Wswitch")
DOCTEST_GCC_SUPPRESS_WARNING("-Wswitch-enum")
DOCTEST_GCC_SUPPRESS_WARNING("-Wswitch-default")
DOCTEST_GCC_SUPPRESS_WARNING("-Wunsafe-loop-optimizations")
DOCTEST_GCC_SUPPRESS_WARNING("-Wold-style-cast")
DOCTEST_GCC_SUPPRESS_WARNING("-Wunused-function")
DOCTEST_GCC_SUPPRESS_WARNING("-Wmultiple-inheritance")
DOCTEST_GCC_SUPPRESS_WARNING("-Wsuggest-attribute")

DOCTEST_MSVC_SUPPRESS_WARNING_PUSH
DOCTEST_MSVC_SUPPRESS_WARNING(4267) // 'var' : conversion from 'x' to 'y', possible loss of data
DOCTEST_MSVC_SUPPRESS_WARNING(4530) // C++ exception handler used, but unwind semantics not enabled
DOCTEST_MSVC_SUPPRESS_WARNING(4577) // 'noexcept' used with no exception handling mode specified
DOCTEST_MSVC_SUPPRESS_WARNING(4774) // format string expected in argument is not a string literal
DOCTEST_MSVC_SUPPRESS_WARNING(4365) // conversion from 'int' to 'unsigned', signed/unsigned mismatch
DOCTEST_MSVC_SUPPRESS_WARNING(5039) // pointer to potentially throwing function passed to extern C
DOCTEST_MSVC_SUPPRESS_WARNING(4800) // forcing value to bool 'true' or 'false' (performance warning)
DOCTEST_MSVC_SUPPRESS_WARNING(5245) // unreferenced function with internal linkage has been removed

DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_BEGIN

// required includes - will go only in one translation unit!
#include <ctime>
#include <cmath>
#include <climits>
// borland (Embarcadero) compiler requires math.h and not cmath - https://github.com/doctest/doctest/pull/37
#ifdef __BORLANDC__
#include <math.h>
#endif // __BORLANDC__
#include <new>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <limits>
#include <utility>
#include <fstream>
#include <sstream>
#ifndef DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
#include <iostream>
#endif // DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
#include <algorithm>
#include <iomanip>
#include <vector>
#ifndef DOCTEST_CONFIG_NO_MULTITHREADING
#include <atomic>
#include <mutex>
#define DOCTEST_DECLARE_MUTEX(name) std::mutex name;
#define DOCTEST_DECLARE_STATIC_MUTEX(name) static DOCTEST_DECLARE_MUTEX(name)
#define DOCTEST_LOCK_MUTEX(name) std::lock_guard<std::mutex> DOCTEST_ANONYMOUS(DOCTEST_ANON_LOCK_)(name);
#else // DOCTEST_CONFIG_NO_MULTITHREADING
#define DOCTEST_DECLARE_MUTEX(name)
#define DOCTEST_DECLARE_STATIC_MUTEX(name)
#define DOCTEST_LOCK_MUTEX(name)
#endif // DOCTEST_CONFIG_NO_MULTITHREADING
#include <set>
#include <map>
#include <unordered_set>
#include <exception>
#include <stdexcept>
#include <csignal>
#include <cfloat>
#include <cctype>
#include <cstdint>
#include <string>

#ifdef DOCTEST_PLATFORM_MAC
#include <sys/types.h>
#include <unistd.h>
#include <sys/sysctl.h>
#endif // DOCTEST_PLATFORM_MAC

#ifdef DOCTEST_PLATFORM_WINDOWS

// defines for a leaner windows.h
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#define DOCTEST_UNDEF_WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN
#ifndef NOMINMAX
#define NOMINMAX
#define DOCTEST_UNDEF_NOMINMAX
#endif // NOMINMAX

// not sure what AfxWin.h is for - here I do what Catch does
#ifdef __AFXDLL
#include <AfxWin.h>
#else
#include <windows.h>
#endif
#include <io.h>

#else // DOCTEST_PLATFORM_WINDOWS

#include <sys/time.h>
#include <unistd.h>

#endif // DOCTEST_PLATFORM_WINDOWS

// this is a fix for https://github.com/doctest/doctest/issues/348
// https://mail.gnome.org/archives/xml/2012-January/msg00000.html
#if !defined(HAVE_UNISTD_H) && !defined(STDOUT_FILENO)
#define STDOUT_FILENO fileno(stdout)
#endif // HAVE_UNISTD_H

DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_END

// counts the number of elements in a C array
#define DOCTEST_COUNTOF(x) (sizeof(x) / sizeof(x[0]))

#ifdef DOCTEST_CONFIG_DISABLE
#define DOCTEST_BRANCH_ON_DISABLED(if_disabled, if_not_disabled) if_disabled
#else // DOCTEST_CONFIG_DISABLE
#define DOCTEST_BRANCH_ON_DISABLED(if_disabled, if_not_disabled) if_not_disabled
#endif // DOCTEST_CONFIG_DISABLE

#ifndef DOCTEST_CONFIG_OPTIONS_PREFIX
#define DOCTEST_CONFIG_OPTIONS_PREFIX "dt-"
#endif

#ifndef DOCTEST_THREAD_LOCAL
#if defined(DOCTEST_CONFIG_NO_MULTITHREADING) || DOCTEST_MSVC && (DOCTEST_MSVC < DOCTEST_COMPILER(19, 0, 0))
#define DOCTEST_THREAD_LOCAL
#else // DOCTEST_MSVC
#define DOCTEST_THREAD_LOCAL thread_local
#endif // DOCTEST_MSVC
#endif // DOCTEST_THREAD_LOCAL

#ifndef DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES
#define DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES 32
#endif

#ifndef DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE
#define DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE 64
#endif

#ifdef DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS
#define DOCTEST_OPTIONS_PREFIX_DISPLAY DOCTEST_CONFIG_OPTIONS_PREFIX
#else
#define DOCTEST_OPTIONS_PREFIX_DISPLAY ""
#endif

#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
#define DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS
#endif

#ifndef DOCTEST_CDECL
#define DOCTEST_CDECL __cdecl
#endif

namespace doctest {

bool is_running_in_test = false;

namespace {
    using namespace detail;

    template <typename Ex>
    DOCTEST_NORETURN void throw_exception(Ex const& e) {
#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
        throw e;
#else  // DOCTEST_CONFIG_NO_EXCEPTIONS
#ifdef DOCTEST_CONFIG_HANDLE_EXCEPTION
        DOCTEST_CONFIG_HANDLE_EXCEPTION(e);
#else // DOCTEST_CONFIG_HANDLE_EXCEPTION
#ifndef DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
        std::cerr << "doctest will terminate because it needed to throw an exception.\n"
                  << "The message was: " << e.what() << '\n';
#endif // DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
#endif // DOCTEST_CONFIG_HANDLE_EXCEPTION
        std::terminate();
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS
    }

#ifndef DOCTEST_INTERNAL_ERROR
#define DOCTEST_INTERNAL_ERROR(msg)                                                                \
    throw_exception(std::logic_error(                                                              \
            __FILE__ ":" DOCTEST_TOSTR(__LINE__) ": Internal doctest error: " msg))
#endif // DOCTEST_INTERNAL_ERROR

    // case insensitive strcmp
    int stricmp(const char* a, const char* b) {
        for(;; a++, b++) {
            const int d = tolower(*a) - tolower(*b);
            if(d != 0 || !*a)
                return d;
        }
    }

    struct Endianness
    {
        enum Arch
        {
            Big,
            Little
        };

        static Arch which() {
            int x = 1;
            // casting any data pointer to char* is allowed
            auto ptr = reinterpret_cast<char*>(&x);
            if(*ptr)
                return Little;
            return Big;
        }
    };
} // namespace

namespace detail {
    DOCTEST_THREAD_LOCAL class
    {
        std::vector<std::streampos> stack;
        std::stringstream           ss;

    public:
        std::ostream* push() {
            stack.push_back(ss.tellp());
            return &ss;
        }

        String pop() {
            if (stack.empty())
                DOCTEST_INTERNAL_ERROR("TLSS was empty when trying to pop!");

            std::streampos pos = stack.back();
            stack.pop_back();
            unsigned sz = static_cast<unsigned>(ss.tellp() - pos);
            ss.rdbuf()->pubseekpos(pos, std::ios::in | std::ios::out);
            return String(ss, sz);
        }
    } g_oss;

    std::ostream* tlssPush() {
        return g_oss.push();
    }

    String tlssPop() {
        return g_oss.pop();
    }

#ifndef DOCTEST_CONFIG_DISABLE

namespace timer_large_integer
{

#if defined(DOCTEST_PLATFORM_WINDOWS)
    using type = ULONGLONG;
#else // DOCTEST_PLATFORM_WINDOWS
    using type = std::uint64_t;
#endif // DOCTEST_PLATFORM_WINDOWS
}

using ticks_t = timer_large_integer::type;

#ifdef DOCTEST_CONFIG_GETCURRENTTICKS
    ticks_t getCurrentTicks() { return DOCTEST_CONFIG_GETCURRENTTICKS(); }
#elif defined(DOCTEST_PLATFORM_WINDOWS)
    ticks_t getCurrentTicks() {
        static LARGE_INTEGER hz = { {0} }, hzo = { {0} };
        if(!hz.QuadPart) {
            QueryPerformanceFrequency(&hz);
            QueryPerformanceCounter(&hzo);
        }
        LARGE_INTEGER t;
        QueryPerformanceCounter(&t);
        return ((t.QuadPart - hzo.QuadPart) * LONGLONG(1000000)) / hz.QuadPart;
    }
#else  // DOCTEST_PLATFORM_WINDOWS
    ticks_t getCurrentTicks() {
        timeval t;
        gettimeofday(&t, nullptr);
        return static_cast<ticks_t>(t.tv_sec) * 1000000 + static_cast<ticks_t>(t.tv_usec);
    }
#endif // DOCTEST_PLATFORM_WINDOWS

    struct Timer
    {
        void         start() { m_ticks = getCurrentTicks(); }
        unsigned int getElapsedMicroseconds() const {
            return static_cast<unsigned int>(getCurrentTicks() - m_ticks);
        }
        //unsigned int getElapsedMilliseconds() const {
        //    return static_cast<unsigned int>(getElapsedMicroseconds() / 1000);
        //}
        double getElapsedSeconds() const { return static_cast<double>(getCurrentTicks() - m_ticks) / 1000000.0; }

    private:
        ticks_t m_ticks = 0;
    };

#ifdef DOCTEST_CONFIG_NO_MULTITHREADING
    template <typename T>
    using Atomic = T;
#else // DOCTEST_CONFIG_NO_MULTITHREADING
    template <typename T>
    using Atomic = std::atomic<T>;
#endif // DOCTEST_CONFIG_NO_MULTITHREADING

#if defined(DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS) || defined(DOCTEST_CONFIG_NO_MULTITHREADING)
    template <typename T>
    using MultiLaneAtomic = Atomic<T>;
#else // DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS
    // Provides a multilane implementation of an atomic variable that supports add, sub, load,
    // store. Instead of using a single atomic variable, this splits up into multiple ones,
    // each sitting on a separate cache line. The goal is to provide a speedup when most
    // operations are modifying. It achieves this with two properties:
    //
    // * Multiple atomics are used, so chance of congestion from the same atomic is reduced.
    // * Each atomic sits on a separate cache line, so false sharing is reduced.
    //
    // The disadvantage is that there is a small overhead due to the use of TLS, and load/store
    // is slower because all atomics have to be accessed.
    template <typename T>
    class MultiLaneAtomic
    {
        struct CacheLineAlignedAtomic
        {
            Atomic<T> atomic{};
            char padding[DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE - sizeof(Atomic<T>)];
        };
        CacheLineAlignedAtomic m_atomics[DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES];

        static_assert(sizeof(CacheLineAlignedAtomic) == DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE,
                      "guarantee one atomic takes exactly one cache line");

    public:
        T operator++() DOCTEST_NOEXCEPT { return fetch_add(1) + 1; }

        T operator++(int) DOCTEST_NOEXCEPT { return fetch_add(1); }

        T fetch_add(T arg, std::memory_order order = std::memory_order_seq_cst) DOCTEST_NOEXCEPT {
            return myAtomic().fetch_add(arg, order);
        }

        T fetch_sub(T arg, std::memory_order order = std::memory_order_seq_cst) DOCTEST_NOEXCEPT {
            return myAtomic().fetch_sub(arg, order);
        }

        operator T() const DOCTEST_NOEXCEPT { return load(); }

        T load(std::memory_order order = std::memory_order_seq_cst) const DOCTEST_NOEXCEPT {
            auto result = T();
            for(auto const& c : m_atomics) {
                result += c.atomic.load(order);
            }
            return result;
        }

        T operator=(T desired) DOCTEST_NOEXCEPT { // lgtm [cpp/assignment-does-not-return-this]
            store(desired);
            return desired;
        }

        void store(T desired, std::memory_order order = std::memory_order_seq_cst) DOCTEST_NOEXCEPT {
            // first value becomes desired", all others become 0.
            for(auto& c : m_atomics) {
                c.atomic.store(desired, order);
                desired = {};
            }
        }

    private:
        // Each thread has a different atomic that it operates on. If more than NumLanes threads
        // use this, some will use the same atomic. So performance will degrade a bit, but still
        // everything will work.
        //
        // The logic here is a bit tricky. The call should be as fast as possible, so that there
        // is minimal to no overhead in determining the correct atomic for the current thread.
        //
        // 1. A global static counter laneCounter counts continuously up.
        // 2. Each successive thread will use modulo operation of that counter so it gets an atomic
        //    assigned in a round-robin fashion.
        // 3. This tlsLaneIdx is stored in the thread local data, so it is directly available with
        //    little overhead.
        Atomic<T>& myAtomic() DOCTEST_NOEXCEPT {
            static Atomic<size_t> laneCounter;
            DOCTEST_THREAD_LOCAL size_t tlsLaneIdx =
                    laneCounter++ % DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES;

            return m_atomics[tlsLaneIdx].atomic;
        }
    };
#endif // DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS

    // this holds both parameters from the command line and runtime data for tests
    struct ContextState : ContextOptions, TestRunStats, CurrentTestCaseStats
    {
        MultiLaneAtomic<int> numAssertsCurrentTest_atomic;
        MultiLaneAtomic<int> numAssertsFailedCurrentTest_atomic;

        std::vector<std::vector<String>> filters = decltype(filters)(9); // 9 different filters

        std::vector<IReporter*> reporters_currently_used;

        assert_handler ah = nullptr;

        Timer timer;

        std::vector<String> stringifiedContexts; // logging from INFO() due to an exception

        // stuff for subcases
        bool reachedLeaf;
        std::vector<SubcaseSignature> subcaseStack;
        std::vector<SubcaseSignature> nextSubcaseStack;
        std::unordered_set<unsigned long long> fullyTraversedSubcases;
        size_t currentSubcaseDepth;
        Atomic<bool> shouldLogCurrentException;

        void resetRunData() {
            numTestCases                = 0;
            numTestCasesPassingFilters  = 0;
            numTestSuitesPassingFilters = 0;
            numTestCasesFailed          = 0;
            numAsserts                  = 0;
            numAssertsFailed            = 0;
            numAssertsCurrentTest       = 0;
            numAssertsFailedCurrentTest = 0;
        }

        void finalizeTestCaseData() {
            seconds = timer.getElapsedSeconds();

            // update the non-atomic counters
            numAsserts += numAssertsCurrentTest_atomic;
            numAssertsFailed += numAssertsFailedCurrentTest_atomic;
            numAssertsCurrentTest       = numAssertsCurrentTest_atomic;
            numAssertsFailedCurrentTest = numAssertsFailedCurrentTest_atomic;

            if(numAssertsFailedCurrentTest)
                failure_flags |= TestCaseFailureReason::AssertFailure;

            if(Approx(currentTest->m_timeout).epsilon(DBL_EPSILON) != 0 &&
               Approx(seconds).epsilon(DBL_EPSILON) > currentTest->m_timeout)
                failure_flags |= TestCaseFailureReason::Timeout;

            if(currentTest->m_should_fail) {
                if(failure_flags) {
                    failure_flags |= TestCaseFailureReason::ShouldHaveFailedAndDid;
                } else {
                    failure_flags |= TestCaseFailureReason::ShouldHaveFailedButDidnt;
                }
            } else if(failure_flags && currentTest->m_may_fail) {
                failure_flags |= TestCaseFailureReason::CouldHaveFailedAndDid;
            } else if(currentTest->m_expected_failures > 0) {
                if(numAssertsFailedCurrentTest == currentTest->m_expected_failures) {
                    failure_flags |= TestCaseFailureReason::FailedExactlyNumTimes;
                } else {
                    failure_flags |= TestCaseFailureReason::DidntFailExactlyNumTimes;
                }
            }

            bool ok_to_fail = (TestCaseFailureReason::ShouldHaveFailedAndDid & failure_flags) ||
                              (TestCaseFailureReason::CouldHaveFailedAndDid & failure_flags) ||
                              (TestCaseFailureReason::FailedExactlyNumTimes & failure_flags);

            // if any subcase has failed - the whole test case has failed
            testCaseSuccess = !(failure_flags && !ok_to_fail);
            if(!testCaseSuccess)
                numTestCasesFailed++;
        }
    };

    ContextState* g_cs = nullptr;

    // used to avoid locks for the debug output
    // TODO: figure out if this is indeed necessary/correct - seems like either there still
    // could be a race or that there wouldn't be a race even if using the context directly
    DOCTEST_THREAD_LOCAL bool g_no_colors;

#endif // DOCTEST_CONFIG_DISABLE
} // namespace detail

char* String::allocate(size_type sz) {
    if (sz <= last) {
        buf[sz] = '\0';
        setLast(last - sz);
        return buf;
    } else {
        setOnHeap();
        data.size = sz;
        data.capacity = data.size + 1;
        data.ptr = new char[data.capacity];
        data.ptr[sz] = '\0';
        return data.ptr;
    }
}

void String::setOnHeap() noexcept { *reinterpret_cast<unsigned char*>(&buf[last]) = 128; }
void String::setLast(size_type in) noexcept { buf[last] = char(in); }
void String::setSize(size_type sz) noexcept {
    if (isOnStack()) { buf[sz] = '\0'; setLast(last - sz); }
    else { data.ptr[sz] = '\0'; data.size = sz; }
}

void String::copy(const String& other) {
    if(other.isOnStack()) {
        memcpy(buf, other.buf, len);
    } else {
        memcpy(allocate(other.data.size), other.data.ptr, other.data.size);
    }
}

String::String() noexcept {
    buf[0] = '\0';
    setLast();
}

String::~String() {
    if(!isOnStack())
        delete[] data.ptr;
} // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks)

String::String(const char* in)
        : String(in, strlen(in)) {}

String::String(const char* in, size_type in_size) {
    memcpy(allocate(in_size), in, in_size);
}

String::String(std::istream& in, size_type in_size) {
    in.read(allocate(in_size), in_size);
}

String::String(const String& other) { copy(other); }

String& String::operator=(const String& other) {
    if(this != &other) {
        if(!isOnStack())
            delete[] data.ptr;

        copy(other);
    }

    return *this;
}

String& String::operator+=(const String& other) {
    const size_type my_old_size = size();
    const size_type other_size  = other.size();
    const size_type total_size  = my_old_size + other_size;
    if(isOnStack()) {
        if(total_size < len) {
            // append to the current stack space
            memcpy(buf + my_old_size, other.c_str(), other_size + 1);
            // NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)
            setLast(last - total_size);
        } else {
            // alloc new chunk
            char* temp = new char[total_size + 1];
            // copy current data to new location before writing in the union
            memcpy(temp, buf, my_old_size); // skip the +1 ('\0') for speed
            // update data in union
            setOnHeap();
            data.size     = total_size;
            data.capacity = data.size + 1;
            data.ptr      = temp;
            // transfer the rest of the data
            memcpy(data.ptr + my_old_size, other.c_str(), other_size + 1);
        }
    } else {
        if(data.capacity > total_size) {
            // append to the current heap block
            data.size = total_size;
            memcpy(data.ptr + my_old_size, other.c_str(), other_size + 1);
        } else {
            // resize
            data.capacity *= 2;
            if(data.capacity <= total_size)
                data.capacity = total_size + 1;
            // alloc new chunk
            char* temp = new char[data.capacity];
            // copy current data to new location before releasing it
            memcpy(temp, data.ptr, my_old_size); // skip the +1 ('\0') for speed
            // release old chunk
            delete[] data.ptr;
            // update the rest of the union members
            data.size = total_size;
            data.ptr  = temp;
            // transfer the rest of the data
            memcpy(data.ptr + my_old_size, other.c_str(), other_size + 1);
        }
    }

    return *this;
}

String::String(String&& other) noexcept {
    memcpy(buf, other.buf, len);
    other.buf[0] = '\0';
    other.setLast();
}

String& String::operator=(String&& other) noexcept {
    if(this != &other) {
        if(!isOnStack())
            delete[] data.ptr;
        memcpy(buf, other.buf, len);
        other.buf[0] = '\0';
        other.setLast();
    }
    return *this;
}

char String::operator[](size_type i) const {
    return const_cast<String*>(this)->operator[](i);
}

char& String::operator[](size_type i) {
    if(isOnStack())
        return reinterpret_cast<char*>(buf)[i];
    return data.ptr[i];
}

DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wmaybe-uninitialized")
String::size_type String::size() const {
    if(isOnStack())
        return last - (size_type(buf[last]) & 31); // using "last" would work only if "len" is 32
    return data.size;
}
DOCTEST_GCC_SUPPRESS_WARNING_POP

String::size_type String::capacity() const {
    if(isOnStack())
        return len;
    return data.capacity;
}

String String::substr(size_type pos, size_type cnt) && {
    cnt = std::min(cnt, size() - 1 - pos);
    char* cptr = c_str();
    memmove(cptr, cptr + pos, cnt);
    setSize(cnt);
    return std::move(*this);
}

String String::substr(size_type pos, size_type cnt) const & {
    cnt = std::min(cnt, size() - 1 - pos);
    return String{ c_str() + pos, cnt };
}

String::size_type String::find(char ch, size_type pos) const {
    const char* begin = c_str();
    const char* end = begin + size();
    const char* it = begin + pos;
    for (; it < end && *it != ch; it++);
    if (it < end) { return static_cast<size_type>(it - begin); }
    else { return npos; }
}

String::size_type String::rfind(char ch, size_type pos) const {
    const char* begin = c_str();
    const char* it = begin + std::min(pos, size() - 1);
    for (; it >= begin && *it != ch; it--);
    if (it >= begin) { return static_cast<size_type>(it - begin); }
    else { return npos; }
}

int String::compare(const char* other, bool no_case) const {
    if(no_case)
        return doctest::stricmp(c_str(), other);
    return std::strcmp(c_str(), other);
}

int String::compare(const String& other, bool no_case) const {
    return compare(other.c_str(), no_case);
}

String operator+(const String& lhs, const String& rhs) { return  String(lhs) += rhs; }

bool operator==(const String& lhs, const String& rhs) { return lhs.compare(rhs) == 0; }
bool operator!=(const String& lhs, const String& rhs) { return lhs.compare(rhs) != 0; }
bool operator< (const String& lhs, const String& rhs) { return lhs.compare(rhs) < 0; }
bool operator> (const String& lhs, const String& rhs) { return lhs.compare(rhs) > 0; }
bool operator<=(const String& lhs, const String& rhs) { return (lhs != rhs) ? lhs.compare(rhs) < 0 : true; }
bool operator>=(const String& lhs, const String& rhs) { return (lhs != rhs) ? lhs.compare(rhs) > 0 : true; }

std::ostream& operator<<(std::ostream& s, const String& in) { return s << in.c_str(); }

Contains::Contains(const String& str) : string(str) { }

bool Contains::checkWith(const String& other) const {
    return strstr(other.c_str(), string.c_str()) != nullptr;
}

String toString(const Contains& in) {
    return "Contains( " + in.string + " )";
}

bool operator==(const String& lhs, const Contains& rhs) { return rhs.checkWith(lhs); }
bool operator==(const Contains& lhs, const String& rhs) { return lhs.checkWith(rhs); }
bool operator!=(const String& lhs, const Contains& rhs) { return !rhs.checkWith(lhs); }
bool operator!=(const Contains& lhs, const String& rhs) { return !lhs.checkWith(rhs); }

namespace {
    void color_to_stream(std::ostream&, Color::Enum) DOCTEST_BRANCH_ON_DISABLED({}, ;)
} // namespace

namespace Color {
    std::ostream& operator<<(std::ostream& s, Color::Enum code) {
        color_to_stream(s, code);
        return s;
    }
} // namespace Color

// clang-format off
const char* assertString(assertType::Enum at) {
    DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4061) // enum 'x' in switch of enum 'y' is not explicitly handled
    #define DOCTEST_GENERATE_ASSERT_TYPE_CASE(assert_type) case assertType::DT_ ## assert_type: return #assert_type
    #define DOCTEST_GENERATE_ASSERT_TYPE_CASES(assert_type) \
        DOCTEST_GENERATE_ASSERT_TYPE_CASE(WARN_ ## assert_type); \
        DOCTEST_GENERATE_ASSERT_TYPE_CASE(CHECK_ ## assert_type); \
        DOCTEST_GENERATE_ASSERT_TYPE_CASE(REQUIRE_ ## assert_type)
    switch(at) {
        DOCTEST_GENERATE_ASSERT_TYPE_CASE(WARN);
        DOCTEST_GENERATE_ASSERT_TYPE_CASE(CHECK);
        DOCTEST_GENERATE_ASSERT_TYPE_CASE(REQUIRE);

        DOCTEST_GENERATE_ASSERT_TYPE_CASES(FALSE);

        DOCTEST_GENERATE_ASSERT_TYPE_CASES(THROWS);

        DOCTEST_GENERATE_ASSERT_TYPE_CASES(THROWS_AS);

        DOCTEST_GENERATE_ASSERT_TYPE_CASES(THROWS_WITH);

        DOCTEST_GENERATE_ASSERT_TYPE_CASES(THROWS_WITH_AS);

        DOCTEST_GENERATE_ASSERT_TYPE_CASES(NOTHROW);

        DOCTEST_GENERATE_ASSERT_TYPE_CASES(EQ);
        DOCTEST_GENERATE_ASSERT_TYPE_CASES(NE);
        DOCTEST_GENERATE_ASSERT_TYPE_CASES(GT);
        DOCTEST_GENERATE_ASSERT_TYPE_CASES(LT);
        DOCTEST_GENERATE_ASSERT_TYPE_CASES(GE);
        DOCTEST_GENERATE_ASSERT_TYPE_CASES(LE);

        DOCTEST_GENERATE_ASSERT_TYPE_CASES(UNARY);
        DOCTEST_GENERATE_ASSERT_TYPE_CASES(UNARY_FALSE);

        default: DOCTEST_INTERNAL_ERROR("Tried stringifying invalid assert type!");
    }
    DOCTEST_MSVC_SUPPRESS_WARNING_POP
}
// clang-format on

const char* failureString(assertType::Enum at) {
    if(at & assertType::is_warn) //!OCLINT bitwise operator in conditional
        return "WARNING";
    if(at & assertType::is_check) //!OCLINT bitwise operator in conditional
        return "ERROR";
    if(at & assertType::is_require) //!OCLINT bitwise operator in conditional
        return "FATAL ERROR";
    return "";
}

DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wnull-dereference")
DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wnull-dereference")
// depending on the current options this will remove the path of filenames
const char* skipPathFromFilename(const char* file) {
#ifndef DOCTEST_CONFIG_DISABLE
    if(getContextOptions()->no_path_in_filenames) {
        auto back    = std::strrchr(file, '\\');
        auto forward = std::strrchr(file, '/');
        if(back || forward) {
            if(back > forward)
                forward = back;
            return forward + 1;
        }
    }
#endif // DOCTEST_CONFIG_DISABLE
    return file;
}
DOCTEST_CLANG_SUPPRESS_WARNING_POP
DOCTEST_GCC_SUPPRESS_WARNING_POP

bool SubcaseSignature::operator==(const SubcaseSignature& other) const {
    return m_line == other.m_line
        && std::strcmp(m_file, other.m_file) == 0
        && m_name == other.m_name;
}

bool SubcaseSignature::operator<(const SubcaseSignature& other) const {
    if(m_line != other.m_line)
        return m_line < other.m_line;
    if(std::strcmp(m_file, other.m_file) != 0)
        return std::strcmp(m_file, other.m_file) < 0;
    return m_name.compare(other.m_name) < 0;
}

DOCTEST_DEFINE_INTERFACE(IContextScope)

namespace detail {
    void filldata<const void*>::fill(std::ostream* stream, const void* in) {
        if (in) { *stream << in; }
        else { *stream << "nullptr"; }
    }

    template <typename T>
    String toStreamLit(T t) {
        std::ostream* os = tlssPush();
        os->operator<<(t);
        return tlssPop();
    }
}

#ifdef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
String toString(const char* in) { return String("\"") + (in ? in : "{null string}") + "\""; }
#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING

#if DOCTEST_MSVC >= DOCTEST_COMPILER(19, 20, 0)
// see this issue on why this is needed: https://github.com/doctest/doctest/issues/183
String toString(const std::string& in) { return in.c_str(); }
#endif // VS 2019

String toString(String in) { return in; }

String toString(std::nullptr_t) { return "nullptr"; }

String toString(bool in) { return in ? "true" : "false"; }

String toString(float in) { return toStreamLit(in); }
String toString(double in) { return toStreamLit(in); }
String toString(double long in) { return toStreamLit(in); }

String toString(char in) { return toStreamLit(static_cast<signed>(in)); }
String toString(char signed in) { return toStreamLit(static_cast<signed>(in)); }
String toString(char unsigned in) { return toStreamLit(static_cast<unsigned>(in)); }
String toString(short in) { return toStreamLit(in); }
String toString(short unsigned in) { return toStreamLit(in); }
String toString(signed in) { return toStreamLit(in); }
String toString(unsigned in) { return toStreamLit(in); }
String toString(long in) { return toStreamLit(in); }
String toString(long unsigned in) { return toStreamLit(in); }
String toString(long long in) { return toStreamLit(in); }
String toString(long long unsigned in) { return toStreamLit(in); }

Approx::Approx(double value)
        : m_epsilon(static_cast<double>(std::numeric_limits<float>::epsilon()) * 100)
        , m_scale(1.0)
        , m_value(value) {}

Approx Approx::operator()(double value) const {
    Approx approx(value);
    approx.epsilon(m_epsilon);
    approx.scale(m_scale);
    return approx;
}

Approx& Approx::epsilon(double newEpsilon) {
    m_epsilon = newEpsilon;
    return *this;
}
Approx& Approx::scale(double newScale) {
    m_scale = newScale;
    return *this;
}

bool operator==(double lhs, const Approx& rhs) {
    // Thanks to Richard Harris for his help refining this formula
    return std::fabs(lhs - rhs.m_value) <
           rhs.m_epsilon * (rhs.m_scale + std::max<double>(std::fabs(lhs), std::fabs(rhs.m_value)));
}
bool operator==(const Approx& lhs, double rhs) { return operator==(rhs, lhs); }
bool operator!=(double lhs, const Approx& rhs) { return !operator==(lhs, rhs); }
bool operator!=(const Approx& lhs, double rhs) { return !operator==(rhs, lhs); }
bool operator<=(double lhs, const Approx& rhs) { return lhs < rhs.m_value || lhs == rhs; }
bool operator<=(const Approx& lhs, double rhs) { return lhs.m_value < rhs || lhs == rhs; }
bool operator>=(double lhs, const Approx& rhs) { return lhs > rhs.m_value || lhs == rhs; }
bool operator>=(const Approx& lhs, double rhs) { return lhs.m_value > rhs || lhs == rhs; }
bool operator<(double lhs, const Approx& rhs) { return lhs < rhs.m_value && lhs != rhs; }
bool operator<(const Approx& lhs, double rhs) { return lhs.m_value < rhs && lhs != rhs; }
bool operator>(double lhs, const Approx& rhs) { return lhs > rhs.m_value && lhs != rhs; }
bool operator>(const Approx& lhs, double rhs) { return lhs.m_value > rhs && lhs != rhs; }

String toString(const Approx& in) {
    return "Approx( " + doctest::toString(in.m_value) + " )";
}
const ContextOptions* getContextOptions() { return DOCTEST_BRANCH_ON_DISABLED(nullptr, g_cs); }

DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4738)
template <typename F>
IsNaN<F>::operator bool() const {
    return std::isnan(value) ^ flipped;
}
DOCTEST_MSVC_SUPPRESS_WARNING_POP
template struct DOCTEST_INTERFACE_DEF IsNaN<float>;
template struct DOCTEST_INTERFACE_DEF IsNaN<double>;
template struct DOCTEST_INTERFACE_DEF IsNaN<long double>;
template <typename F>
String toString(IsNaN<F> in) { return String(in.flipped ? "! " : "") + "IsNaN( " + doctest::toString(in.value) + " )"; }
String toString(IsNaN<float> in) { return toString<float>(in); }
String toString(IsNaN<double> in) { return toString<double>(in); }
String toString(IsNaN<double long> in) { return toString<double long>(in); }

} // namespace doctest

#ifdef DOCTEST_CONFIG_DISABLE
namespace doctest {
Context::Context(int, const char* const*) {}
Context::~Context() = default;
void Context::applyCommandLine(int, const char* const*) {}
void Context::addFilter(const char*, const char*) {}
void Context::clearFilters() {}
void Context::setOption(const char*, bool) {}
void Context::setOption(const char*, int) {}
void Context::setOption(const char*, const char*) {}
bool Context::shouldExit() { return false; }
void Context::setAsDefaultForAssertsOutOfTestCases() {}
void Context::setAssertHandler(detail::assert_handler) {}
void Context::setCout(std::ostream*) {}
int  Context::run() { return 0; }

int                         IReporter::get_num_active_contexts() { return 0; }
const IContextScope* const* IReporter::get_active_contexts() { return nullptr; }
int                         IReporter::get_num_stringified_contexts() { return 0; }
const String*               IReporter::get_stringified_contexts() { return nullptr; }

int registerReporter(const char*, int, IReporter*) { return 0; }

} // namespace doctest
#else // DOCTEST_CONFIG_DISABLE

#if !defined(DOCTEST_CONFIG_COLORS_NONE)
#if !defined(DOCTEST_CONFIG_COLORS_WINDOWS) && !defined(DOCTEST_CONFIG_COLORS_ANSI)
#ifdef DOCTEST_PLATFORM_WINDOWS
#define DOCTEST_CONFIG_COLORS_WINDOWS
#else // linux
#define DOCTEST_CONFIG_COLORS_ANSI
#endif // platform
#endif // DOCTEST_CONFIG_COLORS_WINDOWS && DOCTEST_CONFIG_COLORS_ANSI
#endif // DOCTEST_CONFIG_COLORS_NONE

namespace doctest_detail_test_suite_ns {
// holds the current test suite
doctest::detail::TestSuite& getCurrentTestSuite() {
    static doctest::detail::TestSuite data{};
    return data;
}
} // namespace doctest_detail_test_suite_ns

namespace doctest {
namespace {
    // the int (priority) is part of the key for automatic sorting - sadly one can register a
    // reporter with a duplicate name and a different priority but hopefully that won't happen often :|
    using reporterMap = std::map<std::pair<int, String>, reporterCreatorFunc>;

    reporterMap& getReporters() {
        static reporterMap data;
        return data;
    }
    reporterMap& getListeners() {
        static reporterMap data;
        return data;
    }
} // namespace
namespace detail {
#define DOCTEST_ITERATE_THROUGH_REPORTERS(function, ...)                                           \
    for(auto& curr_rep : g_cs->reporters_currently_used)                                           \
    curr_rep->function(__VA_ARGS__)

    bool checkIfShouldThrow(assertType::Enum at) {
        if(at & assertType::is_require) //!OCLINT bitwise operator in conditional
            return true;

        if((at & assertType::is_check) //!OCLINT bitwise operator in conditional
           && getContextOptions()->abort_after > 0 &&
           (g_cs->numAssertsFailed + g_cs->numAssertsFailedCurrentTest_atomic) >=
                   getContextOptions()->abort_after)
            return true;

        return false;
    }

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
    DOCTEST_NORETURN void throwException() {
        g_cs->shouldLogCurrentException = false;
        throw TestFailureException(); // NOLINT(hicpp-exception-baseclass)
    }
#else // DOCTEST_CONFIG_NO_EXCEPTIONS
    void throwException() {}
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS
} // namespace detail

namespace {
    using namespace detail;
    // matching of a string against a wildcard mask (case sensitivity configurable) taken from
    // https://www.codeproject.com/Articles/1088/Wildcard-string-compare-globbing
    int wildcmp(const char* str, const char* wild, bool caseSensitive) {
        const char* cp = str;
        const char* mp = wild;

        while((*str) && (*wild != '*')) {
            if((caseSensitive ? (*wild != *str) : (tolower(*wild) != tolower(*str))) &&
               (*wild != '?')) {
                return 0;
            }
            wild++;
            str++;
        }

        while(*str) {
            if(*wild == '*') {
                if(!*++wild) {
                    return 1;
                }
                mp = wild;
                cp = str + 1;
            } else if((caseSensitive ? (*wild == *str) : (tolower(*wild) == tolower(*str))) ||
                      (*wild == '?')) {
                wild++;
                str++;
            } else {
                wild = mp;   //!OCLINT parameter reassignment
                str  = cp++; //!OCLINT parameter reassignment
            }
        }

        while(*wild == '*') {
            wild++;
        }
        return !*wild;
    }

    // checks if the name matches any of the filters (and can be configured what to do when empty)
    bool matchesAny(const char* name, const std::vector<String>& filters, bool matchEmpty,
        bool caseSensitive) {
        if (filters.empty() && matchEmpty)
            return true;
        for (auto& curr : filters)
            if (wildcmp(name, curr.c_str(), caseSensitive))
                return true;
        return false;
    }

    DOCTEST_NO_SANITIZE_INTEGER
    unsigned long long hash(unsigned long long a, unsigned long long b) {
        return (a << 5) + b;
    }

    // C string hash function (djb2) - taken from http://www.cse.yorku.ca/~oz/hash.html
    DOCTEST_NO_SANITIZE_INTEGER
    unsigned long long hash(const char* str) {
        unsigned long long hash = 5381;
        char c;
        while ((c = *str++))
            hash = ((hash << 5) + hash) + c; // hash * 33 + c
        return hash;
    }

    unsigned long long hash(const SubcaseSignature& sig) {
        return hash(hash(hash(sig.m_file), hash(sig.m_name.c_str())), sig.m_line);
    }

    unsigned long long hash(const std::vector<SubcaseSignature>& sigs, size_t count) {
        unsigned long long running = 0;
        auto end = sigs.begin() + count;
        for (auto it = sigs.begin(); it != end; it++) {
            running = hash(running, hash(*it));
        }
        return running;
    }

    unsigned long long hash(const std::vector<SubcaseSignature>& sigs) {
        unsigned long long running = 0;
        for (const SubcaseSignature& sig : sigs) {
            running = hash(running, hash(sig));
        }
        return running;
    }
} // namespace
namespace detail {
    bool Subcase::checkFilters() {
        if (g_cs->subcaseStack.size() < size_t(g_cs->subcase_filter_levels)) {
            if (!matchesAny(m_signature.m_name.c_str(), g_cs->filters[6], true, g_cs->case_sensitive))
                return true;
            if (matchesAny(m_signature.m_name.c_str(), g_cs->filters[7], false, g_cs->case_sensitive))
                return true;
        }
        return false;
    }

    Subcase::Subcase(const String& name, const char* file, int line)
            : m_signature({name, file, line}) {
        if (!g_cs->reachedLeaf) {
            if (g_cs->nextSubcaseStack.size() <= g_cs->subcaseStack.size()
                || g_cs->nextSubcaseStack[g_cs->subcaseStack.size()] == m_signature) {
                // Going down.
                if (checkFilters()) { return; }

                g_cs->subcaseStack.push_back(m_signature);
                g_cs->currentSubcaseDepth++;
                m_entered = true;
                DOCTEST_ITERATE_THROUGH_REPORTERS(subcase_start, m_signature);
            }
        } else {
            if (g_cs->subcaseStack[g_cs->currentSubcaseDepth] == m_signature) {
                // This subcase is reentered via control flow.
                g_cs->currentSubcaseDepth++;
                m_entered = true;
                DOCTEST_ITERATE_THROUGH_REPORTERS(subcase_start, m_signature);
            } else if (g_cs->nextSubcaseStack.size() <= g_cs->currentSubcaseDepth
                    && g_cs->fullyTraversedSubcases.find(hash(hash(g_cs->subcaseStack, g_cs->currentSubcaseDepth), hash(m_signature)))
                    == g_cs->fullyTraversedSubcases.end()) {
                if (checkFilters()) { return; }
                // This subcase is part of the one to be executed next.
                g_cs->nextSubcaseStack.clear();
                g_cs->nextSubcaseStack.insert(g_cs->nextSubcaseStack.end(),
                    g_cs->subcaseStack.begin(), g_cs->subcaseStack.begin() + g_cs->currentSubcaseDepth);
                g_cs->nextSubcaseStack.push_back(m_signature);
            }
        }
    }

    DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4996) // std::uncaught_exception is deprecated in C++17
    DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wdeprecated-declarations")
    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wdeprecated-declarations")

    Subcase::~Subcase() {
        if (m_entered) {
            g_cs->currentSubcaseDepth--;

            if (!g_cs->reachedLeaf) {
                // Leaf.
                g_cs->fullyTraversedSubcases.insert(hash(g_cs->subcaseStack));
                g_cs->nextSubcaseStack.clear();
                g_cs->reachedLeaf = true;
            } else if (g_cs->nextSubcaseStack.empty()) {
                // All children are finished.
                g_cs->fullyTraversedSubcases.insert(hash(g_cs->subcaseStack));
            }

#if defined(__cpp_lib_uncaught_exceptions) && __cpp_lib_uncaught_exceptions >= 201411L && (!defined(__MAC_OS_X_VERSION_MIN_REQUIRED) || __MAC_OS_X_VERSION_MIN_REQUIRED >= 101200)
            if(std::uncaught_exceptions() > 0
#else
            if(std::uncaught_exception()
#endif
                && g_cs->shouldLogCurrentException) {
                DOCTEST_ITERATE_THROUGH_REPORTERS(
                        test_case_exception, {"exception thrown in subcase - will translate later "
                                                "when the whole test case has been exited (cannot "
                                                "translate while there is an active exception)",
                                                false});
                g_cs->shouldLogCurrentException = false;
            }

            DOCTEST_ITERATE_THROUGH_REPORTERS(subcase_end, DOCTEST_EMPTY);
        }
    }

    DOCTEST_CLANG_SUPPRESS_WARNING_POP
    DOCTEST_GCC_SUPPRESS_WARNING_POP
    DOCTEST_MSVC_SUPPRESS_WARNING_POP

    Subcase::operator bool() const { return m_entered; }

    Result::Result(bool passed, const String& decomposition)
            : m_passed(passed)
            , m_decomp(decomposition) {}

    ExpressionDecomposer::ExpressionDecomposer(assertType::Enum at)
            : m_at(at) {}

    TestSuite& TestSuite::operator*(const char* in) {
        m_test_suite = in;
        return *this;
    }

    TestCase::TestCase(funcType test, const char* file, unsigned line, const TestSuite& test_suite,
                       const String& type, int template_id) {
        m_file              = file;
        m_line              = line;
        m_name              = nullptr; // will be later overridden in operator*
        m_test_suite        = test_suite.m_test_suite;
        m_description       = test_suite.m_description;
        m_skip              = test_suite.m_skip;
        m_no_breaks         = test_suite.m_no_breaks;
        m_no_output         = test_suite.m_no_output;
        m_may_fail          = test_suite.m_may_fail;
        m_should_fail       = test_suite.m_should_fail;
        m_expected_failures = test_suite.m_expected_failures;
        m_timeout           = test_suite.m_timeout;

        m_test        = test;
        m_type        = type;
        m_template_id = template_id;
    }

    TestCase::TestCase(const TestCase& other)
            : TestCaseData() {
        *this = other;
    }

    DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(26434) // hides a non-virtual function
    TestCase& TestCase::operator=(const TestCase& other) {
        TestCaseData::operator=(other);
        m_test        = other.m_test;
        m_type        = other.m_type;
        m_template_id = other.m_template_id;
        m_full_name   = other.m_full_name;

        if(m_template_id != -1)
            m_name = m_full_name.c_str();
        return *this;
    }
    DOCTEST_MSVC_SUPPRESS_WARNING_POP

    TestCase& TestCase::operator*(const char* in) {
        m_name = in;
        // make a new name with an appended type for templated test case
        if(m_template_id != -1) {
            m_full_name = String(m_name) + "<" + m_type + ">";
            // redirect the name to point to the newly constructed full name
            m_name = m_full_name.c_str();
        }
        return *this;
    }

    bool TestCase::operator<(const TestCase& other) const {
        // this will be used only to differentiate between test cases - not relevant for sorting
        if(m_line != other.m_line)
            return m_line < other.m_line;
        const int name_cmp = strcmp(m_name, other.m_name);
        if(name_cmp != 0)
            return name_cmp < 0;
        const int file_cmp = m_file.compare(other.m_file);
        if(file_cmp != 0)
            return file_cmp < 0;
        return m_template_id < other.m_template_id;
    }

    // all the registered tests
    std::set<TestCase>& getRegisteredTests() {
        static std::set<TestCase> data;
        return data;
    }
} // namespace detail
namespace {
    using namespace detail;
    // for sorting tests by file/line
    bool fileOrderComparator(const TestCase* lhs, const TestCase* rhs) {
        // this is needed because MSVC gives different case for drive letters
        // for __FILE__ when evaluated in a header and a source file
        const int res = lhs->m_file.compare(rhs->m_file, bool(DOCTEST_MSVC));
        if(res != 0)
            return res < 0;
        if(lhs->m_line != rhs->m_line)
            return lhs->m_line < rhs->m_line;
        return lhs->m_template_id < rhs->m_template_id;
    }

    // for sorting tests by suite/file/line
    bool suiteOrderComparator(const TestCase* lhs, const TestCase* rhs) {
        const int res = std::strcmp(lhs->m_test_suite, rhs->m_test_suite);
        if(res != 0)
            return res < 0;
        return fileOrderComparator(lhs, rhs);
    }

    // for sorting tests by name/suite/file/line
    bool nameOrderComparator(const TestCase* lhs, const TestCase* rhs) {
        const int res = std::strcmp(lhs->m_name, rhs->m_name);
        if(res != 0)
            return res < 0;
        return suiteOrderComparator(lhs, rhs);
    }

    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wdeprecated-declarations")
    void color_to_stream(std::ostream& s, Color::Enum code) {
        static_cast<void>(s);    // for DOCTEST_CONFIG_COLORS_NONE or DOCTEST_CONFIG_COLORS_WINDOWS
        static_cast<void>(code); // for DOCTEST_CONFIG_COLORS_NONE
#ifdef DOCTEST_CONFIG_COLORS_ANSI
        if(g_no_colors ||
           (isatty(STDOUT_FILENO) == false && getContextOptions()->force_colors == false))
            return;

        auto col = "";
        // clang-format off
            switch(code) { //!OCLINT missing break in switch statement / unnecessary default statement in covered switch statement
                case Color::Red:         col = "[0;31m"; break;
                case Color::Green:       col = "[0;32m"; break;
                case Color::Blue:        col = "[0;34m"; break;
                case Color::Cyan:        col = "[0;36m"; break;
                case Color::Yellow:      col = "[0;33m"; break;
                case Color::Grey:        col = "[1;30m"; break;
                case Color::LightGrey:   col = "[0;37m"; break;
                case Color::BrightRed:   col = "[1;31m"; break;
                case Color::BrightGreen: col = "[1;32m"; break;
                case Color::BrightWhite: col = "[1;37m"; break;
                case Color::Bright: // invalid
                case Color::None:
                case Color::White:
                default:                 col = "[0m";
            }
        // clang-format on
        s << "\033" << col;
#endif // DOCTEST_CONFIG_COLORS_ANSI

#ifdef DOCTEST_CONFIG_COLORS_WINDOWS
        if(g_no_colors ||
           (_isatty(_fileno(stdout)) == false && getContextOptions()->force_colors == false))
            return;

        static struct ConsoleHelper {
            HANDLE stdoutHandle;
            WORD   origFgAttrs;
            WORD   origBgAttrs;

            ConsoleHelper() {
                stdoutHandle = GetStdHandle(STD_OUTPUT_HANDLE);
                CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
                GetConsoleScreenBufferInfo(stdoutHandle, &csbiInfo);
                origFgAttrs = csbiInfo.wAttributes & ~(BACKGROUND_GREEN | BACKGROUND_RED |
                    BACKGROUND_BLUE | BACKGROUND_INTENSITY);
                origBgAttrs = csbiInfo.wAttributes & ~(FOREGROUND_GREEN | FOREGROUND_RED |
                    FOREGROUND_BLUE | FOREGROUND_INTENSITY);
            }
        } ch;

#define DOCTEST_SET_ATTR(x) SetConsoleTextAttribute(ch.stdoutHandle, x | ch.origBgAttrs)

        // clang-format off
        switch (code) {
            case Color::White:       DOCTEST_SET_ATTR(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE); break;
            case Color::Red:         DOCTEST_SET_ATTR(FOREGROUND_RED);                                      break;
            case Color::Green:       DOCTEST_SET_ATTR(FOREGROUND_GREEN);                                    break;
            case Color::Blue:        DOCTEST_SET_ATTR(FOREGROUND_BLUE);                                     break;
            case Color::Cyan:        DOCTEST_SET_ATTR(FOREGROUND_BLUE | FOREGROUND_GREEN);                  break;
            case Color::Yellow:      DOCTEST_SET_ATTR(FOREGROUND_RED | FOREGROUND_GREEN);                   break;
            case Color::Grey:        DOCTEST_SET_ATTR(0);                                                   break;
            case Color::LightGrey:   DOCTEST_SET_ATTR(FOREGROUND_INTENSITY);                                break;
            case Color::BrightRed:   DOCTEST_SET_ATTR(FOREGROUND_INTENSITY | FOREGROUND_RED);               break;
            case Color::BrightGreen: DOCTEST_SET_ATTR(FOREGROUND_INTENSITY | FOREGROUND_GREEN);             break;
            case Color::BrightWhite: DOCTEST_SET_ATTR(FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE); break;
            case Color::None:
            case Color::Bright: // invalid
            default:                 DOCTEST_SET_ATTR(ch.origFgAttrs);
        }
            // clang-format on
#endif // DOCTEST_CONFIG_COLORS_WINDOWS
    }
    DOCTEST_CLANG_SUPPRESS_WARNING_POP

    std::vector<const IExceptionTranslator*>& getExceptionTranslators() {
        static std::vector<const IExceptionTranslator*> data;
        return data;
    }

    String translateActiveException() {
#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
        String res;
        auto&  translators = getExceptionTranslators();
        for(auto& curr : translators)
            if(curr->translate(res))
                return res;
        // clang-format off
        DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wcatch-value")
        try {
            throw;
        } catch(std::exception& ex) {
            return ex.what();
        } catch(std::string& msg) {
            return msg.c_str();
        } catch(const char* msg) {
            return msg;
        } catch(...) {
            return "unknown exception";
        }
        DOCTEST_GCC_SUPPRESS_WARNING_POP
// clang-format on
#else  // DOCTEST_CONFIG_NO_EXCEPTIONS
        return "";
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS
    }
} // namespace

namespace detail {
    // used by the macros for registering tests
    int regTest(const TestCase& tc) {
        getRegisteredTests().insert(tc);
        return 0;
    }

    // sets the current test suite
    int setTestSuite(const TestSuite& ts) {
        doctest_detail_test_suite_ns::getCurrentTestSuite() = ts;
        return 0;
    }

#ifdef DOCTEST_IS_DEBUGGER_ACTIVE
    bool isDebuggerActive() { return DOCTEST_IS_DEBUGGER_ACTIVE(); }
#else // DOCTEST_IS_DEBUGGER_ACTIVE
#ifdef DOCTEST_PLATFORM_LINUX
    class ErrnoGuard {
    public:
        ErrnoGuard() : m_oldErrno(errno) {}
        ~ErrnoGuard() { errno = m_oldErrno; }
    private:
        int m_oldErrno;
    };
    // See the comments in Catch2 for the reasoning behind this implementation:
    // https://github.com/catchorg/Catch2/blob/v2.13.1/include/internal/catch_debugger.cpp#L79-L102
    bool isDebuggerActive() {
        ErrnoGuard guard;
        std::ifstream in("/proc/self/status");
        for(std::string line; std::getline(in, line);) {
            static const int PREFIX_LEN = 11;
            if(line.compare(0, PREFIX_LEN, "TracerPid:\t") == 0) {
                return line.length() > PREFIX_LEN && line[PREFIX_LEN] != '0';
            }
        }
        return false;
    }
#elif defined(DOCTEST_PLATFORM_MAC)
    // The following function is taken directly from the following technical note:
    // https://developer.apple.com/library/archive/qa/qa1361/_index.html
    // Returns true if the current process is being debugged (either
    // running under the debugger or has a debugger attached post facto).
    bool isDebuggerActive() {
        int        mib[4];
        kinfo_proc info;
        size_t     size;
        // Initialize the flags so that, if sysctl fails for some bizarre
        // reason, we get a predictable result.
        info.kp_proc.p_flag = 0;
        // Initialize mib, which tells sysctl the info we want, in this case
        // we're looking for information about a specific process ID.
        mib[0] = CTL_KERN;
        mib[1] = KERN_PROC;
        mib[2] = KERN_PROC_PID;
        mib[3] = getpid();
        // Call sysctl.
        size = sizeof(info);
        if(sysctl(mib, DOCTEST_COUNTOF(mib), &info, &size, 0, 0) != 0) {
            std::cerr << "\nCall to sysctl failed - unable to determine if debugger is active **\n";
            return false;
        }
        // We're being debugged if the P_TRACED flag is set.
        return ((info.kp_proc.p_flag & P_TRACED) != 0);
    }
#elif DOCTEST_MSVC || defined(__MINGW32__) || defined(__MINGW64__)
    bool isDebuggerActive() { return ::IsDebuggerPresent() != 0; }
#else
    bool isDebuggerActive() { return false; }
#endif // Platform
#endif // DOCTEST_IS_DEBUGGER_ACTIVE

    void registerExceptionTranslatorImpl(const IExceptionTranslator* et) {
        if(std::find(getExceptionTranslators().begin(), getExceptionTranslators().end(), et) ==
           getExceptionTranslators().end())
            getExceptionTranslators().push_back(et);
    }

    DOCTEST_THREAD_LOCAL std::vector<IContextScope*> g_infoContexts; // for logging with INFO()

    ContextScopeBase::ContextScopeBase() {
        g_infoContexts.push_back(this);
    }

    ContextScopeBase::ContextScopeBase(ContextScopeBase&& other) noexcept {
        if (other.need_to_destroy) {
            other.destroy();
        }
        other.need_to_destroy = false;
        g_infoContexts.push_back(this);
    }

    DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4996) // std::uncaught_exception is deprecated in C++17
    DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wdeprecated-declarations")
    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wdeprecated-declarations")

    // destroy cannot be inlined into the destructor because that would mean calling stringify after
    // ContextScope has been destroyed (base class destructors run after derived class destructors).
    // Instead, ContextScope calls this method directly from its destructor.
    void ContextScopeBase::destroy() {
#if defined(__cpp_lib_uncaught_exceptions) && __cpp_lib_uncaught_exceptions >= 201411L && (!defined(__MAC_OS_X_VERSION_MIN_REQUIRED) || __MAC_OS_X_VERSION_MIN_REQUIRED >= 101200)
        if(std::uncaught_exceptions() > 0) {
#else
        if(std::uncaught_exception()) {
#endif
            std::ostringstream s;
            this->stringify(&s);
            g_cs->stringifiedContexts.push_back(s.str().c_str());
        }
        g_infoContexts.pop_back();
    }

    DOCTEST_CLANG_SUPPRESS_WARNING_POP
    DOCTEST_GCC_SUPPRESS_WARNING_POP
    DOCTEST_MSVC_SUPPRESS_WARNING_POP
} // namespace detail
namespace {
    using namespace detail;

#if !defined(DOCTEST_CONFIG_POSIX_SIGNALS) && !defined(DOCTEST_CONFIG_WINDOWS_SEH)
    struct FatalConditionHandler
    {
        static void reset() {}
        static void allocateAltStackMem() {}
        static void freeAltStackMem() {}
    };
#else // DOCTEST_CONFIG_POSIX_SIGNALS || DOCTEST_CONFIG_WINDOWS_SEH

    void reportFatal(const std::string&);

#ifdef DOCTEST_PLATFORM_WINDOWS

    struct SignalDefs
    {
        DWORD id;
        const char* name;
    };
    // There is no 1-1 mapping between signals and windows exceptions.
    // Windows can easily distinguish between SO and SigSegV,
    // but SigInt, SigTerm, etc are handled differently.
    SignalDefs signalDefs[] = {
            {static_cast<DWORD>(EXCEPTION_ILLEGAL_INSTRUCTION),
             "SIGILL - Illegal instruction signal"},
            {static_cast<DWORD>(EXCEPTION_STACK_OVERFLOW), "SIGSEGV - Stack overflow"},
            {static_cast<DWORD>(EXCEPTION_ACCESS_VIOLATION),
             "SIGSEGV - Segmentation violation signal"},
            {static_cast<DWORD>(EXCEPTION_INT_DIVIDE_BY_ZERO), "Divide by zero error"},
    };

    struct FatalConditionHandler
    {
        static LONG CALLBACK handleException(PEXCEPTION_POINTERS ExceptionInfo) {
            // Multiple threads may enter this filter/handler at once. We want the error message to be printed on the
            // console just once no matter how many threads have crashed.
            DOCTEST_DECLARE_STATIC_MUTEX(mutex)
            static bool execute = true;
            {
                DOCTEST_LOCK_MUTEX(mutex)
                if(execute) {
                    bool reported = false;
                    for(size_t i = 0; i < DOCTEST_COUNTOF(signalDefs); ++i) {
                        if(ExceptionInfo->ExceptionRecord->ExceptionCode == signalDefs[i].id) {
                            reportFatal(signalDefs[i].name);
                            reported = true;
                            break;
                        }
                    }
                    if(reported == false)
                        reportFatal("Unhandled SEH exception caught");
                    if(isDebuggerActive() && !g_cs->no_breaks)
                        DOCTEST_BREAK_INTO_DEBUGGER();
                }
                execute = false;
            }
            std::exit(EXIT_FAILURE);
        }

        static void allocateAltStackMem() {}
        static void freeAltStackMem() {}

        FatalConditionHandler() {
            isSet = true;
            // 32k seems enough for doctest to handle stack overflow,
            // but the value was found experimentally, so there is no strong guarantee
            guaranteeSize = 32 * 1024;
            // Register an unhandled exception filter
            previousTop = SetUnhandledExceptionFilter(handleException);
            // Pass in guarantee size to be filled
            SetThreadStackGuarantee(&guaranteeSize);

            // On Windows uncaught exceptions from another thread, exceptions from
            // destructors, or calls to std::terminate are not a SEH exception

            // The terminal handler gets called when:
            // - std::terminate is called FROM THE TEST RUNNER THREAD
            // - an exception is thrown from a destructor FROM THE TEST RUNNER THREAD
            original_terminate_handler = std::get_terminate();
            std::set_terminate([]() DOCTEST_NOEXCEPT {
                reportFatal("Terminate handler called");
                if(isDebuggerActive() && !g_cs->no_breaks)
                    DOCTEST_BREAK_INTO_DEBUGGER();
                std::exit(EXIT_FAILURE); // explicitly exit - otherwise the SIGABRT handler may be called as well
            });

            // SIGABRT is raised when:
            // - std::terminate is called FROM A DIFFERENT THREAD
            // - an exception is thrown from a destructor FROM A DIFFERENT THREAD
            // - an uncaught exception is thrown FROM A DIFFERENT THREAD
            prev_sigabrt_handler = std::signal(SIGABRT, [](int signal) DOCTEST_NOEXCEPT {
                if(signal == SIGABRT) {
                    reportFatal("SIGABRT - Abort (abnormal termination) signal");
                    if(isDebuggerActive() && !g_cs->no_breaks)
                        DOCTEST_BREAK_INTO_DEBUGGER();
                    std::exit(EXIT_FAILURE);
                }
            });

            // The following settings are taken from google test, and more
            // specifically from UnitTest::Run() inside of gtest.cc

            // the user does not want to see pop-up dialogs about crashes
            prev_error_mode_1 = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOALIGNMENTFAULTEXCEPT |
                                             SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX);
            // This forces the abort message to go to stderr in all circumstances.
            prev_error_mode_2 = _set_error_mode(_OUT_TO_STDERR);
            // In the debug version, Visual Studio pops up a separate dialog
            // offering a choice to debug the aborted program - we want to disable that.
            prev_abort_behavior = _set_abort_behavior(0x0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);
            // In debug mode, the Windows CRT can crash with an assertion over invalid
            // input (e.g. passing an invalid file descriptor). The default handling
            // for these assertions is to pop up a dialog and wait for user input.
            // Instead ask the CRT to dump such assertions to stderr non-interactively.
            prev_report_mode = _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
            prev_report_file = _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);
        }

        static void reset() {
            if(isSet) {
                // Unregister handler and restore the old guarantee
                SetUnhandledExceptionFilter(previousTop);
                SetThreadStackGuarantee(&guaranteeSize);
                std::set_terminate(original_terminate_handler);
                std::signal(SIGABRT, prev_sigabrt_handler);
                SetErrorMode(prev_error_mode_1);
                _set_error_mode(prev_error_mode_2);
                _set_abort_behavior(prev_abort_behavior, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);
                static_cast<void>(_CrtSetReportMode(_CRT_ASSERT, prev_report_mode));
                static_cast<void>(_CrtSetReportFile(_CRT_ASSERT, prev_report_file));
                isSet = false;
            }
        }

        ~FatalConditionHandler() { reset(); }

    private:
        static UINT         prev_error_mode_1;
        static int          prev_error_mode_2;
        static unsigned int prev_abort_behavior;
        static int          prev_report_mode;
        static _HFILE       prev_report_file;
        static void (DOCTEST_CDECL *prev_sigabrt_handler)(int);
        static std::terminate_handler original_terminate_handler;
        static bool isSet;
        static ULONG guaranteeSize;
        static LPTOP_LEVEL_EXCEPTION_FILTER previousTop;
    };

    UINT         FatalConditionHandler::prev_error_mode_1;
    int          FatalConditionHandler::prev_error_mode_2;
    unsigned int FatalConditionHandler::prev_abort_behavior;
    int          FatalConditionHandler::prev_report_mode;
    _HFILE       FatalConditionHandler::prev_report_file;
    void (DOCTEST_CDECL *FatalConditionHandler::prev_sigabrt_handler)(int);
    std::terminate_handler FatalConditionHandler::original_terminate_handler;
    bool FatalConditionHandler::isSet = false;
    ULONG FatalConditionHandler::guaranteeSize = 0;
    LPTOP_LEVEL_EXCEPTION_FILTER FatalConditionHandler::previousTop = nullptr;

#else // DOCTEST_PLATFORM_WINDOWS

    struct SignalDefs
    {
        int         id;
        const char* name;
    };
    SignalDefs signalDefs[] = {{SIGINT, "SIGINT - Terminal interrupt signal"},
                               {SIGILL, "SIGILL - Illegal instruction signal"},
                               {SIGFPE, "SIGFPE - Floating point error signal"},
                               {SIGSEGV, "SIGSEGV - Segmentation violation signal"},
                               {SIGTERM, "SIGTERM - Termination request signal"},
                               {SIGABRT, "SIGABRT - Abort (abnormal termination) signal"}};

    struct FatalConditionHandler
    {
        static bool             isSet;
        static struct sigaction oldSigActions[DOCTEST_COUNTOF(signalDefs)];
        static stack_t          oldSigStack;
        static size_t           altStackSize;
        static char*            altStackMem;

        static void handleSignal(int sig) {
            const char* name = "<unknown signal>";
            for(std::size_t i = 0; i < DOCTEST_COUNTOF(signalDefs); ++i) {
                SignalDefs& def = signalDefs[i];
                if(sig == def.id) {
                    name = def.name;
                    break;
                }
            }
            reset();
            reportFatal(name);
            raise(sig);
        }

        static void allocateAltStackMem() {
            altStackMem = new char[altStackSize];
        }

        static void freeAltStackMem() {
            delete[] altStackMem;
        }

        FatalConditionHandler() {
            isSet = true;
            stack_t sigStack;
            sigStack.ss_sp    = altStackMem;
            sigStack.ss_size  = altStackSize;
            sigStack.ss_flags = 0;
            sigaltstack(&sigStack, &oldSigStack);
            struct sigaction sa = {};
            sa.sa_handler       = handleSignal;
            sa.sa_flags         = SA_ONSTACK;
            for(std::size_t i = 0; i < DOCTEST_COUNTOF(signalDefs); ++i) {
                sigaction(signalDefs[i].id, &sa, &oldSigActions[i]);
            }
        }

        ~FatalConditionHandler() { reset(); }
        static void reset() {
            if(isSet) {
                // Set signals back to previous values -- hopefully nobody overwrote them in the meantime
                for(std::size_t i = 0; i < DOCTEST_COUNTOF(signalDefs); ++i) {
                    sigaction(signalDefs[i].id, &oldSigActions[i], nullptr);
                }
                // Return the old stack
                sigaltstack(&oldSigStack, nullptr);
                isSet = false;
            }
        }
    };

    bool             FatalConditionHandler::isSet = false;
    struct sigaction FatalConditionHandler::oldSigActions[DOCTEST_COUNTOF(signalDefs)] = {};
    stack_t          FatalConditionHandler::oldSigStack = {};
    size_t           FatalConditionHandler::altStackSize = 4 * SIGSTKSZ;
    char*            FatalConditionHandler::altStackMem = nullptr;

#endif // DOCTEST_PLATFORM_WINDOWS
#endif // DOCTEST_CONFIG_POSIX_SIGNALS || DOCTEST_CONFIG_WINDOWS_SEH

} // namespace

namespace {
    using namespace detail;

#ifdef DOCTEST_PLATFORM_WINDOWS
#define DOCTEST_OUTPUT_DEBUG_STRING(text) ::OutputDebugStringA(text)
#else
    // TODO: integration with XCode and other IDEs
#define DOCTEST_OUTPUT_DEBUG_STRING(text)
#endif // Platform

    void addAssert(assertType::Enum at) {
        if((at & assertType::is_warn) == 0) //!OCLINT bitwise operator in conditional
            g_cs->numAssertsCurrentTest_atomic++;
    }

    void addFailedAssert(assertType::Enum at) {
        if((at & assertType::is_warn) == 0) //!OCLINT bitwise operator in conditional
            g_cs->numAssertsFailedCurrentTest_atomic++;
    }

#if defined(DOCTEST_CONFIG_POSIX_SIGNALS) || defined(DOCTEST_CONFIG_WINDOWS_SEH)
    void reportFatal(const std::string& message) {
        g_cs->failure_flags |= TestCaseFailureReason::Crash;

        DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_exception, {message.c_str(), true});

        while (g_cs->subcaseStack.size()) {
            g_cs->subcaseStack.pop_back();
            DOCTEST_ITERATE_THROUGH_REPORTERS(subcase_end, DOCTEST_EMPTY);
        }

        g_cs->finalizeTestCaseData();

        DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_end, *g_cs);

        DOCTEST_ITERATE_THROUGH_REPORTERS(test_run_end, *g_cs);
    }
#endif // DOCTEST_CONFIG_POSIX_SIGNALS || DOCTEST_CONFIG_WINDOWS_SEH
} // namespace

AssertData::AssertData(assertType::Enum at, const char* file, int line, const char* expr,
    const char* exception_type, const StringContains& exception_string)
    : m_test_case(g_cs->currentTest), m_at(at), m_file(file), m_line(line), m_expr(expr),
    m_failed(true), m_threw(false), m_threw_as(false), m_exception_type(exception_type),
    m_exception_string(exception_string) {
#if DOCTEST_MSVC
    if (m_expr[0] == ' ') // this happens when variadic macros are disabled under MSVC
        ++m_expr;
#endif // MSVC
}

namespace detail {
    ResultBuilder::ResultBuilder(assertType::Enum at, const char* file, int line, const char* expr,
                                 const char* exception_type, const String& exception_string)
        : AssertData(at, file, line, expr, exception_type, exception_string) { }

    ResultBuilder::ResultBuilder(assertType::Enum at, const char* file, int line, const char* expr,
        const char* exception_type, const Contains& exception_string)
        : AssertData(at, file, line, expr, exception_type, exception_string) { }

    void ResultBuilder::setResult(const Result& res) {
        m_decomp = res.m_decomp;
        m_failed = !res.m_passed;
    }

    void ResultBuilder::translateException() {
        m_threw     = true;
        m_exception = translateActiveException();
    }

    bool ResultBuilder::log() {
        if(m_at & assertType::is_throws) { //!OCLINT bitwise operator in conditional
            m_failed = !m_threw;
        } else if((m_at & assertType::is_throws_as) && (m_at & assertType::is_throws_with)) { //!OCLINT
            m_failed = !m_threw_as || !m_exception_string.check(m_exception);
        } else if(m_at & assertType::is_throws_as) { //!OCLINT bitwise operator in conditional
            m_failed = !m_threw_as;
        } else if(m_at & assertType::is_throws_with) { //!OCLINT bitwise operator in conditional
            m_failed = !m_exception_string.check(m_exception);
        } else if(m_at & assertType::is_nothrow) { //!OCLINT bitwise operator in conditional
            m_failed = m_threw;
        }

        if(m_exception.size())
            m_exception = "\"" + m_exception + "\"";

        if(is_running_in_test) {
            addAssert(m_at);
            DOCTEST_ITERATE_THROUGH_REPORTERS(log_assert, *this);

            if(m_failed)
                addFailedAssert(m_at);
        } else if(m_failed) {
            failed_out_of_a_testing_context(*this);
        }

        return m_failed && isDebuggerActive() && !getContextOptions()->no_breaks &&
            (g_cs->currentTest == nullptr || !g_cs->currentTest->m_no_breaks); // break into debugger
    }

    void ResultBuilder::react() const {
        if(m_failed && checkIfShouldThrow(m_at))
            throwException();
    }

    void failed_out_of_a_testing_context(const AssertData& ad) {
        if(g_cs->ah)
            g_cs->ah(ad);
        else
            std::abort();
    }

    bool decomp_assert(assertType::Enum at, const char* file, int line, const char* expr,
                       const Result& result) {
        bool failed = !result.m_passed;

        // ###################################################################################
        // IF THE DEBUGGER BREAKS HERE - GO 1 LEVEL UP IN THE CALLSTACK FOR THE FAILING ASSERT
        // THIS IS THE EFFECT OF HAVING 'DOCTEST_CONFIG_SUPER_FAST_ASSERTS' DEFINED
        // ###################################################################################
        DOCTEST_ASSERT_OUT_OF_TESTS(result.m_decomp);
        DOCTEST_ASSERT_IN_TESTS(result.m_decomp);
        return !failed;
    }

    MessageBuilder::MessageBuilder(const char* file, int line, assertType::Enum severity) {
        m_stream   = tlssPush();
        m_file     = file;
        m_line     = line;
        m_severity = severity;
    }

    MessageBuilder::~MessageBuilder() {
        if (!logged)
            tlssPop();
    }

    DOCTEST_DEFINE_INTERFACE(IExceptionTranslator)

    bool MessageBuilder::log() {
        if (!logged) {
            m_string = tlssPop();
            logged = true;
        }

        DOCTEST_ITERATE_THROUGH_REPORTERS(log_message, *this);

        const bool isWarn = m_severity & assertType::is_warn;

        // warn is just a message in this context so we don't treat it as an assert
        if(!isWarn) {
            addAssert(m_severity);
            addFailedAssert(m_severity);
        }

        return isDebuggerActive() && !getContextOptions()->no_breaks && !isWarn &&
            (g_cs->currentTest == nullptr || !g_cs->currentTest->m_no_breaks); // break into debugger
    }

    void MessageBuilder::react() {
        if(m_severity & assertType::is_require) //!OCLINT bitwise operator in conditional
            throwException();
    }
} // namespace detail
namespace {
    using namespace detail;

    // clang-format off

// =================================================================================================
// The following code has been taken verbatim from Catch2/include/internal/catch_xmlwriter.h/cpp
// This is done so cherry-picking bug fixes is trivial - even the style/formatting is untouched.
// =================================================================================================

    class XmlEncode {
    public:
        enum ForWhat { ForTextNodes, ForAttributes };

        XmlEncode( std::string const& str, ForWhat forWhat = ForTextNodes );

        void encodeTo( std::ostream& os ) const;

        friend std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode );

    private:
        std::string m_str;
        ForWhat m_forWhat;
    };

    class XmlWriter {
    public:

        class ScopedElement {
        public:
            ScopedElement( XmlWriter* writer );

            ScopedElement( ScopedElement&& other ) DOCTEST_NOEXCEPT;
            ScopedElement& operator=( ScopedElement&& other ) DOCTEST_NOEXCEPT;

            ~ScopedElement();

            ScopedElement& writeText( std::string const& text, bool indent = true );

            template<typename T>
            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {
                m_writer->writeAttribute( name, attribute );
                return *this;
            }

        private:
            mutable XmlWriter* m_writer = nullptr;
        };

#ifndef DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
        XmlWriter( std::ostream& os = std::cout );
#else // DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
        XmlWriter( std::ostream& os );
#endif // DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
        ~XmlWriter();

        XmlWriter( XmlWriter const& ) = delete;
        XmlWriter& operator=( XmlWriter const& ) = delete;

        XmlWriter& startElement( std::string const& name );

        ScopedElement scopedElement( std::string const& name );

        XmlWriter& endElement();

        XmlWriter& writeAttribute( std::string const& name, std::string const& attribute );

        XmlWriter& writeAttribute( std::string const& name, const char* attribute );

        XmlWriter& writeAttribute( std::string const& name, bool attribute );

        template<typename T>
        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
        std::stringstream rss;
            rss << attribute;
            return writeAttribute( name, rss.str() );
        }

        XmlWriter& writeText( std::string const& text, bool indent = true );

        //XmlWriter& writeComment( std::string const& text );

        //void writeStylesheetRef( std::string const& url );

        //XmlWriter& writeBlankLine();

        void ensureTagClosed();

        void writeDeclaration();

    private:

        void newlineIfNecessary();

        bool m_tagIsOpen = false;
        bool m_needsNewline = false;
        std::vector<std::string> m_tags;
        std::string m_indent;
        std::ostream& m_os;
    };

// =================================================================================================
// The following code has been taken verbatim from Catch2/include/internal/catch_xmlwriter.h/cpp
// This is done so cherry-picking bug fixes is trivial - even the style/formatting is untouched.
// =================================================================================================

using uchar = unsigned char;

namespace {

    size_t trailingBytes(unsigned char c) {
        if ((c & 0xE0) == 0xC0) {
            return 2;
        }
        if ((c & 0xF0) == 0xE0) {
            return 3;
        }
        if ((c & 0xF8) == 0xF0) {
            return 4;
        }
        DOCTEST_INTERNAL_ERROR("Invalid multibyte utf-8 start byte encountered");
    }

    uint32_t headerValue(unsigned char c) {
        if ((c & 0xE0) == 0xC0) {
            return c & 0x1F;
        }
        if ((c & 0xF0) == 0xE0) {
            return c & 0x0F;
        }
        if ((c & 0xF8) == 0xF0) {
            return c & 0x07;
        }
        DOCTEST_INTERNAL_ERROR("Invalid multibyte utf-8 start byte encountered");
    }

    void hexEscapeChar(std::ostream& os, unsigned char c) {
        std::ios_base::fmtflags f(os.flags());
        os << "\\x"
            << std::uppercase << std::hex << std::setfill('0') << std::setw(2)
            << static_cast<int>(c);
        os.flags(f);
    }

} // anonymous namespace

    XmlEncode::XmlEncode( std::string const& str, ForWhat forWhat )
    :   m_str( str ),
        m_forWhat( forWhat )
    {}

    void XmlEncode::encodeTo( std::ostream& os ) const {
        // Apostrophe escaping not necessary if we always use " to write attributes
        // (see: https://www.w3.org/TR/xml/#syntax)

        for( std::size_t idx = 0; idx < m_str.size(); ++ idx ) {
            uchar c = m_str[idx];
            switch (c) {
            case '<':   os << "&lt;"; break;
            case '&':   os << "&amp;"; break;

            case '>':
                // See: https://www.w3.org/TR/xml/#syntax
                if (idx > 2 && m_str[idx - 1] == ']' && m_str[idx - 2] == ']')
                    os << "&gt;";
                else
                    os << c;
                break;

            case '\"':
                if (m_forWhat == ForAttributes)
                    os << "&quot;";
                else
                    os << c;
                break;

            default:
                // Check for control characters and invalid utf-8

                // Escape control characters in standard ascii
                // see https://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0
                if (c < 0x09 || (c > 0x0D && c < 0x20) || c == 0x7F) {
                    hexEscapeChar(os, c);
                    break;
                }

                // Plain ASCII: Write it to stream
                if (c < 0x7F) {
                    os << c;
                    break;
                }

                // UTF-8 territory
                // Check if the encoding is valid and if it is not, hex escape bytes.
                // Important: We do not check the exact decoded values for validity, only the encoding format
                // First check that this bytes is a valid lead byte:
                // This means that it is not encoded as 1111 1XXX
                // Or as 10XX XXXX
                if (c <  0xC0 ||
                    c >= 0xF8) {
                    hexEscapeChar(os, c);
                    break;
                }

                auto encBytes = trailingBytes(c);
                // Are there enough bytes left to avoid accessing out-of-bounds memory?
                if (idx + encBytes - 1 >= m_str.size()) {
                    hexEscapeChar(os, c);
                    break;
                }
                // The header is valid, check data
                // The next encBytes bytes must together be a valid utf-8
                // This means: bitpattern 10XX XXXX and the extracted value is sane (ish)
                bool valid = true;
                uint32_t value = headerValue(c);
                for (std::size_t n = 1; n < encBytes; ++n) {
                    uchar nc = m_str[idx + n];
                    valid &= ((nc & 0xC0) == 0x80);
                    value = (value << 6) | (nc & 0x3F);
                }

                if (
                    // Wrong bit pattern of following bytes
                    (!valid) ||
                    // Overlong encodings
                    (value < 0x80) ||
                    (                 value < 0x800   && encBytes > 2) || // removed "0x80 <= value &&" because redundant
                    (0x800 < value && value < 0x10000 && encBytes > 3) ||
                    // Encoded value out of range
                    (value >= 0x110000)
                    ) {
                    hexEscapeChar(os, c);
                    break;
                }

                // If we got here, this is in fact a valid(ish) utf-8 sequence
                for (std::size_t n = 0; n < encBytes; ++n) {
                    os << m_str[idx + n];
                }
                idx += encBytes - 1;
                break;
            }
        }
    }

    std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode ) {
        xmlEncode.encodeTo( os );
        return os;
    }

    XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer )
    :   m_writer( writer )
    {}

    XmlWriter::ScopedElement::ScopedElement( ScopedElement&& other ) DOCTEST_NOEXCEPT
    :   m_writer( other.m_writer ){
        other.m_writer = nullptr;
    }
    XmlWriter::ScopedElement& XmlWriter::ScopedElement::operator=( ScopedElement&& other ) DOCTEST_NOEXCEPT {
        if ( m_writer ) {
            m_writer->endElement();
        }
        m_writer = other.m_writer;
        other.m_writer = nullptr;
        return *this;
    }


    XmlWriter::ScopedElement::~ScopedElement() {
        if( m_writer )
            m_writer->endElement();
    }

    XmlWriter::ScopedElement& XmlWriter::ScopedElement::writeText( std::string const& text, bool indent ) {
        m_writer->writeText( text, indent );
        return *this;
    }

    XmlWriter::XmlWriter( std::ostream& os ) : m_os( os )
    {
        // writeDeclaration(); // called explicitly by the reporters that use the writer class - see issue #627
    }

    XmlWriter::~XmlWriter() {
        while( !m_tags.empty() )
            endElement();
    }

    XmlWriter& XmlWriter::startElement( std::string const& name ) {
        ensureTagClosed();
        newlineIfNecessary();
        m_os << m_indent << '<' << name;
        m_tags.push_back( name );
        m_indent += "  ";
        m_tagIsOpen = true;
        return *this;
    }

    XmlWriter::ScopedElement XmlWriter::scopedElement( std::string const& name ) {
        ScopedElement scoped( this );
        startElement( name );
        return scoped;
    }

    XmlWriter& XmlWriter::endElement() {
        newlineIfNecessary();
        m_indent = m_indent.substr( 0, m_indent.size()-2 );
        if( m_tagIsOpen ) {
            m_os << "/>";
            m_tagIsOpen = false;
        }
        else {
            m_os << m_indent << "</" << m_tags.back() << ">";
        }
        m_os << std::endl;
        m_tags.pop_back();
        return *this;
    }

    XmlWriter& XmlWriter::writeAttribute( std::string const& name, std::string const& attribute ) {
        if( !name.empty() && !attribute.empty() )
            m_os << ' ' << name << "=\"" << XmlEncode( attribute, XmlEncode::ForAttributes ) << '"';
        return *this;
    }

    XmlWriter& XmlWriter::writeAttribute( std::string const& name, const char* attribute ) {
        if( !name.empty() && attribute && attribute[0] != '\0' )
            m_os << ' ' << name << "=\"" << XmlEncode( attribute, XmlEncode::ForAttributes ) << '"';
        return *this;
    }

    XmlWriter& XmlWriter::writeAttribute( std::string const& name, bool attribute ) {
        m_os << ' ' << name << "=\"" << ( attribute ? "true" : "false" ) << '"';
        return *this;
    }

    XmlWriter& XmlWriter::writeText( std::string const& text, bool indent ) {
        if( !text.empty() ){
            bool tagWasOpen = m_tagIsOpen;
            ensureTagClosed();
            if( tagWasOpen && indent )
                m_os << m_indent;
            m_os << XmlEncode( text );
            m_needsNewline = true;
        }
        return *this;
    }

    //XmlWriter& XmlWriter::writeComment( std::string const& text ) {
    //    ensureTagClosed();
    //    m_os << m_indent << "<!--" << text << "-->";
    //    m_needsNewline = true;
    //    return *this;
    //}

    //void XmlWriter::writeStylesheetRef( std::string const& url ) {
    //    m_os << "<?xml-stylesheet type=\"text/xsl\" href=\"" << url << "\"?>\n";
    //}

    //XmlWriter& XmlWriter::writeBlankLine() {
    //    ensureTagClosed();
    //    m_os << '\n';
    //    return *this;
    //}

    void XmlWriter::ensureTagClosed() {
        if( m_tagIsOpen ) {
            m_os << ">" << std::endl;
            m_tagIsOpen = false;
        }
    }

    void XmlWriter::writeDeclaration() {
        m_os << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
    }

    void XmlWriter::newlineIfNecessary() {
        if( m_needsNewline ) {
            m_os << std::endl;
            m_needsNewline = false;
        }
    }

// =================================================================================================
// End of copy-pasted code from Catch
// =================================================================================================

    // clang-format on

    struct XmlReporter : public IReporter
    {
        XmlWriter xml;
        DOCTEST_DECLARE_MUTEX(mutex)

        // caching pointers/references to objects of these types - safe to do
        const ContextOptions& opt;
        const TestCaseData*   tc = nullptr;

        XmlReporter(const ContextOptions& co)
                : xml(*co.cout)
                , opt(co) {}

        void log_contexts() {
            int num_contexts = get_num_active_contexts();
            if(num_contexts) {
                auto              contexts = get_active_contexts();
                std::stringstream ss;
                for(int i = 0; i < num_contexts; ++i) {
                    contexts[i]->stringify(&ss);
                    xml.scopedElement("Info").writeText(ss.str());
                    ss.str("");
                }
            }
        }

        unsigned line(unsigned l) const { return opt.no_line_numbers ? 0 : l; }

        void test_case_start_impl(const TestCaseData& in) {
            bool open_ts_tag = false;
            if(tc != nullptr) { // we have already opened a test suite
                if(std::strcmp(tc->m_test_suite, in.m_test_suite) != 0) {
                    xml.endElement();
                    open_ts_tag = true;
                }
            }
            else {
                open_ts_tag = true; // first test case ==> first test suite
            }

            if(open_ts_tag) {
                xml.startElement("TestSuite");
                xml.writeAttribute("name", in.m_test_suite);
            }

            tc = &in;
            xml.startElement("TestCase")
                    .writeAttribute("name", in.m_name)
                    .writeAttribute("filename", skipPathFromFilename(in.m_file.c_str()))
                    .writeAttribute("line", line(in.m_line))
                    .writeAttribute("description", in.m_description);

            if(Approx(in.m_timeout) != 0)
                xml.writeAttribute("timeout", in.m_timeout);
            if(in.m_may_fail)
                xml.writeAttribute("may_fail", true);
            if(in.m_should_fail)
                xml.writeAttribute("should_fail", true);
        }

        // =========================================================================================
        // WHAT FOLLOWS ARE OVERRIDES OF THE VIRTUAL METHODS OF THE REPORTER INTERFACE
        // =========================================================================================

        void report_query(const QueryData& in) override {
            test_run_start();
            if(opt.list_reporters) {
                for(auto& curr : getListeners())
                    xml.scopedElement("Listener")
                            .writeAttribute("priority", curr.first.first)
                            .writeAttribute("name", curr.first.second);
                for(auto& curr : getReporters())
                    xml.scopedElement("Reporter")
                            .writeAttribute("priority", curr.first.first)
                            .writeAttribute("name", curr.first.second);
            } else if(opt.count || opt.list_test_cases) {
                for(unsigned i = 0; i < in.num_data; ++i) {
                    xml.scopedElement("TestCase").writeAttribute("name", in.data[i]->m_name)
                        .writeAttribute("testsuite", in.data[i]->m_test_suite)
                        .writeAttribute("filename", skipPathFromFilename(in.data[i]->m_file.c_str()))
                        .writeAttribute("line", line(in.data[i]->m_line))
                        .writeAttribute("skipped", in.data[i]->m_skip);
                }
                xml.scopedElement("OverallResultsTestCases")
                        .writeAttribute("unskipped", in.run_stats->numTestCasesPassingFilters);
            } else if(opt.list_test_suites) {
                for(unsigned i = 0; i < in.num_data; ++i)
                    xml.scopedElement("TestSuite").writeAttribute("name", in.data[i]->m_test_suite);
                xml.scopedElement("OverallResultsTestCases")
                        .writeAttribute("unskipped", in.run_stats->numTestCasesPassingFilters);
                xml.scopedElement("OverallResultsTestSuites")
                        .writeAttribute("unskipped", in.run_stats->numTestSuitesPassingFilters);
            }
            xml.endElement();
        }

        void test_run_start() override {
            xml.writeDeclaration();

            // remove .exe extension - mainly to have the same output on UNIX and Windows
            std::string binary_name = skipPathFromFilename(opt.binary_name.c_str());
#ifdef DOCTEST_PLATFORM_WINDOWS
            if(binary_name.rfind(".exe") != std::string::npos)
                binary_name = binary_name.substr(0, binary_name.length() - 4);
#endif // DOCTEST_PLATFORM_WINDOWS

            xml.startElement("doctest").writeAttribute("binary", binary_name);
            if(opt.no_version == false)
                xml.writeAttribute("version", DOCTEST_VERSION_STR);

            // only the consequential ones (TODO: filters)
            xml.scopedElement("Options")
                    .writeAttribute("order_by", opt.order_by.c_str())
                    .writeAttribute("rand_seed", opt.rand_seed)
                    .writeAttribute("first", opt.first)
                    .writeAttribute("last", opt.last)
                    .writeAttribute("abort_after", opt.abort_after)
                    .writeAttribute("subcase_filter_levels", opt.subcase_filter_levels)
                    .writeAttribute("case_sensitive", opt.case_sensitive)
                    .writeAttribute("no_throw", opt.no_throw)
                    .writeAttribute("no_skip", opt.no_skip);
        }

        void test_run_end(const TestRunStats& p) override {
            if(tc) // the TestSuite tag - only if there has been at least 1 test case
                xml.endElement();

            xml.scopedElement("OverallResultsAsserts")
                    .writeAttribute("successes", p.numAsserts - p.numAssertsFailed)
                    .writeAttribute("failures", p.numAssertsFailed);

            xml.startElement("OverallResultsTestCases")
                    .writeAttribute("successes",
                                    p.numTestCasesPassingFilters - p.numTestCasesFailed)
                    .writeAttribute("failures", p.numTestCasesFailed);
            if(opt.no_skipped_summary == false)
                xml.writeAttribute("skipped", p.numTestCases - p.numTestCasesPassingFilters);
            xml.endElement();

            xml.endElement();
        }

        void test_case_start(const TestCaseData& in) override {
            test_case_start_impl(in);
            xml.ensureTagClosed();
        }

        void test_case_reenter(const TestCaseData&) override {}

        void test_case_end(const CurrentTestCaseStats& st) override {
            xml.startElement("OverallResultsAsserts")
                    .writeAttribute("successes",
                                    st.numAssertsCurrentTest - st.numAssertsFailedCurrentTest)
                    .writeAttribute("failures", st.numAssertsFailedCurrentTest)
                    .writeAttribute("test_case_success", st.testCaseSuccess);
            if(opt.duration)
                xml.writeAttribute("duration", st.seconds);
            if(tc->m_expected_failures)
                xml.writeAttribute("expected_failures", tc->m_expected_failures);
            xml.endElement();

            xml.endElement();
        }

        void test_case_exception(const TestCaseException& e) override {
            DOCTEST_LOCK_MUTEX(mutex)

            xml.scopedElement("Exception")
                    .writeAttribute("crash", e.is_crash)
                    .writeText(e.error_string.c_str());
        }

        void subcase_start(const SubcaseSignature& in) override {
            xml.startElement("SubCase")
                    .writeAttribute("name", in.m_name)
                    .writeAttribute("filename", skipPathFromFilename(in.m_file))
                    .writeAttribute("line", line(in.m_line));
            xml.ensureTagClosed();
        }

        void subcase_end() override { xml.endElement(); }

        void log_assert(const AssertData& rb) override {
            if(!rb.m_failed && !opt.success)
                return;

            DOCTEST_LOCK_MUTEX(mutex)

            xml.startElement("Expression")
                    .writeAttribute("success", !rb.m_failed)
                    .writeAttribute("type", assertString(rb.m_at))
                    .writeAttribute("filename", skipPathFromFilename(rb.m_file))
                    .writeAttribute("line", line(rb.m_line));

            xml.scopedElement("Original").writeText(rb.m_expr);

            if(rb.m_threw)
                xml.scopedElement("Exception").writeText(rb.m_exception.c_str());

            if(rb.m_at & assertType::is_throws_as)
                xml.scopedElement("ExpectedException").writeText(rb.m_exception_type);
            if(rb.m_at & assertType::is_throws_with)
                xml.scopedElement("ExpectedExceptionString").writeText(rb.m_exception_string.c_str());
            if((rb.m_at & assertType::is_normal) && !rb.m_threw)
                xml.scopedElement("Expanded").writeText(rb.m_decomp.c_str());

            log_contexts();

            xml.endElement();
        }

        void log_message(const MessageData& mb) override {
            DOCTEST_LOCK_MUTEX(mutex)

            xml.startElement("Message")
                    .writeAttribute("type", failureString(mb.m_severity))
                    .writeAttribute("filename", skipPathFromFilename(mb.m_file))
                    .writeAttribute("line", line(mb.m_line));

            xml.scopedElement("Text").writeText(mb.m_string.c_str());

            log_contexts();

            xml.endElement();
        }

        void test_case_skipped(const TestCaseData& in) override {
            if(opt.no_skipped_summary == false) {
                test_case_start_impl(in);
                xml.writeAttribute("skipped", "true");
                xml.endElement();
            }
        }
    };

    DOCTEST_REGISTER_REPORTER("xml", 0, XmlReporter);

    void fulltext_log_assert_to_stream(std::ostream& s, const AssertData& rb) {
        if((rb.m_at & (assertType::is_throws_as | assertType::is_throws_with)) ==
            0) //!OCLINT bitwise operator in conditional
            s << Color::Cyan << assertString(rb.m_at) << "( " << rb.m_expr << " ) "
                << Color::None;

        if(rb.m_at & assertType::is_throws) { //!OCLINT bitwise operator in conditional
            s << (rb.m_threw ? "threw as expected!" : "did NOT throw at all!") << "\n";
        } else if((rb.m_at & assertType::is_throws_as) &&
                    (rb.m_at & assertType::is_throws_with)) { //!OCLINT
            s << Color::Cyan << assertString(rb.m_at) << "( " << rb.m_expr << ", \""
                << rb.m_exception_string.c_str()
                << "\", " << rb.m_exception_type << " ) " << Color::None;
            if(rb.m_threw) {
                if(!rb.m_failed) {
                    s << "threw as expected!\n";
                } else {
                    s << "threw a DIFFERENT exception! (contents: " << rb.m_exception << ")\n";
                }
            } else {
                s << "did NOT throw at all!\n";
            }
        } else if(rb.m_at &
                    assertType::is_throws_as) { //!OCLINT bitwise operator in conditional
            s << Color::Cyan << assertString(rb.m_at) << "( " << rb.m_expr << ", "
                << rb.m_exception_type << " ) " << Color::None
                << (rb.m_threw ? (rb.m_threw_as ? "threw as expected!" :
                                                "threw a DIFFERENT exception: ") :
                                "did NOT throw at all!")
                << Color::Cyan << rb.m_exception << "\n";
        } else if(rb.m_at &
                    assertType::is_throws_with) { //!OCLINT bitwise operator in conditional
            s << Color::Cyan << assertString(rb.m_at) << "( " << rb.m_expr << ", \""
                << rb.m_exception_string.c_str()
                << "\" ) " << Color::None
                << (rb.m_threw ? (!rb.m_failed ? "threw as expected!" :
                                                "threw a DIFFERENT exception: ") :
                                "did NOT throw at all!")
                << Color::Cyan << rb.m_exception << "\n";
        } else if(rb.m_at & assertType::is_nothrow) { //!OCLINT bitwise operator in conditional
            s << (rb.m_threw ? "THREW exception: " : "didn't throw!") << Color::Cyan
                << rb.m_exception << "\n";
        } else {
            s << (rb.m_threw ? "THREW exception: " :
                                (!rb.m_failed ? "is correct!\n" : "is NOT correct!\n"));
            if(rb.m_threw)
                s << rb.m_exception << "\n";
            else
                s << "  values: " << assertString(rb.m_at) << "( " << rb.m_decomp << " )\n";
        }
    }

    // TODO:
    // - log_message()
    // - respond to queries
    // - honor remaining options
    // - more attributes in tags
    struct JUnitReporter : public IReporter
    {
        XmlWriter xml;
        DOCTEST_DECLARE_MUTEX(mutex)
        Timer timer;
        std::vector<String> deepestSubcaseStackNames;

        struct JUnitTestCaseData
        {
            static std::string getCurrentTimestamp() {
                // Beware, this is not reentrant because of backward compatibility issues
                // Also, UTC only, again because of backward compatibility (%z is C++11)
                time_t rawtime;
                std::time(&rawtime);
                auto const timeStampSize = sizeof("2017-01-16T17:06:45Z");

                std::tm timeInfo;
#ifdef DOCTEST_PLATFORM_WINDOWS
                gmtime_s(&timeInfo, &rawtime);
#else // DOCTEST_PLATFORM_WINDOWS
                gmtime_r(&rawtime, &timeInfo);
#endif // DOCTEST_PLATFORM_WINDOWS

                char timeStamp[timeStampSize];
                const char* const fmt = "%Y-%m-%dT%H:%M:%SZ";

                std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);
                return std::string(timeStamp);
            }

            struct JUnitTestMessage
            {
                JUnitTestMessage(const std::string& _message, const std::string& _type, const std::string& _details)
                    : message(_message), type(_type), details(_details) {}

                JUnitTestMessage(const std::string& _message, const std::string& _details)
                    : message(_message), type(), details(_details) {}

                std::string message, type, details;
            };

            struct JUnitTestCase
            {
                JUnitTestCase(const std::string& _classname, const std::string& _name)
                    : classname(_classname), name(_name), time(0), failures() {}

                std::string classname, name;
                double time;
                std::vector<JUnitTestMessage> failures, errors;
            };

            void add(const std::string& classname, const std::string& name) {
                testcases.emplace_back(classname, name);
            }

            void appendSubcaseNamesToLastTestcase(std::vector<String> nameStack) {
                for(auto& curr: nameStack)
                    if(curr.size())
                        testcases.back().name += std::string("/") + curr.c_str();
            }

            void addTime(double time) {
                if(time < 1e-4)
                    time = 0;
                testcases.back().time = time;
                totalSeconds += time;
            }

            void addFailure(const std::string& message, const std::string& type, const std::string& details) {
                testcases.back().failures.emplace_back(message, type, details);
                ++totalFailures;
            }

            void addError(const std::string& message, const std::string& details) {
                testcases.back().errors.emplace_back(message, details);
                ++totalErrors;
            }

            std::vector<JUnitTestCase> testcases;
            double totalSeconds = 0;
            int totalErrors = 0, totalFailures = 0;
        };

        JUnitTestCaseData testCaseData;

        // caching pointers/references to objects of these types - safe to do
        const ContextOptions& opt;
        const TestCaseData*   tc = nullptr;

        JUnitReporter(const ContextOptions& co)
                : xml(*co.cout)
                , opt(co) {}

        unsigned line(unsigned l) const { return opt.no_line_numbers ? 0 : l; }

        // =========================================================================================
        // WHAT FOLLOWS ARE OVERRIDES OF THE VIRTUAL METHODS OF THE REPORTER INTERFACE
        // =========================================================================================

        void report_query(const QueryData&) override {
            xml.writeDeclaration();
        }

        void test_run_start() override {
            xml.writeDeclaration();
        }

        void test_run_end(const TestRunStats& p) override {
            // remove .exe extension - mainly to have the same output on UNIX and Windows
            std::string binary_name = skipPathFromFilename(opt.binary_name.c_str());
#ifdef DOCTEST_PLATFORM_WINDOWS
            if(binary_name.rfind(".exe") != std::string::npos)
                binary_name = binary_name.substr(0, binary_name.length() - 4);
#endif // DOCTEST_PLATFORM_WINDOWS
            xml.startElement("testsuites");
            xml.startElement("testsuite").writeAttribute("name", binary_name)
                    .writeAttribute("errors", testCaseData.totalErrors)
                    .writeAttribute("failures", testCaseData.totalFailures)
                    .writeAttribute("tests", p.numAsserts);
            if(opt.no_time_in_output == false) {
                xml.writeAttribute("time", testCaseData.totalSeconds);
                xml.writeAttribute("timestamp", JUnitTestCaseData::getCurrentTimestamp());
            }
            if(opt.no_version == false)
                xml.writeAttribute("doctest_version", DOCTEST_VERSION_STR);

            for(const auto& testCase : testCaseData.testcases) {
                xml.startElement("testcase")
                    .writeAttribute("classname", testCase.classname)
                    .writeAttribute("name", testCase.name);
                if(opt.no_time_in_output == false)
                    xml.writeAttribute("time", testCase.time);
                // This is not ideal, but it should be enough to mimic gtest's junit output.
                xml.writeAttribute("status", "run");

                for(const auto& failure : testCase.failures) {
                    xml.scopedElement("failure")
                        .writeAttribute("message", failure.message)
                        .writeAttribute("type", failure.type)
                        .writeText(failure.details, false);
                }

                for(const auto& error : testCase.errors) {
                    xml.scopedElement("error")
                        .writeAttribute("message", error.message)
                        .writeText(error.details);
                }

                xml.endElement();
            }
            xml.endElement();
            xml.endElement();
        }

        void test_case_start(const TestCaseData& in) override {
            testCaseData.add(skipPathFromFilename(in.m_file.c_str()), in.m_name);
            timer.start();
        }

        void test_case_reenter(const TestCaseData& in) override {
            testCaseData.addTime(timer.getElapsedSeconds());
            testCaseData.appendSubcaseNamesToLastTestcase(deepestSubcaseStackNames);
            deepestSubcaseStackNames.clear();

            timer.start();
            testCaseData.add(skipPathFromFilename(in.m_file.c_str()), in.m_name);
        }

        void test_case_end(const CurrentTestCaseStats&) override {
            testCaseData.addTime(timer.getElapsedSeconds());
            testCaseData.appendSubcaseNamesToLastTestcase(deepestSubcaseStackNames);
            deepestSubcaseStackNames.clear();
        }

        void test_case_exception(const TestCaseException& e) override {
            DOCTEST_LOCK_MUTEX(mutex)
            testCaseData.addError("exception", e.error_string.c_str());
        }

        void subcase_start(const SubcaseSignature& in) override {
            deepestSubcaseStackNames.push_back(in.m_name);
        }

        void subcase_end() override {}

        void log_assert(const AssertData& rb) override {
            if(!rb.m_failed) // report only failures & ignore the `success` option
                return;

            DOCTEST_LOCK_MUTEX(mutex)

            std::ostringstream os;
            os << skipPathFromFilename(rb.m_file) << (opt.gnu_file_line ? ":" : "(")
              << line(rb.m_line) << (opt.gnu_file_line ? ":" : "):") << std::endl;

            fulltext_log_assert_to_stream(os, rb);
            log_contexts(os);
            testCaseData.addFailure(rb.m_decomp.c_str(), assertString(rb.m_at), os.str());
        }

        void log_message(const MessageData& mb) override {
            if(mb.m_severity & assertType::is_warn) // report only failures
                return;

            DOCTEST_LOCK_MUTEX(mutex)

            std::ostringstream os;
            os << skipPathFromFilename(mb.m_file) << (opt.gnu_file_line ? ":" : "(")
              << line(mb.m_line) << (opt.gnu_file_line ? ":" : "):") << std::endl;

            os << mb.m_string.c_str() << "\n";
            log_contexts(os);

            testCaseData.addFailure(mb.m_string.c_str(),
                mb.m_severity & assertType::is_check ? "FAIL_CHECK" : "FAIL", os.str());
        }

        void test_case_skipped(const TestCaseData&) override {}

        void log_contexts(std::ostringstream& s) {
            int num_contexts = get_num_active_contexts();
            if(num_contexts) {
                auto contexts = get_active_contexts();

                s << "  logged: ";
                for(int i = 0; i < num_contexts; ++i) {
                    s << (i == 0 ? "" : "          ");
                    contexts[i]->stringify(&s);
                    s << std::endl;
                }
            }
        }
    };

    DOCTEST_REGISTER_REPORTER("junit", 0, JUnitReporter);

    struct Whitespace
    {
        int nrSpaces;
        explicit Whitespace(int nr)
                : nrSpaces(nr) {}
    };

    std::ostream& operator<<(std::ostream& out, const Whitespace& ws) {
        if(ws.nrSpaces != 0)
            out << std::setw(ws.nrSpaces) << ' ';
        return out;
    }

    struct ConsoleReporter : public IReporter
    {
        std::ostream&                 s;
        bool                          hasLoggedCurrentTestStart;
        std::vector<SubcaseSignature> subcasesStack;
        size_t                        currentSubcaseLevel;
        DOCTEST_DECLARE_MUTEX(mutex)

        // caching pointers/references to objects of these types - safe to do
        const ContextOptions& opt;
        const TestCaseData*   tc;

        ConsoleReporter(const ContextOptions& co)
                : s(*co.cout)
                , opt(co) {}

        ConsoleReporter(const ContextOptions& co, std::ostream& ostr)
                : s(ostr)
                , opt(co) {}

        // =========================================================================================
        // WHAT FOLLOWS ARE HELPERS USED BY THE OVERRIDES OF THE VIRTUAL METHODS OF THE INTERFACE
        // =========================================================================================

        void separator_to_stream() {
            s << Color::Yellow
              << "==============================================================================="
                 "\n";
        }

        const char* getSuccessOrFailString(bool success, assertType::Enum at,
                                           const char* success_str) {
            if(success)
                return success_str;
            return failureString(at);
        }

        Color::Enum getSuccessOrFailColor(bool success, assertType::Enum at) {
            return success ? Color::BrightGreen :
                             (at & assertType::is_warn) ? Color::Yellow : Color::Red;
        }

        void successOrFailColoredStringToStream(bool success, assertType::Enum at,
                                                const char* success_str = "SUCCESS") {
            s << getSuccessOrFailColor(success, at)
              << getSuccessOrFailString(success, at, success_str) << ": ";
        }

        void log_contexts() {
            int num_contexts = get_num_active_contexts();
            if(num_contexts) {
                auto contexts = get_active_contexts();

                s << Color::None << "  logged: ";
                for(int i = 0; i < num_contexts; ++i) {
                    s << (i == 0 ? "" : "          ");
                    contexts[i]->stringify(&s);
                    s << "\n";
                }
            }

            s << "\n";
        }

        // this was requested to be made virtual so users could override it
        virtual void file_line_to_stream(const char* file, int line,
                                        const char* tail = "") {
            s << Color::LightGrey << skipPathFromFilename(file) << (opt.gnu_file_line ? ":" : "(")
            << (opt.no_line_numbers ? 0 : line) // 0 or the real num depending on the option
            << (opt.gnu_file_line ? ":" : "):") << tail;
        }

        void logTestStart() {
            if(hasLoggedCurrentTestStart)
                return;

            separator_to_stream();
            file_line_to_stream(tc->m_file.c_str(), tc->m_line, "\n");
            if(tc->m_description)
                s << Color::Yellow << "DESCRIPTION: " << Color::None << tc->m_description << "\n";
            if(tc->m_test_suite && tc->m_test_suite[0] != '\0')
                s << Color::Yellow << "TEST SUITE: " << Color::None << tc->m_test_suite << "\n";
            if(strncmp(tc->m_name, "  Scenario:", 11) != 0)
                s << Color::Yellow << "TEST CASE:  ";
            s << Color::None << tc->m_name << "\n";

            for(size_t i = 0; i < currentSubcaseLevel; ++i) {
                if(subcasesStack[i].m_name[0] != '\0')
                    s << "  " << subcasesStack[i].m_name << "\n";
            }

            if(currentSubcaseLevel != subcasesStack.size()) {
                s << Color::Yellow << "\nDEEPEST SUBCASE STACK REACHED (DIFFERENT FROM THE CURRENT ONE):\n" << Color::None;
                for(size_t i = 0; i < subcasesStack.size(); ++i) {
                    if(subcasesStack[i].m_name[0] != '\0')
                        s << "  " << subcasesStack[i].m_name << "\n";
                }
            }

            s << "\n";

            hasLoggedCurrentTestStart = true;
        }

        void printVersion() {
            if(opt.no_version == false)
                s << Color::Cyan << "[doctest] " << Color::None << "doctest version is \""
                  << DOCTEST_VERSION_STR << "\"\n";
        }

        void printIntro() {
            if(opt.no_intro == false) {
                printVersion();
                s << Color::Cyan << "[doctest] " << Color::None
                  << "run with \"--" DOCTEST_OPTIONS_PREFIX_DISPLAY "help\" for options\n";
            }
        }

        void printHelp() {
            int sizePrefixDisplay = static_cast<int>(strlen(DOCTEST_OPTIONS_PREFIX_DISPLAY));
            printVersion();
            // clang-format off
            s << Color::Cyan << "[doctest]\n" << Color::None;
            s << Color::Cyan << "[doctest] " << Color::None;
            s << "boolean values: \"1/on/yes/true\" or \"0/off/no/false\"\n";
            s << Color::Cyan << "[doctest] " << Color::None;
            s << "filter  values: \"str1,str2,str3\" (comma separated strings)\n";
            s << Color::Cyan << "[doctest]\n" << Color::None;
            s << Color::Cyan << "[doctest] " << Color::None;
            s << "filters use wildcards for matching strings\n";
            s << Color::Cyan << "[doctest] " << Color::None;
            s << "something passes a filter if any of the strings in a filter matches\n";
#ifndef DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS
            s << Color::Cyan << "[doctest]\n" << Color::None;
            s << Color::Cyan << "[doctest] " << Color::None;
            s << "ALL FLAGS, OPTIONS AND FILTERS ALSO AVAILABLE WITH A \"" DOCTEST_CONFIG_OPTIONS_PREFIX "\" PREFIX!!!\n";
#endif
            s << Color::Cyan << "[doctest]\n" << Color::None;
            s << Color::Cyan << "[doctest] " << Color::None;
            s << "Query flags - the program quits after them. Available:\n\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "?,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "help, -" DOCTEST_OPTIONS_PREFIX_DISPLAY "h                      "
              << Whitespace(sizePrefixDisplay*0) <<  "prints this message\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "v,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "version                       "
              << Whitespace(sizePrefixDisplay*1) << "prints the version\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "c,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "count                         "
              << Whitespace(sizePrefixDisplay*1) << "prints the number of matching tests\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "ltc, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "list-test-cases               "
              << Whitespace(sizePrefixDisplay*1) << "lists all matching tests by name\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "lts, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "list-test-suites              "
              << Whitespace(sizePrefixDisplay*1) << "lists all matching test suites\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "lr,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "list-reporters                "
              << Whitespace(sizePrefixDisplay*1) << "lists all registered reporters\n\n";
            // ================================================================================== << 79
            s << Color::Cyan << "[doctest] " << Color::None;
            s << "The available <int>/<string> options/filters are:\n\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "tc,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "test-case=<filters>           "
              << Whitespace(sizePrefixDisplay*1) << "filters     tests by their name\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "tce, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "test-case-exclude=<filters>   "
              << Whitespace(sizePrefixDisplay*1) << "filters OUT tests by their name\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "sf,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "source-file=<filters>         "
              << Whitespace(sizePrefixDisplay*1) << "filters     tests by their file\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "sfe, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "source-file-exclude=<filters> "
              << Whitespace(sizePrefixDisplay*1) << "filters OUT tests by their file\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "ts,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "test-suite=<filters>          "
              << Whitespace(sizePrefixDisplay*1) << "filters     tests by their test suite\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "tse, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "test-suite-exclude=<filters>  "
              << Whitespace(sizePrefixDisplay*1) << "filters OUT tests by their test suite\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "sc,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "subcase=<filters>             "
              << Whitespace(sizePrefixDisplay*1) << "filters     subcases by their name\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "sce, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "subcase-exclude=<filters>     "
              << Whitespace(sizePrefixDisplay*1) << "filters OUT subcases by their name\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "r,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "reporters=<filters>           "
              << Whitespace(sizePrefixDisplay*1) << "reporters to use (console is default)\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "o,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "out=<string>                  "
              << Whitespace(sizePrefixDisplay*1) << "output filename\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "ob,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "order-by=<string>             "
              << Whitespace(sizePrefixDisplay*1) << "how the tests should be ordered\n";
            s << Whitespace(sizePrefixDisplay*3) << "                                       <string> - [file/suite/name/rand/none]\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "rs,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "rand-seed=<int>               "
              << Whitespace(sizePrefixDisplay*1) << "seed for random ordering\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "f,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "first=<int>                   "
              << Whitespace(sizePrefixDisplay*1) << "the first test passing the filters to\n";
            s << Whitespace(sizePrefixDisplay*3) << "                                       execute - for range-based execution\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "l,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "last=<int>                    "
              << Whitespace(sizePrefixDisplay*1) << "the last test passing the filters to\n";
            s << Whitespace(sizePrefixDisplay*3) << "                                       execute - for range-based execution\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "aa,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "abort-after=<int>             "
              << Whitespace(sizePrefixDisplay*1) << "stop after <int> failed assertions\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "scfl,--" DOCTEST_OPTIONS_PREFIX_DISPLAY "subcase-filter-levels=<int>   "
              << Whitespace(sizePrefixDisplay*1) << "apply filters for the first <int> levels\n";
            s << Color::Cyan << "\n[doctest] " << Color::None;
            s << "Bool options - can be used like flags and true is assumed. Available:\n\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "s,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "success=<bool>                "
              << Whitespace(sizePrefixDisplay*1) << "include successful assertions in output\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "cs,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "case-sensitive=<bool>         "
              << Whitespace(sizePrefixDisplay*1) << "filters being treated as case sensitive\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "e,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "exit=<bool>                   "
              << Whitespace(sizePrefixDisplay*1) << "exits after the tests finish\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "d,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "duration=<bool>               "
              << Whitespace(sizePrefixDisplay*1) << "prints the time duration of each test\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "m,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "minimal=<bool>                "
              << Whitespace(sizePrefixDisplay*1) << "minimal console output (only failures)\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "q,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "quiet=<bool>                  "
              << Whitespace(sizePrefixDisplay*1) << "no console output\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "nt,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-throw=<bool>               "
              << Whitespace(sizePrefixDisplay*1) << "skips exceptions-related assert checks\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "ne,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-exitcode=<bool>            "
              << Whitespace(sizePrefixDisplay*1) << "returns (or exits) always with success\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "nr,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-run=<bool>                 "
              << Whitespace(sizePrefixDisplay*1) << "skips all runtime doctest operations\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "ni,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-intro=<bool>               "
              << Whitespace(sizePrefixDisplay*1) << "omit the framework intro in the output\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "nv,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-version=<bool>             "
              << Whitespace(sizePrefixDisplay*1) << "omit the framework version in the output\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "nc,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-colors=<bool>              "
              << Whitespace(sizePrefixDisplay*1) << "disables colors in output\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "fc,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "force-colors=<bool>           "
              << Whitespace(sizePrefixDisplay*1) << "use colors even when not in a tty\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "nb,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-breaks=<bool>              "
              << Whitespace(sizePrefixDisplay*1) << "disables breakpoints in debuggers\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "ns,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-skip=<bool>                "
              << Whitespace(sizePrefixDisplay*1) << "don't skip test cases marked as skip\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "gfl, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "gnu-file-line=<bool>          "
              << Whitespace(sizePrefixDisplay*1) << ":n: vs (n): for line numbers in output\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "npf, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-path-filenames=<bool>      "
              << Whitespace(sizePrefixDisplay*1) << "only filenames and no paths in output\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "nln, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-line-numbers=<bool>        "
              << Whitespace(sizePrefixDisplay*1) << "0 instead of real line numbers in output\n";
            // ================================================================================== << 79
            // clang-format on

            s << Color::Cyan << "\n[doctest] " << Color::None;
            s << "for more information visit the project documentation\n\n";
        }

        void printRegisteredReporters() {
            printVersion();
            auto printReporters = [this] (const reporterMap& reporters, const char* type) {
                if(reporters.size()) {
                    s << Color::Cyan << "[doctest] " << Color::None << "listing all registered " << type << "\n";
                    for(auto& curr : reporters)
                        s << "priority: " << std::setw(5) << curr.first.first
                          << " name: " << curr.first.second << "\n";
                }
            };
            printReporters(getListeners(), "listeners");
            printReporters(getReporters(), "reporters");
        }

        // =========================================================================================
        // WHAT FOLLOWS ARE OVERRIDES OF THE VIRTUAL METHODS OF THE REPORTER INTERFACE
        // =========================================================================================

        void report_query(const QueryData& in) override {
            if(opt.version) {
                printVersion();
            } else if(opt.help) {
                printHelp();
            } else if(opt.list_reporters) {
                printRegisteredReporters();
            } else if(opt.count || opt.list_test_cases) {
                if(opt.list_test_cases) {
                    s << Color::Cyan << "[doctest] " << Color::None
                      << "listing all test case names\n";
                    separator_to_stream();
                }

                for(unsigned i = 0; i < in.num_data; ++i)
                    s << Color::None << in.data[i]->m_name << "\n";

                separator_to_stream();

                s << Color::Cyan << "[doctest] " << Color::None
                  << "unskipped test cases passing the current filters: "
                  << g_cs->numTestCasesPassingFilters << "\n";

            } else if(opt.list_test_suites) {
                s << Color::Cyan << "[doctest] " << Color::None << "listing all test suites\n";
                separator_to_stream();

                for(unsigned i = 0; i < in.num_data; ++i)
                    s << Color::None << in.data[i]->m_test_suite << "\n";

                separator_to_stream();

                s << Color::Cyan << "[doctest] " << Color::None
                  << "unskipped test cases passing the current filters: "
                  << g_cs->numTestCasesPassingFilters << "\n";
                s << Color::Cyan << "[doctest] " << Color::None
                  << "test suites with unskipped test cases passing the current filters: "
                  << g_cs->numTestSuitesPassingFilters << "\n";
            }
        }

        void test_run_start() override {
            if(!opt.minimal)
                printIntro();
        }

        void test_run_end(const TestRunStats& p) override {
            if(opt.minimal && p.numTestCasesFailed == 0)
                return;

            separator_to_stream();
            s << std::dec;

            auto totwidth = int(std::ceil(log10(static_cast<double>(std::max(p.numTestCasesPassingFilters, static_cast<unsigned>(p.numAsserts))) + 1)));
            auto passwidth = int(std::ceil(log10(static_cast<double>(std::max(p.numTestCasesPassingFilters - p.numTestCasesFailed, static_cast<unsigned>(p.numAsserts - p.numAssertsFailed))) + 1)));
            auto failwidth = int(std::ceil(log10(static_cast<double>(std::max(p.numTestCasesFailed, static_cast<unsigned>(p.numAssertsFailed))) + 1)));
            const bool anythingFailed = p.numTestCasesFailed > 0 || p.numAssertsFailed > 0;
            s << Color::Cyan << "[doctest] " << Color::None << "test cases: " << std::setw(totwidth)
              << p.numTestCasesPassingFilters << " | "
              << ((p.numTestCasesPassingFilters == 0 || anythingFailed) ? Color::None :
                                                                          Color::Green)
              << std::setw(passwidth) << p.numTestCasesPassingFilters - p.numTestCasesFailed << " passed"
              << Color::None << " | " << (p.numTestCasesFailed > 0 ? Color::Red : Color::None)
              << std::setw(failwidth) << p.numTestCasesFailed << " failed" << Color::None << " |";
            if(opt.no_skipped_summary == false) {
                const int numSkipped = p.numTestCases - p.numTestCasesPassingFilters;
                s << " " << (numSkipped == 0 ? Color::None : Color::Yellow) << numSkipped
                  << " skipped" << Color::None;
            }
            s << "\n";
            s << Color::Cyan << "[doctest] " << Color::None << "assertions: " << std::setw(totwidth)
              << p.numAsserts << " | "
              << ((p.numAsserts == 0 || anythingFailed) ? Color::None : Color::Green)
              << std::setw(passwidth) << (p.numAsserts - p.numAssertsFailed) << " passed" << Color::None
              << " | " << (p.numAssertsFailed > 0 ? Color::Red : Color::None) << std::setw(failwidth)
              << p.numAssertsFailed << " failed" << Color::None << " |\n";
            s << Color::Cyan << "[doctest] " << Color::None
              << "Status: " << (p.numTestCasesFailed > 0 ? Color::Red : Color::Green)
              << ((p.numTestCasesFailed > 0) ? "FAILURE!" : "SUCCESS!") << Color::None << std::endl;
        }

        void test_case_start(const TestCaseData& in) override {
            hasLoggedCurrentTestStart = false;
            tc                        = &in;
            subcasesStack.clear();
            currentSubcaseLevel = 0;
        }

        void test_case_reenter(const TestCaseData&) override {
            subcasesStack.clear();
        }

        void test_case_end(const CurrentTestCaseStats& st) override {
            if(tc->m_no_output)
                return;

            // log the preamble of the test case only if there is something
            // else to print - something other than that an assert has failed
            if(opt.duration ||
               (st.failure_flags && st.failure_flags != static_cast<int>(TestCaseFailureReason::AssertFailure)))
                logTestStart();

            if(opt.duration)
                s << Color::None << std::setprecision(6) << std::fixed << st.seconds
                  << " s: " << tc->m_name << "\n";

            if(st.failure_flags & TestCaseFailureReason::Timeout)
                s << Color::Red << "Test case exceeded time limit of " << std::setprecision(6)
                  << std::fixed << tc->m_timeout << "!\n";

            if(st.failure_flags & TestCaseFailureReason::ShouldHaveFailedButDidnt) {
                s << Color::Red << "Should have failed but didn't! Marking it as failed!\n";
            } else if(st.failure_flags & TestCaseFailureReason::ShouldHaveFailedAndDid) {
                s << Color::Yellow << "Failed as expected so marking it as not failed\n";
            } else if(st.failure_flags & TestCaseFailureReason::CouldHaveFailedAndDid) {
                s << Color::Yellow << "Allowed to fail so marking it as not failed\n";
            } else if(st.failure_flags & TestCaseFailureReason::DidntFailExactlyNumTimes) {
                s << Color::Red << "Didn't fail exactly " << tc->m_expected_failures
                  << " times so marking it as failed!\n";
            } else if(st.failure_flags & TestCaseFailureReason::FailedExactlyNumTimes) {
                s << Color::Yellow << "Failed exactly " << tc->m_expected_failures
                  << " times as expected so marking it as not failed!\n";
            }
            if(st.failure_flags & TestCaseFailureReason::TooManyFailedAsserts) {
                s << Color::Red << "Aborting - too many failed asserts!\n";
            }
            s << Color::None; // lgtm [cpp/useless-expression]
        }

        void test_case_exception(const TestCaseException& e) override {
            DOCTEST_LOCK_MUTEX(mutex)
            if(tc->m_no_output)
                return;

            logTestStart();

            file_line_to_stream(tc->m_file.c_str(), tc->m_line, " ");
            successOrFailColoredStringToStream(false, e.is_crash ? assertType::is_require :
                                                                   assertType::is_check);
            s << Color::Red << (e.is_crash ? "test case CRASHED: " : "test case THREW exception: ")
              << Color::Cyan << e.error_string << "\n";

            int num_stringified_contexts = get_num_stringified_contexts();
            if(num_stringified_contexts) {
                auto stringified_contexts = get_stringified_contexts();
                s << Color::None << "  logged: ";
                for(int i = num_stringified_contexts; i > 0; --i) {
                    s << (i == num_stringified_contexts ? "" : "          ")
                      << stringified_contexts[i - 1] << "\n";
                }
            }
            s << "\n" << Color::None;
        }

        void subcase_start(const SubcaseSignature& subc) override {
            subcasesStack.push_back(subc);
            ++currentSubcaseLevel;
            hasLoggedCurrentTestStart = false;
        }

        void subcase_end() override {
            --currentSubcaseLevel;
            hasLoggedCurrentTestStart = false;
        }

        void log_assert(const AssertData& rb) override {
            if((!rb.m_failed && !opt.success) || tc->m_no_output)
                return;

            DOCTEST_LOCK_MUTEX(mutex)

            logTestStart();

            file_line_to_stream(rb.m_file, rb.m_line, " ");
            successOrFailColoredStringToStream(!rb.m_failed, rb.m_at);

            fulltext_log_assert_to_stream(s, rb);

            log_contexts();
        }

        void log_message(const MessageData& mb) override {
            if(tc->m_no_output)
                return;

            DOCTEST_LOCK_MUTEX(mutex)

            logTestStart();

            file_line_to_stream(mb.m_file, mb.m_line, " ");
            s << getSuccessOrFailColor(false, mb.m_severity)
              << getSuccessOrFailString(mb.m_severity & assertType::is_warn, mb.m_severity,
                                        "MESSAGE") << ": ";
            s << Color::None << mb.m_string << "\n";
            log_contexts();
        }

        void test_case_skipped(const TestCaseData&) override {}
    };

    DOCTEST_REGISTER_REPORTER("console", 0, ConsoleReporter);

#ifdef DOCTEST_PLATFORM_WINDOWS
    struct DebugOutputWindowReporter : public ConsoleReporter
    {
        DOCTEST_THREAD_LOCAL static std::ostringstream oss;

        DebugOutputWindowReporter(const ContextOptions& co)
                : ConsoleReporter(co, oss) {}

#define DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(func, type, arg)                                    \
    void func(type arg) override {                                                                 \
        bool with_col = g_no_colors;                                                               \
        g_no_colors   = false;                                                                     \
        ConsoleReporter::func(arg);                                                                \
        if(oss.tellp() != std::streampos{}) {                                                      \
            DOCTEST_OUTPUT_DEBUG_STRING(oss.str().c_str());                                        \
            oss.str("");                                                                           \
        }                                                                                          \
        g_no_colors = with_col;                                                                    \
    }

        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_run_start, DOCTEST_EMPTY, DOCTEST_EMPTY)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_run_end, const TestRunStats&, in)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_start, const TestCaseData&, in)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_reenter, const TestCaseData&, in)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_end, const CurrentTestCaseStats&, in)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_exception, const TestCaseException&, in)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(subcase_start, const SubcaseSignature&, in)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(subcase_end, DOCTEST_EMPTY, DOCTEST_EMPTY)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(log_assert, const AssertData&, in)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(log_message, const MessageData&, in)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_skipped, const TestCaseData&, in)
    };

    DOCTEST_THREAD_LOCAL std::ostringstream DebugOutputWindowReporter::oss;
#endif // DOCTEST_PLATFORM_WINDOWS

    // the implementation of parseOption()
    bool parseOptionImpl(int argc, const char* const* argv, const char* pattern, String* value) {
        // going from the end to the beginning and stopping on the first occurrence from the end
        for(int i = argc; i > 0; --i) {
            auto index = i - 1;
            auto temp = std::strstr(argv[index], pattern);
            if(temp && (value || strlen(temp) == strlen(pattern))) { //!OCLINT prefer early exits and continue
                // eliminate matches in which the chars before the option are not '-'
                bool noBadCharsFound = true;
                auto curr            = argv[index];
                while(curr != temp) {
                    if(*curr++ != '-') {
                        noBadCharsFound = false;
                        break;
                    }
                }
                if(noBadCharsFound && argv[index][0] == '-') {
                    if(value) {
                        // parsing the value of an option
                        temp += strlen(pattern);
                        const unsigned len = strlen(temp);
                        if(len) {
                            *value = temp;
                            return true;
                        }
                    } else {
                        // just a flag - no value
                        return true;
                    }
                }
            }
        }
        return false;
    }

    // parses an option and returns the string after the '=' character
    bool parseOption(int argc, const char* const* argv, const char* pattern, String* value = nullptr,
                     const String& defaultVal = String()) {
        if(value)
            *value = defaultVal;
#ifndef DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS
        // offset (normally 3 for "dt-") to skip prefix
        if(parseOptionImpl(argc, argv, pattern + strlen(DOCTEST_CONFIG_OPTIONS_PREFIX), value))
            return true;
#endif // DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS
        return parseOptionImpl(argc, argv, pattern, value);
    }

    // locates a flag on the command line
    bool parseFlag(int argc, const char* const* argv, const char* pattern) {
        return parseOption(argc, argv, pattern);
    }

    // parses a comma separated list of words after a pattern in one of the arguments in argv
    bool parseCommaSepArgs(int argc, const char* const* argv, const char* pattern,
                           std::vector<String>& res) {
        String filtersString;
        if(parseOption(argc, argv, pattern, &filtersString)) {
            // tokenize with "," as a separator, unless escaped with backslash
            std::ostringstream s;
            auto flush = [&s, &res]() {
                auto string = s.str();
                if(string.size() > 0) {
                    res.push_back(string.c_str());
                }
                s.str("");
            };

            bool seenBackslash = false;
            const char* current = filtersString.c_str();
            const char* end = current + strlen(current);
            while(current != end) {
                char character = *current++;
                if(seenBackslash) {
                    seenBackslash = false;
                    if(character == ',' || character == '\\') {
                        s.put(character);
                        continue;
                    }
                    s.put('\\');
                }
                if(character == '\\') {
                    seenBackslash = true;
                } else if(character == ',') {
                    flush();
                } else {
                    s.put(character);
                }
            }

            if(seenBackslash) {
                s.put('\\');
            }
            flush();
            return true;
        }
        return false;
    }

    enum optionType
    {
        option_bool,
        option_int
    };

    // parses an int/bool option from the command line
    bool parseIntOption(int argc, const char* const* argv, const char* pattern, optionType type,
                        int& res) {
        String parsedValue;
        if(!parseOption(argc, argv, pattern, &parsedValue))
            return false;

        if(type) {
            // integer
            // TODO: change this to use std::stoi or something else! currently it uses undefined behavior - assumes '0' on failed parse...
            int theInt = std::atoi(parsedValue.c_str());
            if (theInt != 0) {
                res = theInt; //!OCLINT parameter reassignment
                return true;
            }
        } else {
            // boolean
            const char positive[][5] = { "1", "true", "on", "yes" };  // 5 - strlen("true") + 1
            const char negative[][6] = { "0", "false", "off", "no" }; // 6 - strlen("false") + 1

            // if the value matches any of the positive/negative possibilities
            for (unsigned i = 0; i < 4; i++) {
                if (parsedValue.compare(positive[i], true) == 0) {
                    res = 1; //!OCLINT parameter reassignment
                    return true;
                }
                if (parsedValue.compare(negative[i], true) == 0) {
                    res = 0; //!OCLINT parameter reassignment
                    return true;
                }
            }
        }
        return false;
    }
} // namespace

Context::Context(int argc, const char* const* argv)
        : p(new detail::ContextState) {
    parseArgs(argc, argv, true);
    if(argc)
        p->binary_name = argv[0];
}

Context::~Context() {
    if(g_cs == p)
        g_cs = nullptr;
    delete p;
}

void Context::applyCommandLine(int argc, const char* const* argv) {
    parseArgs(argc, argv);
    if(argc)
        p->binary_name = argv[0];
}

// parses args
void Context::parseArgs(int argc, const char* const* argv, bool withDefaults) {
    using namespace detail;

    // clang-format off
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "source-file=",        p->filters[0]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "sf=",                 p->filters[0]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "source-file-exclude=",p->filters[1]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "sfe=",                p->filters[1]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "test-suite=",         p->filters[2]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "ts=",                 p->filters[2]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "test-suite-exclude=", p->filters[3]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "tse=",                p->filters[3]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "test-case=",          p->filters[4]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "tc=",                 p->filters[4]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "test-case-exclude=",  p->filters[5]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "tce=",                p->filters[5]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "subcase=",            p->filters[6]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "sc=",                 p->filters[6]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "subcase-exclude=",    p->filters[7]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "sce=",                p->filters[7]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "reporters=",          p->filters[8]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "r=",                  p->filters[8]);
    // clang-format on

    int    intRes = 0;
    String strRes;

#define DOCTEST_PARSE_AS_BOOL_OR_FLAG(name, sname, var, default)                                   \
    if(parseIntOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX name "=", option_bool, intRes) ||  \
       parseIntOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX sname "=", option_bool, intRes))   \
        p->var = static_cast<bool>(intRes);                                                        \
    else if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX name) ||                           \
            parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX sname))                            \
        p->var = true;                                                                             \
    else if(withDefaults)                                                                          \
    p->var = default

#define DOCTEST_PARSE_INT_OPTION(name, sname, var, default)                                        \
    if(parseIntOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX name "=", option_int, intRes) ||   \
       parseIntOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX sname "=", option_int, intRes))    \
        p->var = intRes;                                                                           \
    else if(withDefaults)                                                                          \
    p->var = default

#define DOCTEST_PARSE_STR_OPTION(name, sname, var, default)                                        \
    if(parseOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX name "=", &strRes, default) ||        \
       parseOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX sname "=", &strRes, default) ||       \
       withDefaults)                                                                               \
    p->var = strRes

    // clang-format off
    DOCTEST_PARSE_STR_OPTION("out", "o", out, "");
    DOCTEST_PARSE_STR_OPTION("order-by", "ob", order_by, "file");
    DOCTEST_PARSE_INT_OPTION("rand-seed", "rs", rand_seed, 0);

    DOCTEST_PARSE_INT_OPTION("first", "f", first, 0);
    DOCTEST_PARSE_INT_OPTION("last", "l", last, UINT_MAX);

    DOCTEST_PARSE_INT_OPTION("abort-after", "aa", abort_after, 0);
    DOCTEST_PARSE_INT_OPTION("subcase-filter-levels", "scfl", subcase_filter_levels, INT_MAX);

    DOCTEST_PARSE_AS_BOOL_OR_FLAG("success", "s", success, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("case-sensitive", "cs", case_sensitive, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("exit", "e", exit, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("duration", "d", duration, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("minimal", "m", minimal, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("quiet", "q", quiet, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-throw", "nt", no_throw, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-exitcode", "ne", no_exitcode, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-run", "nr", no_run, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-intro", "ni", no_intro, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-version", "nv", no_version, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-colors", "nc", no_colors, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("force-colors", "fc", force_colors, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-breaks", "nb", no_breaks, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-skip", "ns", no_skip, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("gnu-file-line", "gfl", gnu_file_line, !bool(DOCTEST_MSVC));
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-path-filenames", "npf", no_path_in_filenames, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-line-numbers", "nln", no_line_numbers, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-debug-output", "ndo", no_debug_output, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-skipped-summary", "nss", no_skipped_summary, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-time-in-output", "ntio", no_time_in_output, false);
    // clang-format on

    if(withDefaults) {
        p->help             = false;
        p->version          = false;
        p->count            = false;
        p->list_test_cases  = false;
        p->list_test_suites = false;
        p->list_reporters   = false;
    }
    if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "help") ||
       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "h") ||
       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "?")) {
        p->help = true;
        p->exit = true;
    }
    if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "version") ||
       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "v")) {
        p->version = true;
        p->exit    = true;
    }
    if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "count") ||
       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "c")) {
        p->count = true;
        p->exit  = true;
    }
    if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "list-test-cases") ||
       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "ltc")) {
        p->list_test_cases = true;
        p->exit            = true;
    }
    if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "list-test-suites") ||
       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "lts")) {
        p->list_test_suites = true;
        p->exit             = true;
    }
    if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "list-reporters") ||
       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "lr")) {
        p->list_reporters = true;
        p->exit           = true;
    }
}

// allows the user to add procedurally to the filters from the command line
void Context::addFilter(const char* filter, const char* value) { setOption(filter, value); }

// allows the user to clear all filters from the command line
void Context::clearFilters() {
    for(auto& curr : p->filters)
        curr.clear();
}

// allows the user to override procedurally the bool options from the command line
void Context::setOption(const char* option, bool value) {
    setOption(option, value ? "true" : "false");
}

// allows the user to override procedurally the int options from the command line
void Context::setOption(const char* option, int value) {
    setOption(option, toString(value).c_str());
}

// allows the user to override procedurally the string options from the command line
void Context::setOption(const char* option, const char* value) {
    auto argv   = String("-") + option + "=" + value;
    auto lvalue = argv.c_str();
    parseArgs(1, &lvalue);
}

// users should query this in their main() and exit the program if true
bool Context::shouldExit() { return p->exit; }

void Context::setAsDefaultForAssertsOutOfTestCases() { g_cs = p; }

void Context::setAssertHandler(detail::assert_handler ah) { p->ah = ah; }

void Context::setCout(std::ostream* out) { p->cout = out; }

static class DiscardOStream : public std::ostream
{
private:
    class : public std::streambuf
    {
    private:
        // allowing some buffering decreases the amount of calls to overflow
        char buf[1024];

    protected:
        std::streamsize xsputn(const char_type*, std::streamsize count) override { return count; }

        int_type overflow(int_type ch) override {
            setp(std::begin(buf), std::end(buf));
            return traits_type::not_eof(ch);
        }
    } discardBuf;

public:
    DiscardOStream()
            : std::ostream(&discardBuf) {}
} discardOut;

// the main function that does all the filtering and test running
int Context::run() {
    using namespace detail;

    // save the old context state in case such was setup - for using asserts out of a testing context
    auto old_cs = g_cs;
    // this is the current contest
    g_cs               = p;
    is_running_in_test = true;

    g_no_colors = p->no_colors;
    p->resetRunData();

    std::fstream fstr;
    if(p->cout == nullptr) {
        if(p->quiet) {
            p->cout = &discardOut;
        } else if(p->out.size()) {
            // to a file if specified
            fstr.open(p->out.c_str(), std::fstream::out);
            p->cout = &fstr;
        } else {
#ifndef DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
            // stdout by default
            p->cout = &std::cout;
#else // DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
            return EXIT_FAILURE;
#endif // DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
        }
    }

    FatalConditionHandler::allocateAltStackMem();

    auto cleanup_and_return = [&]() {
        FatalConditionHandler::freeAltStackMem();

        if(fstr.is_open())
            fstr.close();

        // restore context
        g_cs               = old_cs;
        is_running_in_test = false;

        // we have to free the reporters which were allocated when the run started
        for(auto& curr : p->reporters_currently_used)
            delete curr;
        p->reporters_currently_used.clear();

        if(p->numTestCasesFailed && !p->no_exitcode)
            return EXIT_FAILURE;
        return EXIT_SUCCESS;
    };

    // setup default reporter if none is given through the command line
    if(p->filters[8].empty())
        p->filters[8].push_back("console");

    // check to see if any of the registered reporters has been selected
    for(auto& curr : getReporters()) {
        if(matchesAny(curr.first.second.c_str(), p->filters[8], false, p->case_sensitive))
            p->reporters_currently_used.push_back(curr.second(*g_cs));
    }

    // TODO: check if there is nothing in reporters_currently_used

    // prepend all listeners
    for(auto& curr : getListeners())
        p->reporters_currently_used.insert(p->reporters_currently_used.begin(), curr.second(*g_cs));

#ifdef DOCTEST_PLATFORM_WINDOWS
    if(isDebuggerActive() && p->no_debug_output == false)
        p->reporters_currently_used.push_back(new DebugOutputWindowReporter(*g_cs));
#endif // DOCTEST_PLATFORM_WINDOWS

    // handle version, help and no_run
    if(p->no_run || p->version || p->help || p->list_reporters) {
        DOCTEST_ITERATE_THROUGH_REPORTERS(report_query, QueryData());

        return cleanup_and_return();
    }

    std::vector<const TestCase*> testArray;
    for(auto& curr : getRegisteredTests())
        testArray.push_back(&curr);
    p->numTestCases = testArray.size();

    // sort the collected records
    if(!testArray.empty()) {
        if(p->order_by.compare("file", true) == 0) {
            std::sort(testArray.begin(), testArray.end(), fileOrderComparator);
        } else if(p->order_by.compare("suite", true) == 0) {
            std::sort(testArray.begin(), testArray.end(), suiteOrderComparator);
        } else if(p->order_by.compare("name", true) == 0) {
            std::sort(testArray.begin(), testArray.end(), nameOrderComparator);
        } else if(p->order_by.compare("rand", true) == 0) {
            std::srand(p->rand_seed);

            // random_shuffle implementation
            const auto first = &testArray[0];
            for(size_t i = testArray.size() - 1; i > 0; --i) {
                int idxToSwap = std::rand() % (i + 1);

                const auto temp = first[i];

                first[i]         = first[idxToSwap];
                first[idxToSwap] = temp;
            }
        } else if(p->order_by.compare("none", true) == 0) {
            // means no sorting - beneficial for death tests which call into the executable
            // with a specific test case in mind - we don't want to slow down the startup times
        }
    }

    std::set<String> testSuitesPassingFilt;

    bool                             query_mode = p->count || p->list_test_cases || p->list_test_suites;
    std::vector<const TestCaseData*> queryResults;

    if(!query_mode)
        DOCTEST_ITERATE_THROUGH_REPORTERS(test_run_start, DOCTEST_EMPTY);

    // invoke the registered functions if they match the filter criteria (or just count them)
    for(auto& curr : testArray) {
        const auto& tc = *curr;

        bool skip_me = false;
        if(tc.m_skip && !p->no_skip)
            skip_me = true;

        if(!matchesAny(tc.m_file.c_str(), p->filters[0], true, p->case_sensitive))
            skip_me = true;
        if(matchesAny(tc.m_file.c_str(), p->filters[1], false, p->case_sensitive))
            skip_me = true;
        if(!matchesAny(tc.m_test_suite, p->filters[2], true, p->case_sensitive))
            skip_me = true;
        if(matchesAny(tc.m_test_suite, p->filters[3], false, p->case_sensitive))
            skip_me = true;
        if(!matchesAny(tc.m_name, p->filters[4], true, p->case_sensitive))
            skip_me = true;
        if(matchesAny(tc.m_name, p->filters[5], false, p->case_sensitive))
            skip_me = true;

        if(!skip_me)
            p->numTestCasesPassingFilters++;

        // skip the test if it is not in the execution range
        if((p->last < p->numTestCasesPassingFilters && p->first <= p->last) ||
           (p->first > p->numTestCasesPassingFilters))
            skip_me = true;

        if(skip_me) {
            if(!query_mode)
                DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_skipped, tc);
            continue;
        }

        // do not execute the test if we are to only count the number of filter passing tests
        if(p->count)
            continue;

        // print the name of the test and don't execute it
        if(p->list_test_cases) {
            queryResults.push_back(&tc);
            continue;
        }

        // print the name of the test suite if not done already and don't execute it
        if(p->list_test_suites) {
            if((testSuitesPassingFilt.count(tc.m_test_suite) == 0) && tc.m_test_suite[0] != '\0') {
                queryResults.push_back(&tc);
                testSuitesPassingFilt.insert(tc.m_test_suite);
                p->numTestSuitesPassingFilters++;
            }
            continue;
        }

        // execute the test if it passes all the filtering
        {
            p->currentTest = &tc;

            p->failure_flags = TestCaseFailureReason::None;
            p->seconds       = 0;

            // reset atomic counters
            p->numAssertsFailedCurrentTest_atomic = 0;
            p->numAssertsCurrentTest_atomic       = 0;

            p->fullyTraversedSubcases.clear();

            DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_start, tc);

            p->timer.start();

            bool run_test = true;

            do {
                // reset some of the fields for subcases (except for the set of fully passed ones)
                p->reachedLeaf = false;
                // May not be empty if previous subcase exited via exception.
                p->subcaseStack.clear();
                p->currentSubcaseDepth = 0;

                p->shouldLogCurrentException = true;

                // reset stuff for logging with INFO()
                p->stringifiedContexts.clear();

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
                try {
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS
// MSVC 2015 diagnoses fatalConditionHandler as unused (because reset() is a static method)
DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4101) // unreferenced local variable
                    FatalConditionHandler fatalConditionHandler; // Handle signals
                    // execute the test
                    tc.m_test();
                    fatalConditionHandler.reset();
DOCTEST_MSVC_SUPPRESS_WARNING_POP
#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
                } catch(const TestFailureException&) {
                    p->failure_flags |= TestCaseFailureReason::AssertFailure;
                } catch(...) {
                    DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_exception,
                                                      {translateActiveException(), false});
                    p->failure_flags |= TestCaseFailureReason::Exception;
                }
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS

                // exit this loop if enough assertions have failed - even if there are more subcases
                if(p->abort_after > 0 &&
                   p->numAssertsFailed + p->numAssertsFailedCurrentTest_atomic >= p->abort_after) {
                    run_test = false;
                    p->failure_flags |= TestCaseFailureReason::TooManyFailedAsserts;
                }

                if(!p->nextSubcaseStack.empty() && run_test)
                    DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_reenter, tc);
                if(p->nextSubcaseStack.empty())
                    run_test = false;
            } while(run_test);

            p->finalizeTestCaseData();

            DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_end, *g_cs);

            p->currentTest = nullptr;

            // stop executing tests if enough assertions have failed
            if(p->abort_after > 0 && p->numAssertsFailed >= p->abort_after)
                break;
        }
    }

    if(!query_mode) {
        DOCTEST_ITERATE_THROUGH_REPORTERS(test_run_end, *g_cs);
    } else {
        QueryData qdata;
        qdata.run_stats = g_cs;
        qdata.data      = queryResults.data();
        qdata.num_data  = unsigned(queryResults.size());
        DOCTEST_ITERATE_THROUGH_REPORTERS(report_query, qdata);
    }

    return cleanup_and_return();
}

DOCTEST_DEFINE_INTERFACE(IReporter)

int IReporter::get_num_active_contexts() { return detail::g_infoContexts.size(); }
const IContextScope* const* IReporter::get_active_contexts() {
    return get_num_active_contexts() ? &detail::g_infoContexts[0] : nullptr;
}

int IReporter::get_num_stringified_contexts() { return detail::g_cs->stringifiedContexts.size(); }
const String* IReporter::get_stringified_contexts() {
    return get_num_stringified_contexts() ? &detail::g_cs->stringifiedContexts[0] : nullptr;
}

namespace detail {
    void registerReporterImpl(const char* name, int priority, reporterCreatorFunc c, bool isReporter) {
        if(isReporter)
            getReporters().insert(reporterMap::value_type(reporterMap::key_type(priority, name), c));
        else
            getListeners().insert(reporterMap::value_type(reporterMap::key_type(priority, name), c));
    }
} // namespace detail

} // namespace doctest

#endif // DOCTEST_CONFIG_DISABLE

#ifdef DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4007) // 'function' : must be 'attribute' - see issue #182
int main(int argc, char** argv) { return doctest::Context(argc, argv).run(); }
DOCTEST_MSVC_SUPPRESS_WARNING_POP
#endif // DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN

DOCTEST_CLANG_SUPPRESS_WARNING_POP
DOCTEST_MSVC_SUPPRESS_WARNING_POP
DOCTEST_GCC_SUPPRESS_WARNING_POP

DOCTEST_SUPPRESS_COMMON_WARNINGS_POP

#endif // DOCTEST_LIBRARY_IMPLEMENTATION
#endif // DOCTEST_CONFIG_IMPLEMENT

#ifdef DOCTEST_UNDEF_WIN32_LEAN_AND_MEAN
#undef WIN32_LEAN_AND_MEAN
#undef DOCTEST_UNDEF_WIN32_LEAN_AND_MEAN
#endif // DOCTEST_UNDEF_WIN32_LEAN_AND_MEAN

#ifdef DOCTEST_UNDEF_NOMINMAX
#undef NOMINMAX
#undef DOCTEST_UNDEF_NOMINMAX
#endif // DOCTEST_UNDEF_NOMINMAX



================================================
FILE: external/doctest/.clang-format
================================================
DisableFormat: true
SortIncludes: Never



================================================
FILE: Source/AMRInterpolator/AMRInterpolator.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef AMRINTERPOLATOR_HPP_
#define AMRINTERPOLATOR_HPP_

// Our includes
#include "BoundaryConditions.hpp"
#include "GRAMR.hpp"
#include "InterpSource.hpp"
#include "InterpolationAlgorithm.hpp"
#include "InterpolationLayout.hpp"
#include "InterpolationQuery.hpp"

#include "MPIContext.hpp"
#include "StateVariables.hpp"

// system includes
#include <limits>

// End include

template <typename InterpAlgo> class AMRInterpolator
{
  public:
    // constructor for backward compatibility
    // (adds an artificial BC with only periodic BC)
    AMRInterpolator(const GRAMR &amr,
                    const std::array<double, AMREX_SPACEDIM> &coarsest_origin,
                    const std::array<double, AMREX_SPACEDIM> &coarsest_dx,
                    int verbosity = 0);
    AMRInterpolator(const GRAMR &amr,
                    const std::array<double, AMREX_SPACEDIM> &coarsest_origin,
                    const std::array<double, AMREX_SPACEDIM> &coarsest_dx,
                    BoundaryConditions::params_t a_bc_params,
                    int verbosity = 0);

    void refresh(const bool a_fill_ghosts = true);

    // if not filling ghosts in refresh, call this explicitly for required vars
    // xxxxx    void fill_multilevel_ghosts(
    //         const VariableType a_var_type,
    //         const Interval &a_comps = Interval(0,
    //         std::numeric_limits<int>::max()), const int a_min_level = 0,
    //         const int a_max_level = std::numeric_limits<int>::max());

    void limit_num_levels(unsigned int num_levels);
    void interp(InterpolationQuery &query);
    // xxxxx    const AMR &getAMR() const;
    const std::array<double, AMREX_SPACEDIM> &get_coarsest_dx();
    const std::array<double, AMREX_SPACEDIM> &get_coarsest_origin();

  private:
    void computeLevelLayouts();
    InterpolationLayout findBoxes(InterpolationQuery &query);

    void prepareMPI(InterpolationQuery &query,
                    const InterpolationLayout &layout);
    void exchangeMPIQuery();
    void calculateAnswers(InterpolationQuery &query);
    void exchangeMPIAnswer();

    /// set values of member 'm_lo_boundary_reflective' and
    /// 'm_hi_boundary_reflective'
    void set_reflective_BC();
    int get_state_var_parity(int comp, int point_idx,
                             const InterpolationQuery &query,
                             const Derivative &deriv) const;
    /// reflect coordinates if BC set to reflective in that direction
    double apply_reflective_BC_on_coord(const InterpolationQuery &query,
                                        int dir, int point_idx) const;

    const GRAMR *m_gr_amr_ptr = nullptr;

    // Coordinates of the point represented by IntVect::Zero in coarsest grid
    std::array<double, AMREX_SPACEDIM> m_coarsest_origin{};

    // Grid spacing in each direction
    std::array<double, AMREX_SPACEDIM> m_coarsest_dx{};

    int m_num_levels{};
    int m_verbosity{};

    std::vector<std::array<double, AMREX_SPACEDIM>> m_origin;
    std::vector<std::array<double, AMREX_SPACEDIM>> m_dx;

    MPIContext m_mpi;
    std::vector<int> m_mpi_mapping;

    // Memoisation of boxes previously found
    std::vector<int> m_mem_level;
    std::vector<int> m_mem_box;

    std::vector<int> m_query_level;
    std::vector<int> m_query_box;
    std::array<std::vector<double>, AMREX_SPACEDIM> m_query_coords;
    std::vector<std::vector<double>> m_query_data;

    std::vector<int> m_answer_level;
    std::vector<int> m_answer_box;
    std::array<std::vector<double>, AMREX_SPACEDIM> m_answer_coords;
    std::vector<std::vector<double>> m_answer_data;

    // A bit of Android-ism here, but it's really useful!
    // Identifies the printout as originating from this class.
    const static std::string TAG;

    // Variables for reflective BC
    // m_bc_params can't be a 'const' reference as we need a
    // constructor with backward compatibility that builds an artificial
    // 'BoundaryConditions::params_t'
    BoundaryConditions::params_t m_bc_params;
    /// simplified bools saying whether or not boundary has
    /// a reflective condition in a given direction
    std::array<bool, AMREX_SPACEDIM> m_lo_boundary_reflective{},
        m_hi_boundary_reflective{};
    std::array<double, AMREX_SPACEDIM> m_upper_corner{};
};

#include "AMRInterpolator.impl.hpp"

#endif /* AMRINTERPOLATOR_HPP_ */



================================================
FILE: Source/AMRInterpolator/AMRInterpolator.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(AMRINTERPOLATOR_HPP_)
#error "This file should only be included through AMRInterpolator.hpp"
#endif

#ifndef AMRINTERPOLATOR_IMPL_HPP_
#define AMRINTERPOLATOR_IMPL_HPP_

#include <sstream>
#include <utility>

// A bit of Android-ism here, but it's really useful!
// Identifies the printout as originating from this class.
template <typename InterpAlgo>
const std::string AMRInterpolator<InterpAlgo>::TAG =
    "\x1b[32;1m[AMRInterpolator]\x1b[0m ";

// NOLINTBEGIN(bugprone-easily-swappable-parameters)
template <typename InterpAlgo>
AMRInterpolator<InterpAlgo>::AMRInterpolator(
    const GRAMR &gr_amr,
    const std::array<double, AMREX_SPACEDIM> &coarsest_origin,
    const std::array<double, AMREX_SPACEDIM> &coarsest_dx, int verbosity)
    : AMRInterpolator(gr_amr, coarsest_origin, coarsest_dx,
                      BoundaryConditions::params_t(), verbosity)
{
}

template <typename InterpAlgo>
AMRInterpolator<InterpAlgo>::AMRInterpolator(
    const GRAMR &gr_amr,
    const std::array<double, AMREX_SPACEDIM> &coarsest_origin,
    const std::array<double, AMREX_SPACEDIM> &coarsest_dx,
    BoundaryConditions::params_t a_bc_params, int verbosity)
    : m_gr_amr_ptr(&gr_amr), m_coarsest_origin(coarsest_origin),
      m_coarsest_dx(coarsest_dx),
      // xxxxx      m_num_levels(const_cast<GRAMR
      // &>(m_gr_amr).getAMRLevels().size()),
      m_verbosity(verbosity), m_bc_params(std::move(a_bc_params))
{
    set_reflective_BC();
}
// NOLINTEND(bugprone-easily-swappable-parameters)

template <typename InterpAlgo>
void AMRInterpolator<InterpAlgo>::refresh(const bool a_fill_ghosts)
{
    amrex::Abort("AMRInterpolator<InterpAlgo>::refresh");
    amrex::ignore_unused(a_fill_ghosts);
#if 0
//xxxxx
    BL_PROFILE("AMRInterpolator::refresh");

    const amrex::Vector<std::unique_ptr<AmrLevel>> &levels =
        const_cast<GRAMR*>(m_gr_amr_ptr)->getAmrLevels();
    m_num_levels = levels.size();

    m_mem_level.clear();
    m_mem_box.clear();

    if (a_fill_ghosts)
    {
        fill_multilevel_ghosts(VariableType::state);
        if (NUM_DIAGNOSTIC_VARS > 0)
            fill_multilevel_ghosts(VariableType::derived);
    }
#endif
}

#if 0
//xxxxx
template <typename InterpAlgo>
void AMRInterpolator<InterpAlgo>::fill_multilevel_ghosts(
    const VariableType a_var_type, const Interval &a_comps,
    const int a_min_level, const int a_max_level)
{
    m_gr_amr_ptr->fill_multilevel_ghosts(a_var_type, a_comps, a_min_level,
                                    a_max_level);
}
#endif

#if 0
//xxxxx
template <typename InterpAlgo>
const AMR &AMRInterpolator<InterpAlgo>::getAMR() const
{
    return *m_gr_amr_ptr;
}
#endif

template <typename InterpAlgo>
const std::array<double, AMREX_SPACEDIM> &
AMRInterpolator<InterpAlgo>::get_coarsest_dx()
{
    return m_coarsest_dx;
}
template <typename InterpAlgo>
const std::array<double, AMREX_SPACEDIM> &
AMRInterpolator<InterpAlgo>::get_coarsest_origin()
{
    return m_coarsest_origin;
}

template <typename InterpAlgo>
void AMRInterpolator<InterpAlgo>::limit_num_levels(unsigned int num_levels)
{
    amrex::Abort("xxxxx AMRInterpolator<InterpAlgo>::limit_num_levels");
    amrex::ignore_unused(num_levels);
#if 0
//xxxxx
    // No need to time this small function. BL_PROFILE("AMRInterpolator::limit_num_levels");

    int max_num_levels = const_cast<GRAMR*>(m_gr_amr_ptr)->getAmrLevels().size();
    if (num_levels > max_num_levels || num_levels == 0)
    {
        m_num_levels = max_num_levels;
    }
    else
    {
        m_num_levels = num_levels;
    }
#endif
}

// The coordinates of the requested points are most likely stored as
// "struct-of-arrays", i.e. we get an array of x-coords, array of y-coords, etc.
// For maximum compatibility, this function accepts raw pointers for
// coordinates.
template <typename InterpAlgo>
void AMRInterpolator<InterpAlgo>::interp(InterpolationQuery &query)
{
    BL_PROFILE("AMRInterpolator::interp");

    if (m_verbosity != 0)
    {
        amrex::Print() << TAG << "\x1b[32;1mInterpolating data\x1b[0m" << '\n';

        for (auto it = query.compsBegin(); it != query.compsEnd(); ++it)
        {
            const Derivative deriv = it->first;

            amrex::Print() << "    This rank is querying for interpolated D(";
            for (int i = 0; i < AMREX_SPACEDIM; ++i)
            {
                amrex::Print() << deriv[i];
                if (i < AMREX_SPACEDIM - 1)
                {
                    amrex::Print() << ",";
                }
            }
            amrex::Print() << ") data for " << it->second.size()
                           << " components" << '\n';
        }

        amrex::Print() << "    Summary: " << query.numComps() << " datasets at "
                       << query.numPoints() << " points" << '\n';
    }

    // Compute the bounds and spacings for each level
    computeLevelLayouts();

    // Find boxes in which to interpolated each data point
    InterpolationLayout interp_layout = findBoxes(query);

    // Prepare MPI buffers
    prepareMPI(query, interp_layout);
    // Calculate interpolated values
    exchangeMPIQuery();
    calculateAnswers(query);
    exchangeMPIAnswer();

    int comp_idx = 0;

    for (auto deriv_it = query.compsBegin(); deriv_it != query.compsEnd();
         ++deriv_it)
    {
        using comps_t  = std::vector<typename InterpolationQuery::out_t>;
        comps_t &comps = deriv_it->second;

        for (auto &comps_it : comps)
        {
            int comp          = std::get<0>(comps_it);
            double *out       = std::get<1>(comps_it);
            VariableType type = std::get<2>(comps_it);
            for (int point_idx = 0; point_idx < query.numPoints(); ++point_idx)
            {
                int parity = get_state_var_parity(comp, point_idx, query,
                                                  deriv_it->first);
                out[point_idx] =
                    parity * m_query_data[comp_idx][m_mpi_mapping[point_idx]];
            }
            comp_idx++;
        }
    }
}

// Calculates each level's grid spacing and origin location
template <typename InterpAlgo>
void AMRInterpolator<InterpAlgo>::computeLevelLayouts()
{
    amrex::Abort("xxxxxx AMRInterpolator<InterpAlgo>::computeLevelLayouts");
#if 0
//xxxxx
    BL_PROFILE("AMRInterpolator::computeLevelLayouts");

    std::ostream &_pout = amrex::Print();

    if (m_verbosity)
    {
        _pout << TAG << "Entering computeLevelLayouts" << std::endl;
    }

    const amrex::Vector<AMRLevel *> &levels =
        const_cast<GRAMR*>(m_gr_amr_ptr)->getAMRLevels();
    const int num_levels = m_num_levels; // levels.size();

    m_origin.resize(num_levels);
    m_dx.resize(num_levels);

    amrex::IntVect prev_small_end = amrex::IntVect::TheZeroVector();
    amrex::IntVect prev_big_end = amrex::IntVect::TheZeroVector();

    for (int level_idx = 0; level_idx < num_levels; ++level_idx)
    {
        AMRLevel &level = *levels[level_idx];
        const Box &domain_box = level.problemDomain().domainBox();
        const amrex::IntVect &small_end = domain_box.smallEnd();
        const amrex::IntVect &big_end = domain_box.bigEnd();

        if (level_idx == 0)
        {
            m_origin[level_idx] = m_coarsest_origin;
            m_dx[level_idx] = m_coarsest_dx;
        }
        else
        {
            const int ref_ratio = level.refRatio();

            for (int i = 0; i < AMREX_SPACEDIM; ++i)
            {
                // Sanity check
                AMREX_ASSERT(ref_ratio ==
                          (big_end[i] - small_end[i] + 1) /
                              (prev_big_end[i] - prev_small_end[i] + 1));

                // This level's dx
                m_dx[level_idx][i] = m_dx[level_idx - 1][i] / ref_ratio;

                m_origin[level_idx][i] =
                    // coordinate of the previous level's origin
                    m_origin[level_idx - 1][i]
                    // ((edge of the boundary cell) + (distance away from
                    // boundary at the refinement level)) * (expressed in terms
                    // of previous level's grid coordinates)
                    + ((prev_small_end[i] - 0.5) + 1.0 / (2 * ref_ratio)) *
                          m_dx[level_idx - 1][i]
                    // offset from this level's grid origin to small end
                    - small_end[i] * m_dx[level_idx][i];
            }
        }

        if (m_verbosity >= 2)
        {
            _pout << "    Level " << level_idx << "\t"
                  << "dx=(" << m_dx[level_idx][0] << "," << m_dx[level_idx][1]
                  << "," << m_dx[level_idx][2] << ")\t"
                  << "grid_origin=(" << m_origin[level_idx][0] << ","
                  << m_origin[level_idx][1] << "," << m_origin[level_idx][2]
                  << ")" << std::endl;
        }

        prev_small_end = small_end;
        prev_big_end = big_end;
    }

    if (m_verbosity)
    {
        _pout << TAG << "Leaving computeLevelLayouts" << std::endl;
    }
#endif
}

template <typename InterpAlgo>
InterpolationLayout
AMRInterpolator<InterpAlgo>::findBoxes(InterpolationQuery &query)
{
    amrex::Abort("AMRInterpolator<InterpAlgo>::findBoxes");
    amrex::ignore_unused(query);
#if 0
//xxxxx
    BL_PROFILE("AMRInterpolator::findBoxes");

    std::ostream &_pout = amrex::Print();

    if (m_verbosity)
    {
        _pout << TAG << "Entering findBoxes" << std::endl;
    }

    const amrex::Vector<AMRLevel *> &levels =
        const_cast<GRAMR*>(m_gr_amr_ptr)->getAMRLevels();
    const int num_levels = m_num_levels; // levels.size();

    std::array<double, AMREX_SPACEDIM> grid_coord;
    amrex::IntVect nearest;

    InterpolationLayout interp_layout(query.numPoints());

    int points_found = 0;

    // Check memoised boxes first
    // FIXME: the memoisation gives bad results in the following case:
    // x1 is found on level n-1 in box A, A is memoised
    // x1 is not on level n
    // x2 is in box B on level n and box A on level n-1
    // The current algorithm fill find x2 in A rather than B as it should do
    // Switched off for now
    // for (int i = 0; i < m_mem_box.size(); ++i)
    //{
    //    const int level_idx = m_mem_level[i];
    //    const AMRLevel& level = *levels[level_idx];

    //    const amrex::MultiFab& level_data = dynamic_cast<const
    //    InterpSource&>(level).getLevelData(); const DisjointBoxLayout&
    //    box_layout = level_data.disjointBoxLayout(); const Box& domain_box =
    //    level.problemDomain().domainBox();

    //    AMREX_ASSERT(box_layout.isClosed() && box_layout.isSorted());

    //    const amrex::IntVect& small_end = domain_box.smallEnd();
    //    const amrex::IntVect& big_end = domain_box.bigEnd();

    //    const int box_idx = m_mem_box[i];
    //    const LayoutIterator& layout_it  = box_layout.layoutIterator();
    //    const LayoutIndex& layout_idx = layout_it[box_idx];
    //    const Box& box = box_layout[layout_idx];
    //    int rank = box_layout.procID(layout_idx);

    //    for (int point_idx = 0; point_idx < query.numPoints(); ++point_idx)
    //    {
    //        // Skip points that have already been found in another box
    //        if (interp_layout.level_idx[point_idx] > -1)
    //        {
    //            continue;
    //        }
    //        else
    //        {
    //            // Calculate "grid coordinates" for current point
    //            for (int i = 0; i < AMREX_SPACEDIM; ++i)
    //            {
    //                grid_coord[i] = (query.m_coords[i][point_idx] -
    //                m_origin[level_idx][i]) / m_dx[level_idx][i];
    //
    //                // point lies beyond the "small end" of the whole domain,
    //                but still within the boundary cell if (grid_coord[i] <
    //                small_end[i] /*&& grid_coord[i] >= small_end[i] - 0.5*/)
    //                nearest[i] = small_end[i];
    //
    //                // point lies beyond the "big end" of the whole domain,
    //                but still within the boundary cell else if (grid_coord[i]
    //                > big_end[i] /*&& grid_coord[i] <= big_end[i] + 0.5*/)
    //                nearest[i] = big_end[i];
    //
    //                // otherwise we round to nearest grid point
    //                else nearest[i] = (int) ceil(grid_coord[i] - 0.5);
    //            }

    //            if (box.contains(nearest))
    //            {
    //                interp_layout.rank[point_idx] = rank;
    //                interp_layout.level_idx[point_idx] = level_idx;
    //                interp_layout.box_idx[point_idx] = box_idx;

    //                if (m_verbosity >= 2)
    //                {
    //                    _pout << "    Found (";
    //                    for (int i = 0; i < AMREX_SPACEDIM; ++i)
    //                    {
    //                        _pout << query.m_coords[i][point_idx];
    //                        if (i < AMREX_SPACEDIM - 1) _pout << ",";
    //                    }
    //                    _pout << ") in level " << level_idx << " box " <<
    //                    box_idx << " (rank " << rank << ")" << std::endl;
    //                }

    //                points_found += 1;

    //                if (points_found == query.numPoints())
    //                {
    //                    if (m_verbosity)
    //                    {
    //                        _pout << "    Completed findBoxes using only
    //                        memoised data" << std::endl;
    //                    }

    //                    // The last remaining socially acceptable use of goto.
    //                    // Cherish it.
    //                    goto found_all_points;
    //                }
    //            }
    //        }
    //    }
    //}

    // Start at the innermost level and increment points_found as we find a box
    // in which to interpolate each point.
    for (int level_idx = num_levels - 1; level_idx >= 0; --level_idx)
    {
        const AMRLevel &level = *levels[level_idx];

        const amrex::MultiFab &level_data =
            dynamic_cast<const InterpSource &>(level).getLevelData(
                VariableType::state);
        const DisjointBoxLayout &box_layout = level_data.disjointBoxLayout();
        const Box &domain_box = level.problemDomain().domainBox();

        AMREX_ASSERT(box_layout.isClosed() && box_layout.isSorted());

        const amrex::IntVect &small_end = domain_box.smallEnd();
        const amrex::IntVect &big_end = domain_box.bigEnd();

        const LayoutIterator &layout_it = box_layout.layoutIterator();

        for (int box_idx = 0; box_idx < box_layout.size(); ++box_idx)
        {
            const LayoutIndex &layout_idx = layout_it[box_idx];

            const Box &box = box_layout[layout_idx];
            int rank = box_layout.procID(layout_idx);

            bool new_box = false;

            for (int point_idx = 0; point_idx < query.numPoints(); ++point_idx)
            {
                // Skip points that have already been found in another box
                if (interp_layout.level_idx[point_idx] > -1)
                {
                    continue;
                }
                else
                {
                    // Calculate "grid coordinates" for current point
                    for (int i = 0; i < AMREX_SPACEDIM; ++i)
                    {
                        double coord =
                            apply_reflective_BC_on_coord(query, i, point_idx);
                        grid_coord[i] = (coord - m_origin[level_idx][i]) /
                                        m_dx[level_idx][i];

                        // point lies beyond the "small end" of the whole
                        // domain, but still within the boundary cell
                        if (grid_coord[i] <
                            small_end
                                [i] /*&& grid_coord[i] >= small_end[i] - 0.5*/)
                            nearest[i] = small_end[i];

                        // point lies beyond the "big end" of the whole domain,
                        // but still within the boundary cell
                        else if (
                            grid_coord[i] >
                            big_end[i] /*&& grid_coord[i] <= big_end[i] + 0.5*/)
                            nearest[i] = big_end[i];

                        // otherwise we round to nearest grid point
                        else
                            nearest[i] = (int)ceil(grid_coord[i] - 0.5);
                    }

                    if (box.contains(nearest))
                    {
                        interp_layout.rank[point_idx] = rank;
                        interp_layout.level_idx[point_idx] = level_idx;
                        interp_layout.box_idx[point_idx] = box_idx;

                        if (m_verbosity >= 2)
                        {
                            _pout << "    Found (";
                            for (int i = 0; i < AMREX_SPACEDIM; ++i)
                            {
                                _pout << query.m_coords[i][point_idx];
                                if (i < AMREX_SPACEDIM - 1)
                                    _pout << ",";
                            }
                            _pout << ") in level " << level_idx << " box "
                                  << box_idx << " (rank " << rank << ")"
                                  << std::endl;
                        }

                        points_found += 1;
                        new_box = true;

                        if (points_found == query.numPoints())
                        {
                            m_mem_level.push_back(level_idx);
                            m_mem_box.push_back(box_idx);

                            // The last remaining socially acceptable use of
                            // goto. Cherish it.
                            goto found_all_points;
                        }
                    }
                }
            }

            if (new_box)
            {
                m_mem_level.push_back(level_idx);
                m_mem_box.push_back(box_idx);
            }
        }
    }

found_all_points:
    AMREX_ASSERT(points_found == query.numPoints());
    if (m_verbosity)
    {
        _pout << "    All points have been found" << std::endl;
        _pout << TAG << "Leaving findBoxes" << std::endl;
    }

    return interp_layout;
#else
    return InterpolationLayout{query.numPoints()};
#endif
}

template <typename InterpAlgo>
void AMRInterpolator<InterpAlgo>::prepareMPI(InterpolationQuery &query,
                                             const InterpolationLayout &layout)
{
    BL_PROFILE("AMRInterpolator::prepareMPI");

    amrex::Print _pout;

    if (m_verbosity != 0)
    {
        _pout << TAG << "Entering prepareMPI" << '\n';
    }

    // Count the number of points queried to each rank
    m_mpi.clearQueryCounts();
    for (int point_idx = 0; point_idx < query.numPoints(); ++point_idx)
    {
        int rank = layout.rank[point_idx];
        AMREX_ASSERT(rank > -1);
        m_mpi.incrementQueryCount(rank);
    }

    // Resize MPI 'query' buffers
    m_query_level.resize(query.numPoints());
    m_query_box.resize(query.numPoints());
    for (auto &m_query_coord : m_query_coords)
    {
        m_query_coord.resize(query.numPoints());
    }

    m_query_data.resize(query.numComps());
    for (int comp = 0; comp < query.numComps(); ++comp)
    {
        m_query_data[comp].resize(query.numPoints());
    }

    // Reorder query data for MPI_Ialltoallv
    m_mpi_mapping.resize(query.numPoints());
    std::vector<int> rank_counter(m_mpi.comm_size(), 0);
    for (int point_idx = 0; point_idx < query.numPoints(); ++point_idx)
    {
        int rank = layout.rank[point_idx];
        int idx  = m_mpi.queryDispl(rank) + rank_counter[rank];

        m_query_level[idx] = layout.level_idx[point_idx];
        m_query_box[idx]   = layout.box_idx[point_idx];

        for (int i = 0; i < AMREX_SPACEDIM; ++i)
        {
            // m_query_coords[i][idx] = query.m_coords[i][point_idx];
            m_query_coords[i][idx] =
                apply_reflective_BC_on_coord(query, i, point_idx);
        }

        m_mpi_mapping[point_idx] = idx;

        rank_counter[rank] += 1;
    }

    m_mpi.exchangeLayout();

    // Resize MPI 'answer' buffers
    int num_answers = m_mpi.totalAnswerCount();

    m_answer_level.resize(num_answers);
    m_answer_box.resize(num_answers);
    for (auto &m_answer_coord : m_answer_coords)
    {
        m_answer_coord.resize(num_answers);
    }

    m_answer_data.resize(query.numComps());
    for (int comp = 0; comp < query.numComps(); ++comp)
    {
        m_answer_data[comp].resize(num_answers);
    }

    if (m_verbosity >= 2)
    {
        _pout << "    Number of points that needs to be answered back:" << '\n';
        for (int rank = 0; rank < m_mpi.comm_size(); ++rank)
        {
            _pout << "    Rank " << rank << "\t= " << m_mpi.queryCount(rank)
                  << '\n';
        }
        _pout << TAG << "Leaving prepareMPI" << '\n';
    }
}

template <typename InterpAlgo>
void AMRInterpolator<InterpAlgo>::exchangeMPIQuery()
{
    BL_PROFILE("AMRInterpolator::exchangeMPIQuery");

    amrex::Print _pout;

    if (m_verbosity > 0)
    {
        _pout << TAG << "Entering exchangeMPIQuery" << '\n';
    }

#ifdef AMREX_USE_MPI // TODO: it would be nicer if this ifdef were moved into
                     // MPIContext ... the only issue is the MPI datatype
    m_mpi.asyncBegin();

    m_mpi.asyncExchangeQuery(m_query_level.data(), m_answer_level.data(),
                             MPI_INT);
    m_mpi.asyncExchangeQuery(m_query_box.data(), m_answer_box.data(), MPI_INT);
    for (int i = 0; i < AMREX_SPACEDIM; ++i)
    {
        m_mpi.asyncExchangeQuery(m_query_coords[i].data(),
                                 m_answer_coords[i].data(), MPI_DOUBLE);
    }

    m_mpi.asyncEnd();
#else
    m_answer_level = m_query_level;
    m_answer_box   = m_query_box;
    for (int i = 0; i < AMREX_SPACEDIM; ++i)
        m_answer_coords[i] = m_query_coords[i];
#endif

    if (m_verbosity > 0)
    {
        _pout << TAG << "Entering exchangeMPIQuery" << '\n';
    }
}

template <typename InterpAlgo>
void AMRInterpolator<InterpAlgo>::calculateAnswers(InterpolationQuery &query)
{
    amrex::Abort("xxxxx calculateAnswers");
    amrex::ignore_unused(query);
#if 0
//xxxxx
    BL_PROFILE("AMRInterpolator::calculateAnswers");

    std::ostream &_pout = amrex::Print();

    if (m_verbosity)
    {
        _pout << TAG << "Entering calculateAnswer" << std::endl;
    }

    const amrex::Vector<AMRLevel *> &levels =
        const_cast<GRAMR*>(m_gr_amr_ptr)->getAMRLevels();
    // const int num_levels = levels.size();
    // const int num_comps = query.numComps();
    const int num_answers = m_mpi.totalAnswerCount();

    std::array<double, AMREX_SPACEDIM> grid_coord;
    amrex::IntVect nearest;

    for (int answer_idx = 0; answer_idx < num_answers; ++answer_idx)
    {
        const int box_idx = m_answer_box[answer_idx];
        const int level_idx = m_answer_level[answer_idx];

        const AMRLevel &level = *levels[level_idx];
        const InterpSource &source = dynamic_cast<const InterpSource &>(level);
        const amrex::MultiFab *const evolution_level_data_ptr =
            &source.getLevelData(VariableType::state);
        const amrex::MultiFab *diagnostics_level_data_ptr;
        if (NUM_DIAGNOSTIC_VARS > 0)
        {
            diagnostics_level_data_ptr =
                &source.getLevelData(VariableType::derived);
        }
        const DisjointBoxLayout *const evolution_box_layout_ptr =
            &evolution_level_data_ptr->disjointBoxLayout();
        const DisjointBoxLayout *diagnostics_box_layout_ptr;
        if (NUM_DIAGNOSTIC_VARS > 0)
        {
            diagnostics_box_layout_ptr =
                &diagnostics_level_data_ptr->disjointBoxLayout();
        }

        const Box &domain_box = level.problemDomain().domainBox();
        const amrex::IntVect &small_end = domain_box.smallEnd();
        const amrex::IntVect &big_end = domain_box.bigEnd();

        // Convert the LayoutIndex to DataIndex
        const DataIndex evolution_data_idx(
            evolution_box_layout_ptr->layoutIterator()[box_idx]);
        DataIndex diagnostics_data_idx;
        if (NUM_DIAGNOSTIC_VARS > 0)
        {
            diagnostics_data_idx = DataIndex(
                diagnostics_box_layout_ptr->layoutIterator()[box_idx]);
        }

        const Box &box = (*evolution_box_layout_ptr)[evolution_data_idx];
        const FArrayBox *const evolution_fab_ptr =
            &((*evolution_level_data_ptr)[evolution_data_idx]);
        const FArrayBox *diagnostics_fab_ptr;
        if (NUM_DIAGNOSTIC_VARS > 0)
        {
            diagnostics_fab_ptr =
                &((*diagnostics_level_data_ptr)[diagnostics_data_idx]);
        }

        for (int i = 0; i < AMREX_SPACEDIM; ++i)
        {
            grid_coord[i] =
                (m_answer_coords[i][answer_idx] - m_origin[level_idx][i]) /
                m_dx[level_idx][i];

            if (!(grid_coord[i] >= box.smallEnd()[i] - 0.5 &&
                  grid_coord[i] <= box.bigEnd()[i] + 0.5))
            {
                std::ostringstream s;
                s << "grid_coord[" << i << "] = " << grid_coord[i]
                  << " is out of range [" << (box.smallEnd()[i] - 0.5) << ","
                  << (box.bigEnd()[i] + 0.5) << "]";
                MayDay::Abort(s.str().c_str());
            }

            // point lies beyond the "small end" of the whole domain, but still
            // within the boundary cell
            if (grid_coord[i] < small_end[i] &&
                grid_coord[i] >= small_end[i] - 0.5)
                nearest[i] = small_end[i];

            // point lies beyond the "big end" of the whole domain, but still
            // within the boundary cell
            else if (grid_coord[i] > big_end[i] &&
                     grid_coord[i] <= big_end[i] + 0.5)
                nearest[i] = big_end[i];

            // otherwise we round to nearest grid point
            else
                nearest[i] = (int)ceil(grid_coord[i] - 0.5);
        }

        if (m_verbosity >= 2)
        {
            _pout << "    Interpolating (";
            for (int i = 0; i < AMREX_SPACEDIM; ++i)
            {
                _pout << m_answer_coords[i][answer_idx];
                if (i < AMREX_SPACEDIM - 1)
                    _pout << ",";
            }
            _pout << ") in level " << level_idx << " box " << box_idx << std::endl;
        }

        InterpAlgo algo(source);
        int comp_idx = 0;

        for (typename InterpolationQuery::iterator deriv_it =
                 query.compsBegin();
             deriv_it != query.compsEnd(); ++deriv_it)
        {
            const Derivative deriv = deriv_it->first;

            typedef std::vector<typename InterpolationQuery::out_t> comps_t;
            comps_t &comps = deriv_it->second;
            algo.setup(deriv, m_dx[level_idx], grid_coord, nearest);

            for (typename comps_t::iterator it = comps.begin();
                 it != comps.end(); ++it)
            {
                int comp = std::get<0>(*it);
                const FArrayBox *fab_ptr;
                if (NUM_DIAGNOSTIC_VARS > 0)
                {
                    VariableType var_type = std::get<2>(*it);
                    fab_ptr = (var_type == VariableType::state)
                                  ? evolution_fab_ptr
                                  : diagnostics_fab_ptr;
                }
                else
                {
                    fab_ptr = evolution_fab_ptr;
                }
                double out_val = algo.interpData(*fab_ptr, comp);
                m_answer_data[comp_idx++][answer_idx] = out_val;
            }
        }
    }
#endif
}

template <typename InterpAlgo>
void AMRInterpolator<InterpAlgo>::exchangeMPIAnswer()
{
    BL_PROFILE("AMRInterpolator::exchangeMPIAnswer");

    if (m_verbosity > 0)
    {
        amrex::Print() << TAG << "Entering exchangeMPIAnswer" << '\n';
    }

#ifdef AMREX_USE_MPI // TODO: it would be nicer if this ifdef were moved into
                     // MPIContext ... the only issue is the MPI datatype
    m_mpi.asyncBegin();

    m_mpi.asyncExchangeAnswer(m_answer_level.data(), m_query_level.data(),
                              MPI_INT);
    m_mpi.asyncExchangeAnswer(m_answer_box.data(), m_query_box.data(), MPI_INT);
    for (std::size_t comp = 0; comp < m_answer_data.size(); ++comp)
    {
        m_mpi.asyncExchangeAnswer(m_answer_data[comp].data(),
                                  m_query_data[comp].data(), MPI_DOUBLE);
    }

    m_mpi.asyncEnd();
#else
    m_query_level = m_answer_level;
    m_query_box   = m_answer_box;
    m_query_data  = m_answer_data;
#endif

    if (m_verbosity > 0)
    {
        amrex::Print() << TAG << "Leaving exchangeMPIAnswer" << '\n';
    }
}

template <typename InterpAlgo>
void AMRInterpolator<InterpAlgo>::set_reflective_BC()
{
    amrex::Abort("xxxxx AMRInterpolator<InterpAlgo>::set_reflective_BC");
#if 0
//xxxxx
    const amrex::IntVect &big_end = const_cast<GRAMR*>(m_gr_amr_ptr)
                                 ->getAmrLevels()[0]
                                 ->problemDomain()
                                 .domainBox()
                                 .bigEnd();

    FOR(i)
    {
        m_upper_corner[i] = (big_end[i] + 1) * m_coarsest_dx[i];

        m_lo_boundary_reflective[i] =
            (m_bc_params.lo_boundary[i] == BoundaryConditions::REFLECTIVE_BC);
        m_hi_boundary_reflective[i] =
            (m_bc_params.hi_boundary[i] == BoundaryConditions::REFLECTIVE_BC);
    }
#endif
}

template <typename InterpAlgo>
int AMRInterpolator<InterpAlgo>::get_state_var_parity(
    int comp, int point_idx, const InterpolationQuery &query,
    const Derivative &deriv) const
{

    int parity = 1;
    FOR (dir)
    {
        double coord = query.m_coords[dir][point_idx];
        if ((m_lo_boundary_reflective[dir] && coord < 0.) ||
            (m_hi_boundary_reflective[dir] && coord > m_upper_corner[dir]))
        {

            parity *= BoundaryConditions::get_state_var_parity(comp, dir);
            if (deriv[dir] == 1)
            { // invert parity to first derivatives
                parity *= -1;
            }
        }
    }
    return parity;
}

template <typename InterpAlgo>
double AMRInterpolator<InterpAlgo>::apply_reflective_BC_on_coord(
    const InterpolationQuery &query, int dir, int point_idx) const
{
    double coord = query.m_coords[dir][point_idx];
    if (m_lo_boundary_reflective[dir] && coord < 0.)
    {
        coord = -coord;
    }
    else if (m_hi_boundary_reflective[dir] && coord > m_upper_corner[dir])
    {
        coord = 2. * m_upper_corner[dir] - coord;
    }
    return coord;
}

#endif /* AMRINTERPOLATOR_IMPL_HPP_ */



================================================
FILE: Source/AMRInterpolator/CylindricalExtraction.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef CYLINDRICALEXTRACTION_HPP_
#define CYLINDRICALEXTRACTION_HPP_

#include "CylindricalGeometry.hpp"
#include "SurfaceExtraction.hpp"

//! A child class of SurfaceExtraction for extraction on cylindrical shells
class CylindricalExtraction : public SurfaceExtraction<CylindricalGeometry>
{
  public:
    struct params_t : SurfaceExtraction::params_t
    {
        int &num_extraction_radii             = num_surfaces;
        std::vector<double> &extraction_radii = surface_param_values;
        int &num_points_z                     = num_points_u;
        int &num_points_phi                   = num_points_v;
        std::array<double, AMREX_SPACEDIM> center; //!< the center of the
                                                   //!< cylindrical shells
        double z_length;
    };
    const std::array<double, AMREX_SPACEDIM> m_center;
    double m_z_length;

    CylindricalExtraction(const params_t &a_params, double a_dt, double a_time,
                          bool a_first_step, double a_restart_time = 0.0)
        : SurfaceExtraction({a_params.center, a_params.z_length}, a_params,
                            a_dt, a_time, a_first_step, a_restart_time),
          m_center(a_params.center), m_z_length(a_params.z_length)
    {
    }

    CylindricalExtraction(const params_t &a_params,
                          const std::vector<vars_t> &a_vars, double a_dt,
                          double a_time, bool a_first_step,
                          double a_restart_time = 0.0)
        : CylindricalExtraction(a_params, a_dt, a_time, a_first_step,
                                a_restart_time)
    {
        add_vars(a_vars);
    }

    CylindricalExtraction(const params_t &a_params,
                          const std::vector<int> &a_evolution_vars, double a_dt,
                          double a_time, bool a_first_step,
                          double a_restart_time = 0.0)
        : CylindricalExtraction(a_params, a_dt, a_time, a_first_step,
                                a_restart_time)
    {
        add_evolution_vars(a_evolution_vars);
    }

    void execute_query(AMRInterpolator<Lagrange<4>> *a_interpolator)
    {
        // extract the values of the fields on the cylinders
        extract(a_interpolator);

        if (m_params.write_extraction)
        {
            write_extraction("CylinderExtractionOut_");
        }
    }
};

#endif /* CYLINDRICALEXTRACTION_HPP_ */



================================================
FILE: Source/AMRInterpolator/CylindricalGeometry.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef CYLINDRICALGEOMETRY_HPP_
#define CYLINDRICALGEOMETRY_HPP_

// Other includes
#include <array>
#include <cmath>
#include <string>

//! This class, derived from the SurfaceGeometry class, provides cylindrical
//! shell geometry implementation for the SurfaceExtraction class v = phi
class CylindricalGeometry
{
  private:
    const std::array<double, AMREX_SPACEDIM> m_center;
    const double m_z_length;

  public:
    CylindricalGeometry(const std::array<double, AMREX_SPACEDIM> &a_center,
                        double a_z_length)
        : m_center(a_center), m_z_length(a_z_length)
    {
    }

    //! returns the grid spacing in z
    inline double du(int a_num_points_z) const
    {
        return m_z_length / (a_num_points_z - 1);
    }

    //! returns the grid spacing in phi
    inline double dv(int a_num_points_phi) const
    {
        return 2.0 * M_PI / ((double)a_num_points_phi);
    }

    //! returns the z coordinate associated to the theta/u index
    inline double u(int a_iz, int a_num_points_z) const
    {
        return a_iz * du(a_num_points_z) - (m_z_length / 2.0);
    }

    //! returns the phi coordinate associated to the phi/v index
    inline double v(int a_iphi, int a_num_points_phi) const
    {
        return a_iphi * dv(a_num_points_phi);
    }

    inline bool is_u_periodic() const { return false; }
    inline bool is_v_periodic() const { return true; }
    //! returns the Cartesian coordinate in direction a_dir with specified
    //! radius, z and phi.
    inline double get_grid_coord(int a_dir, double a_radius, double a_z,
                                 double a_phi) const
    {
        switch (a_dir)
        {
        case (0):
            return m_center[0] + a_radius * cos(a_phi);
        case (1):
            return m_center[1] + a_radius * sin(a_phi);
        case (2):
            return m_center[2] + a_z;
        default:
            amrex::Abort("CylindricalGeometry: Direction not supported");
        }
    }

    //! returns the area element on a cylinder with radius a_radius at the point
    //! (a_z, a_phi)
    inline double area_element(double a_radius, double a_z, double a_phi) const
    {
        return a_radius;
    }

    inline std::string param_name() const { return "r"; }

    inline std::string u_name() const { return "z"; }

    inline std::string v_name() const { return "phi"; }
};

#endif /* CYLINDRICALGEOMETRY_HPP_ */



================================================
FILE: Source/AMRInterpolator/Derivative.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef DERIVATIVE_HPP_
#define DERIVATIVE_HPP_

#include <array>
#include <string>

#include "AMReX_SPACE.H"

class Derivative : public std::array<int, AMREX_SPACEDIM>
{
  private:
    Derivative(int dir) : array{AMREX_D_DECL(0, 0, 0)} { (*this)[dir] = 1; }

    Derivative(int dir1, int dir2) : array{AMREX_D_DECL(0, 0, 0)}
    {
        (*this)[dir1] += 1;
        (*this)[dir2] += 1;
    }

  public:
    Derivative() : array{AMREX_D_DECL(0, 0, 0)} {}

    // Ordering for std::map

    bool operator==(const Derivative &rhs) const
    {
        for (int i = 0; i < AMREX_SPACEDIM; ++i)
        {
            if ((*this)[i] != rhs[i])
            {
                return false;
            }
        }

        return true;
    }

    bool operator!=(const Derivative &deriv) const { return (*this) != deriv; }

    bool operator<(const Derivative &rhs) const
    {
        int derivs     = 0;
        int rhs_derivs = 0;

        for (int i = 0; i < AMREX_SPACEDIM; ++i)
        {
            derivs     += (*this)[i];
            rhs_derivs += rhs[i];
        }

        if (derivs < rhs_derivs)
        {
            return true;
        }
        if (derivs > rhs_derivs)
        {
            return false;
        }

        for (int i = 0; i < AMREX_SPACEDIM; ++i)
        {
            // This is counterintuitive but is actually the ordering the we
            // want in order to generalise to arbitrary #dims
            if ((*this)[i] > rhs[i])
            {
                return true;
            }
            if ((*this)[i] < rhs[i])
            {
                return false;
            }
        }

        return false;
    }

    static const Derivative LOCAL;

    static const Derivative dx;
    static const Derivative dy;
    static const Derivative dz;

    static const Derivative dxdx;
    static const Derivative dydy;
    static const Derivative dzdz;

    static const Derivative dxdy;
    static const Derivative dxdz;
    static const Derivative dydz;

    static std::string name(const Derivative &deriv)
    {
        if (deriv == dx)
        {
            return "dx";
        }
        if (deriv == dy)
        {
            return "dy";
        }
        if (deriv == dz)
        {
            return "dz";
        }
        if (deriv == dxdx)
        {
            return "dxdx";
        }
        if (deriv == dydy)
        {
            return "dydy";
        }
        if (deriv == dzdz)
        {
            return "dzdz";
        }
        if (deriv == dxdy)
        {
            return "dxdy";
        }
        if (deriv == dxdz)
        {
            return "dxdz";
        }
        if (deriv == dydz)
        {
            return "dydz";
        }
        return "";
    }
};

/* Moved to DerivativeSetup.hpp as otherwise multiply
 * defined in the various translaion units

const Derivative Derivative::LOCAL;

const Derivative Derivative::dx(0);
const Derivative Derivative::dy(1);
const Derivative Derivative::dz(2);

const Derivative Derivative::dxdx(0, 0);
const Derivative Derivative::dydy(1, 1);
const Derivative Derivative::dzdz(2, 2);

const Derivative Derivative::dxdy(0, 1);
const Derivative Derivative::dxdz(0, 2);
const Derivative Derivative::dydz(1, 2);
*/
#endif /* DERIVATIVE_HPP_ */



================================================
FILE: Source/AMRInterpolator/DerivativeSetup.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef DERIVATIVESETUP_HPP_
#define DERIVATIVESETUP_HPP_

#include "Derivative.hpp"

const Derivative Derivative::LOCAL;

const Derivative Derivative::dx(0);
const Derivative Derivative::dy(1);
const Derivative Derivative::dz(2);

const Derivative Derivative::dxdx(0, 0);
const Derivative Derivative::dydy(1, 1);
const Derivative Derivative::dzdz(2, 2);

const Derivative Derivative::dxdy(0, 1);
const Derivative Derivative::dxdz(0, 2);
const Derivative Derivative::dydz(1, 2);

#endif /* DERIVATIVESETUP_HPP_ */



================================================
FILE: Source/AMRInterpolator/IntegrationMethod.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef INTEGRATIONMETHOD_HPP_
#define INTEGRATIONMETHOD_HPP_

#include <AMReX_BLassert.H>

// Other includes
#include <utility>
#include <vector>

//! A class to store and return the weights associated to a Newton-Cotes formula
//! for numerical integration/quadrature which can be closed (i.e. includes the
//! endpoints) or open (does not include the end points). This is used by
//! SurfaceExtraction for integration over extraction surfaces.
class IntegrationMethod
{
  private:
    std::vector<double> m_weights;
    size_t m_num_weights;
    bool m_is_closed;

  public:
    //! Constructor
    IntegrationMethod(const std::vector<double> &a_weights,
                      bool a_is_closed = true)
        : m_weights(a_weights), m_num_weights(a_weights.size()),
          m_is_closed(a_is_closed)
    {
        AMREX_ASSERT(a_weights.size() > 0);
    }

    //! Checks that this integration method is suitable given the number of
    //! points and periodicity
    [[nodiscard]] inline bool is_valid(int a_num_points,
                                       bool a_is_periodic) const
    {
        if (m_is_closed && !a_is_periodic)
        {
            return (a_num_points % m_num_weights == 1 || m_num_weights == 1);
        }

        return (a_num_points % m_num_weights == 0);
    }

    //! Returns whether this IntegrationMethod is closed or not
    [[nodiscard]] inline bool is_closed() const { return m_is_closed; }

    //! Returns the weight for a point with given index
    [[nodiscard]] inline double weight(int a_index, int a_num_points,
                                       bool a_is_periodic) const
    {
        const size_t weight_index = a_index % m_num_weights;
        const bool endpoint =
            (a_index == 0 || a_index == a_num_points - 1) && !a_is_periodic;
        // if this is a closed formula, not a geometry endpoint but at the edge
        // of the formula, need to double the weight as this is how Newton-Cotes
        // formulae are combined.
        if (m_is_closed && !endpoint && weight_index == 0)
        {
            return 2.0 * m_weights[weight_index];
        } // otherwise we just use the weight from the formula
        return m_weights[weight_index];
    }

    static const IntegrationMethod trapezium;
    static const IntegrationMethod midpoint;
    static const IntegrationMethod simpson;
    static const IntegrationMethod boole;
};

#endif /* INTEGRATIONMETHOD_HPP_ */



================================================
FILE: Source/AMRInterpolator/IntegrationMethodSetup.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef INTEGRATIONMETHODSETUP_HPP_
#define INTEGRATIONMETHODSETUP_HPP_

#include "IntegrationMethod.hpp"

// define the static IntegrationMethods here
const IntegrationMethod IntegrationMethod::trapezium({0.5});
const IntegrationMethod IntegrationMethod::midpoint({1.0}, false);
const IntegrationMethod IntegrationMethod::simpson({0.3333333333333333,
                                                    1.3333333333333333});
const IntegrationMethod
    IntegrationMethod::boole({0.3111111111111111, 1.4222222222222222,
                              0.53333333333333, 1.4222222222222222});

#endif /* INTEGRATIONMETHODSETUP_HPP_ */



================================================
FILE: Source/AMRInterpolator/InterpolationAlgorithm.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef INTERPOLATIONALGORITHM_HPP_
#define INTERPOLATIONALGORITHM_HPP_

#include <AMReX_FArrayBox.H>

// Other includes
#include <array>

class InterpolationAlgorithm
{
};

class NearestNeighbour : public InterpolationAlgorithm
{
  public:
    static inline double
    interpPoint(const std::array<double, AMREX_SPACEDIM> & /*gridCoord*/,
                const amrex::FArrayBox & /*fab*/, int /*comps*/,
                const amrex::IntVect & /*nearest*/)
    {
        amrex::Abort("xxxxx interpPoint todo");
        return 0.; // xxxxx fab.get(nearest, comps);
    }
};

#endif /* INTERPOLATIONALGORITHM_HPP_ */



================================================
FILE: Source/AMRInterpolator/InterpolationLayout.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef INTERPOLATIONLAYOUT_HPP_
#define INTERPOLATIONLAYOUT_HPP_

#include <vector>

class InterpolationLayout
{
  private:
    template <typename InterpAlgo> friend class AMRInterpolator;

    std::vector<int> rank;
    std::vector<int> level_idx;
    std::vector<int> box_idx;

    InterpolationLayout(size_t num_points)
        : rank(num_points, -1), level_idx(num_points, -1),
          box_idx(num_points, -1)
    {
    }
};

#endif /* INTERPOLATIONLAYOUT_HPP_ */



================================================
FILE: Source/AMRInterpolator/InterpolationQuery.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef INTERPOLATIONQUERY_HPP_
#define INTERPOLATIONQUERY_HPP_

// Other includes
#include "Derivative.hpp"
#include "VariableType.hpp"
#include <map>
#include <tuple>
#include <utility>
#include <vector>

class InterpolationQuery
{
  public:
    using out_t      = std::tuple<int, double *, VariableType>;
    using comp_map_t = std::map<Derivative, std::vector<out_t>>;
    using iterator =
        typename std::map<Derivative, std::vector<out_t>>::iterator;

  private:
    template <typename InterpAlgo> friend class AMRInterpolator;

    size_t m_num_points;
    std::vector<const double *> m_coords;
    comp_map_t m_comps;

  public:
    InterpolationQuery(int num_points)
        : m_num_points(num_points), m_coords(AMREX_SPACEDIM, nullptr)
    {
    }

    InterpolationQuery &setCoords(int dim, const double *coords)
    {
        AMREX_ASSERT(dim < AMREX_SPACEDIM);
        this->m_coords[dim] = coords;
        return *this;
    }

    InterpolationQuery &
    addComp(int comp, double *out_ptr,
            const Derivative &deriv    = Derivative::LOCAL,
            VariableType variable_type = VariableType::state)
    {
        AMREX_ASSERT(out_ptr != NULL || m_num_points == 0);

        auto result = m_comps.find(deriv);
        if (result == m_comps.end())
        {
            result = m_comps
                         .insert(std::pair<Derivative, std::vector<out_t>>(
                             deriv, std::vector<out_t>()))
                         .first;
        }

        result->second.emplace_back(comp, out_ptr, variable_type);
        return *this;
    }

    InterpolationQuery &clearComps()
    {
        m_comps.clear();
        return *this;
    }

    inline int numComps()
    {
        int accum = 0;

        for (auto &m_comp : m_comps)
        {
            accum += static_cast<int>(m_comp.second.size());
        }

        return accum;
    }

    [[nodiscard]] inline size_t numPoints() const { return m_num_points; }

    inline iterator compsBegin() { return m_comps.begin(); }

    inline iterator compsEnd() { return m_comps.end(); }
};

#endif /* INTERPOLATIONQUERY_HPP_ */



================================================
FILE: Source/AMRInterpolator/InterpSource.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef INTERPSOURCE_H_
#define INTERPSOURCE_H_

// Other inclues
#include "VariableType.hpp"

#include <AMReX_MultiFab.H>

#include <array>

// Abstract base class to get the FABs out of an AMRLevel
class InterpSource
{
  public:
    [[nodiscard]] virtual const amrex::MultiFab &
    getLevelData(const VariableType var_type = VariableType::state) const = 0;
    [[nodiscard]] virtual bool
    contains(const std::array<double, AMREX_SPACEDIM> &point) const = 0;

    virtual ~InterpSource() = default;
};

#endif /* INTERPSOURCE_H_ */



================================================
FILE: Source/AMRInterpolator/Lagrange.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef LAGRANGE_HPP_
#define LAGRANGE_HPP_

#include "InterpSource.hpp"
#include <utility>

template <int Order> class Lagrange
{
    const InterpSource *m_source_ptr;
    bool m_verbosity;

    struct Stencil;

    struct Stencil
    {
        int m_width;
        int m_deriv;
        double m_dx;
        double m_point_offset;

        std::vector<double> m_weights;

        Stencil(int width, int deriv, double dx, double point_offset);
        inline bool operator==(const Stencil &rhs) const;
        [[nodiscard]] inline bool isSameAs(int width, int deriv, double dx,
                                           double point_offset) const;

        inline const double &operator[](unsigned int i) const;
    };

    using stencil_collection_t = std::vector<Stencil>;
    stencil_collection_t m_memoized_stencils;

    Stencil getStencil(int width, int deriv, double dx, double point_offset);

    // Helper function to generate tensor product weights
    // Argument 'dim' is used for recursion over dimensions.
    std::pair<std::vector<amrex::IntVect>, std::vector<double>>
    generateStencil(const std::array<int, AMREX_SPACEDIM> &deriv,
                    const std::array<double, AMREX_SPACEDIM> &dx,
                    const std::array<double, AMREX_SPACEDIM> &evalCoord,
                    const amrex::IntVect &nearest,
                    int dim = AMREX_SPACEDIM - 1);

    std::vector<amrex::IntVect> m_interp_points;
    std::vector<double> m_interp_weights;

    // We are adding 216+ numbers at roughly the same magnitudes but alternating
    // signs. Let's keep track of positive and negative terms separately to make
    // sure we don't run into trouble.
    std::multiset<double> m_interp_neg;
    std::multiset<double> m_interp_pos;

  public:
    Lagrange(const InterpSource &source, bool verbosity = false);

    void setup(const std::array<int, AMREX_SPACEDIM> &deriv,
               const std::array<double, AMREX_SPACEDIM> &dx,
               const std::array<double, AMREX_SPACEDIM> &evalCoord,
               const amrex::IntVect &nearest);
    double interpData(const amrex::FArrayBox &fab, int comp);

    const static std::string TAG;
};

#include "Lagrange.impl.hpp"

#endif /* LAGRANGE_HPP_ */



================================================
FILE: Source/AMRInterpolator/Lagrange.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(LAGRANGE_HPP_)
#error "This file should only be included through Lagrange.hpp"
#endif

#ifndef LAGRANGE_IMPL_HPP_
#define LAGRANGE_IMPL_HPP_

#include <cmath>

template <int Order>
const std::string Lagrange<Order>::TAG = "\x1b[36;1m[Lagrange]\x1b[0m ";

/* Finite difference weight generation algorithm
 *
 * Translated from the F77 code found in
 * Bengt Fornberg: "Calculation of Weights in Finite Difference Formulas"
 * SIAM Review 40, 3 (1998): 685-691
 *
 * Here we restrict ourselves to integer grid. Original code allows for
 * arbitrary grid locations specified by grid[i]. To recover the general
 * routine: - change type of c1,c2,c3 to 'double' - replace '0', 'i', 'j' in the
 * annotated lines with 'grid[0]', 'grid[i]', 'grid[j]'.
 */
// NOLINTBEGIN(bugprone-easily-swappable-parameters)
template <int Order>
Lagrange<Order>::Stencil::Stencil(int width, int deriv, double dx,
                                  double point_offset)
    : m_width(width), m_deriv(deriv), m_dx(dx), m_point_offset(point_offset)
// NOLINTEND(bugprone-easily-swappable-parameters)
{
    // NOLINTBEGIN(readability-identifier-length)
    int c1    = 1;
    int c2    = 0;
    int c3    = 0;
    double c4 = 0 - m_point_offset; /* replace for general grid */
    double c5 = NAN;
    // NOLINTEND(readability-identifier-length)

    std::vector<double> tmp_weights(static_cast<size_t>(width * (deriv + 1)),
                                    0.);

    tmp_weights[0] = 1.0;

    for (int i = 1; i < m_width; ++i)
    {
        int min_i_deriv = (i < m_deriv) ? i : m_deriv;

        c2 = 1;
        c5 = c4;
        c4 = i - m_point_offset; /* replace for general grid */

        for (int j = 0; j < i; ++j)
        {
            c3 = i - j; /* replace for general grid */
            c2 = c2 * c3;

            if (j == i - 1)
            {
                for (int k = min_i_deriv; k > 0; --k)
                {
                    tmp_weights[k * m_width + i] =
                        c1 *
                        (k * tmp_weights[(k - 1) * m_width + (i - 1)] -
                         c5 * tmp_weights[k * m_width + (i - 1)]) /
                        c2;
                }
                tmp_weights[i] = -c1 * c5 * tmp_weights[i - 1] / c2;
            }

            for (int k = min_i_deriv; k > 0; --k)
            {
                tmp_weights[k * m_width + j] =
                    (c4 * tmp_weights[k * m_width + j] -
                     k * tmp_weights[(k - 1) * m_width + j]) /
                    c3;
            }
            tmp_weights[j] = c4 * tmp_weights[j] / c3;
        }

        c1 = c2;
    }

    if (deriv > 0)
    {
        const double dx_factor = pow(m_dx, deriv);
        m_weights.resize(m_width);
        for (int i = 0; i < m_width; ++i)
        {
            m_weights[i] = tmp_weights[m_width * m_deriv + i] / dx_factor;
        }
    }
    else
    {
        m_weights = std::move(tmp_weights);
    }

    // NOLINTBEGIN(readability-simplify-boolean-expr)
    if (false)
    {
        amrex::Print() << TAG << "Created a stencil for deriv " << m_deriv
                       << " of width " << m_width << " for point "
                       << m_point_offset << '\n';
        amrex::Print() << "    Weights = { ";
        for (int i = 0; i < m_width; ++i)
        {
            amrex::Print() << m_weights[i] << " ";
        }
        amrex::Print() << "}" << '\n';
    }
    // NOLINTEND(readability-simplify-boolean-expr)
}

template <int Order>
bool Lagrange<Order>::Stencil::operator==(
    const Lagrange<Order>::Stencil &rhs) const
{
    return (rhs.m_width == m_width) && (rhs.m_deriv == m_deriv) &&
           (rhs.m_point_offset == m_point_offset) && (rhs.m_dx == m_dx);
}

template <int Order>
bool Lagrange<Order>::Stencil::isSameAs(int width, int deriv, double dx,
                                        double point_offset) const
{
    return (width == m_width) && (deriv == m_deriv) && (dx == m_dx) &&
           (point_offset == m_point_offset);
}

/* STENCIL ACCESSOR */

template <int Order>
typename Lagrange<Order>::Stencil
Lagrange<Order>::getStencil(int width, int deriv, double dx,
                            double point_offset)
{
    for (typename stencil_collection_t::iterator it =
             m_memoized_stencils.begin();
         it != m_memoized_stencils.end(); ++it)
    {
        if (it->isSameAs(width, deriv, dx, point_offset))
        {
            // Make a copy, lest std::vector decides to move our stencil during
            // growth op
            return *it;
        }
    }

    // We have to insert a new stencil.
    return *m_memoized_stencils.insert(m_memoized_stencils.end(),
                                       Stencil(width, deriv, dx, point_offset));
}

template <int Order>
const double &Lagrange<Order>::Stencil::operator[](unsigned int i) const
{
    AMREX_ASSERT(i < m_width);
    return m_weights[i];
}

/* LAGRANGE TENSOR PRODUCT LOGIC */

template <int Order>
Lagrange<Order>::Lagrange(const InterpSource &source, bool verbosity)
    : m_source_ptr(&source), m_verbosity(verbosity)
{
}

template <int Order>
void Lagrange<Order>::setup(const std::array<int, AMREX_SPACEDIM> &deriv,
                            const std::array<double, AMREX_SPACEDIM> &dx,
                            const std::array<double, AMREX_SPACEDIM> &evalCoord,
                            const amrex::IntVect &nearest)
{
    std::pair<std::vector<amrex::IntVect>, std::vector<double>> result =
        generateStencil(deriv, dx, evalCoord, nearest);
    m_interp_points  = result.first;
    m_interp_weights = result.second;

    /*
    amrex::Print() << TAG << "Stencil: coord = { ";
    for (int i = 0; i < AMREX_SPACEDIM; ++i)
    {
        amrex::Print() << evalCoord[i] << " ";
    }
    amrex::Print() << "}, weights = { ";
    for (int i = 0; i < m_interp_weights.size(); ++i)
    {
        amrex::Print() << m_interp_weights[i] << " ";
    }
    amrex::Print() << "}" << endl;
    */
}

template <int Order>
double Lagrange<Order>::interpData(const amrex::FArrayBox &fab, int comp)
{
    amrex::Abort("xxxxx interpData todo");
    /*
    m_interp_neg.clear();
    m_interp_pos.clear();

    // We are adding 200+ numbers at roughly the same magnitudes but alternating
    signs.
    // Let's keep track of positive and negative terms separately to make sure
    we don't run into trouble. for (int i = 0; i < m_interp_points.size(); ++i)
    {
        double data = m_interp_weights[i] * fab.get(m_interp_points[i], comp);
        if (data > 0)
        {
            m_interp_pos.insert(data);
        }
        else
        {
            m_interp_neg.insert(data);
        }
    }

    // Add positive terms from smallest to largest
    double pos = 0;
    for (typename multiset<double>::iterator it = m_interp_pos.begin(); it !=
    m_interp_pos.end(); ++it)
    {
        pos += *it;
    }

    // Largest negative term has smallest magnitude. Use reverse iterator.
    double neg = 0;
    for (typename multiset<double>::reverse_iterator it = m_interp_neg.rbegin();
    it != m_interp_neg.rend(); ++it)
    {
        neg += *it;
    }

    return pos + neg;
    */

    double accum = 0.0;

    for (int i = 0; i < m_interp_points.size(); ++i)
    {
        double data =
            m_interp_weights[i]; // xxxxx * fab.get(m_interp_points[i], comp);
        accum += data;
    }

    return accum;
}

// NOLINTBEGIN(readability-function-cognitive-complexity)
template <int Order>
std::pair<std::vector<amrex::IntVect>, std::vector<double>>
Lagrange<Order>::generateStencil(
    const std::array<int, AMREX_SPACEDIM> &deriv,
    const std::array<double, AMREX_SPACEDIM> &dx,
    const std::array<double, AMREX_SPACEDIM> &evalCoord,
    const amrex::IntVect &nearest, int dim)
{
    std::vector<amrex::IntVect> out_points;
    std::vector<double> out_weights;

    /*
     * SCAN ALONG THIS DIRECTION TO FIND THE LARGEST CONTIGUOUS CHUNK OF VALID
     * POINTS
     */

    // Allocate a std::vector twice as big as we can possibly need
    // This way we insert to either direction without shifting/growing
    std::vector<int> my_points(static_cast<size_t>(2 * (Order + deriv[dim])));

    enum
    {
        DOWN,
        UP
    };

    std::array<bool, 2> can_grow{true, true};
    int points_min = Order + deriv[dim];
    int points_max = Order + deriv[dim];

    std::array<double, AMREX_SPACEDIM> interp_coord = evalCoord;
    int candidate                                   = nearest[dim];
    int grown_direction = (nearest[dim] - evalCoord[dim] < 0) ? DOWN : UP;

    while ((can_grow[DOWN] || can_grow[UP]) &&
           (points_max - points_min < Order + deriv[dim]))
    {
        interp_coord[dim] = candidate;

        if (m_source_ptr->contains(interp_coord))
        {
            int idx =
                (grown_direction == DOWN) ? (--points_min) : (points_max++);
            my_points[idx] = candidate;
        }
        else
        {
            can_grow[grown_direction] = false;
        }

        // Flip "grow" direction if we can do so
        if (can_grow[1 - grown_direction])
        {
            grown_direction = 1 - grown_direction;
        }

        candidate = (grown_direction != DOWN) ? (my_points[points_max - 1] + 1)
                                              : (my_points[points_min] - 1);
    }

    int stencil_width = points_max - points_min;
    AMREX_ASSERT(stencil_width > 0);

    const Stencil my_weights =
        getStencil(stencil_width, deriv[dim], dx[dim],
                   evalCoord[dim] - my_points[points_min]);

    if (m_verbosity)
    {
        amrex::Print() << TAG << "Stencil: dim = " << dim
                       << ", coord = " << evalCoord[dim] << ", points = { ";
        for (int i = points_min; i < points_max; ++i)
        {
            amrex::Print() << my_points[i] << " ";
        }
        amrex::Print() << "}, weights = { ";
        for (int i = 0; i < stencil_width; ++i)
        {
            amrex::Print() << my_weights[i] << " ";
        }
        amrex::Print() << "}" << '\n';
    }

    // There is going to be potentially a LOT of temporary std::vectors getting
    // allocated in here. If things get slow this will be a good place to look
    // first.
    for (int i = 0; i < stencil_width; ++i)
    {
        interp_coord[dim] = my_points[i + points_min];

        if (dim > 0)
        {
            // Descend to the next dimension
            std::pair<std::vector<amrex::IntVect>, std::vector<double>>
                sub_result =
                    generateStencil(deriv, dx, interp_coord, nearest, dim - 1);
            std::vector<amrex::IntVect> &sub_points = sub_result.first;
            std::vector<double> &sub_weights        = sub_result.second;

            // Take tensor product weights
            for (int j = 0; j < sub_points.size(); ++j)
            {
                if (my_weights[i] != 0)
                {
                    out_points.push_back(sub_points[j]);
                    out_weights.push_back(my_weights[i] * sub_weights[j]);
                }
            }
        }
        else
        {
            // "Terminal" dimension, just push back our own stuff
            if (my_weights[i] != 0)
            {
                out_points.emplace_back(interp_coord[0], interp_coord[1],
                                        interp_coord[2]);
                out_weights.push_back(my_weights[i]);
            }
        }
    }

    return {std::move(out_points), std::move(out_weights)};
}
// NOLINTEND(readability-function-cognitive-complexity)

#endif /* LAGRANGE_IMPL_HPP_ */



================================================
FILE: Source/AMRInterpolator/Make.package
================================================
GRTECLYN_CEXE_headers += AMRInterpolator.hpp \
                         AMRInterpolator.impl.hpp \
                         CylindricalExtraction.hpp \
                         CylindricalGeometry.hpp \
                         Derivative.hpp \
                         DerivativeSetup.hpp \
                         IntegrationMethod.hpp \
                         IntegrationMethodSetup.hpp \
                         InterpolationAlgorithm.hpp \
                         InterpolationLayout.hpp \
                         InterpolationQuery.hpp \
                         InterpSource.hpp \
                         Lagrange.hpp \
                         Lagrange.impl.hpp \
                         MPIContext.hpp \
                         MPIContext.impl.hpp \
                         MPILayout.hpp \
                         MPILayout.impl.hpp \
                         QuinticConvolution.hpp \
                         QuinticConvolution.impl.hpp \
                         SphericalExtraction.hpp \
                         SphericalGeometry.hpp \
                         SurfaceExtraction.hpp \
                         SurfaceExtraction.impl.hpp \
                         WeylExtraction.hpp



================================================
FILE: Source/AMRInterpolator/MPIContext.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef MPICONTEXT_HPP_
#define MPICONTEXT_HPP_

#include "MPILayout.hpp"
#include <AMReX_ParallelDescriptor.H>
#include <vector>

class MPIContext
{
  public:
    MPIContext();

    // Getters
    inline int queryCount(int rank);
    inline int totalQueryCount();
    inline int answerCount(int rank);
    inline int totalAnswerCount();
    inline int queryDispl(int rank);
    inline int answerDispl(int rank);

    // Setters
    inline void setQueryCount(int rank, int count);
    inline void incrementQueryCount(int rank);
    inline void clearQueryCounts();

    void exchangeLayout();

#ifdef AMREX_USE_MPI
    // MPI asynchronous comms
    inline void asyncBegin();
    inline void asyncExchangeQuery(void *sendbuf, void *recvbuf,
                                   MPI_Datatype type);
    inline void asyncExchangeAnswer(void *sendbuf, void *recvbuf,
                                    MPI_Datatype type);
    inline void asyncEnd();
#endif

    // MPI utils
    static int comm_size();
    static int comm_rank();

  private:
    MPILayout m_query;
    MPILayout m_answer;

    bool m_async_active{false};
#ifdef AMREX_USE_MPI
    std::vector<MPI_Request> m_mpi_requests;
#endif
};

inline int MPIContext::comm_size()
{
    return amrex::ParallelDescriptor::NProcs();
}

inline int MPIContext::comm_rank()
{
    return amrex::ParallelDescriptor::MyProc();
}

#include "MPIContext.impl.hpp"

#endif /* MPICONTEXT_HPP_ */



================================================
FILE: Source/AMRInterpolator/MPIContext.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef MPICONTEXT_IMPL_HPP_
#define MPICONTEXT_IMPL_HPP_

inline MPIContext::MPIContext() : m_query(comm_size()), m_answer(comm_size()) {}

inline int MPIContext::queryCount(int rank) { return m_query.count(rank); }

inline int MPIContext::totalQueryCount() { return m_query.totalCount(); }

inline int MPIContext::answerCount(int rank) { return m_answer.count(rank); }

inline int MPIContext::totalAnswerCount() { return m_answer.totalCount(); }

inline int MPIContext::queryDispl(int rank) { return m_query.displ(rank); }

inline int MPIContext::answerDispl(int rank) { return m_answer.displ(rank); }

inline void MPIContext::setQueryCount(int rank, int count)
{
    AMREX_ASSERT(!m_async_active);
    m_query.setCount(rank, count);
}

inline void MPIContext::incrementQueryCount(int rank)
{
    AMREX_ASSERT(!m_async_active);
    m_query.incrementCount(rank);
}

inline void MPIContext::clearQueryCounts()
{
    AMREX_ASSERT(!m_async_active);
    m_query.clearCounts();
}

inline void MPIContext::exchangeLayout()
{
    AMREX_ASSERT(!m_async_active);
#ifdef AMREX_USE_MPI
    MPI_Alltoall(m_query.countsPtr(), 1, MPI_INT, m_answer.countsPtr(), 1,
                 MPI_INT, amrex::ParallelDescriptor::Communicator());
#else
    *m_answer.countsPtr() = *m_query.countsPtr();
#endif
    m_answer.updateDirty();
}

#ifdef AMREX_USE_MPI
inline void MPIContext::asyncBegin()
{
    AMREX_ASSERT(!m_async_active);
    m_async_active = true;
}

inline void MPIContext::asyncExchangeQuery(void *sendbuf, void *recvbuf,
                                           MPI_Datatype type)
{
    AMREX_ASSERT(m_async_active);
    MPI_Request req = 0;
    m_mpi_requests.push_back(req);

#if MPI_VERSION >= 3 && !defined(OPEN_MPI)
    MPI_Ialltoallv(sendbuf, m_query.countsPtr(), m_query.displsPtr(), type,
                   recvbuf, m_answer.countsPtr(), m_answer.displsPtr(), type,
                   amrex::ParallelDescriptor::Communicator(),
                   &m_mpi_requests.back());
#else
    MPI_Alltoallv(sendbuf, m_query.countsPtr(), m_query.displsPtr(), type,
                  recvbuf, m_answer.countsPtr(), m_answer.displsPtr(), type,
                  amrex::ParallelDescriptor::Communicator());
#endif
}

inline void MPIContext::asyncExchangeAnswer(void *sendbuf, void *recvbuf,
                                            MPI_Datatype type)
{
    AMREX_ASSERT(m_async_active);
    MPI_Request req = 0;
    m_mpi_requests.push_back(req);

#if MPI_VERSION >= 3 && !defined(OPEN_MPI)
    MPI_Ialltoallv(sendbuf, m_answer.countsPtr(), m_answer.displsPtr(), type,
                   recvbuf, m_query.countsPtr(), m_query.displsPtr(), type,
                   amrex::ParallelDescriptor::Communicator(),
                   &m_mpi_requests.back());
#else
    MPI_Alltoallv(sendbuf, m_answer.countsPtr(), m_answer.displsPtr(), type,
                  recvbuf, m_query.countsPtr(), m_query.displsPtr(), type,
                  amrex::ParallelDescriptor::Communicator());
#endif
}

inline void MPIContext::asyncEnd()
{
    AMREX_ASSERT(m_async_active);
    m_async_active = false;

#if MPI_VERSION >= 3 && !defined(OPEN_MPI)
    MPI_Waitall(
        static_cast<int>(m_mpi_requests.size()), m_mpi_requests.data(),
        MPI_STATUSES_IGNORE); // NOLINT(cppcoreguidelines-pro-type-cstyle-cast)
#endif

    m_mpi_requests.clear();
}
#endif /* ifdef AMREX_USE_MPI */

#endif /* MPICONTEXT_IMPL_HPP_ */



================================================
FILE: Source/AMRInterpolator/MPILayout.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef MPILAYOUT_HPP_
#define MPILAYOUT_HPP_

#include <vector>

class MPILayout
{

  public:
    // Getters
    inline int count(int rank) const;
    inline int totalCount() const;
    inline int displ(int rank) const;

    // Setters
    inline void setCount(int rank, int count);
    inline void incrementCount(int rank);
    inline void clearCounts();

  private:
    friend class MPIContext;

    MPILayout(int num_process);

    int m_num_process;
    std::vector<int> m_counts;
    mutable std::vector<int> m_displs;

    mutable int m_total_count{};
    mutable bool m_dirty{false};

    inline void updateDirty() const;
    inline int *countsPtr();
    inline int *displsPtr();
};

#include "MPILayout.impl.hpp"

#endif /* MPILAYOUT_HPP_ */



================================================
FILE: Source/AMRInterpolator/MPILayout.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef MPILAYOUT_IMPL_HPP_
#define MPILAYOUT_IMPL_HPP_

inline MPILayout::MPILayout(int num_process)
    : m_num_process(num_process), m_counts(m_num_process, 0),
      m_displs(m_num_process, 0)
{
}

inline int MPILayout::count(int rank) const { return m_counts[rank]; }

inline int MPILayout::totalCount() const
{
    if (m_dirty)
    {
        updateDirty();
    }
    return m_total_count;
}

inline int MPILayout::displ(int rank) const
{
    if (m_dirty)
    {
        updateDirty();
    }
    return m_displs[rank];
}

inline void MPILayout::setCount(int rank, int count)
{
    AMREX_ASSERT(rank < m_num_process && count >= 0);
    m_counts[rank] = count;
    m_dirty        = true;
}

inline void MPILayout::incrementCount(int rank)
{
    AMREX_ASSERT(rank < m_num_process);
    ++m_counts[rank];
    m_dirty = true;
}

inline void MPILayout::clearCounts()
{
    m_counts.assign(m_num_process, 0);
    m_dirty = true;
}

inline void MPILayout::updateDirty() const
{
    m_total_count = m_counts[0];
    for (int i = 1; i < m_num_process; ++i)
    {
        m_total_count += m_counts[i];
        m_displs[i]    = m_displs[i - 1] + m_counts[i - 1];
    }
    m_dirty = false;
}

inline int *MPILayout::countsPtr() { return m_counts.data(); }

inline int *MPILayout::displsPtr()
{
    if (m_dirty)
    {
        updateDirty();
    }
    return m_displs.data();
}

#endif /* MPILAYOUT_IMPL_HPP_ */



================================================
FILE: Source/AMRInterpolator/QuinticConvolution.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef QUINTICCONVOLUTION_HPP_
#define QUINTICCONVOLUTION_HPP_

#include "InterpSource.hpp"
#include <utility>

class QuinticConvolution
{
    const InterpSource &m_source;
    bool m_verbosity;

    std::vector<IntVect> m_interp_points;
    std::vector<double> m_interp_weights;

  public:
    QuinticConvolution(const InterpSource &source, bool verbosity = false);

    void setup(const std::array<int, AMREX_SPACEDIM> &deriv,
               const std::array<double, AMREX_SPACEDIM> &dx,
               const std::array<double, AMREX_SPACEDIM> &evalCoord,
               const IntVect &nearest);
    double interpData(const FArrayBox &fab, int comp);

    const static string TAG;
};

#include "QuinticConvolution.impl.hpp"

#endif /* QUINTICCONVOLUTION_HPP_ */



================================================
FILE: Source/AMRInterpolator/QuinticConvolution.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef QUINTICCONVOLUTION_IMPL_HPP_
#define QUINTICCONVOLUTION_IMPL_HPP_

const string QuinticConvolution::TAG = "\x1b[36;1m[QuinticConvolution]\x1b[0m ";

QuinticConvolution::QuinticConvolution(const InterpSource &source,
                                       bool verbosity)
    : m_source(source), m_verbosity(verbosity)
{
    AMREX_ASSERT(AMREX_SPACEDIM <= 3);
}

void QuinticConvolution::setup(
    const std::array<int, AMREX_SPACEDIM> &deriv,
    const std::array<double, AMREX_SPACEDIM> &dx,
    const std::array<double, AMREX_SPACEDIM> &evalCoord, const IntVect &nearest)
{
    m_interp_points.clear();
    m_interp_weights.clear();

    double weights_1d[AMREX_SPACEDIM][6];

    for (int dim = 0; dim < AMREX_SPACEDIM; ++dim)
    {
        double s = evalCoord[dim] - floor(evalCoord[dim]);

        if (deriv[dim] == 0)
        {
            weights_1d[dim][0] =
                s *
                (0.046875 +
                 s * (-0.1875 + s * (0.28125 + (-0.1875 + 0.046875 * s) * s)));
            weights_1d[dim][1] =
                s *
                (-0.59375 +
                 s * (1.25 + s * (-0.5625 + (-0.296875 + 0.203125 * s) * s)));
            weights_1d[dim][2] =
                1. + (s * s) * (-2.125 + (1.96875 - 0.84375 * s) * (s * s));
            weights_1d[dim][3] =
                s * (0.59375 +
                     s * (1.25 + s * (0.5625 + (-2.25 + 0.84375 * s) * s)));
            weights_1d[dim][4] =
                s *
                (-0.046875 +
                 s * (-0.1875 + s * (-0.28125 + (0.71875 - 0.203125 * s) * s)));
            weights_1d[dim][5] =
                (0.046875 - 0.046875 * s) * ((s * s) * (s * s));
        }
        else if (deriv[dim] == 1)
        {
            weights_1d[dim][0] =
                (0.046875 +
                 s * (-0.375 + s * (0.84375 + (-0.75 + 0.234375 * s) * s))) /
                dx[dim];
            weights_1d[dim][1] =
                (-0.59375 +
                 s * (2.5 + s * (-1.6875 + s * (-1.1875 + 1.015625 * s)))) /
                dx[dim];
            weights_1d[dim][2] =
                (s * (-4.25 + (7.875 - 4.21875 * s) * (s * s))) / dx[dim];
            weights_1d[dim][3] =
                (0.59375 + s * (2.5 + s * (1.6875 + s * (-9. + 4.21875 * s)))) /
                dx[dim];
            weights_1d[dim][4] =
                (-0.046875 +
                 s * (-0.375 + s * (-0.84375 + (2.875 - 1.015625 * s) * s))) /
                dx[dim];
            weights_1d[dim][5] =
                ((0.1875 - 0.234375 * s) * s * (s * s)) / dx[dim];
        }
        else if (deriv[dim] == 2)
        {
            weights_1d[dim][0] =
                (-0.375 + s * (1.6875 + (-2.25 + 0.9375 * s) * s)) /
                (dx[dim] * dx[dim]);
            weights_1d[dim][1] =
                (2.5 + s * (-3.375 + s * (-3.5625 + 4.0625 * s))) /
                (dx[dim] * dx[dim]);
            weights_1d[dim][2] =
                (-4.25 + (23.625 - 16.875 * s) * (s * s)) / (dx[dim] * dx[dim]);
            weights_1d[dim][3] = (2.5 + s * (3.375 + s * (-27. + 16.875 * s))) /
                                 (dx[dim] * dx[dim]);
            weights_1d[dim][4] =
                (-0.375 + s * (-1.6875 + (8.625 - 4.0625 * s) * s)) /
                (dx[dim] * dx[dim]);
            weights_1d[dim][5] =
                ((0.5625 - 0.9375 * s) * (s * s)) / (dx[dim] * dx[dim]);
        }
        else
        {
            amrex::Abort("Quintic convolution algorithm only supports up to "
                         "second derivative");
        }
    }

    std::array<double, AMREX_SPACEDIM> interp_coord;

#if AMREX_SPACEDIM >= 3
    for (int z = 0; z < 6; ++z)
    {
        interp_coord[2] = floor(evalCoord[2]) + z - 2;
#endif
        for (int y = 0; y < 6; ++y)
        {
            interp_coord[1] = floor(evalCoord[1]) + y - 2;

            for (int x = 0; x < 6; ++x)
            {
                interp_coord[0] = floor(evalCoord[0]) + x - 2;
                AMREX_ASSERT(m_source.contains(interp_coord));

                m_interp_points.push_back(IntVect(D_DECL6(
                    interp_coord[0], interp_coord[1], interp_coord[2],
                    interp_coord[3], interp_coord[4], interp_coord[5])));
                m_interp_weights.push_back(D_TERM6(weights_1d[0][x],
                                                   *weights_1d[1][y],
                                                   *weights_1d[2][z], , , ));
            }
        }
#if AMREX_SPACEDIM >= 3
    }
#endif
}

double QuinticConvolution::interpData(const FArrayBox &fab, int comp)
{
    amrex::Abort("xxxxx QuinticConvolution::interpData todo");

    long double accum = 0.0;

    for (int i = 0; i < m_interp_points.size(); ++i)
    {
        double data  = m_interp_weights[i] * fab.get(m_interp_points[i], comp);
        accum       += data;
    }

    return accum;
}

#endif /* QUINTICCONVOLUTION_IMPL_HPP_ */

/*
HIGHER ORDER WEIGHTS

s*(-0.009114583333333334 + s*(0.036458333333333336 + s*(-0.0546875 +
(0.036458333333333336 - 0.009114583333333334*s)*s))) s*(0.11979166666666667 +
s*(-0.2604166666666667 + s*(0.13541666666666666 + (0.040364583333333336 -
0.03515625*s)*s))) s*(-0.7122395833333334 + s*(1.2135416666666667 +
s*(-0.10677083333333333 + (-0.6979166666666666 + 0.3033854166666667*s)*s))) 1. +
(s*s)*(-1.9791666666666667 + (1.6497395833333333 - 0.6705729166666666*s)*(s*s))
s*(0.7122395833333334 + s*(1.2135416666666667 + s*(0.10677083333333333 +
(-1.703125 + 0.6705729166666666*s)*s))) s*(-0.11979166666666667 +
s*(-0.2604166666666667 + s*(-0.13541666666666666 + (0.8190104166666666 -
0.3033854166666667*s)*s))) s*(0.009114583333333334 + s*(0.036458333333333336 +
s*(0.0546875 + (-0.13541666666666666 + 0.03515625*s)*s)))
(-0.009114583333333334 + 0.009114583333333334*s)*((s*s)*(s*s))

-0.009114583333333334 + s*(0.07291666666666667 + s*(-0.1640625 +
(0.14583333333333334 - 0.045572916666666664*s)*s)) 0.11979166666666667 +
s*(-0.5208333333333334 + s*(0.40625 + (0.16145833333333334 - 0.17578125*s)*s))
-0.7122395833333334 + s*(2.4270833333333335 + s*(-0.3203125 +
s*(-2.7916666666666665 + 1.5169270833333333*s))) s*(-3.9583333333333335 +
(6.598958333333333 - 3.3528645833333335*s)*(s*s)) -0.7122395833333334 +
s*(-2.4270833333333335 + s*(-0.3203125 + (6.8125 - 3.3528645833333335*s)*s))
0.11979166666666667 + s*(0.5208333333333334 + s*(0.40625 +
s*(-3.2760416666666665 + 1.5169270833333333*s))) -0.009114583333333334 +
s*(-0.07291666666666667 + s*(-0.1640625 + (0.5416666666666666 -
0.17578125*s)*s)) (0.036458333333333336 - 0.045572916666666664*s)*s*(s*s)

0.07291666666666667 + s*(-0.328125 + (0.4375 - 0.18229166666666666*s)*s)
-0.5208333333333334 + s*(0.8125 + (0.484375 - 0.703125*s)*s)
2.4270833333333335 + s*(-0.640625 + s*(-8.375 + 6.067708333333333*s))
-3.9583333333333335 + (19.796875 - 13.411458333333334*s)*(s*s)
2.4270833333333335 + s*(0.640625 + s*(-20.4375 + 13.411458333333334*s))
-0.5208333333333334 + s*(-0.8125 + (9.828125 - 6.067708333333333*s)*s)
0.07291666666666667 + s*(0.328125 + (-1.625 + 0.703125*s)*s)
(-0.109375 + 0.18229166666666666*s)*(s*s)
*/



================================================
FILE: Source/AMRInterpolator/SphericalExtraction.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SPHERICALEXTRACTION_HPP_
#define SPHERICALEXTRACTION_HPP_

#include "SphericalGeometry.hpp"
#include "SphericalHarmonics.hpp"
#include "SurfaceExtraction.hpp"

//! A child class of SurfaceExtraction for extraction on spherical shells
class SphericalExtraction : public SurfaceExtraction<SphericalGeometry>
{
  public:
    struct params_t : SurfaceExtraction::params_t
    {
        int &num_extraction_radii() { return num_surfaces; }

        [[nodiscard]] const int &num_extraction_radii() const
        {
            return num_surfaces;
        }

        auto &extraction_radii() { return surface_param_values; }

        [[nodiscard]] const auto &extraction_radii() const
        {
            return surface_param_values;
        }

        int &num_points_theta() { return num_points_u; }

        [[nodiscard]] const int &num_points_theta() const
        {
            return num_points_u;
        }

        int &num_points_phi() { return num_points_v; }

        [[nodiscard]] const int &num_points_phi() const { return num_points_v; }

        std::array<double, AMREX_SPACEDIM> center{}; //!< the center of the
                                                     //!< spherical shells
        std::array<double, AMREX_SPACEDIM> &extraction_center()
        {
            return center;
        }
        int num_modes{}; //!< the number of modes to extract
        std::vector<std::pair<int, int>> modes; //!< the modes to extract
                                                //!< l = first, m = second

        [[nodiscard]] const SurfaceExtraction::params_t &
        get_surface_extraction_params() const
        {
            return *this;
        }
    };

  protected:
    std::array<double, AMREX_SPACEDIM> m_center;
    int m_num_modes;
    std::vector<std::pair<int, int>> m_modes;

  public:
    SphericalExtraction(const params_t &a_params, double a_dt, double a_time,
                        bool a_first_step, double a_restart_time = 0.0)
        : SurfaceExtraction(a_params.center,
                            a_params.get_surface_extraction_params(), a_dt,
                            a_time, a_first_step, a_restart_time),
          m_center(a_params.center), m_num_modes(a_params.num_modes),
          m_modes(a_params.modes)
    {
    }

    SphericalExtraction(const params_t &a_params,
                        const std::vector<vars_t> &a_vars, double a_dt,
                        double a_time, bool a_first_step,
                        double a_restart_time = 0.0)
        : SphericalExtraction(a_params, a_dt, a_time, a_first_step,
                              a_restart_time)
    {
        add_vars(a_vars);
    }

    SphericalExtraction(const params_t &a_params,
                        const std::vector<int> &a_evolution_vars, double a_dt,
                        double a_time, bool a_first_step,
                        double a_restart_time = 0.0)
        : SphericalExtraction(a_params, a_dt, a_time, a_first_step,
                              a_restart_time)
    {
        add_evolution_vars(a_evolution_vars);
    }

    // alias this long type used for complex functions defined on the surface
    // and dependent on the interpolated data
    using complex_function_t = std::function<std::pair<double, double>(
        std::vector<double> &, double, double, double)>;

    //! Add the integrand corresponding to the spin-weighted spherical harmonic
    //! decomposition of a complex-valued function, a_function
    //! (normalised by 1/r^2), over each spherical shell
    // NOLINTBEGIN(readability-identifier-length)
    void add_mode_integrand(
        int es, int el, int em, const complex_function_t &a_function,
        std::pair<std::vector<double>, std::vector<double>> &out_integrals,
        const IntegrationMethod &a_method_theta = IntegrationMethod::simpson,
        const IntegrationMethod &a_method_phi   = IntegrationMethod::trapezium,
        const bool a_broadcast_integral         = false)
    {
        auto integrand_re = [center = m_center, &geom = m_geom, es, el, em,
                             &a_function](std::vector<double> &a_data_here,
                                          double r, double theta, double phi)
        {
            // note that spin_Y_lm requires the coordinates with the center
            // at the origin
            double x = geom.get_grid_coord(0, r, theta, phi) - center[0];
            double y = geom.get_grid_coord(1, r, theta, phi) - center[1];
            double z = geom.get_grid_coord(2, r, theta, phi) - center[2];
            SphericalHarmonics::Y_lm_t Y_lm =
                SphericalHarmonics::spin_Y_lm(x, y, z, es, el, em);
            auto function_here = a_function(a_data_here, r, theta, phi);
            return (function_here.first * Y_lm.Real +
                    function_here.second * Y_lm.Im) /
                   (r * r);
        };
        add_integrand(integrand_re, out_integrals.first, a_method_theta,
                      a_method_phi, a_broadcast_integral);

        auto integrand_im = [center = m_center, &geom = m_geom, es, el, em,
                             &a_function](std::vector<double> &a_data_here,
                                          double r, double theta, double phi)
        {
            // note that spin_Y_lm requires the coordinates with the center
            // at the origin
            double x = geom.get_grid_coord(0, r, theta, phi) - center[0];
            double y = geom.get_grid_coord(1, r, theta, phi) - center[1];
            double z = geom.get_grid_coord(2, r, theta, phi) - center[2];
            SphericalHarmonics::Y_lm_t Y_lm =
                SphericalHarmonics::spin_Y_lm(x, y, z, es, el, em);
            auto function_here = a_function(a_data_here, r, theta, phi);
            return (function_here.second * Y_lm.Real -
                    function_here.first * Y_lm.Im) /
                   (r * r);
        };
        add_integrand(integrand_im, out_integrals.second, a_method_theta,
                      a_method_phi, a_broadcast_integral);
    }

    //! If you only want to extract one mode, you can use this function which
    //! calls add_mode_integrand, then integrate and returns the integrals
    std::pair<std::vector<double>, std::vector<double>> integrate_mode(
        int es, int el, int em, const complex_function_t &a_function,
        const IntegrationMethod &a_method_theta = IntegrationMethod::simpson,
        const IntegrationMethod &a_method_phi   = IntegrationMethod::trapezium)
    {
        m_integrands.clear();
        m_integration_methods.clear();
        m_integrals.clear();

        std::pair<std::vector<double>, std::vector<double>> integrals;
        add_mode_integrand(es, el, em, a_function, integrals, a_method_theta,
                           a_method_phi);
        integrate();
        return integrals;
    }
    // NOLINTEND(readability-identifier-length)
};

#endif /* SPHERICALEXTRACTION_HPP_ */



================================================
FILE: Source/AMRInterpolator/SphericalGeometry.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SPHERICALGEOMETRY_HPP_
#define SPHERICALGEOMETRY_HPP_

// Other includes
#include <array>
#include <cmath>
#include <string>

//! This SurfaceGeometry template class provides spherical shell geometry
//! implementation for the SurfaceExtraction class
//! u = theta, v = phi
class SphericalGeometry
{
  private:
    std::array<double, AMREX_SPACEDIM> m_center;

  public:
    SphericalGeometry(const std::array<double, AMREX_SPACEDIM> &a_center)
        : m_center(a_center)
    {
    }

    //! returns the grid spacing in theta
    [[nodiscard]] static inline double du(int a_num_points_theta)
    {
        return M_PI / (double)(a_num_points_theta - 1);
    }

    //! returns the grid spacing in phi
    [[nodiscard]] static inline double dv(int a_num_points_phi)
    {
        return 2.0 * M_PI / ((double)a_num_points_phi);
    }

    //! returns the theta coordinate associated to the theta/u index
    [[nodiscard]] static inline double u(int a_itheta, int a_num_points_theta)
    {
        return a_itheta * du(a_num_points_theta);
    }

    //! returns the phi coordinate associated to the phi/v index
    [[nodiscard]] static inline double v(int a_iphi, int a_num_points_phi)
    {
        return a_iphi * dv(a_num_points_phi);
    }

    [[nodiscard]] static inline bool is_u_periodic() { return false; }
    [[nodiscard]] static inline bool is_v_periodic() { return true; }

    //! returns the Cartesian coordinate in direction a_dir with specified
    //! radius, theta and phi.
    // NOLINTBEGIN(bugprone-easily-swappable-parameters)
    [[nodiscard]] inline double get_grid_coord(int a_dir, double a_radius,
                                               double a_theta,
                                               double a_phi) const
    // NOLINTEND(bugprone-easily-swappable-parameters)
    {
        switch (a_dir)
        {
        case (0):
            return m_center[0] + a_radius * sin(a_theta) * cos(a_phi);
        case (1):
            return m_center[1] + a_radius * sin(a_theta) * sin(a_phi);
        case (2):
            return m_center[2] + a_radius * cos(a_theta);
        default:
            amrex::Abort("SphericalGeometry: Direction not supported");
            return 0.;
        }
    }

    //! returns the area element on a sphere with radius a_radius at the point
    //! (a_theta, a_phi)
    [[nodiscard]] static inline double
    area_element(double a_radius, double a_theta, double /*a_phi*/)
    {
        return a_radius * a_radius * sin(a_theta);
    }

    [[nodiscard]] static inline std::string param_name() { return "r"; }

    [[nodiscard]] static inline std::string u_name() { return "theta"; }

    [[nodiscard]] static inline std::string v_name() { return "phi"; }
};

#endif /* SPHERICALGEOMETRY_HPP_ */



================================================
FILE: Source/AMRInterpolator/SurfaceExtraction.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SURFACEEXTRACTION_HPP_
#define SURFACEEXTRACTION_HPP_

// AMReX includes
#include <AMReX_GpuContainers.H>

// Other includes
#include "AMRInterpolator.hpp"
#include "DimensionDefinitions.hpp"
#include "FilesystemTools.hpp"
#include "IntegrationMethod.hpp"
#include "InterpolationQuery.hpp"
#include "Lagrange.hpp"
#include "SmallDataIO.hpp" // for writing data
#include "StateVariables.hpp"

#include <algorithm>
#include <array>
#include <functional>
#include <tuple>
#include <utility>
#include <vector>

//! This class extracts grid variables on 2 dimensional surfaces each
//! parameterised by u and v with different surfaces given by level sets of
//! another parameter
template <class SurfaceGeometry> class SurfaceExtraction
{
  public:
    struct params_t
    {
        int num_surfaces{}; //!< number of surfaces over which to extraction
        amrex::Gpu::ManagedVector<double>
            surface_param_values; //!< the values of the
                                  //!< parameter that gives the required
                                  //!< surfaces with SurfaceGeom geometry (e.g.
                                  //!< radii for spherical shells)
        int num_points_u{}; //!< the number of points for the first parameter
                            //!< that parameterises each surface
        int num_points_v{}; //!< the number of points for the second parameter
                            //!< that parameterises each surfaces
        amrex::Gpu::ManagedVector<int>
            extraction_levels;   //!< the level on which to do the
                                 //!< extraction for each surface
        bool write_extraction{}; //!< whether or not to write the extracted data

        std::string data_path, integral_file_prefix;
        std::string extraction_path, extraction_file_prefix;

        int min_extraction_level()
        {
            return *(std::min_element(extraction_levels.begin(),
                                      extraction_levels.end()));
        }
    };

    using vars_t = std::tuple<int, VariableType, Derivative>;

  protected:
    SurfaceGeometry m_geom; //!< the geometry class which knows about
                            //!< the particular surface
    params_t m_params;
    std::vector<std::tuple<int, VariableType, Derivative>>
        m_vars; //!< the vector of pairs of
    //!< variables and derivatives to extract
    double m_dt{};
    double m_time{};
    bool m_first_step{};
    double m_restart_time{};
    int m_num_interp_points{}; //!< the total number of points this
                               //!< rank will extract (0 on ranks > 0)
    double m_du{};             //!< the grid spacing in u (used in integrate)
    double m_dv{};             //!< the grid spacing in v (used in integrate)

    std::vector<std::vector<double>> m_interp_data;
    std::array<std::vector<double>, AMREX_SPACEDIM> m_interp_coords;
    // this is the really long type used for integrands
    // the vector<double> is a vector of all the extracted variables at that
    // point in the order they were added
    using integrand_t =
        std::function<double(std::vector<double> &, double, double, double)>;
    std::vector<integrand_t> m_integrands;
    std::vector<std::array<IntegrationMethod, 2>> m_integration_methods;
    std::vector<std::reference_wrapper<std::vector<double>>> m_integrals;
    std::vector<bool> m_broadcast_integrals;

    bool m_done_extraction{}; //!< whether or not the extract function has
                              //!< been called for this object

    //! returns the flattened index for m_interp_data and m_interp_coords
    //! associated to given surface, u and v indices
    [[nodiscard]] int index(int a_isurface, int a_iu, int a_iv) const
    {
        return a_isurface * m_params.num_points_u * m_params.num_points_v +
               a_iu * m_params.num_points_v + a_iv;
    }

  public:
    //! Normal constructor which requires vars to be added after construction
    //! using add_var or add_vars
    SurfaceExtraction(const SurfaceGeometry &a_geom, params_t a_params,
                      double a_dt, double a_time, bool a_first_step,
                      double a_restart_time = 0.0);

    //! add a single variable or derivative of variable
    void add_var(int a_var, const VariableType var_type = VariableType::state,
                 const Derivative &a_deriv = Derivative::LOCAL);

    //! add a vector of variables/derivatives of variables
    void add_vars(const std::vector<vars_t> &a_vars);

    //! add a vector of evolution variables (no derivatives)
    void add_evolution_vars(const std::vector<int> &a_vars);

    //! add a vector of diagnostic variables (no derivatives)
    void add_diagnostic_vars(const std::vector<int> &a_vars);

    // NOLINTBEGIN(bugprone-easily-swappable-parameters)
    //! Alternative constructor with a predefined vector of variables and
    //! derivatives
    SurfaceExtraction(
        const SurfaceGeometry &a_geom, const params_t &a_params,
        const std::vector<std::tuple<int, VariableType, Derivative>> &a_vars,
        double a_dt, double a_time, bool a_first_step,
        double a_restart_time = 0.0);

    //! Another alternative constructor with a predefined vector of variables
    //! no derivatives
    SurfaceExtraction(const SurfaceGeometry &a_geom, const params_t &a_params,
                      const std::vector<int> &a_vars, double a_dt,
                      double a_time, bool a_first_step,
                      double a_restart_time = 0.0);
    // NOLINTEND(bugprone-easily-swappable-parameters)

    //! Do the extraction
    template <typename InterpAlgo>
    void extract(AMRInterpolator<InterpAlgo> *a_interpolator);

    //! Add an integrand dependent on the interpolated data over the surface
    //! for integrate() to integrate over.
    //! Note the area_element is already included from the SurfaceGeometry
    //! template class
    //! The last argument is whether to broadcast the result to all MPI ranks
    //! or just keep on rank 0. Most use cases won't need this set to true.
    void add_integrand(
        const integrand_t &a_integrand, std::vector<double> &out_integrals,
        const IntegrationMethod &a_method_u = IntegrationMethod::trapezium,
        const IntegrationMethod &a_method_v = IntegrationMethod::trapezium,
        const bool a_broadcast_integral     = false);

    //! Add an integrand which is just a single var. The a_var argument should
    //! correspond to the order in which the desired var was added to this
    //! object with add_var
    //! The last argument is whether to broadcast the result to all MPI ranks
    //! or just keep on rank 0. Most use cases won't need this set to true.
    void add_var_integrand(
        int a_var, std::vector<double> &out_integrals,
        const IntegrationMethod &a_method_u = IntegrationMethod::trapezium,
        const IntegrationMethod &a_method_v = IntegrationMethod::trapezium,
        const bool a_broadcast_integral     = false);

    //! Integrate the integrands added using add_integrand
    void integrate();

    //! This integrate function can be used if you only want to integrate one
    //! integrand. It calls add_integrand() and integrate()
    //! The last argument is whether to broadcast the result to all MPI ranks
    //! or just keep on rank 0. Most use cases won't need this set to true.
    std::vector<double> integrate(
        integrand_t a_integrand,
        const IntegrationMethod &a_method_u = IntegrationMethod::trapezium,
        const IntegrationMethod &a_method_v = IntegrationMethod::trapezium,
        const bool a_broadcast_integral     = false);

    //! Write the interpolated data to a file with a block for each surface
    void write_extraction(std::string a_file_prefix) const;

    //! write some integrals to a file at this timestep
    void write_integrals(const std::string &a_filename,
                         const std::vector<std::vector<double>> &a_integrals,
                         const std::vector<std::string> &a_labels = {}) const;

    //! convenience caller for write_integrals in the case of just integral per
    //! surface
    void write_integral(const std::string &a_filename,
                        const std::vector<double> &a_integrals,
                        const std::string &a_label = "") const;
};

#include "SurfaceExtraction.impl.hpp"

#endif /* SURFACEEXTRACTION_HPP_ */



================================================
FILE: Source/AMRInterpolator/SurfaceExtraction.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(SURFACEEXTRACTION_HPP_)
#error "This file should only be included through SurfaceExtraction.hpp"
#endif

#ifndef SURFACEEXTRACTION_IMPL_HPP_
#define SURFACEEXTRACTION_IMPL_HPP_

#include <utility>

// NOLINTBEGIN(bugprone-easily-swappable-parameters)
//! Normal constructor which requires vars to be added after construction
//! using add_var or add_vars
template <class SurfaceGeometry>
SurfaceExtraction<SurfaceGeometry>::SurfaceExtraction(
    const SurfaceGeometry &a_geom, params_t a_params, double a_dt,
    double a_time, bool a_first_step, double a_restart_time)
    : m_geom(a_geom), m_params(std::move(a_params)), m_dt(a_dt), m_time(a_time),
      m_first_step(a_first_step), m_restart_time(a_restart_time),
      m_num_interp_points((amrex::ParallelDescriptor::MyProc() == 0)
                              ? m_params.num_surfaces * m_params.num_points_u *
                                    m_params.num_points_v
                              : 0),
      m_du(m_geom.du(m_params.num_points_u)),
      m_dv(m_geom.dv(m_params.num_points_v))
// NOLINTEND(bugprone-easily-swappable-parameters)
{
    // check folders only in first two timesteps
    // (or at m_first_step if this is not the first two timesteps)
    if (m_time < m_restart_time + 1.5 * m_dt || m_first_step)
    {
        if (!FilesystemTools::directory_exists(m_params.data_path))
        {
            FilesystemTools::mkdir_recursive(m_params.data_path);
        }

        if (m_params.write_extraction &&
            !FilesystemTools::directory_exists(m_params.extraction_path))
        {
            FilesystemTools::mkdir_recursive(m_params.extraction_path);
        }
    }

    // only interp points on rank 0
    if (amrex::ParallelDescriptor::MyProc() == 0)
    {
        FOR (idir)
        {
            m_interp_coords[idir].resize(m_num_interp_points);
        }

        for (int isurface = 0; isurface < m_params.num_surfaces; ++isurface)
        {
            double surface_param_value =
                m_params.surface_param_values[isurface];
            for (int iu = 0; iu < m_params.num_points_u; ++iu)
            {
                double u = m_geom.u(iu, m_params.num_points_u);
                for (int iv = 0; iv < m_params.num_points_v; ++iv)
                {
                    double v = m_geom.v(iv, m_params.num_points_v);
                    FOR (idir)
                    {
                        int idx                    = index(isurface, iu, iv);
                        m_interp_coords[idir][idx] = m_geom.get_grid_coord(
                            idir, surface_param_value, u, v);
                    }
                }
            }
        }
    }
}

//! add a single variable or derivative of variable
template <class SurfaceGeometry>
void SurfaceExtraction<SurfaceGeometry>::add_var(int a_var,
                                                 const VariableType a_var_type,
                                                 const Derivative &a_deriv)
{
    AMREX_ASSERT(!m_done_extraction);
    m_vars.emplace_back(a_var, a_var_type, a_deriv);
    // m_num_interp_points is 0 on ranks > 0
    m_interp_data.emplace_back(m_num_interp_points);
}

//! add a vector of variables/derivatives of variables
template <class SurfaceGeometry>
void SurfaceExtraction<SurfaceGeometry>::add_vars(
    const std::vector<std::tuple<int, VariableType, Derivative>> &a_vars)
{
    for (auto var : a_vars)
    {
        add_var(std::get<0>(var), std::get<1>(var), std::get<2>(var));
    }
}

//! add a vector of evolutionvariables (no derivatives)
template <class SurfaceGeometry>
void SurfaceExtraction<SurfaceGeometry>::add_evolution_vars(
    const std::vector<int> &a_vars)
{
    for (auto var : a_vars)
    {
        add_var(var, VariableType::state);
    }
}

//! add a vector of evolutionvariables (no derivatives)
template <class SurfaceGeometry>
void SurfaceExtraction<SurfaceGeometry>::add_diagnostic_vars(
    const std::vector<int> &a_vars)
{
    for (auto var : a_vars)
    {
        add_var(var, VariableType::derived);
    }
}

//! Alternative constructor with a predefined vector of variables and
//! derivatives
template <class SurfaceGeometry>
SurfaceExtraction<SurfaceGeometry>::SurfaceExtraction(
    const SurfaceGeometry &a_geom, const params_t &a_params,
    const std::vector<std::tuple<int, VariableType, Derivative>> &a_vars,
    double a_dt, double a_time, bool a_first_step, double a_restart_time)
    : SurfaceExtraction<SurfaceGeometry>(a_geom, a_params, a_dt, a_time,
                                         a_first_step, a_restart_time)
{
    add_vars(a_vars);
}

//! Another alternative constructor with a predefined vector of variables
//! no derivatives
template <class SurfaceGeometry>
SurfaceExtraction<SurfaceGeometry>::SurfaceExtraction(
    const SurfaceGeometry &a_geom, const params_t &a_params,
    const std::vector<int> &a_vars, double a_dt, double a_time,
    bool a_first_step, double a_restart_time)
    : SurfaceExtraction<SurfaceExtraction>(a_geom, a_params, a_dt, a_time,
                                           a_first_step, a_restart_time)
{
    add_evolution_vars(a_vars);
}

//! Do the extraction
template <class SurfaceGeometry>
template <typename InterpAlgo>
void SurfaceExtraction<SurfaceGeometry>::extract(
    AMRInterpolator<InterpAlgo> *a_interpolator)
{
    if (a_interpolator == nullptr)
    {
        amrex::Abort("SurfaceExtraction: invalid AMRInterpolator pointer");
    }
    // m_num_interp_points is 0 on ranks > 0
    InterpolationQuery query(m_num_interp_points);
    FOR (idir)
    {
        query.setCoords(idir, m_interp_coords[idir].data());
    }
    for (std::size_t ivar = 0; ivar < m_vars.size(); ++ivar)
    {
        // note the difference in order between the m_vars tuple in this class
        // and the InterpolationQuery::out_t type
        query.addComp(std::get<0>(m_vars[ivar]), m_interp_data[ivar].data(),
                      std::get<2>(m_vars[ivar]), std::get<1>(m_vars[ivar]));
    }

    // submit the query
    a_interpolator->interp(query);
    m_done_extraction = true;
}

//! Add an integrand (which must of type integrand_t) for integrate() to
//! integrate over. Note the area_element is already included from the
//! SurfaceGeometry template class
template <class SurfaceGeometry>
void SurfaceExtraction<SurfaceGeometry>::add_integrand(
    const integrand_t &a_integrand, std::vector<double> &out_integrals,
    const IntegrationMethod &a_method_u, const IntegrationMethod &a_method_v,
    const bool a_broadcast_integral)
{
    // if broadcasting integral to all ranks, all ranks need to know about it
    m_broadcast_integrals.push_back(a_broadcast_integral);
    if (a_broadcast_integral || amrex::ParallelDescriptor::MyProc() == 0)
    {
        // resize the out_integrals and store a reference to it
        out_integrals.resize(m_params.num_surfaces);
        std::fill(out_integrals.begin(), out_integrals.end(), 0.0);
    }
    m_integrals.push_back(std::ref(out_integrals));

    // only rank 0 actually does the integration and needs to know about the
    // integrand and integration method
    if (amrex::ParallelDescriptor::MyProc() == 0)
    {
        // store the integrand
        m_integrands.push_back(a_integrand);

        // check if integration methods are valid given periodicity and number
        // of points
        bool valid_u =
            a_method_u.is_valid(m_params.num_points_u, m_geom.is_u_periodic());
        bool valid_v =
            a_method_v.is_valid(m_params.num_points_v, m_geom.is_v_periodic());

        // default to using the trapezium rule if provided methods are not valid
        IntegrationMethod method_u = IntegrationMethod::trapezium;
        IntegrationMethod method_v = IntegrationMethod::trapezium;
        if (!valid_u)
        {
            amrex::Warning(
                "SurfaceExtraction<SurfaceGeometry>::integrate: Provided "
                "IntegrationMethod for u is not valid with\nthis num_points_u; "
                "reverting to trapezium rule.");
        }
        else
        {
            method_u = a_method_u;
        }
        if (!valid_v)
        {
            amrex::Warning(
                "SurfaceExtraction<SurfaceGeometry>::integrate: Provided "
                "IntegrationMethod for v is not valid with\nthis num_points_v; "
                "reverting to trapezium rule.");
        }
        else
        {
            method_v = a_method_v;
        }
        m_integration_methods.push_back({method_u, method_v});
    }
}

//! Add an integrand which is just a single var. The a_var argument should
//! correspond to the order in which the desired var was added to this object
//! with add_var
template <class SurfaceGeometry>
void SurfaceExtraction<SurfaceGeometry>::add_var_integrand(
    int a_var, std::vector<double> &out_integrals,
    const IntegrationMethod &a_method_u, const IntegrationMethod &a_method_v,
    const bool a_broadcast_integral)
{
    AMREX_ASSERT(a_var >= 0 && a_var < m_vars.size());
    integrand_t var_integrand =
        [var = a_var](std::vector<double> &data, double /*unused*/,
                      double /*unused*/, double /*unused*/)
    { return data[var]; };
    add_integrand(var_integrand, out_integrals, a_method_u, a_method_v,
                  a_broadcast_integral);
}

// NOLINTBEGIN(readability-function-cognitive-complexity)
template <class SurfaceGeometry>
void SurfaceExtraction<SurfaceGeometry>::integrate()
{
    AMREX_ASSERT(m_done_extraction);
    if (amrex::ParallelDescriptor::MyProc() == 0)
    {
        // note this condition won't be true on other ranks
        AMREX_ASSERT(m_integrands.size() == m_integration_methods.size() &&
                     m_integrals.size() > 0);
        int num_integrals = m_integrals.size();

        for (int isurface = 0; isurface < m_params.num_surfaces; ++isurface)
        {
            double surface_param_value =
                m_params.surface_param_values[isurface];
            for (int iu = 0; iu < m_params.num_points_u; ++iu)
            {
                double u = m_geom.u(iu, m_params.num_points_u);
                std::vector<double> inner_integral(num_integrals, 0.0);
                for (int iv = 0; iv < m_params.num_points_v; ++iv)
                {
                    double v = m_geom.v(iv, m_params.num_points_v);
                    std::vector<double> data_here(m_vars.size());
                    for (std::size_t ivar = 0; ivar < m_vars.size(); ++ivar)
                    {
                        data_here[ivar] =
                            m_interp_data[ivar][index(isurface, iu, iv)];
                    }
                    for (int iintegral = 0; iintegral < num_integrals;
                         ++iintegral)
                    {
                        auto integrand = m_integrands[iintegral];
                        double integrand_with_area_element =
                            integrand(data_here, surface_param_value, u, v) *
                            m_geom.area_element(surface_param_value, u, v);
                        double weight =
                            m_integration_methods[iintegral][1].weight(
                                iv, m_params.num_points_v,
                                m_geom.is_v_periodic());
                        inner_integral[iintegral] +=
                            weight * m_dv * integrand_with_area_element;
                    }
                }
                for (int iintegral = 0; iintegral < num_integrals; ++iintegral)
                {
                    double weight = m_integration_methods[iintegral][0].weight(
                        iu, m_params.num_points_u, m_geom.is_u_periodic());
                    (m_integrals[iintegral].get())[isurface] +=
                        weight * m_du * inner_integral[iintegral];
                }
            }
        }
    }

    // now broadcast result to non-zero ranks if requested
    for (std::size_t iintegral = 0; iintegral < m_integrals.size(); ++iintegral)
    {
        if (m_broadcast_integrals[iintegral])
        {
            amrex::Vector<double> broadcast_Vector;
            if (amrex::ParallelDescriptor::MyProc() == 0)
            {
                // xxxxx    broadcast_Vector = m_integrals[iintegral].get();
                // xxxxx broadcast(broadcast_Vector, 0);
                if (amrex::ParallelDescriptor::MyProc() != 0)
                {
                    // xxxxx m_integrals[iintegral].get() = broadcast_Vector;
                }
            }
        }
    }
}
// NOLINTEND(readability-function-cognitive-complexity)

//! Integrate some integrand dependent on the interpolated data over the
//! surface. The integrand function should be of the signature
//! double integrand(std::vector<double> data_here,
//!     double a_surface_param_value, double a_u, double a_v)
//! where data_here is a vector of all the interpolated variables at the
//! point specified by the other arguments.
template <class SurfaceGeometry>
std::vector<double> SurfaceExtraction<SurfaceGeometry>::integrate(
    integrand_t a_integrand, const IntegrationMethod &a_method_u,
    const IntegrationMethod &a_method_v, const bool a_broadcast_integral)
{
    m_integrands.clear();
    m_integration_methods.clear();
    m_integrals.clear();

    std::vector<double> out_integrals(m_params.num_surfaces, 0.0);
    add_integrand(a_integrand, out_integrals, a_method_u, a_method_v,
                  a_broadcast_integral);
    integrate();

    return out_integrals;
}

//! Write the interpolated data to a file with a block for each surface
template <class SurfaceGeometry>
void SurfaceExtraction<SurfaceGeometry>::write_extraction(
    std::string a_file_prefix) const
{
    AMREX_ASSERT(m_done_extraction);
    if (amrex::ParallelDescriptor::MyProc() == 0)
    {
        SmallDataIO extraction_file(m_params.extraction_path + a_file_prefix,
                                    m_dt, m_time, m_restart_time,
                                    SmallDataIO::NEW, m_first_step);

        for (int isurface = 0; isurface < m_params.num_surfaces; ++isurface)
        {
            // Write headers
            std::vector<std::string> header1_strings = {
                "time = " + std::to_string(m_time) + ",",
                m_geom.param_name() + " = " +
                    std::to_string(m_params.surface_param_values[isurface])};
            extraction_file.write_header_line(header1_strings, "");
            std::vector<std::string> components(m_vars.size());
            for (std::size_t ivar = 0; ivar < m_vars.size(); ++ivar)
            {
                if (std::get<2>(m_vars[ivar]) != Derivative::LOCAL)
                {
                    components[ivar] =
                        Derivative::name(std::get<2>(m_vars[ivar])) + "_";
                }
                else
                {
                    components[ivar] = "";
                }
                if (std::get<1>(m_vars[ivar]) == VariableType::state)
                {
                    components[ivar] +=
                        StateVariables::names[std::get<0>(m_vars[ivar])];
                }
                else
                {
                    // components[ivar] +=
                    //     DiagnosticVariables::names[std::get<0>(m_vars[ivar])];
                }
            }
            std::vector<std::string> coords = {m_geom.u_name(),
                                               m_geom.v_name()};
            extraction_file.write_header_line(components, coords);

            // Now the data
            for (int iu = 0; iu < m_params.num_points_u; ++iu)
            {
                double u = m_geom.u(iu, m_params.num_points_u);
                for (int iv = 0; iv < m_params.num_points_v; ++iv)
                {
                    double v = m_geom.v(iv, m_params.num_points_v);
                    int idx  = index(isurface, iu, iv);
                    std::vector<double> data(m_vars.size());
                    for (std::size_t ivar = 0; ivar < m_vars.size(); ++ivar)
                    {
                        data[ivar] = m_interp_data[ivar][idx];
                    }

                    extraction_file.write_data_line(data, {u, v});
                }
            }
            extraction_file.line_break();
        }
    }
}

//! write some integrals to a file at this timestep
template <class SurfaceGeometry>
void SurfaceExtraction<SurfaceGeometry>::write_integrals(
    const std::string &a_filename,
    const std::vector<std::vector<double>> &a_integrals,
    const std::vector<std::string> &a_labels) const
{
    if (amrex::ParallelDescriptor::MyProc() == 0)
    {
        const size_t num_integrals_per_surface = a_integrals.size();
        // if labels are provided there must be the same number of labels as
        // there are integrals
        if (!a_labels.empty())
        {
            AMREX_ASSERT(num_integrals_per_surface ==
                         static_cast<int>(a_labels.size()));
        }
        // each inner vector element of a_integrals must have the same number of
        // elements as there are surfaces (i.e. one integral per surface)
        for (auto vect : a_integrals)
        {
            AMREX_ASSERT(static_cast<int>(vect.size()) ==
                         m_params.num_surfaces);
        }
        // open file for writing
        SmallDataIO integral_file(m_params.data_path + a_filename, m_dt, m_time,
                                  m_restart_time, SmallDataIO::APPEND,
                                  m_first_step);

        // remove any duplicate data if this is a restart
        integral_file.remove_duplicate_time_data();

        if (m_first_step)
        {
            // make header strings
            std::vector<std::string> header1_strings(num_integrals_per_surface *
                                                     m_params.num_surfaces);
            std::vector<std::string> header2_strings(num_integrals_per_surface *
                                                     m_params.num_surfaces);
            for (size_t isurface = 0; isurface < m_params.num_surfaces;
                 ++isurface)
            {
                for (size_t iintegral = 0;
                     iintegral < num_integrals_per_surface; ++iintegral)
                {
                    size_t idx =
                        isurface * num_integrals_per_surface + iintegral;
                    if (a_labels.empty())
                    {
                        header1_strings[idx] = "";
                    }
                    else
                    {
                        header1_strings[idx] = a_labels[iintegral];
                    }
                    header2_strings[idx] =
                        std::to_string(m_params.surface_param_values[isurface]);
                }
            }
            std::string pre_header2_string = m_geom.param_name() + " = ";

            // write headers
            integral_file.write_header_line(header1_strings);
            integral_file.write_header_line(header2_strings,
                                            pre_header2_string);
        }

        // make vector of data for writing
        std::vector<double> data_for_writing(num_integrals_per_surface *
                                             m_params.num_surfaces);
        for (size_t isurface = 0; isurface < m_params.num_surfaces; ++isurface)
        {
            for (size_t iintegral = 0; iintegral < num_integrals_per_surface;
                 ++iintegral)
            {
                size_t idx = isurface * num_integrals_per_surface + iintegral;
                data_for_writing[idx] = a_integrals[iintegral][isurface];
            }
        }

        // write data
        integral_file.write_time_data_line(data_for_writing);
    }
}

//! convenience caller for write_integrals in the case of just one integral per
//! surface
template <class SurfaceGeometry>
void SurfaceExtraction<SurfaceGeometry>::write_integral(
    const std::string &a_filename, const std::vector<double> &a_integrals,
    const std::string &a_label) const
{
    std::vector<std::vector<double>> integrals(1, a_integrals);
    if (!a_label.empty())
    {
        std::vector<std::string> labels(1, a_label);
        write_integrals(a_filename, integrals, labels);
    }
    else
    {
        write_integrals(a_filename, integrals);
    }
}

#endif /* SURFACEEXTRACTION_IMPL_HPP_ */



================================================
FILE: Source/AMRInterpolator/WeylExtraction.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef WEYLEXTRACTION_HPP_
#define WEYLEXTRACTION_HPP_

#include "SphericalExtraction.hpp"

//!  The class allows extraction of the values of the Weyl scalar components on
//!  spherical shells at specified radii, and integration over those shells
/*!
   The class allows the user to extract data from the grid for the Weyl
   components over spherical shells at specified radii. The values may then be
   written to an output file, or integrated across the surfaces.
*/
class WeylExtraction : public SphericalExtraction
{
  public:
    //! The constructor
    WeylExtraction(SphericalExtraction::params_t &a_params, double a_dt,
                   double a_time, bool a_first_step,
                   double a_restart_time = 0.0)
        : SphericalExtraction(a_params, a_dt, a_time, a_first_step,
                              a_restart_time)
    {
#if 0
        add_var(c_Weyl4_Re, VariableType::derived);
        add_var(c_Weyl4_Im, VariableType::derived);
#endif
    }

    //! The old constructor which assumes it is called in specificPostTimeStep
    //! so the first time step is when m_time == m_dt
    WeylExtraction(SphericalExtraction::params_t a_params, double a_dt,
                   double a_time, double a_restart_time = 0.0)
        : WeylExtraction(a_params, a_dt, a_time, (a_dt == a_time),
                         a_restart_time)
    {
    }

    //! Execute the query
    void execute_query(AMRInterpolator<Lagrange<4>> *a_interpolator)
    {
        // extract the values of the Weyl scalars on the spheres
        extract(a_interpolator);

        if (m_params.write_extraction)
        {
            write_extraction(m_params.extraction_file_prefix);
        }

        // now calculate and write the requested spherical harmonic modes
        std::vector<std::pair<std::vector<double>, std::vector<double>>>
            mode_integrals(m_num_modes);

        // note that this is normalised by multiplying by radius
        auto normalised_Weyl4_complex = [](std::vector<double> Weyl4_reim_parts,
                                           double r, double /*unused*/,
                                           double /*unused*/)
        {
            // here the std::vector<double> passed will just have
            // the real and imaginary parts of the Weyl4 scalar as its
            // only components
            return std::make_pair(r * Weyl4_reim_parts[0],
                                  r * Weyl4_reim_parts[1]);
        };

        // add the modes that will be integrated
        for (int imode = 0; imode < m_num_modes; ++imode)
        {
            const auto &mode                  = m_modes[imode];
            constexpr int spin_quantum_number = -2;
            add_mode_integrand(spin_quantum_number, mode.first, mode.second,
                               normalised_Weyl4_complex, mode_integrals[imode]);
        }

        // do the integration over the surface
        integrate();

        // write the integrals
        for (int imode = 0; imode < m_num_modes; ++imode)
        {
            const auto &mode               = m_modes[imode];
            std::string integrals_filename = m_params.integral_file_prefix +
                                             std::to_string(mode.first) +
                                             std::to_string(mode.second);
            std::vector<std::vector<double>> integrals_for_writing = {
                std::move(mode_integrals[imode].first),
                std::move(mode_integrals[imode].second)};
            std::vector<std::string> labels = {"integral Re", "integral Im"};
            write_integrals(integrals_filename, integrals_for_writing, labels);
        }
    }
};

#endif /* WEYLEXTRACTION_HPP_ */



================================================
FILE: Source/BlackHoles/BHAMR.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef BHAMR_HPP_
#define BHAMR_HPP_

#include "GRAMR.hpp"
#include "PunctureTracker.hpp"

#include <AMReX_ParmParse.H>

/// A child of Chombo's AMR class to interface with tools which require
/// access to the whole AMR hierarchy, and those of GRAMR
/**
 * This object inherits from GRAMR and adds tools required for BH spacetimes
 */

template <int num_punctures> class BHAMR : public GRAMR
{
  private:
    PunctureTracker<num_punctures> m_puncture_tracker;

  public:
    BHAMR(amrex::LevelBld *a_levelbld) : GRAMR(a_levelbld)
    {
        amrex::ParmParse puncture_tracking_pp("puncture_tracking");
        bool puncture_tracking_enabled = false; // default

        puncture_tracking_pp.query("enabled", puncture_tracking_enabled);
        if (puncture_tracking_enabled)
        {
            m_puncture_tracker.initialize(this);
        }
    }

    PunctureTracker<num_punctures> &get_puncture_tracker()
    {
        return m_puncture_tracker;
    }
};

#endif /* BHAMR_HPP_ */



================================================
FILE: Source/BlackHoles/BinaryBHInitialData.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef BINARYBHINITIALDATA_HPP_
#define BINARYBHINITIALDATA_HPP_

#include "BoostedBHInitialData.hpp"
#include "Cell.hpp"
#include "Coordinates.hpp"
#include "StateVariables.hpp" //This files needs NUM_VARS - total number of components
#include "Tensor.hpp"
#include <array>

enum Lapse
{
    ONE,
    PRE_COLLAPSED,
    CHI
};

class BinaryBHInitialData
{
  protected:
    double m_dx;
    BoostedBHInitialData bh1;
    BoostedBHInitialData bh2;
    int m_initial_lapse;

  public:
    // NOLINTBEGIN(bugprone-easily-swappable-parameters)
    AMREX_FORCE_INLINE
    BinaryBHInitialData(BoostedBHInitialData::params_t a_bh1_params,
                        BoostedBHInitialData::params_t a_bh2_params,
                        double a_dx,
                        int a_initial_lapse = Lapse::PRE_COLLAPSED);
    // NOLINTEND(bugprone-easily-swappable-parameters)

    AMREX_FORCE_INLINE AMREX_GPU_DEVICE void
    init_data(int i, int j, int k,
              const amrex::CellData<amrex::Real> &cell) const;

  protected:
    [[nodiscard]] AMREX_FORCE_INLINE AMREX_GPU_DEVICE amrex::Real
    compute_chi(Coordinates coords) const;

    [[nodiscard]] AMREX_FORCE_INLINE AMREX_GPU_DEVICE Tensor<2, amrex::Real>
    compute_A(amrex::Real chi, Coordinates coords) const;
};

#include "BinaryBHInitialData.impl.hpp"

#endif /* BINARYBHINITIALDATA_HPP_ */



================================================
FILE: Source/BlackHoles/BinaryBHInitialData.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(BINARYBHINITIALDATA_HPP_)
#error "This file should only be included through BinaryBHInitialData.hpp"
#endif

#ifndef BINARYBHINITIALDATA_IMPL_HPP_
#define BINARYBHINITIALDATA_IMPL_HPP_

#include "BSSNVars.hpp"
#include "VarsTools.hpp"

// Constructor
// NOLINTBEGIN(bugprone-easily-swappable-parameters)
AMREX_FORCE_INLINE BinaryBHInitialData::BinaryBHInitialData(
    BoostedBHInitialData::params_t a_bh1_params,
    BoostedBHInitialData::params_t a_bh2_params, double a_dx,
    int a_initial_lapse)
    : m_dx(a_dx), bh1(a_bh1_params), bh2(a_bh2_params),
      m_initial_lapse(a_initial_lapse)
// NOLINTEND(bugprone-easily-swappable-parameters)
{
}

[[nodiscard]] AMREX_FORCE_INLINE AMREX_GPU_DEVICE amrex::Real
BinaryBHInitialData::compute_chi(Coordinates coords) const
{
    const amrex::Real psi =
        1. + bh1.psi_minus_one(coords) + bh2.psi_minus_one(coords);
    return pow(psi, -4);
}

[[nodiscard]] AMREX_FORCE_INLINE AMREX_GPU_DEVICE Tensor<2, amrex::Real>
BinaryBHInitialData::compute_A(amrex::Real chi, Coordinates coords) const
{

    Tensor<2, amrex::Real> Aij1 = bh1.Aij(coords);
    Tensor<2, amrex::Real> Aij2 = bh2.Aij(coords);
    Tensor<2, amrex::Real> out;

    // Aij(CCZ4) = psi^(-6) * Aij(Baumgarte&Shapiro book)
    FOR (i, j)
        out[i][j] = pow(chi, 3 / 2.) * (Aij1[i][j] + Aij2[i][j]);

    return out;
}

AMREX_FORCE_INLINE
AMREX_GPU_DEVICE // or AMREX_GPU_HOST_DEVICE depending on what's needed
    void
    BinaryBHInitialData::init_data(
        int i, int j, int k, const amrex::CellData<amrex::Real> &cell) const
{
    // TODO: Remove this once BSSNVars de-data_t-ed
    BSSNVars::VarsWithGauge<amrex::Real> vars;
    VarsTools::assign(vars,
                      0.); // Set only the non-zero components explicitly below
    Coordinates coords(amrex::IntVect(i, j, k), m_dx);

    vars.chi = compute_chi(coords);

    // Conformal metric is flat
    FOR (ii)
        vars.h[ii][ii] = 1.;

    vars.A = compute_A(vars.chi, coords);

    switch (m_initial_lapse)
    {
    case Lapse::ONE:
        vars.lapse = 1.;
        break;
    case Lapse::PRE_COLLAPSED:
        vars.lapse = std::sqrt(vars.chi);
        break;
    case Lapse::CHI:
        vars.lapse = vars.chi;
        break;
    default:
        amrex::Abort(
            "BinaryBHInitialData::Supplied initial lapse not supported.");
    }

    store_vars(cell, vars);
}

#endif /* BINARYBHINITIALDATA_IMPL_HPP_ */



================================================
FILE: Source/BlackHoles/BoostedBHInitialData.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef BOOSTEDBHINITIALDATA_HPP_
#define BOOSTEDBHINITIALDATA_HPP_
/**
 * BOOSTED SCHWARZSCHILD BLACK HOLE
 * Baumgarte & Shapiro, pp. 73-74
 * NB: \bar{A} as defined in the book is psi^{-6} * \bar{A}_{BSSN}
 */

#include "Coordinates.hpp"
#include "Tensor.hpp"
#include <array>

class BoostedBHInitialData
{

  public:
    struct params_t
    {
        double mass;
        std::array<double, AMREX_SPACEDIM> center;
        std::array<double, AMREX_SPACEDIM> momentum;
    };

    AMREX_FORCE_INLINE BoostedBHInitialData(params_t a_params);

    // conformal factor
    [[nodiscard]] AMREX_FORCE_INLINE AMREX_GPU_DEVICE amrex::Real
    psi_minus_one(Coordinates a_coords) const;

    // extrinsic curvature
    [[nodiscard]] AMREX_FORCE_INLINE AMREX_GPU_DEVICE Tensor<2, amrex::Real>
    Aij(Coordinates a_coords) const;

  private:
    params_t m_params;

    [[nodiscard]] AMREX_FORCE_INLINE AMREX_GPU_DEVICE amrex::Real
    center_dist(Coordinates a_coords) const;

    [[nodiscard]] AMREX_FORCE_INLINE AMREX_GPU_DEVICE amrex::Real
    psi0(amrex::Real a_r) const;

    [[nodiscard]] AMREX_FORCE_INLINE AMREX_GPU_DEVICE amrex::Real
    psi2(amrex::Real a_r, amrex::Real a_cos_theta) const;

    [[nodiscard]] AMREX_FORCE_INLINE AMREX_GPU_DEVICE amrex::Real
    psi2_0(amrex::Real a_r) const;

    [[nodiscard]] AMREX_FORCE_INLINE AMREX_GPU_DEVICE amrex::Real
    psi2_2(amrex::Real a_r) const;
};

#include "BoostedBHInitialData.impl.hpp"

#endif /*BOOSTEDBHINITIALDATA_HPP_*/



================================================
FILE: Source/BlackHoles/BoostedBHInitialData.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(BOOSTEDBHINITIALDATA_HPP_)
#error "This file should only be included through BoostedBHInitialData.hpp"
#endif

#ifndef BOOSTEDBHINITIALDATA_IMPL_HPP_
#define BOOSTEDBHINITIALDATA_IMPL_HPP_

#include "AlwaysInline.hpp"
#include "DimensionDefinitions.hpp"
#include <cmath>

AMREX_FORCE_INLINE BoostedBHInitialData::BoostedBHInitialData(params_t a_params)
    : m_params(a_params)
{
}

[[nodiscard]] AMREX_FORCE_INLINE AMREX_GPU_DEVICE amrex::Real
BoostedBHInitialData::psi_minus_one(Coordinates coords) const
{
    const amrex::Real r         = center_dist(coords);
    const amrex::Real cos_theta = (coords.z - m_params.center[2]) / r;
    const amrex::Real P_squared = std::pow(m_params.momentum[0], 2) +
                                  std::pow(m_params.momentum[1], 2) +
                                  std::pow(m_params.momentum[2], 2);
    return psi0(r) +
           P_squared * psi2(r, cos_theta) / (m_params.mass * m_params.mass);
}

[[nodiscard]] AMREX_FORCE_INLINE AMREX_GPU_DEVICE Tensor<2, amrex::Real>
BoostedBHInitialData::Aij(Coordinates a_coords) const
{
    const amrex::Real r = center_dist(a_coords);
    const Tensor<1, amrex::Real> l{(a_coords.x - m_params.center[0]) / r,
                                   (a_coords.y - m_params.center[1]) / r,
                                   (a_coords.z - m_params.center[2]) / r};
    const amrex::Real l_dot_p = l[0] * m_params.momentum[0] +
                                l[1] * m_params.momentum[1] +
                                l[2] * m_params.momentum[2];

    Tensor<2, amrex::Real> out;

    FOR (i, j)
    {
        const double delta = (i == j) ? 1 : 0;
        out[i][j]          = 1.5 *
                    (m_params.momentum[i] * l[j] + m_params.momentum[j] * l[i] -
                     (delta - l[i] * l[j]) * l_dot_p) /
                    (r * r);
    }
    return out;
}

/* PRIVATE */

[[nodiscard]] AMREX_FORCE_INLINE AMREX_GPU_DEVICE amrex::Real
BoostedBHInitialData::center_dist(Coordinates a_coords) const
{
    amrex::Real r = std::sqrt(std::pow(a_coords.x - m_params.center[0], 2) +
                              std::pow(a_coords.y - m_params.center[1], 2) +
                              std::pow(a_coords.z - m_params.center[2], 2));

    return std::max(r, 1e-6);
}

[[nodiscard]] AMREX_FORCE_INLINE AMREX_GPU_DEVICE amrex::Real
BoostedBHInitialData::psi0(amrex::Real a_r) const
{
    return m_params.mass / (2 * a_r);
}

[[nodiscard]] AMREX_FORCE_INLINE AMREX_GPU_DEVICE amrex::Real
BoostedBHInitialData::psi2(amrex::Real a_r, amrex::Real a_cos_theta) const
{
    return psi2_0(a_r) + psi2_2(a_r) * (1.5 * a_cos_theta * a_cos_theta - 0.5);
}

[[nodiscard]] AMREX_FORCE_INLINE AMREX_GPU_DEVICE amrex::Real
BoostedBHInitialData::psi2_0(amrex::Real a_r) const
{
    const amrex::Real psi0_here    = psi0(a_r);
    const amrex::Real psi0_sq_here = psi0_here * psi0_here;
    return std::pow(1 + psi0_here, -5) * (psi0_here / 8) *
           (psi0_sq_here * psi0_sq_here + 5 * psi0_here * psi0_sq_here +
            10 * psi0_sq_here + 10 * psi0_here + 5);
}

[[nodiscard]] AMREX_FORCE_INLINE AMREX_GPU_DEVICE amrex::Real
BoostedBHInitialData::psi2_2(amrex::Real a_r) const
{
    const amrex::Real psi0_here    = psi0(a_r);
    const amrex::Real psi0_sq_here = psi0_here * psi0_here;
    return 0.05 * std::pow(1 + psi0_here, -5) * psi0_sq_here *
               (84 * psi0_here * psi0_sq_here * psi0_sq_here +
                378 * psi0_sq_here * psi0_sq_here +
                658 * psi0_here * psi0_sq_here + 539 * psi0_sq_here +
                192 * psi0_here + 15) +
           4.2 * psi0_here * psi0_sq_here * log(psi0_here / (1 + psi0_here));
}

#endif /* BOOSTEDBHINITIALDATA_IMPL_HPP_ */



================================================
FILE: Source/BlackHoles/KerrBHInitialData.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef KERRBHINITIALDATA_HPP_
#define KERRBHINITIALDATA_HPP_

#include "ADMConformalVars.hpp"
#include "Cell.hpp"
#include "CoordinateTransformations.hpp"
#include "Coordinates.hpp"
#include "StateVariables.hpp" //This files needs NUM_VARS - total number of components
#include "Tensor.hpp"
#include "TensorAlgebra.hpp"
#include "VarsTools.hpp"
#include "simd.hpp"

//! Class which computes the Kerr initial conditions per arXiv 1401.1548
class KerrBHInitialData
{
    // Use the variable definition in CCZ4
    template <class data_t>
    using Vars = ADMConformalVars::VarsWithGauge<data_t>;

  public:
    //! Stuct for the params of the Kerr BHInitialData
    struct params_t
    {
        double mass; //!<< The mass of the Kerr BH
        std::array<double, AMREX_SPACEDIM>
            center;  //!< The center of the Kerr BH
        double spin; //!< The spin param a = J/M, so 0 <= |a| <= M
    };

  protected:
    double m_dx;
    params_t m_params;

  public:
    KerrBHInitialData(params_t a_params, double a_dx)
        : m_dx(a_dx), m_params(a_params)

    {
        // check this spin param is sensible
        if (std::abs(m_params.spin) > m_params.mass)
        {
            amrex::Abort("The spin parameter must satisfy |a| <= M");
        }
    }

    template <class data_t> void compute(Cell<data_t> current_cell) const;

  protected:
    //! Function which computes the components of the metric in spherical coords
    template <class data_t>
    void compute_kerr(
        Tensor<2, data_t>
            &spherical_g, //!<< The spatial metric in spherical coords
        Tensor<2, data_t>
            &spherical_K, //!<< The extrinsic curvature in spherical coords
        Tensor<1, data_t>
            &spherical_shift, //!<< The spherical components of the shift
        data_t &kerr_lapse,   //!<< The lapse for the kerr solution
        const Coordinates<data_t> coords //!<< Coords of current cell
    ) const;
};

#include "KerrBHInitialData.impl.hpp"

#endif /* KERRBHINITIALDATA_HPP_ */



================================================
FILE: Source/BlackHoles/KerrBHInitialData.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(KERRBHINITIALDATA_HPP_)
#error "This file should only be included through KerrBHInitialData.hpp"
#endif

#ifndef KERRBHINITIALDATA_IMPL_HPP_
#define KERRBHINITIALDATA_IMPL_HPP_

#include "DimensionDefinitions.hpp"

// Computes semi-isotropic Kerr solution as detailed in Liu, Etienne and Shapiro
// 2010, arxiv gr-qc/1001.4077
template <class data_t>
void KerrBHInitialData::compute(Cell<data_t> current_cell) const
{
    // set up vars for the metric and extrinsic curvature, shift and lapse in
    // spherical coords
    Tensor<2, data_t> spherical_g;
    Tensor<2, data_t> spherical_K;
    Tensor<1, data_t> spherical_shift;
    data_t kerr_lapse;

    // The cartesian variables and coords
    Vars<data_t> vars;
    Coordinates<data_t> coords(current_cell, m_dx, m_params.center);

    // Compute the components in spherical coords as per 1401.1548
    compute_kerr(spherical_g, spherical_K, spherical_shift, kerr_lapse, coords);

    // work out where we are on the grid
    data_t x = coords.x;
    double y = coords.y;
    double z = coords.z;

    using namespace CoordinateTransformations;
    // Convert spherical components to cartesian components using coordinate
    // transforms
    vars.h     = spherical_to_cartesian_LL(spherical_g, x, y, z);
    vars.A     = spherical_to_cartesian_LL(spherical_K, x, y, z);
    vars.shift = spherical_to_cartesian_U(spherical_shift, x, y, z);

    using namespace TensorAlgebra;
    // Convert to BSSN vars
    data_t deth = compute_determinant(vars.h);
    auto h_UU   = compute_inverse_sym(vars.h);
    vars.chi    = pow(deth, -1. / 3.);

    // transform extrinsic curvature into A and TrK - note h is still non
    // conformal version which is what we need here
    vars.K = compute_trace(vars.A, h_UU);
    make_trace_free(vars.A, vars.h, h_UU);

    // Make conformal
    FOR (i, j)
    {
        vars.h[i][j] *= vars.chi;
        vars.A[i][j] *= vars.chi;
    }

    // use a pre collapsed lapse, could also use analytic one
    // vars.lapse = kerr_lapse;
    vars.lapse = pow(vars.chi, 0.5);

    // Populate the variables on the grid
    // NB We stil need to set Gamma^i which is NON ZERO
    // but we do this via a separate class/compute function
    // as we need the gradients of the metric which are not yet available
    current_cell.store_vars(vars);
}

template <class data_t>
void KerrBHInitialData::compute_kerr(Tensor<2, data_t> &spherical_g,
                                     Tensor<2, data_t> &spherical_K,
                                     Tensor<1, data_t> &spherical_shift,
                                     data_t &kerr_lapse,
                                     const Coordinates<data_t> coords) const
{
    // Kerr black hole params - mass M and spin a
    double M = m_params.mass;
    double a = m_params.spin;

    // work out where we are on the grid
    data_t x = coords.x;
    double y = coords.y;
    double z = coords.z;

    // the radius, subject to a floor
    data_t r  = coords.get_radius();
    data_t r2 = r * r;

    // the radius in xy plane, subject to a floor
    data_t rho2 = simd_max(x * x + y * y, 1e-12);
    data_t rho  = sqrt(rho2);

    // calculate useful position quantities
    data_t cos_theta  = z / r;
    data_t sin_theta  = rho / r;
    data_t cos_theta2 = cos_theta * cos_theta;
    data_t sin_theta2 = sin_theta * sin_theta;

    // calculate useful metric quantities
    double r_plus  = M + sqrt(M * M - a * a);
    double r_minus = M - sqrt(M * M - a * a);

    // The Boyer-Lindquist coordinate
    data_t r_BL = r * pow(1.0 + 0.25 * r_plus / r, 2.0);

    // Other useful quantities per 1001.4077
    data_t Sigma = r_BL * r_BL + a * a * cos_theta2;
    data_t Delta = r_BL * r_BL - 2.0 * M * r_BL + a * a;
    // In the paper this is just 'A', but not to be confused with A_ij
    data_t AA = pow(r_BL * r_BL + a * a, 2.0) - Delta * a * a * sin_theta2;
    // The rr component of the conformal spatial matric
    data_t gamma_rr =
        Sigma * pow(r + 0.25 * r_plus, 2.0) / (r * r2 * (r_BL - r_minus));

    // Metric in semi isotropic Kerr-Schild coordinates, r, theta (t or th), phi
    // (p)
    FOR (i, j)
    {
        spherical_g[i][j] = 0.0;
    }
    spherical_g[0][0] = gamma_rr;                // gamma_rr
    spherical_g[1][1] = Sigma;                   // gamma_tt
    spherical_g[2][2] = AA / Sigma * sin_theta2; // gamma_pp

    // Extrinsic curvature
    FOR (i, j)
    {
        spherical_K[i][j] = 0.0;
    }

    // set non zero elements of Krtp - K_rp, K_tp
    spherical_K[0][2] =
        a * M * sin_theta2 / (Sigma * sqrt(AA * Sigma)) *
        (3.0 * pow(r_BL, 4.0) + 2 * a * a * r_BL * r_BL - pow(a, 4.0) -
         a * a * (r_BL * r_BL - a * a) * sin_theta2) *
        (1.0 + 0.25 * r_plus / r) / sqrt(r * r_BL - r * r_minus);
    spherical_K[2][0] = spherical_K[0][2];
    spherical_K[2][1] = -2.0 * pow(a, 3.0) * M * r_BL * cos_theta * sin_theta *
                        sin_theta2 / (Sigma * sqrt(AA * Sigma)) *
                        (r - 0.25 * r_plus) * sqrt(r_BL / r - r_minus / r);
    spherical_K[1][2] = spherical_K[2][1];

    // set the analytic lapse
    kerr_lapse = sqrt(Delta * Sigma / AA);

    // set the shift (only the phi component is non zero)
    spherical_shift[0] = 0.0;
    spherical_shift[1] = 0.0;
    spherical_shift[2] = -2.0 * M * a * r_BL / AA;
}

#endif /* KERRBHINITIALDATA_IMPL_HPP_ */



================================================
FILE: Source/BlackHoles/Make.package
================================================
GRTECLYN_CEXE_headers += BHAMR.hpp \
                         BinaryBHInitialData.hpp \
                         BinaryBHInitialData.impl.hpp \
                         BoostedBHInitialData.hpp \
                         BoostedBHInitialData.impl.hpp \
                         KerrBHInitialData.hpp \
                         KerrBHInitialData.impl.hpp \
                         PunctureTracker.hpp \
                         PunctureTracker.impl.hpp \
                         TwoPuncturesInitialData.hpp \
                         TwoPuncturesInitialData.impl.hpp



================================================
FILE: Source/BlackHoles/PunctureTracker.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef PUNCTURETRACKER_HPP_
#define PUNCTURETRACKER_HPP_

#include <AMReX_Array.H>
#include <AMReX_Particles.H>

#include "GRAMR.hpp"

//!  The class tracks the puncture locations by advecting them in the reverse
//!  direction to the shift. It is an amrex AoS ParticleContainer.
template <unsigned int num_punctures>
class PunctureTracker : public amrex::ParticleContainer<AMREX_SPACEDIM, 1>
{
  public:
    static constexpr unsigned int num_puncture_coords =
        num_punctures * AMREX_SPACEDIM;

  private:
    amrex::Array<amrex::Real, num_puncture_coords> m_puncture_coords;

    std::string m_punctures_filename;
    bool m_disable_writeout{false}; // if true, don't write .dat file (doesn't
                                    // affect checkpoint and plotfiles)
    std::string m_checkpoint_subdir;

    GRAMR *m_gr_amr{nullptr};

    bool m_initialized{false};
    bool m_puncture_coords_set{false};
    bool m_started{false};

    double m_restart_time{0.0};

  public:
    //! The constructor
    using amrex::ParticleContainer<AMREX_SPACEDIM, 1>::ParticleContainer;

    //! Initialize the tracker. Note that this does not set up the underlying
    //! ParticleContainer
    void initialize(GRAMR *a_gr_amr);

    //! start the puncture tracker from the initial punctures
    void start_from_initial_punctures();

    //! restart the puncture tracker
    void restart(const std::string &a_restart_chk_dir);

    //! write punctures to the checkpoint directory
    void checkpoint(const std::string &a_chk_dir);

    //! write punctures to the plot file
    void write_plotfile(const std::string &a_dir);

    //! Track the punctures and write out if requested
    void track(double a_time, double a_dt, const bool a_write_punctures = true);

    //! Set the puncture coordinates (for the initial coordinates)
    void
    set_puncture_coords(const amrex::Array<amrex::Real, num_puncture_coords>
                            &a_puncture_coords);

    //! Get the puncture coordinates
    const amrex::Array<amrex::Real, num_puncture_coords> &
    get_puncture_coords() const;

#ifndef AMREX_USE_CUDA
  private: // CUDA doesn't allow lambdas in private functions
#endif

    //! set the initial punctures in the particle container
    void set_initial_punctures_pc();

    //! update m_puncture_coords from the particle locations
    void update_puncture_coords();

    //! return the linear index of the coord in the idir direction for the
    //! ipuncture puncture in m_puncture_coords
    static AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE int
    linear_idx(int ipuncture, int idir)
    {
        return ipuncture * AMREX_SPACEDIM + idir;
    }

#ifdef AMREX_USE_CUDA
  private:
#endif
    //! write the initial punctures to a file
    void write_initial_punctures() const;

    //! SmallDataIO requires a std::vector to write the coords
    std::vector<amrex::Real> get_puncture_vector() const;
};

#include "PunctureTracker.impl.hpp"

#endif /* PUNCTURETRACKER_HPP_ */



================================================
FILE: Source/BlackHoles/PunctureTracker.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef PUNCTURETRACKER_HPP_
#error "This file should only be included through PunctureTracker.hpp"
#endif

#ifndef PUNCTURETRACKER_IMPL_HPP_
#define PUNCTURETRACKER_IMPL_HPP_

// #include "AMReXParameters.hpp" // for writing data
#include "DimensionDefinitions.hpp"
#include "FilesystemTools.hpp"
#include "GRAMRLevel.hpp"
#include "SmallDataIO.hpp" // for writing data
#include "StateVariables.hpp"

// AMReX includes
#include <AMReX_AmrParGDB.H>
#include <AMReX_ParmParse.H>
#include <AMReX_TracerParticle_mod_K.H> // for linear_interpolation

//! Set up puncture tracker
template <unsigned int num_punctures>
void PunctureTracker<num_punctures>::initialize(GRAMR *a_gr_amr)
{
    amrex::ParmParse puncture_tracking_pp("puncture_tracking");

    std::string filename{"punctures"}; // default
    puncture_tracking_pp.queryAdd("filename", filename);

    std::string output_path{"."}; // default
    // Maybe we might want to change this to a more generic GRTeclyn output_path
    // at some point
    puncture_tracking_pp.queryAdd("output_path", output_path);

    puncture_tracking_pp.queryAdd("disable_writeout", m_disable_writeout);

    if (!FilesystemTools::directory_exists(output_path))
    {
        FilesystemTools::mkdir_recursive(output_path);
    }

    m_punctures_filename = output_path + "/" + filename;
    m_checkpoint_subdir  = filename;

    AMREX_ASSERT(a_gr_amr != nullptr);
    m_gr_amr = a_gr_amr;

    {
        // Disable particle tiling as we won't have many particles
        // TODO: Remove if we add more particles elsewhere
        amrex::ParmParse particles_pp("particles");
        particles_pp.add("do_tiling", 0);
    }

    m_initialized = true;
}

template <unsigned int num_punctures>
void PunctureTracker<num_punctures>::start_from_initial_punctures()
{
    AMREX_ASSERT(m_initialized);
    // must call set_puncture_coords for the initial punctures first
    AMREX_ASSERT(m_puncture_coords_set);

    // Define the particle container
    Define(dynamic_cast<amrex::ParGDBBase *>(m_gr_amr->GetParGDB()));

    // If it's first step, we use the initial puncture locations set above
    write_initial_punctures();

    // Add the initial puncture particles to the underlying
    // ParticleContainer
    set_initial_punctures_pc();

    m_started = true;
}

template <unsigned int num_punctures>
void PunctureTracker<num_punctures>::restart(
    const std::string &a_restart_chk_dir)
{
    AMREX_ASSERT(m_initialized);

    // Define the particle container
    Define(dynamic_cast<amrex::ParGDBBase *>(m_gr_amr->GetParGDB()));

    Restart(a_restart_chk_dir, m_checkpoint_subdir);

    m_started = true;

    m_restart_time = m_gr_amr->get_restart_time();

    // The above Restart function will only set the punctures in the underlying
    // ParticleContainer so let's update our own m_puncture_coords
    update_puncture_coords();
}

template <unsigned int num_punctures>
void PunctureTracker<num_punctures>::write_plotfile(const std::string &a_dir)
{
    AMREX_ASSERT(m_initialized);
    AMREX_ASSERT(m_started);

    std::string plotfile_subdir = "particles"; // this is what ParaView expects

    amrex::Vector<std::string> real_comp_names{AMREX_D_DECL(
        StateVariables::names[c_shift1], StateVariables::names[c_shift2],
        StateVariables::names[c_shift3])};

    amrex::Vector<std::string> int_comp_names({"puncture_index"});

    Redistribute();
    WritePlotFile(a_dir, plotfile_subdir, real_comp_names, int_comp_names);
}

template <unsigned int num_punctures>
void PunctureTracker<num_punctures>::checkpoint(const std::string &a_chk_dir)
{
    AMREX_ASSERT(m_initialized);
    AMREX_ASSERT(m_started);

    Redistribute();
    Checkpoint(a_chk_dir, m_checkpoint_subdir);
}

//! set and write initial puncture locations
template <unsigned int num_punctures>
void PunctureTracker<num_punctures>::set_initial_punctures_pc()
{
    AMREX_ASSERT(m_initialized);

    if (amrex::ParallelDescriptor::MyProc() != 0)
        return;

    // It doesn't matter where we put the puncture particles initially.
    // They will be redistributed later
    const int base_level = 0;
    {
        auto &particle_tile = DefineAndReturnParticleTile(base_level, 0, 0);
        particle_tile.resize(num_punctures);
        const auto &particle_tile_data = particle_tile.getParticleTileData();

        amrex::GpuArray<amrex::Real, num_puncture_coords> d_puncture_coords;
        std::copy(m_puncture_coords.begin(), m_puncture_coords.end(),
                  d_puncture_coords.begin());

        amrex::ParallelFor(
            num_punctures,
            [=] AMREX_GPU_DEVICE(int ipuncture)
            {
                FOR1 (idir)
                {
                    auto &puncture_particle = particle_tile_data[ipuncture];
                    puncture_particle.pos(idir) =
                        d_puncture_coords[linear_idx(ipuncture, idir)];
                    puncture_particle.id()     = ipuncture + 1;
                    puncture_particle.idata(0) = ipuncture + 1;
                    puncture_particle.cpu()    = 0;
                }
            });
        amrex::Gpu::streamSynchronize();
    }
}

template <unsigned int num_punctures>
void PunctureTracker<num_punctures>::set_puncture_coords(
    const amrex::Array<amrex::Real,
                       PunctureTracker<num_punctures>::num_puncture_coords>
        &a_puncture_coords)
{
    m_puncture_coords = a_puncture_coords;

    m_puncture_coords_set = true;
}

template <unsigned int num_punctures>
const amrex::Array<amrex::Real,
                   PunctureTracker<num_punctures>::num_puncture_coords> &
PunctureTracker<num_punctures>::get_puncture_coords() const
{
    AMREX_ASSERT(m_puncture_coords_set);
    return m_puncture_coords;
}

template <unsigned int num_punctures>
std::vector<amrex::Real>
PunctureTracker<num_punctures>::get_puncture_vector() const
{
    AMREX_ASSERT(m_initialized);
    AMREX_ASSERT(m_puncture_coords_set);

    std::vector<amrex::Real> puncture_coords_vector(num_puncture_coords);
    std::copy(m_puncture_coords.begin(), m_puncture_coords.end(),
              puncture_coords_vector.begin());

    return puncture_coords_vector;
}

template <unsigned int num_punctures>
void PunctureTracker<num_punctures>::write_initial_punctures() const
{
    AMREX_ASSERT(m_initialized);
    if (m_disable_writeout)
    {
        return;
    }
    // now the write out to a new file
    bool first_step = true;
    double dt       = 1.; // doesn't matter
    double time     = 0.;
    SmallDataIO punctures_file(m_punctures_filename, dt, time, m_restart_time,
                               SmallDataIO::APPEND, first_step);
    std::vector<std::string> header1_strings(
        static_cast<size_t>(num_puncture_coords));
    for (int ipuncture = 0; ipuncture < num_punctures; ipuncture++)
    {
        std::string idx = std::to_string(ipuncture + 1);
        header1_strings[AMREX_SPACEDIM * ipuncture + 0] = "x_" + idx;
        header1_strings[AMREX_SPACEDIM * ipuncture + 1] = "y_" + idx;
        header1_strings[AMREX_SPACEDIM * ipuncture + 2] = "z_" + idx;
    }
    punctures_file.write_header_line(header1_strings);

    // use a vector for the write out
    punctures_file.write_time_data_line(get_puncture_vector());
}

//! track the punctures and write out if requested
template <unsigned int num_punctures>
void PunctureTracker<num_punctures>::track(double a_time, double a_dt,
                                           const bool a_write_punctures)
{
    BL_PROFILE("PunctureTracker::track");
    AMREX_ASSERT(m_initialized);
    AMREX_ASSERT(m_started);

    // leave if this is called at t=0, we don't want to move the puncture yet
    {
        if (a_time == 0.)
            return;
    }

    // Redistribute punctures to the correct grid
    Redistribute();

    for (int ilevel = 0; ilevel <= m_gr_amr->finestLevel(); ilevel++)
    {
        if (this->NumberOfParticlesAtLevel(ilevel) == 0L)
        {
            continue;
        }
        amrex::AmrLevel &amr_level = m_gr_amr->getLevel(ilevel);

        const amrex::Geometry &geom  = amr_level.Geom();
        amrex::MultiFab &state_level = amr_level.get_new_data(State_Type);

        // We should only need 1 ghost cell as we are doing linear interpolation
        amrex::IntVect ghosts_to_fill = amrex::IntVect::TheUnitVector();
        state_level.FillBoundary(c_shift1, GR_SPACEDIM, ghosts_to_fill,
                                 geom.periodicity());

        const auto problem_domain_lo = geom.ProbLoArray();
        const auto problem_domain_hi = geom.ProbHiArray();
        const auto dxi               = geom.InvCellSizeArray();

        // This code is almost identical to
        // TracerParticleContainer::AdvectWithUcc except we advect in the
        // opposite direction to the shift.
        for (int ipass = 0; ipass < 2; ipass++)
        {
            for (ParIterType punc_iter(*this, ilevel); punc_iter.isValid();
                 ++punc_iter)
            {
                ParticleTileType &punc_tile = ParticlesAt(ilevel, punc_iter);
                auto &punc_particles        = punc_tile.GetArrayOfStructs();
                auto *punc_particles_data   = punc_particles.data();
                int num_punc_tile           = punc_iter.numParticles();
                const auto &fab_array = state_level[punc_iter].const_array();

                amrex::ParallelFor(
                    num_punc_tile,
                    [=] AMREX_GPU_DEVICE(int ipunc)
                    {
                        auto &p = punc_particles_data[ipunc];
                        amrex::ParticleReal shift[AMREX_SPACEDIM];
                        amrex::IntVect is_nodal =
                            amrex::IntVect::TheZeroVector();
                        int num_arrays = 1;

                        amrex::linear_interpolate_to_particle(
                            p, problem_domain_lo, dxi, &fab_array, shift,
                            &is_nodal, c_shift1, GR_SPACEDIM, num_arrays);

                        if (ipass == 0)
                        {
                            FOR1 (idir)
                            {
                                p.rdata(idir) = p.pos(idir);
                                p.pos(idir) -= static_cast<amrex::ParticleReal>(
                                    0.5 * a_dt * shift[idir]);
                            }
                        }
                        else
                        {
                            FOR1 (idir)
                            {
                                p.pos(idir) = p.rdata(idir) -
                                              static_cast<amrex::ParticleReal>(
                                                  a_dt * shift[idir]);
                                p.rdata(idir) = shift[idir];
                            }
                        }

                        // make sure the particles don't leave the problem
                        // domain otherwise AMReX will mark them invalid
                        FOR1 (idir)
                        {
                            p.pos(idir) =
                                std::max(p.pos(idir), problem_domain_lo[idir]);
                            p.pos(idir) =
                                std::min(p.pos(idir), problem_domain_hi[idir]);
                        }
                    }); // amrex::ParallelFor
            } // punc_iter
        } // ipass
    } // ilevel

    // update m_puncture_coords with the updated locations of the puncture
    // particles
    update_puncture_coords();

    // write them out
    if (a_write_punctures && !m_disable_writeout)
    {
        bool first_step = false;
        SmallDataIO punctures_file(m_punctures_filename, a_dt, a_time,
                                   m_restart_time, SmallDataIO::APPEND,
                                   first_step);

        // use a vector for the write out
        punctures_file.remove_duplicate_time_data();
        punctures_file.write_time_data_line(get_puncture_vector());
    }
}

template <unsigned int num_punctures>
void PunctureTracker<num_punctures>::update_puncture_coords()
{
    BL_PROFILE("PunctureTracker::update_puncture_coords");
    AMREX_ASSERT(m_initialized);
    AMREX_ASSERT(m_started);

    // We will perform an MPI sum reduction to get the coords so set them to
    // zero by default
    m_puncture_coords.fill(0.0);

    amrex::Gpu::DeviceVector<amrex::ParticleReal> d_puncture_coords(
        num_puncture_coords, 0.0);

    auto d_puncture_coords_ptr = d_puncture_coords.data();

    for (int ilevel = 0; ilevel <= m_gr_amr->finestLevel(); ilevel++)
    {
        if (this->NumberOfParticlesAtLevel(ilevel) == 0L)
        {
            continue;
        }

        // Now if this proc has a puncture particle, we set its location
        for (ParIterType punc_iter(*this, ilevel); punc_iter.isValid();
             ++punc_iter)
        {
            auto &punc_particles      = punc_iter.GetArrayOfStructs();
            auto *punc_particles_data = punc_particles.data();
            int num_punc_tile         = punc_iter.numParticles();

            amrex::ParallelFor(
                num_punc_tile,
                [=] AMREX_GPU_DEVICE(int ipunc)
                {
                    auto &p      = punc_particles_data[ipunc];
                    int punc_idx = p.idata(0) - 1;
                    FOR1 (idir)
                    {
                        d_puncture_coords_ptr[linear_idx(punc_idx, idir)] +=
                            p.pos(idir);
                    }
                });
        }
    } // ilevel

    amrex::Gpu::copy(amrex::Gpu::deviceToHost, d_puncture_coords.begin(),
                     d_puncture_coords.end(), m_puncture_coords.data());

    // MPI sum over all ranks
    amrex::ParallelAllReduce::Sum(m_puncture_coords.data(), num_puncture_coords,
                                  amrex::ParallelContext::CommunicatorAll());
}

#endif


================================================
FILE: Source/BlackHoles/TwoPuncturesInitialData.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifdef USE_TWOPUNCTURES

#ifndef TWOPUNCTURESINITIALDATA_HPP_
#define TWOPUNCTURESINITIALDATA_HPP_

#include "CCZ4Vars.hpp"
#include "Cell.hpp"
#include "Coordinates.hpp"
#include "StateVariables.hpp" //This files needs NUM_VARS - total number of components
#include "Tensor.hpp"
#include "TensorAlgebra.hpp"
#include "TwoPunctures.hpp"
#include "VarsTools.hpp"
#include "simd.hpp"
#include <array>

//! This compute class sets the initial data computed by TwoPunctures on the
//! grid
class TwoPuncturesInitialData
{
  protected:
    double m_dx;
    std::array<double, AMREX_SPACEDIM> m_center;
    const TP::TwoPunctures &m_two_punctures;

  public:
    template <class data_t> using Vars = CCZ4Vars::VarsWithGauge<data_t>;

    TwoPuncturesInitialData(const double a_dx,
                            const std::array<double, AMREX_SPACEDIM> a_center,
                            const TP::TwoPunctures &a_two_punctures)
        : m_dx(a_dx), m_center(a_center), m_two_punctures(a_two_punctures)
    {
    }

    void compute(Cell<double> current_cell) const;

  protected:
    void interpolate_tp_vars(const Coordinates<double> &coords,
                             Tensor<2, double> &out_h_phys,
                             Tensor<2, double> &out_extrinsic_K,
                             double &out_lapse, Tensor<1, double> &out_shift,
                             double &out_Theta,
                             Tensor<1, double> &out_Z3) const;
};

#include "TwoPuncturesInitialData.impl.hpp"

#endif /* TWOPUNCTURESINITIALDATA_HPP_ */
#endif /* USE_TWOPUNCTURES */



================================================
FILE: Source/BlackHoles/TwoPuncturesInitialData.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(TWOPUNCTURESINITIALDATA_HPP_)
#error "This file should only be included through TwoPuncturesInitialData.hpp"
#endif

#ifndef TWOPUNCTURESINITIALDATA_IMPL_HPP_
#define TWOPUNCTURESINITIALDATA_IMPL_HPP_

void TwoPuncturesInitialData::compute(Cell<double> current_cell) const
{
    Vars<double> vars;
    // Set only the non-zero components explicitly below
    VarsTools::assign(vars, 0.);

    Coordinates<double> coords(current_cell, m_dx, m_center);
    Tensor<2, double> h_phys, K_tensor;
    Tensor<1, double> shift, Z3;
    double lapse, Theta;

    interpolate_tp_vars(coords, h_phys, K_tensor, lapse, shift, Theta, Z3);

    using namespace TensorAlgebra;
    // analytically set Bowen-York properties below (e.g. conformal flatness,
    // tracefree K)

    // metric variables
    vars.chi = pow(compute_determinant_sym(h_phys), -1. / 3.);
    FOR (i)
    {
        // Bowen-York data is conformally flat
        vars.h[i][i] = 1.0;
    }

    // extrinsic curvature
    FOR (i, j)
    {
        vars.A[i][j] = vars.chi * K_tensor[i][j];
    }
    // conformal flatness means h_UU = h
    make_trace_free(vars.A, vars.h, vars.h);

    // gauge
    vars.lapse = lapse;

    current_cell.store_vars(vars);
}

void TwoPuncturesInitialData::interpolate_tp_vars(
    const Coordinates<double> &coords, Tensor<2, double> &out_h_phys,
    Tensor<2, double> &out_K_tensor, double &out_lapse,
    Tensor<1, double> &out_shift, double &out_Theta,
    Tensor<1, double> &out_Z3) const
{
    double coords_array[AMREX_SPACEDIM];
    coords_array[0] = coords.x;
    coords_array[1] = coords.y;
    coords_array[2] = coords.z;

    using namespace TP::Z4VectorShortcuts;
    double TP_state[Qlen];
    m_two_punctures.Interpolate(coords_array, TP_state);

    // metric
    out_h_phys[0][0] = TP_state[g11];
    out_h_phys[0][1] = out_h_phys[1][0] = TP_state[g12];
    out_h_phys[0][2] = out_h_phys[2][0] = TP_state[g13];
    out_h_phys[1][1]                    = TP_state[g22];
    out_h_phys[1][2] = out_h_phys[2][1] = TP_state[g23];
    out_h_phys[2][2]                    = TP_state[g33];

    // extrinsic curvature
    out_K_tensor[0][0] = TP_state[K11];
    out_K_tensor[0][1] = out_K_tensor[1][0] = TP_state[K12];
    out_K_tensor[0][2] = out_K_tensor[2][0] = TP_state[K13];
    out_K_tensor[1][1]                      = TP_state[K22];
    out_K_tensor[1][2] = out_K_tensor[2][1] = TP_state[K23];
    out_K_tensor[2][2]                      = TP_state[K33];

    // Z4 vector
    out_Z3[0] = TP_state[Z1];
    out_Z3[1] = TP_state[Z2];
    out_Z3[2] = TP_state[Z3];
    out_Theta = TP_state[Theta];

    // gauge
    out_lapse    = TP_state[lapse];
    out_shift[0] = TP_state[shift1];
    out_shift[1] = TP_state[shift2];
    out_shift[2] = TP_state[shift3];
}

#endif /* TWOPUNCTURESINITIALDATA_IMPL_HPP_ */



================================================
FILE: Source/CCZ4/ADMConformalVars.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef ADMCONFORMALVARS_HPP_
#define ADMCONFORMALVARS_HPP_

#include "StateVariables.hpp"
#include "Tensor.hpp"
#include "VarsTools.hpp"

/// Namespace for ADM vars in conformally decomposed form
/** The structs in this namespace collect all the ADM variables. It's main use
 *is to make a local, nicely laid-out, copy of the ADM variables for the
 *current grid cell (Otherwise, this data would only exist on the grid in the
 *huge, flattened Chombo array). \sa {CCZ4Vars, BSSNVars}
 **/
namespace ADMConformalVars
{
/// Vars object for ADM vars, including gauge vars
template <class data_t> struct VarsNoGauge
{
    data_t chi{};        //!< Conformal factor
    Tensor<2, data_t> h; //!< Conformal metric
    data_t K{};          //!< Trace of the extrinsic curvature
    Tensor<2, data_t> A; //!< trace-free part of the rescale extrinsic
                         //! curvature, i.e. \f$\chi
                         //!(K_{ij})^{\mathrm{TF}}\f$

    /// Defines the mapping between members of Vars and Chombo grid
    /// variables (enum in User_Variables)
    template <typename mapping_function_t>
    AMREX_GPU_DEVICE void enum_mapping(mapping_function_t mapping_function)
    {
        using namespace VarsTools; // define_enum_mapping is part of VarsTools
        // Scalars
        define_enum_mapping(mapping_function, c_chi, chi);
        define_enum_mapping(mapping_function, c_K, K);

        // Symmetric 2-tensors
        define_symmetric_enum_mapping(mapping_function,
                                      GRInterval<c_h11, c_h33>(), h);
        define_symmetric_enum_mapping(mapping_function,
                                      GRInterval<c_A11, c_A33>(), A);
    }
};

/// Vars object for ADM vars, including gauge vars
template <class data_t> struct VarsWithGauge : public VarsNoGauge<data_t>
{
    data_t lapse;
    Tensor<1, data_t> shift;

    /// Defines the mapping between members of Vars and Chombo grid
    /// variables (enum in User_Variables)
    template <typename mapping_function_t>
    AMREX_GPU_DEVICE void enum_mapping(mapping_function_t mapping_function)
    {
        using namespace VarsTools; // define_enum_mapping is part of VarsTools
        VarsNoGauge<data_t>::enum_mapping(mapping_function);
        define_enum_mapping(mapping_function, c_lapse, lapse);
        define_enum_mapping(mapping_function, GRInterval<c_shift1, c_shift3>(),
                            shift);
    }
};

/// Vars object for ADM vars requiring second derivs, excluding gauge vars
template <class data_t> struct Diff2VarsNoGauge
{
    data_t chi;          //!< Conformal factor
    Tensor<2, data_t> h; //!< Conformal metric

    template <typename mapping_function_t>
    AMREX_GPU_DEVICE void enum_mapping(mapping_function_t mapping_function)
    {
        using namespace VarsTools; // define_enum_mapping is part of VarsTools
        define_enum_mapping(mapping_function, c_chi, chi);
        define_symmetric_enum_mapping(mapping_function,
                                      GRInterval<c_h11, c_h33>(), h);
    }
};

/// Vars object for ADM vars requiring second derivs, with gauge vars
template <class data_t>
struct Diff2VarsWithGauge : public Diff2VarsNoGauge<data_t>
{
    data_t lapse;
    Tensor<1, data_t> shift;

    /// Defines the mapping between members of Vars and Chombo grid
    /// variables (enum in User_Variables)
    template <typename mapping_function_t>
    AMREX_GPU_DEVICE void enum_mapping(mapping_function_t mapping_function)
    {
        using namespace VarsTools; // define_enum_mapping is part of VarsTools
        Diff2VarsNoGauge<data_t>::enum_mapping(mapping_function);
        define_enum_mapping(mapping_function, c_lapse, lapse);
        define_enum_mapping(mapping_function, GRInterval<c_shift1, c_shift3>(),
                            shift);
    }
};
} // namespace ADMConformalVars

#endif /* ADMCONFORMALVARS_HPP_ */



================================================
FILE: Source/CCZ4/BSSNVars.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef BSSNVARS_HPP_
#define BSSNVARS_HPP_

#include "ADMConformalVars.hpp"
#include "Tensor.hpp"
#include "VarsTools.hpp"

/// Namespace for BSSN vars
/** The structs in this namespace collect all the BSSN variables. It's main use
 *  is to make a local, nicely laid-out, copy of the BSSN variables for the
 *  current grid cell (Otherwise, this data would only exist on the grid in
 *  the huge, flattened Chombo array). \sa {CCZ4Vars, ADMConformalVars}
 **/
namespace BSSNVars
{
/// Vars object for BSSN vars excluding gauge vars
template <class data_t>
struct VarsNoGauge : public ADMConformalVars::VarsNoGauge<data_t>
{
    Tensor<1, data_t> Gamma; //!< Conformal connection functions

    /// Defines the mapping between members of Vars and Chombo grid
    /// variables (enum in User_Variables)
    template <typename mapping_function_t>
    AMREX_GPU_DEVICE void enum_mapping(mapping_function_t mapping_function)
    {
        using namespace VarsTools; // define_enum_mapping is part of VarsTools
        ADMConformalVars::VarsNoGauge<data_t>::enum_mapping(mapping_function);
        define_enum_mapping(mapping_function, GRInterval<c_Gamma1, c_Gamma3>(),
                            Gamma); //!< The auxilliary variable Gamma^i
    }
};

/// Vars object for BSSN vars, including gauge vars
template <class data_t> struct VarsWithGauge : public VarsNoGauge<data_t>
{
    data_t lapse{};
    Tensor<1, data_t> shift;
    Tensor<1, data_t> B; //!< \f$B^i = \partial_t \beta^i\f$, this is used
                         //! for second order shift conditions

    /// Defines the mapping between members of Vars and Chombo grid
    /// variables (enum in User_Variables)
    template <typename mapping_function_t>
    AMREX_GPU_DEVICE void enum_mapping(mapping_function_t mapping_function)
    {
        using namespace VarsTools; // define_enum_mapping is part of VarsTools
        VarsNoGauge<data_t>::enum_mapping(mapping_function);
        define_enum_mapping(mapping_function, c_lapse, lapse);
        define_enum_mapping(mapping_function, GRInterval<c_shift1, c_shift3>(),
                            shift);
        define_enum_mapping(mapping_function, GRInterval<c_B1, c_B3>(), B);
    }
};

/// Vars object for BSSN vars needing second derivs, excluding gauge vars
template <class data_t>
struct Diff2VarsNoGauge : public ADMConformalVars::Diff2VarsNoGauge<data_t>
{
};

/// Vars object for BSSN vars needing second derivs, including gauge vars
template <class data_t>
struct Diff2VarsWithGauge : public ADMConformalVars::Diff2VarsWithGauge<data_t>
{
};
} // namespace BSSNVars

#endif /* BSSNVARS_HPP_ */



================================================
FILE: Source/CCZ4/CCZ4Geometry.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// This file calculates CCZ4 geometric quantities (or a similar 3+1 split).
#ifndef CCZ4GEOMETRY_HPP_
#define CCZ4GEOMETRY_HPP_

#include "DimensionDefinitions.hpp"
#include "TensorAlgebra.hpp"

//! A structure for the decomposed elements of the Energy Momentum Tensor in
//! 3+1D
struct emtensor_t
{
    Tensor<2, amrex::Real> S; //!< S_ij = T_ij
    Tensor<1, amrex::Real> j; //!< j_i = T_ia_n^a
    amrex::Real trS;          //!< trS = S^i_i
    amrex::Real rho;          //!< rho = T_ab n^a n^b
};

struct ricci_t
{
    Tensor<2, amrex::Real> LL; // Ricci with two indices down
    amrex::Real scalar{};      // Ricci scalar
};

class CCZ4Geometry
{
  protected:
    AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE static amrex::Real compute_z_terms(
        const int i, const int j, const Tensor<1, amrex::Real> &Z_over_chi,
        const Tensor<2, amrex::Real> &h, const Tensor<1, amrex::Real> &d1_chi)
    {
        amrex::Real out = 0.;
        FOR (k)
        {
            out += Z_over_chi[k] * (h[i][k] * d1_chi[j] + h[j][k] * d1_chi[i] -
                                    h[i][j] * d1_chi[k]);
        }
        return out;
    }

  public:
    template <template <class> class vars_t, class d2_vars_t>
    AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE static ricci_t
    compute_ricci_Z(const vars_t<amrex::Real> &vars,
                    const vars_t<Tensor<1, amrex::Real>> &d1,
                    const d2_vars_t &d2, const Tensor<2, amrex::Real> &h_UU,
                    const chris_t &chris,
                    const Tensor<1, amrex::Real> &Z_over_chi)
    {
        ricci_t out;

        Tensor<2, amrex::Real> covdtilde2chi;
        FOR (k, l)
        {
            covdtilde2chi[k][l] = d2.chi[k][l];
            FOR (m)
            {
                covdtilde2chi[k][l] -= chris.ULL[m][k][l] * d1.chi[m];
            }
        }

        Tensor<3, amrex::Real> chris_LLU = {0.};
        amrex::Real boxtildechi          = 0.;
        amrex::Real dchi_dot_dchi        = 0.;
        FOR (i, j)
        {
            boxtildechi   += covdtilde2chi[i][j] * h_UU[i][j];
            dchi_dot_dchi += d1.chi[i] * d1.chi[j] * h_UU[i][j];
            FOR (k, l)
            {
                chris_LLU[i][j][k] += h_UU[k][l] * chris.LLL[i][j][l];
            }
        }

        FOR (i, j)
        {
            amrex::Real ricci_hat = 0;
            FOR (k)
            {
                // We call this ricci_hat rather than ricci_tilde as we have
                // replaced what should be \tilde{Gamma} with \hat{Gamma} in
                // order to avoid adding terms that cancel later on
                ricci_hat += 0.5 * (vars.h[k][i] * d1.Gamma[k][j] +
                                    vars.h[k][j] * d1.Gamma[k][i]);
                ricci_hat += 0.5 * vars.Gamma[k] * d1.h[i][j][k];
                FOR (l)
                {
                    ricci_hat += -0.5 * h_UU[k][l] * d2.h[i][j][k][l] +
                                 (chris.ULL[k][l][i] * chris_LLU[j][k][l] +
                                  chris.ULL[k][l][j] * chris_LLU[i][k][l] +
                                  chris.ULL[k][i][l] * chris_LLU[k][j][l]);
                }
            }

            amrex::Real ricci_chi =
                0.5 * ((GR_SPACEDIM - 2) * covdtilde2chi[i][j] +
                       vars.h[i][j] * boxtildechi -
                       ((GR_SPACEDIM - 2) * d1.chi[i] * d1.chi[j] +
                        GR_SPACEDIM * vars.h[i][j] * dchi_dot_dchi) /
                           (2 * vars.chi));

            amrex::Real z_terms =
                compute_z_terms(i, j, Z_over_chi, vars.h, d1.chi);

            out.LL[i][j] =
                (ricci_chi + vars.chi * ricci_hat + z_terms) / vars.chi;
        }

        out.scalar = vars.chi * TensorAlgebra::compute_trace(out.LL, h_UU);

        return out;
    }

    AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE static Tensor<2, amrex::Real>
    compute_d1_chris_contracted(const Tensor<2, amrex::Real> &h_UU,
                                const Tensor<2, Tensor<1, amrex::Real>> &d1_h,
                                const Tensor<2, Tensor<2, amrex::Real>> &d2_h)
    {
        Tensor<2, amrex::Real> d1_chris_contracted = 0.0;
        FOR (i, j)
        {
            FOR (m, n, p)
            {
                amrex::Real d1_terms = 0.0;
                FOR (q, r)
                {
                    d1_terms += -h_UU[q][r] * (d1_h[n][q][j] * d1_h[m][p][r] +
                                               d1_h[m][n][j] * d1_h[p][q][r]);
                }
                d1_chris_contracted[i][j] +=
                    h_UU[i][m] * h_UU[n][p] * (d2_h[m][n][j][p] + d1_terms);
            }
        }
        return d1_chris_contracted;
    }

    // This function allows adding arbitrary multiples of D_{(i}Z_{j)}
    // to the Ricci scalar rather than the default of 2 in compute_ricci_Z
    template <template <class> class vars_t, class d2_vars_t>
    AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE static ricci_t
    compute_ricci_Z_general(const vars_t<amrex::Real> &vars,
                            const vars_t<Tensor<1, amrex::Real>> &d1,
                            const d2_vars_t &d2,
                            const Tensor<2, amrex::Real> &h_UU,
                            const chris_t &chris, const double dZ_coeff)
    {
        // get contributions from conformal metric and factor with zero Z vector
        Tensor<1, amrex::Real> zero_Z = 0.;
        auto ricci = compute_ricci_Z(vars, d1, d2, h_UU, chris, zero_Z);

        // need to add term to correct for d1.Gamma (includes Z contribution)
        // and Gamma in ricci_hat
        auto d1_chris_contracted =
            compute_d1_chris_contracted(h_UU, d1.h, d2.h);
        Tensor<1, amrex::Real> Z_over_chi;
        FOR (i)
        {
            Z_over_chi[i] = 0.5 * (vars.Gamma[i] - chris.contracted[i]);
        }
        FOR (i, j)
        {
            FOR (m)
            {
                // This corrects for the \hat{Gamma}s in ricci_hat
                ricci.LL[i][j] +=
                    (1. - 0.5 * dZ_coeff) * 0.5 *
                    (vars.h[m][i] *
                         (d1_chris_contracted[m][j] - d1.Gamma[m][j]) +
                     vars.h[m][j] *
                         (d1_chris_contracted[m][i] - d1.Gamma[m][i]) +
                     (chris.contracted[m] - vars.Gamma[m]) * d1.h[i][j][m]);
            }
            amrex::Real z_terms =
                compute_z_terms(i, j, Z_over_chi, vars.h, d1.chi);
            ricci.LL[i][j] += 0.5 * dZ_coeff * z_terms / vars.chi;
        }
        ricci.scalar = vars.chi * TensorAlgebra::compute_trace(ricci.LL, h_UU);
        return ricci;
    }

    // This function returns the pure Ricci scalar with no contribution from the
    // Z vector - used e.g. in the constraint calculations.
    template <template <class> class vars_t, class d2_vars_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE static ricci_t
    compute_ricci(const vars_t<amrex::Real> &vars,
                  const vars_t<Tensor<1, amrex::Real>> &d1, const d2_vars_t &d2,
                  const Tensor<2, amrex::Real> &h_UU, const chris_t &chris)
    {
        return compute_ricci_Z_general(vars, d1, d2, h_UU, chris, 0.0);
    }
};

#endif /* CCZ4GEOMETRY_HPP_ */



================================================
FILE: Source/CCZ4/CCZ4RHS.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef CCZ4RHS_HPP_
#define CCZ4RHS_HPP_

#include "CCZ4Geometry.hpp"
#include "CCZ4Vars.hpp"
#include "Cell.hpp"
#include "FourthOrderDerivatives.hpp"
#include "MovingPunctureGauge.hpp"
#include "Tensor.hpp"
#include "TensorAlgebra.hpp"

#include "StateVariables.hpp" //This files needs NUM_VARS - total number of components

#include <array>

/// Base parameter struct for CCZ4
/** This struct collects the gauge independent CCZ4 parameters i.e. the damping
 * ones
 */
struct CCZ4_base_params_t
{
    double kappa1;    //!< Damping parameter kappa1 as in arXiv:1106.2254
    double kappa2;    //!< Damping parameter kappa2 as in arXiv:1106.2254
    double kappa3;    //!< Damping parameter kappa3 as in arXiv:1106.2254
    bool covariantZ4; //!< if true, replace kappa1->kappa1/lapse as in
                      //!<  arXiv:1307.7391 eq. 27
};

/// Parameter struct for CCZ4
/** This struct collects all parameters that are necessary for CCZ4 such as
 * gauge and damping parameters. It inherits from CCZ4_base_params_t and
 * gauge_t::params_t
 */
template <class gauge_params_t = MovingPunctureGauge::params_t>
struct CCZ4_params_t : public CCZ4_base_params_t, public gauge_params_t
{
};

/// Compute class to calculate the CCZ4 right hand side
/**
 * This compute class implements the CCZ4 right hand side equations. Use it by
 *handing it to a loop in the BoxLoops namespace. CCZ4RHS includes a struct
 *in its scope: CCZ4RHS::Vars (the CCZ4 variables like conformal factor,
 *conformal metric, extrinsic curvature, etc).
 **/
template <class gauge_t = MovingPunctureGauge,
          class deriv_t = FourthOrderDerivatives>
class CCZ4RHS
{
  public:
    enum
    {
        USE_CCZ4,
        USE_BSSN
    };

    using params_t = CCZ4_params_t<typename gauge_t::params_t>;

    /// CCZ4 variables
    template <class data_t> using Vars = CCZ4Vars::VarsWithGauge<data_t>;

    /// CCZ4 variables
    template <class data_t>
    using Diff2Vars = CCZ4Vars::Diff2VarsWithGauge<data_t>;

  protected:
    params_t m_params; //!< CCZ4 parameters
    gauge_t m_gauge;   //!< Class to compute gauge in rhs_equation
    double m_sigma;    //!< Coefficient for Kreiss-Oliger dissipation
    int m_formulation;
    double m_cosmological_constant;
    deriv_t m_deriv;

  public:
    /// Constructor
    CCZ4RHS(
        params_t a_params,            //!< The CCZ4 parameters
        double a_dx,                  //!< The grid spacing
        double a_sigma,               //!< Kreiss-Oliger dissipation coefficient
        int a_formulation = USE_CCZ4, //!< Switches between CCZ4, BSSN,...
        double a_cosmological_constant = 0 //!< Value of the cosmological const.
    );

    /// Compute function
    /** This function orchestrates the calculation of the rhs for one specific
     * grid cell. This function is called by the BoxLoops::loop for each grid
     * cell; there should rarely be a need to call it directly.
     */
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
    compute(int i, int j, int k, const amrex::Array4<amrex::Real> &rhs,
            const amrex::Array4<amrex::Real const> &state) const;

  protected:
    /// Calculates the rhs for CCZ4
    /** Calculates the right hand side for CCZ4 and calls rhs_gauge for the
     *gauge conditions The variables (the template argument vars_t) must contain
     *at least the members: chi, h[i][j], Gamma[i], A[i][j], Theta, lapse and
     *shift[i].
     **/
    template <template <class> class vars_t, class d2_vars_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void rhs_equation(
        vars_t<amrex::Real> &rhs, //!< Reference to the variables into which the
                                  //! output right hand side is written
        const vars_t<amrex::Real>
            &vars, //!< The values of the current variables
        const vars_t<Tensor<1, amrex::Real>>
            &d1,             //!< First derivative of the variables
        const d2_vars_t &d2, //!< The second derivative the variables
        const vars_t<amrex::Real>
            &advec //!< The advection derivatives of the variables
    ) const;
};

#include "CCZ4RHS.impl.hpp"

#endif /* CCZ4RHS_HPP_ */



================================================
FILE: Source/CCZ4/CCZ4RHS.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(CCZ4RHS_HPP_)
#error "This file should only be included through CCZ4RHS.hpp"
#endif

#ifndef CCZ4RHS_IMPL_HPP_
#define CCZ4RHS_IMPL_HPP_

#include "DimensionDefinitions.hpp"
#include "GRInterval.hpp"
#include "VarsTools.hpp"

// NOLINTBEGIN(bugprone-easily-swappable-parameters)
template <class gauge_t, class deriv_t>
inline CCZ4RHS<gauge_t, deriv_t>::CCZ4RHS(
    CCZ4_params_t<typename gauge_t::params_t> a_params, double a_dx,
    double a_sigma, int a_formulation, double a_cosmological_constant)
    : m_params(a_params), m_gauge(a_params), m_sigma(a_sigma),
      m_formulation(a_formulation),
      m_cosmological_constant(a_cosmological_constant), m_deriv(a_dx)
// NOLINTEND(bugprone-easily-swappable-parameters)
{
    // A user who wants to use BSSN should also have damping paramters = 0
    if (m_formulation == USE_BSSN)
    {
        if ((m_params.kappa1 != 0.) || (m_params.kappa2 != 0.) ||
            (m_params.kappa3 != 0.))
        {
            amrex::Abort("BSSN formulation is selected - CCZ4 kappa values "
                         "should be set to zero in params");
        }
    }
    if (m_formulation > USE_BSSN)
    {
        amrex::Abort("The requested formulation is not supported");
    }
}

template <class gauge_t, class deriv_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE void CCZ4RHS<gauge_t, deriv_t>::compute(
    int i, int j, int k, const amrex::Array4<amrex::Real> &rhs,
    const amrex::Array4<amrex::Real const> &state) const
{
    const auto vars = load_vars<Vars>(state.cellData(i, j, k));
    const auto d1   = m_deriv.template diff1<Vars>(i, j, k, state);
    const auto d2   = m_deriv.template diff2<Diff2Vars>(i, j, k, state);
    const auto advec =
        m_deriv.template advection<Vars>(i, j, k, state, vars.shift);

    Vars<amrex::Real> rhs_vars;
    rhs_equation(rhs_vars, vars, d1, d2, advec);

    m_deriv.add_dissipation(i, j, k, rhs_vars, state, m_sigma);

    store_vars(rhs.cellData(i, j, k), rhs_vars);
}

// NOLINTBEGIN(readability-function-cognitive-complexity)
template <class gauge_t, class deriv_t>
template <template <class> class vars_t, class d2_vars_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
CCZ4RHS<gauge_t, deriv_t>::rhs_equation(
    vars_t<amrex::Real> &rhs, const vars_t<amrex::Real> &vars,
    const vars_t<Tensor<1, amrex::Real>> &d1, const d2_vars_t &d2,
    const vars_t<amrex::Real> &advec) const
{
    using namespace TensorAlgebra;

    auto h_UU  = compute_inverse_sym(vars.h);
    auto chris = compute_christoffel(d1.h, h_UU);

    Tensor<1, amrex::Real> Z_over_chi;
    Tensor<1, amrex::Real> Z; // NOLINT(readability-identifier-length)

    if (m_formulation == USE_BSSN)
    {
        FOR (i)
            Z_over_chi[i] = 0.0;
    }
    else
    {
        FOR (i)
            Z_over_chi[i] = 0.5 * (vars.Gamma[i] - chris.contracted[i]);
    }
    FOR (i)
        Z[i] = vars.chi * Z_over_chi[i];

    auto ricci =
        CCZ4Geometry::compute_ricci_Z(vars, d1, d2, h_UU, chris, Z_over_chi);

    amrex::Real divshift        = compute_trace(d1.shift);
    amrex::Real Z_dot_d1lapse   = compute_dot_product(Z, d1.lapse);
    amrex::Real dlapse_dot_dchi = compute_dot_product(d1.lapse, d1.chi, h_UU);

    Tensor<2, amrex::Real> covdtilde2lapse;
    Tensor<2, amrex::Real> covd2lapse;
    FOR (k, l)
    {
        covdtilde2lapse[k][l] = d2.lapse[k][l];
        FOR (m)
        {
            covdtilde2lapse[k][l] -= chris.ULL[m][k][l] * d1.lapse[m];
        }
        covd2lapse[k][l] =
            vars.chi * covdtilde2lapse[k][l] +
            0.5 * (d1.lapse[k] * d1.chi[l] + d1.chi[k] * d1.lapse[l] -
                   vars.h[k][l] * dlapse_dot_dchi);
    }

    amrex::Real tr_covd2lapse = -(GR_SPACEDIM / 2.0) * dlapse_dot_dchi;
    FOR (i)
    {
        tr_covd2lapse -= vars.chi * chris.contracted[i] * d1.lapse[i];
        FOR (j)
        {
            tr_covd2lapse += h_UU[i][j] * (vars.chi * d2.lapse[i][j] +
                                           d1.lapse[i] * d1.chi[j]);
        }
    }

    Tensor<2, amrex::Real> A_UU = raise_all(vars.A, h_UU);

    // A^{ij} A_{ij}. - Note the abuse of the compute trace function.
    amrex::Real tr_A2 = compute_trace(vars.A, A_UU);
    rhs.chi           = advec.chi +
              (2.0 / GR_SPACEDIM) * vars.chi * (vars.lapse * vars.K - divshift);
    FOR (i, j)
    {
        rhs.h[i][j] = advec.h[i][j] - 2.0 * vars.lapse * vars.A[i][j] -
                      (2.0 / GR_SPACEDIM) * vars.h[i][j] * divshift;
        FOR (k)
        {
            rhs.h[i][j] +=
                vars.h[k][i] * d1.shift[k][j] + vars.h[k][j] * d1.shift[k][i];
        }
    }

    Tensor<2, amrex::Real> Adot_TF;
    FOR (i, j)
    {
        Adot_TF[i][j] =
            -covd2lapse[i][j] + vars.chi * vars.lapse * ricci.LL[i][j];
    }
    make_trace_free(Adot_TF, vars.h, h_UU);

    FOR (i, j)
    {
        rhs.A[i][j] = advec.A[i][j] + Adot_TF[i][j] +
                      vars.A[i][j] * (vars.lapse * (vars.K - 2 * vars.Theta) -
                                      (2.0 / GR_SPACEDIM) * divshift);
        FOR (k)
        {
            rhs.A[i][j] +=
                vars.A[k][i] * d1.shift[k][j] + vars.A[k][j] * d1.shift[k][i];
            FOR (l)
            {
                rhs.A[i][j] -=
                    2 * vars.lapse * h_UU[k][l] * vars.A[i][k] * vars.A[l][j];
            }
        }
    }

    amrex::Real kappa1_times_lapse;
    if (m_params.covariantZ4)
    {
        kappa1_times_lapse = m_params.kappa1;
    }
    else
    {
        kappa1_times_lapse = m_params.kappa1 * vars.lapse;
    }

    if (m_formulation == USE_BSSN)
    {
        rhs.Theta = 0; // ensure the Theta of CCZ4 remains at zero
        // Use hamiltonian constraint to remove ricci.scalar for BSSN update
        rhs.K = advec.K + vars.lapse * (tr_A2 + vars.K * vars.K / GR_SPACEDIM) -
                tr_covd2lapse;
        rhs.K += -2 * vars.lapse * m_cosmological_constant / (GR_SPACEDIM - 1.);
    }
    else
    {
        rhs.Theta =
            advec.Theta +
            0.5 * vars.lapse *
                (ricci.scalar - tr_A2 +
                 ((GR_SPACEDIM - 1.0) / (double)GR_SPACEDIM) * vars.K * vars.K -
                 2 * vars.Theta * vars.K) -
            0.5 * vars.Theta * kappa1_times_lapse *
                ((GR_SPACEDIM + 1) + m_params.kappa2 * (GR_SPACEDIM - 1)) -
            Z_dot_d1lapse;

        rhs.Theta += -vars.lapse * m_cosmological_constant;
        rhs.K =
            advec.K +
            vars.lapse * (ricci.scalar + vars.K * (vars.K - 2 * vars.Theta)) -
            kappa1_times_lapse * GR_SPACEDIM * (1 + m_params.kappa2) *
                vars.Theta -
            tr_covd2lapse;
        rhs.K += -2 * vars.lapse * GR_SPACEDIM / (GR_SPACEDIM - 1.) *
                 m_cosmological_constant;
    }

    Tensor<1, amrex::Real> Gammadot;
    FOR (i)
    {
        Gammadot[i] = (2.0 / GR_SPACEDIM) *
                          (divshift * (chris.contracted[i] +
                                       2 * m_params.kappa3 * Z_over_chi[i]) -
                           2 * vars.lapse * vars.K * Z_over_chi[i]) -
                      2 * kappa1_times_lapse * Z_over_chi[i];
        FOR (j)
        {
            Gammadot[i] +=
                2 * h_UU[i][j] *
                    (vars.lapse * d1.Theta[j] - vars.Theta * d1.lapse[j]) -
                2 * A_UU[i][j] * d1.lapse[j] -
                vars.lapse * ((2 * (GR_SPACEDIM - 1.0) / (double)GR_SPACEDIM) *
                                  h_UU[i][j] * d1.K[j] +
                              GR_SPACEDIM * A_UU[i][j] * d1.chi[j] / vars.chi) -
                (chris.contracted[j] + 2 * m_params.kappa3 * Z_over_chi[j]) *
                    d1.shift[i][j];

            FOR (k)
            {
                Gammadot[i] +=
                    2 * vars.lapse * chris.ULL[i][j][k] * A_UU[j][k] +
                    h_UU[j][k] * d2.shift[i][j][k] +
                    ((GR_SPACEDIM - 2.0) / (double)GR_SPACEDIM) * h_UU[i][j] *
                        d2.shift[k][j][k];
            }
        }
    }

    FOR (i)
    {
        rhs.Gamma[i] = advec.Gamma[i] + Gammadot[i];
    }

    m_gauge.rhs_gauge(rhs, vars, d1, d2, advec);
}
// NOLINTEND(readability-function-cognitive-complexity)

#endif /* CCZ4RHS_IMPL_HPP_ */



================================================
FILE: Source/CCZ4/CCZ4StateVariables.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef CCZ4STATEVARIABLES_HPP
#define CCZ4STATEVARIABLES_HPP

#include <algorithm>
#include <array>
#include <string>

#include "BCParity.hpp"

/// This enum gives the index of the CCZ4 state variables on the grid
enum
{
    c_chi,

    c_h11,
    c_h12,
    c_h13,
    c_h22,
    c_h23,
    c_h33,

    c_K,

    c_A11,
    c_A12,
    c_A13,
    c_A22,
    c_A23,
    c_A33,

    c_Theta,

    c_Gamma1,
    c_Gamma2,
    c_Gamma3,

    c_lapse,

    c_shift1,
    c_shift2,
    c_shift3,

    c_B1,
    c_B2,
    c_B3,

    NUM_CCZ4_VARS
};

namespace CCZ4StateVariables
{
static const amrex::Vector<std::string> names = {
    "chi",

    "h11",    "h12",    "h13",    "h22", "h23", "h33",

    "K",

    "A11",    "A12",    "A13",    "A22", "A23", "A33",

    "Theta",

    "Gamma1", "Gamma2", "Gamma3",

    "lapse",

    "shift1", "shift2", "shift3",

    "B1",     "B2",     "B3",
};

static const std::array<BCParity, NUM_CCZ4_VARS> parities = {
    BCParity::even, // chi

    BCParity::even,   // h11
    BCParity::odd_xy, // h12
    BCParity::odd_xz, // h13
    BCParity::even,   // h22
    BCParity::odd_yz, // h23
    BCParity::even,   // h33

    BCParity::even, // K

    BCParity::even,   // A11
    BCParity::odd_xy, // A12
    BCParity::odd_xz, // A13
    BCParity::even,   // A22
    BCParity::odd_yz, // A23
    BCParity::even,   // A33

    BCParity::even, // Theta

    BCParity::odd_x, // Gamma1
    BCParity::odd_y, // Gamma2
    BCParity::odd_z, // Gamma3

    BCParity::even, // lapse

    BCParity::odd_x, // shift1
    BCParity::odd_y, // shift2
    BCParity::odd_z, // shift3

    BCParity::odd_x, // B1
    BCParity::odd_y, // B2
    BCParity::odd_z, // B3
};
} // namespace CCZ4StateVariables

#endif /* CCZ4STATEVARIABLES_HPP */



================================================
FILE: Source/CCZ4/CCZ4Vars.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef CCZ4VARS_HPP_
#define CCZ4VARS_HPP_

#include "ADMConformalVars.hpp"
#include "BSSNVars.hpp"
#include "Tensor.hpp"
#include "VarsTools.hpp"

/// Namespace for CCZ4 vars
/** The structs in this namespace collect all the CCZ4 variables. It's main use
 *  is to make a local, nicely laid-out, copy of the CCZ4 variables for the
 *  current grid cell (Otherwise, this data would only exist on the grid in
 *  the huge, flattened Chombo array). \sa {CCZ4Vars, ADMConformalVars}
 **/
namespace CCZ4Vars
{
/// Vars object for CCZ4 vars, including gauge vars
template <class data_t>
struct VarsNoGauge : public BSSNVars::VarsNoGauge<data_t>
{
    data_t Theta; //!< CCZ4 quantity associated to Hamiltonian constraint

    /// Defines the mapping between members of Vars and Chombo grid
    /// variables (enum in User_Variables)
    template <typename mapping_function_t>
    AMREX_GPU_DEVICE void enum_mapping(mapping_function_t mapping_function)
    {
        using namespace VarsTools; // define_enum_mapping is part of VarsTools
        BSSNVars::VarsNoGauge<data_t>::enum_mapping(mapping_function);
        define_enum_mapping(mapping_function, c_Theta, Theta);
    }
};

/// Vars object for CCZ4 vars, including gauge vars
template <class data_t>
struct VarsWithGauge : public BSSNVars::VarsWithGauge<data_t>
{
    data_t Theta{}; //!< CCZ4 quantity associated to hamiltonian constraint

    /// Defines the mapping between members of Vars and Chombo grid
    /// variables (enum in User_Variables)
    template <typename mapping_function_t>
    AMREX_GPU_DEVICE void enum_mapping(mapping_function_t mapping_function)
    {
        using namespace VarsTools; // define_enum_mapping is part of VarsTools
        BSSNVars::VarsWithGauge<data_t>::enum_mapping(mapping_function);
        define_enum_mapping(mapping_function, c_Theta, Theta);
    }
};

/// Vars object for CCZ4 vars needing second derivs, excluding gauge vars
template <class data_t>
struct Diff2VarsNoGauge : public ADMConformalVars::Diff2VarsNoGauge<data_t>
{
};

/// Vars object for CCZ4 vars needing second derivs, including gauge vars
template <class data_t>
struct Diff2VarsWithGauge : public ADMConformalVars::Diff2VarsWithGauge<data_t>
{
};
} // namespace CCZ4Vars

#endif /* CCZ4VARS_HPP_ */



================================================
FILE: Source/CCZ4/Constraints.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// This compute class calculates Hamiltonian and Momentum constraints

#ifndef CONSTRAINTS_HPP_
#define CONSTRAINTS_HPP_

// GRTeclyn includes
#include "BSSNVars.hpp"
#include "CCZ4Geometry.hpp"
#include "Cell.hpp"
#include "FourthOrderDerivatives.hpp"
#include "Interval.hpp"
#include "Tensor.hpp"

// AMReX includes
#include <AMReX_MultiFab.H>
#include <AMReX_REAL.H>

// System includes
#include <array>

class Constraints
{
  public:
    static inline const std::string name = "constraints";

    /// Variable names
    static inline const amrex::Vector<std::string> var_names = {"Ham", "Mom1",
                                                                "Mom2", "Mom3"};

    static inline const amrex::Vector<std::string> var_names_norm = {"Ham",
                                                                     "Mom"};

    /// CCZ4 variables
    template <class data_t> using MetricVars = BSSNVars::VarsNoGauge<data_t>;

    /// CCZ4 variables
    template <class data_t>
    using Diff2Vars = BSSNVars::Diff2VarsNoGauge<data_t>;

    /// Vars object for Constraints
    struct Vars
    {
        amrex::Real Ham{};
        amrex::Real Ham_abs_terms{};
        Tensor<1, amrex::Real> Mom;
        Tensor<1, amrex::Real> Mom_abs_terms;
    };

    // Constructor which allows specifying Ham and Mom vars
    // if the interval of a_c_Moms is of size 1, then
    // sqrt(Mom1^2 + Mom2^2 + Mom3^2) is stored in that variable
    // ...abs_terms stores the absolute value of the individual terms in the
    // conformally decomposed expressions which can be used in to normalize
    // the constraint violations
    // Any zero-length Interval or negative var is not calculated
    // If a positive interval is passed for one of a_c_Moms or
    // a_c_moms_abs_terms then it must have length consistent with
    // s_calc_mom_norm
    AMREX_FORCE_INLINE
    Constraints(double dx, int a_c_Ham, const Interval &a_c_Moms,
                int a_c_Ham_abs_terms              = -1,
                const Interval &a_c_Moms_abs_terms = Interval(),
                double cosmological_constant       = 0.0);

    AMREX_FORCE_INLINE AMREX_GPU_DEVICE void
    compute(int i, int j, int k, const amrex::Array4<amrex::Real> &cst,
            const amrex::Array4<amrex::Real const> &state) const;

    /// Adds the constraints to the derive list
    /// Call in variableSetUp()
    AMREX_FORCE_INLINE static void set_up(int a_state_index,
                                          bool a_calc_mom_norm = false);

    // Has signature of DeriveFuncMF so that it can be stored in the derive_lst
    AMREX_FORCE_INLINE static void
    compute_mf(amrex::MultiFab &out_mf, int dcomp, int ncomp,
               const amrex::MultiFab &src_mf, const amrex::Geometry &geomdata,
               amrex::Real /*time*/, const int * /*bcrec*/, int /*level*/);

  protected:
    // NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
    static inline bool s_calc_mom_norm =
        false; // set to true with set_up() to store just sqrt(Mom1^2 + Mom2^2 +
               // Mom3^2) instead of Mom1, Mom2, Mom3 separately
    FourthOrderDerivatives m_deriv;
    int m_c_Ham;
    Interval m_c_Moms;
    int m_c_Ham_abs_terms = -1;
    Interval m_c_Moms_abs_terms;
    double m_cosmological_constant;

    template <template <class> class vars_t, class d2_vars_t>
    AMREX_FORCE_INLINE AMREX_GPU_DEVICE Vars constraint_equations(
        const vars_t<amrex::Real> &vars,
        const vars_t<Tensor<1, amrex::Real>> &d1, const d2_vars_t &d2,
        const Tensor<2, amrex::Real> &h_UU, const chris_t &chris) const;

    AMREX_FORCE_INLINE AMREX_GPU_DEVICE void
    store_vars(const Vars &out,
               const amrex::CellData<amrex::Real> &current_cell) const;
};

#include "Constraints.impl.hpp"

#endif /* CONSTRAINTS_HPP_ */



================================================
FILE: Source/CCZ4/Constraints.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(CONSTRAINTS_HPP_)
#error "This file should only be included through Constraints.hpp"
#endif

#ifndef CONSTRAINTS_IMPL_HPP_
#define CONSTRAINTS_IMPL_HPP_

#include "Constraints.hpp"
#include "DimensionDefinitions.hpp"
#include "GRInterval.hpp"
#include "VarsTools.hpp"

// AMReX includes
#include <AMReX_AmrLevel.H>

// NOLINTBEGIN(bugprone-easily-swappable-parameters)
AMREX_FORCE_INLINE
Constraints::Constraints(double dx, int a_c_Ham, const Interval &a_c_Moms,
                         int a_c_Ham_abs_terms /*defaulted*/,
                         const Interval &a_c_Moms_abs_terms /*defaulted*/,
                         double cosmological_constant /*defaulted*/)
    : m_deriv(dx), m_c_Ham(a_c_Ham), m_c_Moms(a_c_Moms),
      m_c_Ham_abs_terms(a_c_Ham_abs_terms),
      m_c_Moms_abs_terms(a_c_Moms_abs_terms),
      m_cosmological_constant(cosmological_constant)
{
    AMREX_ALWAYS_ASSERT_WITH_MESSAGE(
        (a_c_Ham >= 0 && a_c_Ham_abs_terms < 0) ||
            (a_c_Ham < 0 && a_c_Ham_abs_terms >= 0),
        "must calculate one of either Ham or Ham_abs_terms");
    AMREX_ALWAYS_ASSERT_WITH_MESSAGE(
        a_c_Moms.size() * a_c_Moms_abs_terms.size() <= 0,
        "must choose at most one of Mom or Mom_abs_terms");
    const auto &moms_interval =
        (a_c_Moms.size() > 0) ? a_c_Moms : a_c_Moms_abs_terms;
    if (moms_interval.size() > 0)
    {
        AMREX_ALWAYS_ASSERT(moms_interval.size() == (s_calc_mom_norm ? 1 : 3));
    }
}
// NOLINTEND(bugprone-easily-swappable-parameters)

AMREX_GPU_DEVICE void
Constraints::compute(int i, int j, int k, const amrex::Array4<amrex::Real> &cst,
                     const amrex::Array4<amrex::Real const> &state) const
{
    const auto d1 = m_deriv.template diff1<MetricVars>(i, j, k, state);
    const auto d2 = m_deriv.template diff2<Diff2Vars>(i, j, k, state);

    const auto state_cell = state.cellData(i, j, k);
    const auto vars       = load_vars<MetricVars>(state_cell);
    const auto h_UU       = TensorAlgebra::compute_inverse_sym(vars.h);
    const auto chris      = TensorAlgebra::compute_christoffel(d1.h, h_UU);

    Vars out = constraint_equations(vars, d1, d2, h_UU, chris);

    const auto cst_cell = cst.cellData(i, j, k);
    store_vars(out, cst_cell);
}

AMREX_GPU_DEVICE void
Constraints::store_vars(const Vars &out,
                        const amrex::CellData<amrex::Real> &current_cell) const
{
    if (m_c_Ham >= 0)
    {
        current_cell[m_c_Ham] = out.Ham;
    }
    if (m_c_Ham_abs_terms >= 0)
    {
        current_cell[m_c_Ham_abs_terms] = out.Ham_abs_terms;
    }
    if (m_c_Moms.size() == GR_SPACEDIM)
    {
        FOR (i)
        {
            int ivar           = m_c_Moms.begin() + i;
            current_cell[ivar] = out.Mom[i];
        }
    }
    else if (m_c_Moms.size() == 1)
    {
        amrex::Real Mom_sq = 0.0;
        FOR (i)
        {
            Mom_sq += out.Mom[i] * out.Mom[i];
        }
        amrex::Real Mom                = sqrt(Mom_sq);
        current_cell[m_c_Moms.begin()] = Mom;
    }
    if (m_c_Moms_abs_terms.size() == GR_SPACEDIM)
    {
        FOR (i)
        {
            int ivar           = m_c_Moms_abs_terms.begin() + i;
            current_cell[ivar] = out.Mom_abs_terms[i];
        }
    }
    else if (m_c_Moms_abs_terms.size() == 1)
    {
        amrex::Real Mom_abs_terms_sq = 0.0;
        FOR (i)
        {
            Mom_abs_terms_sq += out.Mom_abs_terms[i] * out.Mom_abs_terms[i];
        }
        amrex::Real Mom_abs_terms                = sqrt(Mom_abs_terms_sq);
        current_cell[m_c_Moms_abs_terms.begin()] = Mom_abs_terms;
    }
}

void Constraints::set_up(int a_state_index, bool a_calc_mom_norm)
{
    s_calc_mom_norm = a_calc_mom_norm;
    int num_ghosts  = 2; // no advection terms so only need 2 ghost cells

    const auto &comp_names = (s_calc_mom_norm) ? var_names_norm : var_names;
    auto &derive_lst       = amrex::AmrLevel::get_derive_lst();
    const auto &desc_lst   = amrex::AmrLevel::get_desc_lst();

    derive_lst.add(
        name, amrex::IndexType::TheCellType(),
        static_cast<int>(comp_names.size()), comp_names, compute_mf,
        [=](const amrex::Box &box) { return amrex::grow(box, num_ghosts); },
        &amrex::cell_quartic_interp);

    // We only need the non-gauge CCZ4 variables to calculate the constraints
    derive_lst.addComponent(name, desc_lst, a_state_index, 0, c_lapse);
}

void Constraints::compute_mf(amrex::MultiFab &out_mf, int dcomp, int ncomp,
                             const amrex::MultiFab &src_mf,
                             const amrex::Geometry &geomdata,
                             amrex::Real /*time*/, const int * /*bcrec*/,
                             int /*level*/)
{
    const auto &out_arrays = out_mf.arrays();
    const auto &src_arrays = src_mf.const_arrays();
    int iham               = dcomp;
    Interval imom          = Interval(dcomp + 1, dcomp + AMREX_SPACEDIM);
    Constraints constraints(geomdata.CellSize(0), iham, imom);

    amrex::ParallelFor(
        out_mf, out_mf.nGrowVect(),
        [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k) noexcept
        {
            constraints.compute(i, j, k, out_arrays[box_no],
                                src_arrays[box_no]);
        });
}

template <template <class> class vars_t, class d2_vars_t>
AMREX_FORCE_INLINE AMREX_GPU_DEVICE Constraints::Vars
Constraints::constraint_equations(const vars_t<amrex::Real> &vars,
                                  const vars_t<Tensor<1, amrex::Real>> &d1,
                                  const d2_vars_t &d2,
                                  const Tensor<2, amrex::Real> &h_UU,
                                  const chris_t &chris) const
{
    Vars out;

    if (m_c_Ham >= 0 || m_c_Ham_abs_terms >= 0)
    {
        auto ricci = CCZ4Geometry::compute_ricci(vars, d1, d2, h_UU, chris);

        auto A_UU         = TensorAlgebra::raise_all(vars.A, h_UU);
        amrex::Real tr_A2 = TensorAlgebra::compute_trace(vars.A, A_UU);

        out.Ham = ricci.scalar +
                  (GR_SPACEDIM - 1.) * vars.K * vars.K / GR_SPACEDIM - tr_A2;
        out.Ham -= 2 * m_cosmological_constant;

        out.Ham_abs_terms =
            std::abs(ricci.scalar) + std::abs(tr_A2) +
            std::abs((GR_SPACEDIM - 1.) * vars.K * vars.K / GR_SPACEDIM);
        out.Ham_abs_terms += 2.0 * std::abs(m_cosmological_constant);
    }

    if (m_c_Moms.size() > 0 || m_c_Moms_abs_terms.size() > 0)
    {
        Tensor<3, amrex::Real> covd_A;
        FOR (i, j, k)
        {
            covd_A[i][j][k] = d1.A[j][k][i];
            FOR (l)
            {
                covd_A[i][j][k] += -chris.ULL[l][i][j] * vars.A[l][k] -
                                   chris.ULL[l][i][k] * vars.A[l][j];
            }
        }
        FOR (i)
        {
            out.Mom[i]           = -(GR_SPACEDIM - 1.) * d1.K[i] / GR_SPACEDIM;
            out.Mom_abs_terms[i] = std::abs(out.Mom[i]);
        }
        Tensor<1, amrex::Real> covd_A_term = 0.0;
        Tensor<1, amrex::Real> d1_chi_term = 0.0;
        FOR (i, j, k)
        {
            covd_A_term[i] += h_UU[j][k] * covd_A[k][j][i];
            d1_chi_term[i] += -GR_SPACEDIM * h_UU[j][k] * vars.A[i][j] *
                              d1.chi[k] / (2 * vars.chi);
        }
        FOR (i)
        {
            out.Mom[i] += covd_A_term[i] + d1_chi_term[i];
            out.Mom_abs_terms[i] +=
                std::abs(covd_A_term[i]) + std::abs(d1_chi_term[i]);
        }
    }
    return out;
}

#endif /* CONSTRAINTS_IMPL_HPP_ */



================================================
FILE: Source/CCZ4/GammaCalculator.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef GAMMACALCULATOR_HPP_
#define GAMMACALCULATOR_HPP_

#include "Cell.hpp"
#include "Coordinates.hpp"
#include "FourthOrderDerivatives.hpp"
#include "GRInterval.hpp"
#include "StateVariables.hpp" //This files needs NUM_VARS - total number of components
#include "Tensor.hpp"
#include "TensorAlgebra.hpp"
#include "VarsTools.hpp"
#include "simd.hpp"

class GammaCalculator
{
    // Only variables needed are metric
    template <class data_t> struct Vars
    {
        Tensor<2, data_t> h;

        template <typename mapping_function_t>
        AMREX_GPU_DEVICE void enum_mapping(mapping_function_t mapping_function)
        {
            VarsTools::define_symmetric_enum_mapping(
                mapping_function, GRInterval<c_h11, c_h33>(), h);
        }
    };

  protected:
    const FourthOrderDerivatives
        m_deriv; //!< An object for calculating derivatives of the variables

  public:
    GammaCalculator(double a_dx) : m_deriv(a_dx) {}

    void compute(Cell current_cell) const
    {
        // copy data from chombo gridpoint into local variables, and calc 1st
        // derivs
        Vars<amrex::Real> vars;
        load_vars(current_cell, vars);
        // TODO: Port this code
        // This code hasn't been ported to GRTeclyn.
        // We've just removed templating over data_t.
        const auto d1 = m_deriv.template diff1<Vars>(current_cell);

        using namespace TensorAlgebra;
        const auto h_UU  = compute_inverse_sym(vars.h);
        const auto chris = compute_christoffel(d1.h, h_UU);

        // assign values of Gamma^k = h_UU^ij * \tilde{Gamma}^k_ij in the output
        // FArrayBox
        current_cell.store_vars(chris.contracted,
                                GRInterval<c_Gamma1, c_Gamma3>());
    }
};

#endif /* GAMMACALCULATOR_HPP_ */



================================================
FILE: Source/CCZ4/IntegratedMovingPunctureGauge.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef INTEGRATEDMOVINGPUNCTUREGAUGE_HPP_
#define INTEGRATEDMOVINGPUNCTUREGAUGE_HPP_

#include "CCZ4Vars.hpp"
#include "Cell.hpp"
#include "DimensionDefinitions.hpp"
#include "MovingPunctureGauge.hpp"
#include "Tensor.hpp"

/// This is an example of a gauge class that can be used in the CCZ4RHS compute
/// class
/**
 * This class implements a slightly more generic version of the moving puncture
 * gauge. In particular it uses a Bona-Masso slicing condition of the form
 * f(lapse) = -c*lapse^(p-2)
 * and an Integrated version of the Gamma-driver shift condition
 * (see details in arXiv:gr-qc/0605030)
 **/
class IntegratedMovingPunctureGauge
{
  public:
    using params_t = MovingPunctureGauge::params_t;

  protected:
    params_t m_params;

    /// Vars needed internally in 'compute'
    template <class data_t> struct Vars
    {
        Tensor<1, data_t> shift;
        Tensor<1, data_t> Gamma; //!< Conformal connection functions

        /// Defines the mapping between members of Vars and Chombo grid
        /// variables (enum in User_Variables)
        template <typename mapping_function_t>
        AMREX_GPU_HOST_DEVICE void
        enum_mapping(mapping_function_t mapping_function)
        {
            VarsTools::define_enum_mapping(
                mapping_function, GRInterval<c_shift1, c_shift3>(), shift);
            VarsTools::define_enum_mapping(
                mapping_function, GRInterval<c_Gamma1, c_Gamma3>(), Gamma);
        }
    };

  public:
    IntegratedMovingPunctureGauge(const params_t &a_params) : m_params(a_params)
    {
    }

    // set the initial B^i to the initial condition equivalent to:
    // \partial_t shift - advec_coeff * advec.shift = 0
    // Include in your Example in GRAMRLevel::initial_data as:
    // fillAllGhosts();
    // BoxLoops::loop(IntegratedMovingPunctureGauge(m_p.ccz4_params),
    // m_state_new, m_state_new, EXCLUDE_GHOST_CELLS);
    void compute(Cell<amrex::Real> current_cell) const
    {
        // TODO: Port this class
        // We've just removed templating over data_t
        const auto vars = current_cell.template load_vars<Vars>();

        Tensor<1, amrex::Real> B; // NOLINT(readability-identifier-length)
        FOR (i)
        {
            B[i] = m_params.shift_Gamma_coeff * vars.Gamma[i] -
                   m_params.eta * vars.shift[i];
        }

        current_cell.store_vars(B, GRInterval<c_B1, c_B3>());
    }

    template <template <class> class vars_t, class d2_vars_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
    rhs_gauge(vars_t<amrex::Real> &rhs, const vars_t &vars<amrex::Real>,
              const vars_t<Tensor<1, amrex::Real>> &d1, const d2_vars_t &d2,
              const vars_t<amrex::Real> &advec) const
    {
        rhs.lapse = m_params.lapse_advec_coeff * advec.lapse -
                    m_params.lapse_coeff *
                        pow(vars.lapse, m_params.lapse_power) *
                        (vars.K - 2 * vars.Theta);
        FOR (i)
        {
            rhs.shift[i] = m_params.shift_advec_coeff * advec.shift[i] +
                           m_params.shift_Gamma_coeff * vars.Gamma[i] -
                           m_params.eta * vars.shift[i] - vars.B[i];
            rhs.B[i] = 0.; // static, stays the same to save initial condition
        }
    }
};

#endif /* INTEGRATEDMOVINGPUNCTUREGAUGE_HPP_ */



================================================
FILE: Source/CCZ4/Make.package
================================================
GRTECLYN_CEXE_headers += ADMConformalVars.hpp \
                         BSSNVars.hpp \
                         CCZ4Geometry.hpp \
                         CCZ4RHS.hpp \
                         CCZ4RHS.impl.hpp \
                         CCZ4StateVariables.hpp \
                         CCZ4Vars.hpp \
                         Constraints.hpp \
                         Constraints.impl.hpp \
                         GammaCalculator.hpp \
                         IntegratedMovingPunctureGauge.hpp \
                         MovingPunctureGauge.hpp \
                         PositiveChiAndLapse.hpp \
                         TraceARemoval.hpp \
                         Weyl4.hpp \
                         Weyl4.impl.hpp



================================================
FILE: Source/CCZ4/MovingPunctureGauge.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef MOVINGPUNCTUREGAUGE_HPP_
#define MOVINGPUNCTUREGAUGE_HPP_

#include "DimensionDefinitions.hpp"
#include "Tensor.hpp"
#include <AMReX_REAL.H>

/// This is an example of a gauge class that can be used in the CCZ4RHS compute
/// class
/**
 * This class implements a slightly more generic version of the moving puncture
 * gauge. In particular it uses a Bona-Masso slicing condition of the form
 * f(lapse) = -c*lapse^(p-2)
 * and a Gamma-driver shift condition
 **/
class MovingPunctureGauge
{
  public:
    struct params_t
    {
        // lapse params:
        double lapse_advec_coeff = 0.; //!< Switches advection terms in
                                       //! the lapse condition on/off
        double lapse_power = 1.; //!< The power p in \f$\partial_t \alpha = - c
                                 //!\alpha^p(K-2\Theta)\f$
        double lapse_coeff = 2.; //!< The coefficient c in \f$\partial_t \alpha
                                 //!= -c \alpha^p(K-2\Theta)\f$
        // shift params:
        double shift_Gamma_coeff = 0.75; //!< Gives the F in \f$\partial_t
                                         //!  \beta^i =  F B^i\f$
        double shift_advec_coeff = 0.;   //!< Switches advection terms in the
                                         //! shift condition on/off
        double eta = 1.; //!< The eta in \f$\partial_t B^i = \partial_t \tilde
                         //!\Gamma - \eta B^i\f$
    };

  protected:
    params_t m_params;

  public:
    MovingPunctureGauge(const params_t &a_params) : m_params(a_params) {}
    template <template <class> class vars_t, class d2_vars_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
    rhs_gauge(vars_t<amrex::Real> &rhs, const vars_t<amrex::Real> &vars,
              const vars_t<Tensor<1, amrex::Real>> & /*d1*/,
              const d2_vars_t & /*d2*/, const vars_t<amrex::Real> &advec) const
    {
        rhs.lapse = m_params.lapse_advec_coeff * advec.lapse -
                    m_params.lapse_coeff *
                        pow(vars.lapse, m_params.lapse_power) *
                        (vars.K - 2 * vars.Theta);
        FOR (i)
        {
            rhs.shift[i] = m_params.shift_advec_coeff * advec.shift[i] +
                           m_params.shift_Gamma_coeff * vars.B[i];
            rhs.B[i] = m_params.shift_advec_coeff * advec.B[i] -
                       m_params.shift_advec_coeff * advec.Gamma[i] +
                       rhs.Gamma[i] - m_params.eta * vars.B[i];
        }
    }
};

#endif /* MOVINGPUNCTUREGAUGE_HPP_ */



================================================
FILE: Source/CCZ4/PositiveChiAndLapse.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// This compute class enforces the positive chi and lapse condition
#ifndef POSITIVECHIANDLAPSE_HPP_
#define POSITIVECHIANDLAPSE_HPP_

#include "Cell.hpp"
#include "StateVariables.hpp"

class PositiveChiAndLapse
{
  private:
    double m_min_chi;
    double m_min_lapse;

  public:
    // NOLINTBEGIN(bugprone-easily-swappable-parameters)
    //! Constructor for class
    AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE PositiveChiAndLapse(
        const double a_min_chi = 1e-4, const double a_min_lapse = 1e-4)
        : m_min_chi(a_min_chi), m_min_lapse(a_min_lapse)
    {
    }
    // NOLINTEND(bugprone-easily-swappable-parameters)

    AMREX_GPU_HOST_DEVICE void
    operator()(const amrex::CellData<amrex::Real> &cell) const
    {
        auto chi   = cell[c_chi];
        auto lapse = cell[c_lapse];

        chi   = std::max(chi, m_min_chi);
        lapse = std::max(lapse, m_min_lapse);

        cell[c_chi]   = chi;
        cell[c_lapse] = lapse;
    }
};

#endif /* POSITIVECHIANDLAPSE_HPP_ */



================================================
FILE: Source/CCZ4/TraceARemoval.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// This class enforces A to be trace-free
#ifndef TRACEAREMOVAL_HPP_
#define TRACEAREMOVAL_HPP_

#include "CCZ4Geometry.hpp"
#include "Cell.hpp"
#include "StateVariables.hpp"
#include "Tensor.hpp"
#include "TensorAlgebra.hpp"
#include "VarsTools.hpp"

class TraceARemoval
{
  public:
    template <class data_t> struct Vars
    {
        Tensor<2, data_t> h;
        Tensor<2, data_t> A;

        template <typename mapping_function_t>
        AMREX_GPU_HOST_DEVICE void
        enum_mapping(mapping_function_t mapping_function);
    };

    AMREX_GPU_HOST_DEVICE void
    operator()(const amrex::CellData<amrex::Real> &cell) const
    {
        auto vars = load_vars<Vars>(cell);

        const auto h_UU = TensorAlgebra::compute_inverse_sym(vars.h);
        TensorAlgebra::make_trace_free(vars.A, vars.h, h_UU);

        store_vars(cell, vars);
    }
};

template <class data_t>
template <typename mapping_function_t>
AMREX_GPU_HOST_DEVICE void
TraceARemoval::Vars<data_t>::enum_mapping(mapping_function_t mapping_function)
{
    VarsTools::define_symmetric_enum_mapping(mapping_function,
                                             GRInterval<c_h11, c_h33>(), h);
    VarsTools::define_symmetric_enum_mapping(mapping_function,
                                             GRInterval<c_A11, c_A33>(), A);
}

#endif /* TRACEAREMOVAL_HPP_ */



================================================
FILE: Source/CCZ4/Weyl4.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef WEYL4_HPP_
#define WEYL4_HPP_

#include "CCZ4RHS.hpp"
#include "Cell.hpp"
#include "Coordinates.hpp"
#include "FourthOrderDerivatives.hpp"
#include "GRParmParse.hpp"
#include "StateVariables.hpp" //This files needs c_NUM - total number of components
#include "Tensor.hpp"
#include "TensorAlgebra.hpp"
#include <array>

// AMReX Includes
#include <AMReX_AmrLevel.H>

//! Struct for the E and B fields
struct EBFields_t
{
    Tensor<2, amrex::Real> E; //!< Electric component of Weyltensor
    Tensor<2, amrex::Real> B; //!< Magnetic component of Weyltensor
};

//! Struct for the null tetrad
struct Tetrad_t
{
    Tensor<1, amrex::Real> u; //!< the vector u^i
    Tensor<1, amrex::Real> v; //!< the vector v^i
    Tensor<1, amrex::Real> w; //!< the vector w^i
};

//! Struct for the Newman Penrose scalar
struct NPScalar_t
{
    amrex::Real Real; // Real component
    amrex::Real Im;   // Imaginary component
};

//!  Calculates the Weyl4 scalar for spacetimes without matter content
/*!
   This class calculates the Weyl4 scalar real and im parts using definitions
   from Alcubierres book "Introduction to 3+1 Numerical Relativity". We use a
   decomposition of the Weyl tensor in electric and magnetic parts, which then
   is used together with the tetrads defined in "gr-qc/0104063" to calculate the
   Weyl4 scalar.
*/
class Weyl4
{
  public:
    /// derive record name
    static inline const std::string name = "Weyl4";

    /// Variable names
    static inline const amrex::Vector<std::string> var_names = {"Weyl4_Re",
                                                                "Weyl4_Im"};

    // Use the variable definitions containing the needed quantities
    // TODO: Get rid of these data_ts once the derivatives are refactored -
    // at the moment they require the vars to have template arguments
    template <class data_t> using Vars = CCZ4Vars::VarsWithGauge<data_t>;
    template <class data_t>
    using Diff2Vars = ADMConformalVars::Diff2VarsNoGauge<data_t>;

    // NOLINTBEGIN(bugprone-easily-swappable-parameters)
    //! Constructor of class Weyl4
    /*!
        Takes in the centre for the calculation of the tetrads, grid spacing and
        the formulation.
    */
    Weyl4(const std::array<double, AMREX_SPACEDIM> &a_center, double a_dx,
          int a_dcomp, int a_formulation = CCZ4RHS<>::USE_CCZ4)
        : m_center(a_center), m_dx(a_dx), m_deriv(a_dx), m_dcomp(a_dcomp),
          m_formulation(a_formulation)
    {
    }
    // NOLINTEND(bugprone-easily-swappable-parameters)

    //! Computes Weyl4 in a cell
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
    compute(int i, int j, int k,
            const amrex::Array4<amrex::Real> &a_derive_array,
            const amrex::Array4<amrex::Real const> &a_state_array) const;

    AMREX_FORCE_INLINE static void set_up(int a_state_index);

    // Has signature of DeriveFuncMF so that it can be stored in the derive_lst
    AMREX_FORCE_INLINE static void
    compute_mf(amrex::MultiFab &out_mf, int dcomp, int ncomp,
               const amrex::MultiFab &src_mf, const amrex::Geometry &geomdata,
               amrex::Real /*time*/, const int * /*bcrec*/, int /*level*/);

  protected:
    std::array<double, AMREX_SPACEDIM> m_center; //!< The grid center
    double m_dx;                                 //!< the grid spacing
    FourthOrderDerivatives m_deriv; //!< for calculating derivs of vars
    int m_dcomp;       //!< Which commponent to store Weyl4_Re (Weyl4_Im will be
                       //!< m_dcomp+1)
    int m_formulation; //!< CCZ4 or BSSN?

    //! Compute spatial volume element
    [[nodiscard]] AMREX_GPU_DEVICE AMREX_FORCE_INLINE Tensor<3, amrex::Real>
    compute_epsilon3_LUU(const Vars<amrex::Real> &vars,
                         const Tensor<2, amrex::Real> &h_UU) const;

    //! Calculation of Weyl_4 scalar
    [[nodiscard]] AMREX_GPU_DEVICE AMREX_FORCE_INLINE NPScalar_t compute_Weyl4(
        const EBFields_t &ebfields, const Vars<amrex::Real> &vars,
        const Vars<Tensor<1, amrex::Real>> &d1,
        const Diff2Vars<Tensor<2, amrex::Real>> &d2,
        const Tensor<2, amrex::Real> &h_UU, const Coordinates &coords) const;

    //! Calculation of the tetrads
    [[nodiscard]] AMREX_GPU_DEVICE AMREX_FORCE_INLINE Tetrad_t
    compute_null_tetrad(const Vars<amrex::Real> &vars,
                        const Tensor<2, amrex::Real> &h_UU,
                        const Coordinates &coords) const;

    //! Calulation of the decomposition of the Weyl tensor in Electric and
    //! Magnetic fields
    [[nodiscard]] AMREX_GPU_DEVICE AMREX_FORCE_INLINE EBFields_t
    compute_EB_fields(const Vars<amrex::Real> &vars,
                      const Vars<Tensor<1, amrex::Real>> &d1,
                      const Diff2Vars<Tensor<2, amrex::Real>> &d2,
                      const Tensor<3, amrex::Real> &epsilon3_LUU,
                      const Tensor<2, amrex::Real> &h_UU,
                      const chris_t &chris) const;
};

#include "Weyl4.impl.hpp"

#endif /* WEYL4_HPP_ */



================================================
FILE: Source/CCZ4/Weyl4.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(WEYL4_HPP_)
#error "This file should only be included through Weyl4.hpp"
#endif

#ifndef WEYL4_IMPL_HPP_
#define WEYL4_IMPL_HPP_

AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
Weyl4::compute(int i, int j, int k,
               const amrex::Array4<amrex::Real> &a_derive_array,
               const amrex::Array4<amrex::Real const> &a_state_array) const
{
    // copy data from the state array into local variables
    const auto state_cell = a_state_array.cellData(i, j, k);
    const auto vars       = load_vars<Vars>(state_cell);
    const auto d1 = m_deriv.template diff1<Vars>(i, j, k, a_state_array);
    const auto d2 = m_deriv.template diff2<Diff2Vars>(i, j, k, a_state_array);

    // Get the coordinates
    const Coordinates coords(amrex::IntVect(i, j, k), m_dx, m_center);

    // Compute the inverse metric and Christoffel symbols
    using namespace TensorAlgebra;
    const auto h_UU  = compute_inverse_sym(vars.h);
    const auto chris = compute_christoffel(d1.h, h_UU);

    // Compute the spatial volume element
    const auto epsilon3_LUU = compute_epsilon3_LUU(vars, h_UU);

    // Compute the E and B fields
    EBFields_t ebfields =
        compute_EB_fields(vars, d1, d2, epsilon3_LUU, h_UU, chris);

    // work out the Newman Penrose scalar
    NPScalar_t out = compute_Weyl4(ebfields, vars, d1, d2, h_UU, coords);

    // store the result
    a_derive_array(i, j, k, m_dcomp)     = out.Real;
    a_derive_array(i, j, k, m_dcomp + 1) = out.Im;
}

AMREX_GPU_DEVICE AMREX_FORCE_INLINE Tensor<3, amrex::Real>
Weyl4::compute_epsilon3_LUU(const Vars<amrex::Real> &vars,
                            const Tensor<2, amrex::Real> &h_UU) const
{
    // raised normal vector, NB index 3 is time
    Tensor<1, amrex::Real, 4> n_U;
    n_U[3] = 1. / vars.lapse;
    FOR (i)
    {
        n_U[i] = -vars.shift[i] / vars.lapse;
    }

    // 4D levi civita symbol and 3D levi civita tensor in LLL and LUU form
    const auto epsilon4 = TensorAlgebra::epsilon4D();
    Tensor<3, amrex::Real> epsilon3_LLL;
    Tensor<3, amrex::Real> epsilon3_LUU;

    // Projection of antisymmentric Tensor onto hypersurface - see 8.3.17,
    // Alcubierre
    FOR (i, j, k)
    {
        epsilon3_LLL[i][j][k] = 0.0;
        epsilon3_LUU[i][j][k] = 0.0;
    }
    // projection of 4-antisymetric tensor to 3-tensor on hypersurface
    // note last index contracted as per footnote 86 pg 290 Alcubierre
    FOR (i, j, k)
    {
        for (int l = 0; l < 4; ++l)
        {
            epsilon3_LLL[i][j][k] += n_U[l] * epsilon4[i][j][k][l] *
                                     vars.lapse / (vars.chi * sqrt(vars.chi));
        }
    }
    // rasing indices
    FOR (i, j, k)
    {
        FOR (m, n)
        {
            epsilon3_LUU[i][j][k] += epsilon3_LLL[i][m][n] * h_UU[m][j] *
                                     vars.chi * h_UU[n][k] * vars.chi;
        }
    }

    return epsilon3_LUU;
}

// Calculation of E and B fields, using tetrads from gr-qc/0104063
// BSSN expressions from Alcubierre book
// CCZ4 expressions calculated by MR and checked with TF see:
// https://www.overleaf.com/read/tvqjbyhvqqtp
AMREX_GPU_DEVICE AMREX_FORCE_INLINE EBFields_t Weyl4::compute_EB_fields(
    const Vars<amrex::Real> &vars, const Vars<Tensor<1, amrex::Real>> &d1,
    const Diff2Vars<Tensor<2, amrex::Real>> &d2,
    const Tensor<3, amrex::Real> &epsilon3_LUU,
    const Tensor<2, amrex::Real> &h_UU, const chris_t &chris) const
{
    EBFields_t out;

    // Extrinsic curvature
    Tensor<2, amrex::Real> K_tensor;
    Tensor<3, amrex::Real> d1_K_tensor;
    Tensor<3, amrex::Real> covariant_deriv_K_tensor;

    // Compute inverse, Christoffel symbols, Ricci tensor and Z terms
    // Note that unlike in CCZ4 equations we want R_ij + 0.5(D_iZ_j + D_jZ_i)
    // rather than R_ij + D_iZ_j + D_jZ_i hence use compute_ricci_Z_general
    double dZ_coeff        = (m_formulation == CCZ4RHS<>::USE_CCZ4) ? 1. : 0.;
    auto ricci_and_Z_terms = CCZ4Geometry::compute_ricci_Z_general(
        vars, d1, d2, h_UU, chris, dZ_coeff);

    // Compute full spatial Christoffel symbols
    using namespace TensorAlgebra;
    const Tensor<3, amrex::Real> chris_phys =
        compute_phys_chris(d1.chi, vars.chi, vars.h, h_UU, chris.ULL);

    // Extrinsic curvature and corresponding covariant and partial derivatives
    FOR (i, j)
    {
        K_tensor[i][j] = vars.A[i][j] / vars.chi +
                         1. / 3. * (vars.h[i][j] * vars.K) / vars.chi;

        FOR (k)
        {
            d1_K_tensor[i][j][k] = d1.A[i][j][k] / vars.chi -
                                   d1.chi[k] / vars.chi * K_tensor[i][j] +
                                   1. / 3. * d1.h[i][j][k] * vars.K / vars.chi +
                                   1. / 3. * vars.h[i][j] * d1.K[k] / vars.chi;
        }
    }
    // covariant derivative of K
    FOR (i, j, k)
    {
        covariant_deriv_K_tensor[i][j][k] = d1_K_tensor[i][j][k];

        FOR (l)
        {
            covariant_deriv_K_tensor[i][j][k] +=
                -chris_phys[l][k][i] * K_tensor[l][j] -
                chris_phys[l][k][j] * K_tensor[i][l];
        }
    }

    // Use 'K-Theta' in CCZ4. Just 'K' in BSSN. Not a mistake, this is not to
    // confuse with the typical 'K-2*Theta' that appears in the CCZ4 equations
    amrex::Real K_minus_theta = vars.K;
    if (m_formulation == CCZ4RHS<>::USE_CCZ4)
    {
        K_minus_theta -= vars.Theta;
    }

    // Calculate electric and magnetic fields
    FOR (i, j)
    {
        out.E[i][j] = 0.0;
        out.B[i][j] = 0.0;
    }

    FOR (i, j)
    {
        out.E[i][j] +=
            ricci_and_Z_terms.LL[i][j] + K_minus_theta * K_tensor[i][j];

        FOR (k, l)
        {
            out.E[i][j] +=
                -K_tensor[i][k] * K_tensor[l][j] * h_UU[k][l] * vars.chi;

            out.B[i][j] +=
                epsilon3_LUU[i][k][l] * covariant_deriv_K_tensor[l][j][k];
        }
    }

    // For CCZ4, explicit symmetrization appears naturally;
    // For BSSN, only extra matter terms appear in the original expression, but
    // assuming the Momentum constraints are satisfied, we can make the
    // expression explicitly symmetric, which we enforce below
    // (see Alcubierre chapter 8.3, from eq. 8.3.15 onwards)
    TensorAlgebra::make_symmetric(out.B);

    // For CCZ4, Eij is explicitly trace-free;
    // For BSSN, only extra matter terms appear in the original expression, but
    // assuming the Hamiltonian constraint is satisfied, we can make the
    // expression explicitly trace free, which we enforce below
    // (see Alcubierre chapter 8.3, from eq. 8.3.15 onwards)
    TensorAlgebra::make_trace_free(out.E, vars.h, h_UU);

    return out;
}

// Calculation of the Weyl4 scalar
AMREX_GPU_DEVICE AMREX_FORCE_INLINE NPScalar_t Weyl4::compute_Weyl4(
    const EBFields_t &ebfields, const Vars<amrex::Real> &vars,
    const Vars<Tensor<1, amrex::Real>> &d1,
    const Diff2Vars<Tensor<2, amrex::Real>> &d2,
    const Tensor<2, amrex::Real> &h_UU, const Coordinates &coords) const
{
    NPScalar_t out;

    // Calculate the tetrads
    const Tetrad_t tetrad = compute_null_tetrad(vars, h_UU, coords);

    // Projection of Electric and magnetic field components using tetrads
    out.Real = 0.0;
    out.Im   = 0.0;
    FOR (i, j)
    {
        out.Real += 0.5 * (ebfields.E[i][j] * (tetrad.w[i] * tetrad.w[j] -
                                               tetrad.v[i] * tetrad.v[j]) -
                           2.0 * ebfields.B[i][j] * tetrad.w[i] * tetrad.v[j]);
        out.Im   += 0.5 * (ebfields.B[i][j] * (-tetrad.w[i] * tetrad.w[j] +
                                             tetrad.v[i] * tetrad.v[j]) -
                         2.0 * ebfields.E[i][j] * tetrad.w[i] * tetrad.v[j]);
    }

    return out;
}

// Calculation of the null tetrad
// Defintions from gr-qc/0104063
// "The Lazarus project: A pragmatic approach to binary black hole evolutions",
// Baker et al.
AMREX_GPU_DEVICE AMREX_FORCE_INLINE Tetrad_t Weyl4::compute_null_tetrad(
    const Vars<amrex::Real> &vars, const Tensor<2, amrex::Real> &h_UU,
    const Coordinates &coords) const
{
    Tetrad_t out;

    // compute coords
    const amrex::Real x = coords.x;
    const amrex::Real y = coords.y;
    const amrex::Real z = coords.z;

    // the alternating levi civita symbol
    const Tensor<3, double> epsilon = TensorAlgebra::epsilon();

    // calculate the tetrad
    out.u[0] = x;
    out.u[1] = y;
    out.u[2] = z;

    out.v[0] = -y;
    out.v[1] = x;
    out.v[2] = 0.0;

    out.w[0] = 0.0;
    out.w[1] = 0.0;
    out.w[2] = 0.0;

    FOR (i, j, k, m)
    {
        out.w[i] += 1. / sqrt(vars.chi) * h_UU[i][j] * epsilon[j][k][m] *
                    out.v[k] * out.u[m];
    }

    // Gram Schmitt orthonormalisation
    // Choice of orthonormalisaion to avoid frame-dragging
    amrex::Real omega_11 = 0.0;
    FOR (i, j)
    {
        omega_11 += out.v[i] * out.v[j] * vars.h[i][j] / vars.chi;
    }
    FOR (i)
    {
        out.v[i] = out.v[i] / sqrt(omega_11);
    }

    amrex::Real omega_12 = 0.0;
    FOR (i, j)
    {
        omega_12 += out.v[i] * out.u[j] * vars.h[i][j] / vars.chi;
    }
    FOR (i)
    {
        out.u[i] += -omega_12 * out.v[i];
    }

    amrex::Real omega_22 = 0.0;
    FOR (i, j)
    {
        omega_22 += out.u[i] * out.u[j] * vars.h[i][j] / vars.chi;
    }
    FOR (i)
    {
        out.u[i] = out.u[i] / sqrt(omega_22);
    }

    amrex::Real omega_13 = 0.0;
    amrex::Real omega_23 = 0.0;
    FOR (i, j)
    {
        omega_13 += out.v[i] * out.w[j] * vars.h[i][j] / vars.chi;
        omega_23 += out.u[i] * out.w[j] * vars.h[i][j] / vars.chi;
    }
    FOR (i)
    {
        out.w[i] += -(omega_13 * out.v[i] + omega_23 * out.u[i]);
    }

    amrex::Real omega_33 = 0.0;
    FOR (i, j)
    {
        omega_33 += out.w[i] * out.w[j] * vars.h[i][j] / vars.chi;
    }
    FOR (i)
    {
        out.w[i] = out.w[i] / sqrt(omega_33);
    }

    return out;
}

AMREX_FORCE_INLINE
void Weyl4::set_up(int a_state_index)
{
    int num_ghosts = 2; // no advection terms so only need 2 ghost cells

    auto &derive_lst     = amrex::AmrLevel::get_derive_lst();
    const auto &desc_lst = amrex::AmrLevel::get_desc_lst();

    // Add Weyl4 to the derive list
    derive_lst.add(
        name, amrex::IndexType::TheCellType(),
        static_cast<int>(var_names.size()), var_names, Weyl4::compute_mf,
        [=](const amrex::Box &box) { return amrex::grow(box, 2); },
        &amrex::cell_quartic_interp);

    // We need all of the CCZ4 variables to calculate Weyl4
    // (except B but easier to keep it in to avoid having to define yet another
    // CCZ4Vars struct)
    derive_lst.addComponent(name, desc_lst, a_state_index, 0, NUM_CCZ4_VARS);
}

AMREX_FORCE_INLINE
void Weyl4::compute_mf(amrex::MultiFab &out_mf, int dcomp, int ncomp,
                       const amrex::MultiFab &src_mf,
                       const amrex::Geometry &geomdata, amrex::Real /*time*/,
                       const int * /*bcrec*/, int /*level*/)
{
    const auto &out_arrays = out_mf.arrays();
    const auto &src_arrays = src_mf.const_arrays();

    GRParmParse pp;
    std::array<double, AMREX_SPACEDIM> center{};
    int formulation = 0;
    pp.get("extraction_center", center);
    pp.get("formulation", formulation);

    Weyl4 weyl4(center, geomdata.CellSize(0), dcomp, formulation);
    amrex::ParallelFor(
        out_mf, out_mf.nGrowVect(),
        [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k) noexcept
        { weyl4.compute(i, j, k, out_arrays[box_no], src_arrays[box_no]); });
}

#endif /* WEYL4_HPP_ */



================================================
FILE: Source/Grids/BCParity.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef BCPARITY_HPP_
#define BCPARITY_HPP_

#include <AMReX_IntVect.H>
#include <map>

//! A scoped enumerator for the parity of a variable wrt reflective boundaries
enum class BCParity
{
    undefined,
    even,
    odd_x,
    odd_y,
    odd_z,
    odd_xy,
    odd_yz,
    odd_xz,
    odd_xyz
};

static inline const std::map<BCParity, amrex::IntVect> bc_parity_map = {
    {BCParity::even, amrex::IntVect(1)},
    {BCParity::odd_x, amrex::IntVect(-1, 1, 1)},
    {BCParity::odd_y, amrex::IntVect(1, -1, 1)},
    {BCParity::odd_z, amrex::IntVect(1, 1, -1)},
    {BCParity::odd_xy, amrex::IntVect(-1, -1, 1)},
    {BCParity::odd_yz, amrex::IntVect(1, -1, -1)},
    {BCParity::odd_xz, amrex::IntVect(-1, 1, -1)},
    {BCParity::odd_xyz, amrex::IntVect(-1, -1, -1)},
};

#endif


================================================
FILE: Source/Grids/BoundaryConditions.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// Other includes
#include "BoundaryConditions.hpp"
#include "StateVariablesParmParse.hpp"

#include <algorithm>
#include <array>
#include <cmath>
#include <map>
#include <numeric>
#include <string>

BoundaryConditions::params_t::params_t()
{
    // set defaults
    hi_boundary.fill(STATIC_BC);
    lo_boundary.fill(STATIC_BC);
    is_periodic.fill(true);

    vars_asymptotic_values.fill(0.0);
}

void BoundaryConditions::params_t::set_is_periodic(
    const std::array<int, AMREX_SPACEDIM> &a_is_periodic_int)
{
    FOR (idir)
    {
        is_periodic[idir] = static_cast<bool>(a_is_periodic_int[idir]);
        if (!is_periodic[idir])
        {
            nonperiodic_boundaries_exist = true;
        }
    }
}
void BoundaryConditions::params_t::set_hi_boundary(
    const std::array<int, AMREX_SPACEDIM> &a_hi_boundary)
{
    FOR (idir)
    {
        if (!is_periodic[idir])
        {
            hi_boundary[idir] = a_hi_boundary[idir];
            if (hi_boundary[idir] == REFLECTIVE_BC)
            {
                boundary_rhs_enforced       = true;
                boundary_solution_enforced  = true;
                reflective_boundaries_exist = true;
            }
            else if (hi_boundary[idir] == SOMMERFELD_BC)
            {
                boundary_rhs_enforced       = true;
                sommerfeld_boundaries_exist = true;
            }
            else if (hi_boundary[idir] == EXTRAPOLATING_BC)
            {
                boundary_rhs_enforced          = true;
                boundary_solution_enforced     = true;
                extrapolating_boundaries_exist = true;
            }
            else if (hi_boundary[idir] == MIXED_BC)
            {
                boundary_rhs_enforced          = true;
                boundary_solution_enforced     = true;
                sommerfeld_boundaries_exist    = true;
                extrapolating_boundaries_exist = true;
                mixed_boundaries_exist         = true;
            }
        }
    }
}
void BoundaryConditions::params_t::set_lo_boundary(
    const std::array<int, AMREX_SPACEDIM> &a_lo_boundary)
{
    FOR (idir)
    {
        if (!is_periodic[idir])
        {
            lo_boundary[idir] = a_lo_boundary[idir];
            if (lo_boundary[idir] == REFLECTIVE_BC)
            {
                boundary_solution_enforced  = true;
                reflective_boundaries_exist = true;
            }
            else if (lo_boundary[idir] == SOMMERFELD_BC)
            {
                boundary_rhs_enforced       = true;
                sommerfeld_boundaries_exist = true;
            }
            else if (lo_boundary[idir] == EXTRAPOLATING_BC)
            {
                boundary_rhs_enforced          = true;
                boundary_solution_enforced     = true;
                extrapolating_boundaries_exist = true;
            }
            else if (lo_boundary[idir] == MIXED_BC)
            {
                boundary_rhs_enforced          = true;
                boundary_solution_enforced     = true;
                sommerfeld_boundaries_exist    = true;
                extrapolating_boundaries_exist = true;
                mixed_boundaries_exist         = true;
            }
        }
    }
}

void BoundaryConditions::params_t::read_params(GRParmParse &pp)
{
    // still load even if not contained, to ensure printout saying parameters
    // were set to their default values
    std::array<int, AMREX_SPACEDIM> is_periodic_int{AMREX_D_DECL(1, 1, 1)};
    pp.load("isPeriodic", is_periodic_int, is_periodic_int);
    if (pp.contains("isPeriodic"))
    {
        set_is_periodic(is_periodic_int);
    }

    std::array<int, AMREX_SPACEDIM> hiBoundary{};
    pp.load("hi_boundary", hiBoundary, hi_boundary);
    if (pp.contains("hi_boundary"))
    {
        set_hi_boundary(hiBoundary);
    }

    std::array<int, AMREX_SPACEDIM> loBoundary{};
    pp.load("lo_boundary", loBoundary, lo_boundary);
    if (pp.contains("lo_boundary"))
    {
        set_lo_boundary(loBoundary);
    }

    if (sommerfeld_boundaries_exist)
    {
        size_t num_values = 0;
        std::vector<int> nonzero_asymptotic_vars;
        StateVariablesParmParse::load_vars_to_vector(
            pp, "nonzero_asymptotic_vars", nonzero_asymptotic_vars);
        const double default_value = 0.0;
        StateVariablesParmParse::load_values_to_array(
            pp, "nonzero_asymptotic_values", nonzero_asymptotic_vars,
            vars_asymptotic_values, default_value);
    }
    if (extrapolating_boundaries_exist)
    {
        pp.load("extrapolation_order", extrapolation_order, 1);
    }
    if (mixed_boundaries_exist)
    {
        std::vector<int> extrapolating_vars;
        StateVariablesParmParse::load_vars_to_vector(pp, "extrapolating_vars",
                                                     extrapolating_vars);
        for (int icomp = 0; icomp < NUM_VARS; icomp++)
        {
            bool is_extrapolating = false;
            // if the variable is not in extrapolating vars, it
            // is assumed to be sommerfeld by default
            for (auto &extrapolating_var : extrapolating_vars)
            {
                if (icomp == extrapolating_var)
                {
                    mixed_bc_vars_map.insert(
                        std::make_pair(icomp, EXTRAPOLATING_BC));
                    is_extrapolating = true;
                }
            }
            if (!is_extrapolating)
            {
                mixed_bc_vars_map.insert(std::make_pair(icomp, SOMMERFELD_BC));
            }
        }
    }
    if (nonperiodic_boundaries_exist)
    {
        // write out boundary conditions where non periodic - useful for
        // debug
        write_boundary_conditions(*this);
    }
}

/// define function sets members and is_defined set to true
void BoundaryConditions::define(std::array<double, AMREX_SPACEDIM> a_center,
                                const params_t &a_params,
                                const amrex::Geometry &a_geom, int a_num_ghosts)
{
    m_num_ghosts = a_num_ghosts;
    m_params     = a_params;
    FOR (i)
    {
        m_center[i] = a_center[i];
    }
    m_geom     = a_geom;
    is_defined = true;
}

/// change the asymptotic values of the variables for the Sommerfeld BCs
/// this will allow them to evolve during a simulation if necessary
void BoundaryConditions::set_vars_asymptotic_values(
    std::array<double, NUM_VARS> &vars_asymptotic_values)
{
    m_params.vars_asymptotic_values = vars_asymptotic_values;
}

void BoundaryConditions::write_reflective_conditions(int idir)
{
    amrex::Print()
        << "The variables that are parity odd in this direction are : " << '\n';
    for (int icomp = 0; icomp < NUM_VARS; icomp++)
    {
        int parity = get_state_var_parity(icomp, idir);
        if (parity == -1)
        {
            amrex::Print() << StateVariables::names[icomp] << "    ";
        }
    }
}

void BoundaryConditions::write_sommerfeld_conditions(int /*idir*/,
                                                     const params_t &a_params)
{
    amrex::Print() << "The non zero asymptotic values of the variables "
                      "in this direction are : "
                   << '\n';
    for (int icomp = 0; icomp < NUM_VARS; icomp++)
    {
        if (a_params.vars_asymptotic_values[icomp] != 0)
        {
            amrex::Print() << StateVariables::names[icomp] << " = "
                           << a_params.vars_asymptotic_values[icomp] << "    ";
        }
    }
    // not done for diagnostics
}

void BoundaryConditions::write_mixed_conditions(int idir,
                                                const params_t &a_params)
{
    // check all the vars have been assigned a BC - this should always be the
    // case because of how the params are assigned
    AMREX_ASSERT(a_params.mixed_bc_vars_map.size() == NUM_VARS);

    // now do the write out
    amrex::Print()
        << "The variables that use extrapolating bcs in this direction are : "
        << '\n';
    for (int icomp = 0; icomp < NUM_VARS; icomp++)
    {
        if (a_params.mixed_bc_vars_map.at(icomp) == EXTRAPOLATING_BC)
        {
            amrex::Print() << StateVariables::names[icomp] << "    ";
        }
    }
    amrex::Print() << '\n';
    amrex::Print()
        << "The other variables all use Sommerfeld boundary conditions."
        << '\n';
    write_sommerfeld_conditions(idir, a_params);
}

/// write out boundary params (used during setup for debugging)
void BoundaryConditions::write_boundary_conditions(const params_t &a_params)
{
    amrex::Print() << "You are using non periodic boundary conditions." << '\n';
    amrex::Print() << "The boundary params chosen are:  " << '\n';
    amrex::Print() << "---------------------------------" << '\n';

    std::map<int, std::string> bc_names = {
        {STATIC_BC,        "Static"       },
        {SOMMERFELD_BC,    "Sommerfeld"   },
        {REFLECTIVE_BC,    "Reflective"   },
        {EXTRAPOLATING_BC, "Extrapolating"},
        {MIXED_BC,         "Mixed"        }
    };
    FOR (idir)
    {
        if (!a_params.is_periodic[idir])
        {
            amrex::Print() << "- " << bc_names[a_params.hi_boundary[idir]]
                           << " boundaries in direction high " << idir << '\n';
            // high directions
            if (a_params.hi_boundary[idir] == REFLECTIVE_BC)
            {
                write_reflective_conditions(idir);
            }
            else if (a_params.hi_boundary[idir] == SOMMERFELD_BC)
            {
                write_sommerfeld_conditions(idir, a_params);
            }
            else if (a_params.hi_boundary[idir] == MIXED_BC)
            {
                write_mixed_conditions(idir, a_params);
            }
            amrex::Print() << "\n" << '\n';

            // low directions
            amrex::Print() << "- " << bc_names[a_params.lo_boundary[idir]]
                           << " boundaries in direction low " << idir << '\n';
            if (a_params.lo_boundary[idir] == REFLECTIVE_BC)
            {
                write_reflective_conditions(idir);
            }
            else if (a_params.lo_boundary[idir] == SOMMERFELD_BC)
            {
                write_sommerfeld_conditions(idir, a_params);
            }
            else if (a_params.lo_boundary[idir] == MIXED_BC)
            {
                write_mixed_conditions(idir, a_params);
            }
            amrex::Print() << "\n" << '\n';
        }
    }
    amrex::Print() << "---------------------------------" << '\n';
}

/// The function which returns the parity of each of the vars in
/// StateVariables.hpp (It is only required for reflective boundary conditions.)
// NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
int BoundaryConditions::get_state_var_parity(int a_comp, int a_dir)
{
    BCParity comp_parity = StateVariables::parities[a_comp];

    AMREX_ALWAYS_ASSERT_WITH_MESSAGE(
        comp_parity != BCParity::undefined,
        "BoundaryConditions: cannot have undefined variable parities if using "
        "reflective BCs");

    auto dir_parities = bc_parity_map.at(comp_parity);

    return dir_parities[a_dir];
}

/// Get the boundary condition for given face
int BoundaryConditions::get_boundary_condition(amrex::Orientation face) const
{
    return face.isLow() ? m_params.lo_boundary[face.coordDir()]
                        : m_params.hi_boundary[face.coordDir()];
}

void BoundaryConditions::apply_sommerfeld_boundaries(
    amrex::MultiFab &a_rhs, const amrex::MultiFab &a_soln) const
{
    if (!m_params.sommerfeld_boundaries_exist)
    {
        return;
    }

    amrex::Vector<amrex::Box> sommboxes;
    {
        amrex::Box domain = m_geom.Domain();
        for (int idim = AMREX_SPACEDIM - 1; idim >= 0; --idim)
        {
            if (!m_params.is_periodic[idim])
            {
                int bclo = get_boundary_condition(
                    amrex::Orientation(idim, amrex::Orientation::low));
                AMREX_ALWAYS_ASSERT_WITH_MESSAGE(bclo != MIXED_BC,
                                                 "xxxx mixed bc todo");
                if (bclo == SOMMERFELD_BC)
                {
                    const int len  = domain.length(idim);
                    amrex::Box box = domain;
                    box.growHi(idim, -(len - m_num_ghosts));
                    domain.growLo(idim, -m_num_ghosts);
                    sommboxes.push_back(box);
                }
                int bchi = get_boundary_condition(
                    amrex::Orientation(idim, amrex::Orientation::high));
                AMREX_ALWAYS_ASSERT_WITH_MESSAGE(bchi != MIXED_BC,
                                                 "xxxx mixed bc todo");
                if (bchi == SOMMERFELD_BC)
                {
                    const int len  = domain.length(idim);
                    amrex::Box box = domain;
                    box.growLo(idim, -(len - m_num_ghosts));
                    domain.growHi(idim, -m_num_ghosts);
                    sommboxes.push_back(box);
                }
            }
        }
    }

    AMREX_ASSERT(amrex::almostEqual(m_geom.CellSize(0), m_geom.CellSize(1)) &&
                 amrex::almostEqual(m_geom.CellSize(0), m_geom.CellSize(2)));
    const auto dx     = m_geom.CellSize(0);
    amrex::Box domain = m_geom.Domain();
    for (amrex::OrientationIter orit; orit.isValid(); ++orit)
    {
        amrex::Orientation face = orit();
        int bc_on_face          = get_boundary_condition(face);
        if (m_geom.isPeriodic(face.coordDir()) || bc_on_face == REFLECTIVE_BC)
        {                      // xxxxx todo: what about other BCs?
            domain.grow(face); // to use the central derivative stencil
        }
    }
    const auto domlo  = domain.smallEnd();
    const auto domhi  = domain.bigEnd();
    const auto center = m_center;

    if (m_asymptotic_values.empty())
    {
        m_asymptotic_values.resize(NUM_VARS);
        amrex::Gpu::copy(
            amrex::Gpu::hostToDevice, m_params.vars_asymptotic_values.begin(),
            m_params.vars_asymptotic_values.end(), m_asymptotic_values.begin());
    }
    auto *asymptotic_values = m_asymptotic_values.data();

#if defined(AMREX_USE_OMP) && !defined(AMREX_USE_GPU)
#pragma omp parallel
#endif
    for (amrex::MFIter mfi(a_rhs); mfi.isValid(); ++mfi)
    {
        const amrex::Box &valid_box                 = mfi.validbox();
        const amrex::Array4<amrex::Real const> &sol = a_soln.const_array(mfi);
        const amrex::Array4<amrex::Real> &rhs       = a_rhs.array(mfi);
        for (const auto &sommbox : sommboxes)
        {
            amrex::Box valid_sommbox = sommbox & valid_box;
            if (valid_sommbox.ok())
            {
                amrex::ParallelFor(
                    valid_sommbox, a_rhs.nComp(),
                    [=] AMREX_GPU_DEVICE(int i, int j, int k, int n) noexcept
                    {
                        amrex::RealVect loc((i + 0.5) * dx - center[0],
                                            (j + 0.5) * dx - center[1],
                                            (k + 0.5) * dx - center[2]);
                        amrex::Real tmp = 0.;
                        amrex::IntVect iv(i, j, k);
                        for (int idir2 = 0; idir2 < AMREX_SPACEDIM; ++idir2)
                        {
                            amrex::IntVect iv_offset1 = iv;
                            amrex::IntVect iv_offset2 = iv;
                            amrex::Real d1            = NAN;
                            if (iv[idir2] == domlo[idir2])
                            {
                                iv_offset1[idir2] += +1;
                                iv_offset2[idir2] += +2;
                                d1 = (1.0 / dx) * (-1.5 * sol(iv, n) +
                                                   2.0 * sol(iv_offset1, n) -
                                                   0.5 * sol(iv_offset2, n));
                            }
                            else if (iv[idir2] == domhi[idir2])
                            {
                                iv_offset1[idir2] += -1;
                                iv_offset2[idir2] += -2;
                                d1 = (1.0 / dx) * (+1.5 * sol(iv, n) -
                                                   2.0 * sol(iv_offset1, n) +
                                                   0.5 * sol(iv_offset2, n));
                            }
                            else
                            {
                                iv_offset1[idir2] += +1;
                                iv_offset2[idir2] += -1;
                                d1                 = (0.5 / dx) *
                                     (sol(iv_offset1, n) - sol(iv_offset2, n));
                            }
                            // for each direction add dphidx * x^i
                            tmp += -d1 * loc[idir2];
                        }
                        // asymptotic values - these need to have been set in
                        // the params file
                        double radius =
                            std::sqrt(loc[0] * loc[0] + loc[1] * loc[1] +
                                      loc[2] * loc[2]);
                        rhs(i, j, k, n) =
                            (asymptotic_values[n] - sol(i, j, k, n) + tmp) *
                            (1. / radius);
                    });
            }
        }
    }
}

#if 0
//xxxxx
/// Fill the rhs boundary values appropriately based on the params set
void BoundaryConditions::fill_rhs_boundaries(const Side::LoHiSide a_side,
                                             const GRLevelData &a_soln,
                                             GRLevelData &a_rhs)
{
    AMREX_ASSERT(is_defined);
    BL_PROFILE("BoundaryConditions::fill_rhs_boundaries");

    // cycle through the directions, filling the rhs
    FOR(idir)
    {
        // only do something if this direction is not periodic
        if (!m_params.is_periodic[idir])
        {
            int boundary_condition = get_boundary_condition(a_side, idir);
            constexpr bool filling_rhs = true;
            fill_boundary_cells_dir(a_side, a_soln, a_rhs, idir,
                                    boundary_condition,
                                    Interval(0, NUM_VARS - 1),
                                    VariableType::state, filling_rhs);
        }
    }
}
#endif

#if 0
// xxxxx
/// fill solution boundary conditions, e.g. after interpolation
void BoundaryConditions::fill_solution_boundaries(const Side::LoHiSide a_side,
                                                  GRLevelData &a_state,
                                                  const Interval &a_comps)
{
    AMREX_ASSERT(is_defined);
    BL_PROFILE("BoundaryConditions::fill_solution_boundaries");

    // cycle through the directions
    FOR(idir)
    {
        // only do something if this direction is not periodic and solution
        // boundary enforced in this direction
        if (!m_params.is_periodic[idir])
        {
            int boundary_condition = get_boundary_condition(a_side, idir);

            // same copying of cells which we require for the rhs solution
            // but tell it we are not filling the rhs for mixed condition
            if ((boundary_condition == REFLECTIVE_BC) ||
                (boundary_condition == EXTRAPOLATING_BC) ||
                (boundary_condition == MIXED_BC))
            {
                const bool filling_rhs = false;
                fill_boundary_cells_dir(a_side, a_state, a_state, idir,
                                        boundary_condition, a_comps,
                                        VariableType::state, filling_rhs);
            }
        }
    }
}
#endif

#if 0
//xxxxx
/// fill diagnostic boundaries
void BoundaryConditions::fill_diagnostic_boundaries(const Side::LoHiSide a_side,
                                                    GRLevelData &a_state,
                                                    const Interval &a_comps)
{
    AMREX_ASSERT(is_defined);
    BL_PROFILE("BoundaryConditions::fill_diagnostic_boundaries");

    // cycle through the directions
    FOR(idir)
    {
        // only do something if this direction is not periodic
        if (!m_params.is_periodic[idir])
        {
            int boundary_condition = get_boundary_condition(a_side, idir);
            // for any non reflective BC, we just want to fill the ghosts with
            // something non nan so set the boundary condition to be
            // EXTRAPOLATING
            if (boundary_condition != REFLECTIVE_BC)
            {
                boundary_condition = EXTRAPOLATING_BC;
            }
            const bool filling_rhs = false;
            fill_boundary_cells_dir(a_side, a_state, a_state, idir,
                                    boundary_condition, a_comps,
                                    VariableType::derived, filling_rhs);
        }
    }
}
#endif

#if 0
//xxxxxx
/// Fill the boundary values appropriately based on the params set
/// in the direction dir
void BoundaryConditions::fill_boundary_cells_dir(
    const Side::LoHiSide a_side, const GRLevelData &a_soln, GRLevelData &a_out,
    const int dir, const int boundary_condition, const Interval &a_comps,
    const VariableType var_type, const bool filling_rhs)
{
    std::vector<int> comps_vector, sommerfeld_comps_vector,
        extrapolating_comps_vector;
    if (boundary_condition != MIXED_BC)
    {
        comps_vector.resize(a_comps.size());
        std::iota(comps_vector.begin(), comps_vector.end(), a_comps.begin());
    }
    else
    {
        for (int icomp = a_comps.begin(); icomp <= a_comps.end(); ++icomp)
        {
            if (m_params.mixed_bc_vars_map[icomp] == SOMMERFELD_BC)
                sommerfeld_comps_vector.push_back(icomp);
            else if (m_params.mixed_bc_vars_map[icomp] == EXTRAPOLATING_BC)
                extrapolating_comps_vector.push_back(icomp);
        }
    }

    // iterate through the boxes, shared amongst threads
    DataIterator dit = a_out.dataIterator();
    int nbox = dit.size();
#pragma omp parallel for default(shared)
    for (int ibox = 0; ibox < nbox; ++ibox)
    {
        DataIndex dind = dit[ibox];
        amrex::FArrayBox &out_box = a_out[dind];
        const amrex::FArrayBox &soln_box = a_soln[dind];
        amrex::Box this_box = out_box.box();
        amrex::IntVect offset_lo = -this_box.smallEnd() + m_domain_box.smallEnd();
        amrex::IntVect offset_hi = +this_box.bigEnd() - m_domain_box.bigEnd();

        // reduce box to the intersection of the box and the
        // problem domain ie remove all outer ghost cells
        this_box &= m_domain_box;
        // get the boundary box (may be Empty)
        amrex::Box boundary_box =
            get_boundary_box(a_side, dir, offset_lo, offset_hi, this_box);

        // now we have the appropriate box, fill it!
        BoxIterator bit(boundary_box);
        for (bit.begin(); bit.ok(); ++bit)
        {
            amrex::IntVect iv = bit();
            switch (boundary_condition)
            {
            // simplest case - boundary values are set to zero
            case STATIC_BC:
            {
                for (int icomp = a_comps.begin(); icomp <= a_comps.end();
                     ++icomp)
                {
                    out_box(iv, icomp) = 0.0;
                }
                break;
            }
            // Sommerfeld is outgoing radiation - only applies to rhs
            case SOMMERFELD_BC:
            {
                fill_sommerfeld_cell(out_box, soln_box, iv, comps_vector);
                break;
            }
            // Enforce a reflective symmetry in some direction
            case REFLECTIVE_BC:
            {
                fill_reflective_cell(out_box, iv, a_side, dir, comps_vector,
                                     var_type);
                break;
            }
            case EXTRAPOLATING_BC:
            {
                fill_extrapolating_cell(out_box, iv, a_side, dir, comps_vector,
                                        m_params.extrapolation_order);
                break;
            }
            case MIXED_BC:
            {
                fill_extrapolating_cell(out_box, iv, a_side, dir,
                                        extrapolating_comps_vector,
                                        m_params.extrapolation_order);
                if (filling_rhs)
                {
                    fill_sommerfeld_cell(out_box, soln_box, iv,
                                         sommerfeld_comps_vector);
                }
                break;
            }
            default:
                amrex::Abort(
                    "BoundaryCondition::Supplied boundary not supported.");
            } // end switch
        }     // end iterate over box
    }         // end iterate over boxes
}
#endif

void BoundaryConditions::fill_sommerfeld_cell(
    amrex::FArrayBox &rhs_box, const amrex::FArrayBox &soln_box,
    const amrex::IntVect a_iv, const std::vector<int> &sommerfeld_comps)
{
    amrex::Abort("xxxxx todo BoundaryConditions::fill_sommerfeld_cell");
    amrex::ignore_unused(rhs_box, soln_box, a_iv, sommerfeld_comps);
#if 0
//xxxxx
    // assumes an asymptotic value + radial waves and permits them
    // to exit grid with minimal reflections
    // get real position on the grid
    amrex::RealVect loc(a_iv + 0.5 * RealVect::Unit);
    loc *= m_dx;
    loc -= m_center;
    double radius_squared = 0.0;
    FOR(i) { radius_squared += loc[i] * loc[i]; }
    double radius = sqrt(radius_squared);
    amrex::IntVect lo_local_offset = a_iv - soln_box.smallEnd();
    amrex::IntVect hi_local_offset = soln_box.bigEnd() - a_iv;

    // Apply Sommerfeld BCs to each variable in sommerfeld_comps
    for (int icomp : sommerfeld_comps)
    {
        rhs_box(a_iv, icomp) = 0.0;
        FOR(idir2)
        {
            amrex::IntVect iv_offset1 = a_iv;
            amrex::IntVect iv_offset2 = a_iv;
            double d1;
            // bit of work to get the right stencils for near
            // the edges of the domain, only using second order
            // stencils for now
            if (lo_local_offset[idir2] < 1)
            {
                // near lo end
                iv_offset1[idir2] += +1;
                iv_offset2[idir2] += +2;
                d1 = 1.0 / m_dx *
                     (-1.5 * soln_box(a_iv, icomp) +
                      2.0 * soln_box(iv_offset1, icomp) -
                      0.5 * soln_box(iv_offset2, icomp));
            }
            else if (hi_local_offset[idir2] < 1)
            {
                // near hi end
                iv_offset1[idir2] += -1;
                iv_offset2[idir2] += -2;
                d1 = 1.0 / m_dx *
                     (+1.5 * soln_box(a_iv, icomp) -
                      2.0 * soln_box(iv_offset1, icomp) +
                      0.5 * soln_box(iv_offset2, icomp));
            }
            else
            {
                // normal case
                iv_offset1[idir2] += +1;
                iv_offset2[idir2] += -1;
                d1 =
                    0.5 / m_dx *
                    (soln_box(iv_offset1, icomp) - soln_box(iv_offset2, icomp));
            }

            // for each direction add dphidx * x^i / r
            rhs_box(a_iv, icomp) += -d1 * loc[idir2] / radius;
        }

        // asymptotic values - these need to have been set in
        // the params file
        rhs_box(a_iv, icomp) +=
            (m_params.vars_asymptotic_values[icomp] - soln_box(a_iv, icomp)) /
            radius;
    }
#endif
}

#if 0
//xxxxx
void BoundaryConditions::fill_extrapolating_cell(
    amrex::FArrayBox &out_box, const amrex::IntVect iv, const Side::LoHiSide a_side,
    const int dir, const std::vector<int> &extrapolating_comps,
    const int order) const
{
    for (int icomp : extrapolating_comps)
    {
        // current radius
        double radius = Coordinates<double>::get_radius(
            iv, m_dx, {m_center[0], m_center[1], m_center[2]});

        // vector of 2 nearest values and radii within the grid
        std::array<double, 2> value_at_point;
        std::array<double, 2> r_at_point;
        // how many units are we from domain boundary?
        int units_from_edge = 0;
        if (a_side == Side::Hi)
        {
            // how many units are we from domain boundary?
            units_from_edge = iv[dir] - m_domain_box.bigEnd(dir);
            // vector of 2 nearest values and radii within the grid
            for (int i = 0; i < 2; i++)
            {
                amrex::IntVect iv_tmp = iv;
                iv_tmp[dir] += -units_from_edge - i;
                FOR(idir)
                {
                    if (iv_tmp[idir] > m_domain_box.bigEnd(idir))
                    {
                        iv_tmp[idir] = m_domain_box.bigEnd(idir);
                    }
                    else if (iv_tmp[idir] < m_domain_box.smallEnd(idir))
                    {
                        iv_tmp[idir] = m_domain_box.smallEnd(idir);
                    }
                }
                value_at_point[i] = out_box(iv_tmp, icomp);
                r_at_point[i] = Coordinates<double>::get_radius(
                    iv_tmp, m_dx, {m_center[0], m_center[1], m_center[2]});
            }
        }
        else // Lo side
        {
            // how many units are we from domain boundary?
            units_from_edge = -iv[dir] + m_domain_box.smallEnd(dir);
            // vector of 2 nearest values within the grid
            for (int i = 0; i < 2; i++)
            {
                amrex::IntVect iv_tmp = iv;
                iv_tmp[dir] += units_from_edge + i;
                FOR(idir)
                {
                    if (iv_tmp[idir] > m_domain_box.bigEnd(idir))
                    {
                        iv_tmp[idir] = m_domain_box.bigEnd(idir);
                    }
                    else if (iv_tmp[idir] < m_domain_box.smallEnd(idir))
                    {
                        iv_tmp[idir] = m_domain_box.smallEnd(idir);
                    }
                }
                value_at_point[i] = out_box(iv_tmp, icomp);
                r_at_point[i] = Coordinates<double>::get_radius(
                    iv_tmp, m_dx, {m_center[0], m_center[1], m_center[2]});
            }
        }

        // assume some radial dependence and fit it
        double analytic_change = 0.0;
        // comp = const
        if (order == 0)
        {
            analytic_change = 0.0;
        }
        // comp = B + A*r
        else if (order == 1)
        {
            double delta_r_in_domain = r_at_point[1] - r_at_point[0];
            double A =
                (value_at_point[1] - value_at_point[0]) / delta_r_in_domain;
            double delta_r_here = radius - r_at_point[0];
            analytic_change = A * delta_r_here;
        }
        // other orders not supported yet
        else
        {
            amrex::Abort("Order not supported for boundary extrapolation.");
        }

        // set the value here to the extrapolated value
        out_box(iv, icomp) = value_at_point[0] + analytic_change;
    }
}
#endif

#if 0
//xxxxx
/// Copy the boundary values from src to dest
/// NB only acts if same box layout of input and output data
void BoundaryConditions::copy_boundary_cells(const Side::LoHiSide a_side,
                                             const GRLevelData &a_src,
                                             GRLevelData &a_dest)
{
    BL_PROFILE("BoundaryConditions::copy_boundary_cells");

    AMREX_ASSERT(is_defined);
    AMREX_ASSERT(a_src.nComp() == NUM_VARS);
    if (a_src.boxLayout() == a_dest.boxLayout())
    {
        // cycle through the directions
        FOR(idir)
        {
            // only do something if this direction is not periodic
            if (!m_params.is_periodic[idir])
            {
                // iterate through the boxes, shared amongst threads
                DataIterator dit = a_dest.dataIterator();
                int nbox = dit.size();
#pragma omp parallel for default(shared)
                for (int ibox = 0; ibox < nbox; ++ibox)
                {
                    DataIndex dind = dit[ibox];
                    amrex::FArrayBox &m_dest_box = a_dest[dind];
                    amrex::Box this_box = m_dest_box.box();
                    amrex::IntVect offset_lo =
                        -this_box.smallEnd() + m_domain_box.smallEnd();
                    amrex::IntVect offset_hi =
                        +this_box.bigEnd() - m_domain_box.bigEnd();

                    // reduce box to the intersection of the box and the
                    // problem domain ie remove all outer ghost cells
                    this_box &= m_domain_box;

                    // get the boundary box (may be Empty)
                    amrex::Box boundary_box = get_boundary_box(a_side, idir, offset_lo,
                                                        offset_hi, this_box);

                    BoxIterator bit(boundary_box);
                    for (bit.begin(); bit.ok(); ++bit)
                    {
                        amrex::IntVect iv = bit();
                        for (int icomp = 0; icomp < NUM_VARS; ++icomp)
                        {
                            m_dest_box(iv, icomp) = a_src[dind](iv, icomp);
                        }
                    } // end iterate over box
                }     // end iterate over boxes
            }         // end if(not periodic)
        }             // end iterate over spacedims
    }                 // end test for same box layout
}
#endif

#if 0
//xxxxx
/// Fill the fine boundary values in a_state
/// Required for interpolating onto finer levels at boundaries
void BoundaryConditions::interp_boundaries(GRLevelData &a_fine_state,
                                           GRLevelData &a_coarse_state,
                                           const Side::LoHiSide a_side)
{
    AMREX_ASSERT(is_defined);
    AMREX_ASSERT(a_fine_state.nComp() == NUM_VARS);
    AMREX_ASSERT(a_coarse_state.nComp() == NUM_VARS);
    BL_PROFILE("BoundaryConditions::interp_boundaries");

    // cycle through the directions
    FOR(idir)
    {
        // only do something if this direction is not periodic
        if (!m_params.is_periodic[idir])
        {
            // Ref ratio is always two
            int ref_ratio = 2;

            // create a coarsened fine layout and copy the coarse data onto
            // it
            DisjointBoxLayout coarsened_layout;
            coarsen(coarsened_layout, a_fine_state.disjointBoxLayout(),
                    ref_ratio * IntVect::Unit);
            GRLevelData coarsened_fine;
            coarsened_fine.define(coarsened_layout, NUM_VARS,
                                  m_num_ghosts * IntVect::Unit);
            amrex::Box coarse_domain_box = coarsen(m_domain_box, ref_ratio);

            // trick the copyTo into thinking the boundary cells are within
            // the domain by growing the domain
            amrex::Box grown_domain_box = coarse_domain_box;
            grown_domain_box.grow(m_num_ghosts * IntVect::Unit);
            Copier boundary_copier;
            boundary_copier.ghostDefine(
                a_coarse_state.disjointBoxLayout(),
                coarsened_fine.disjointBoxLayout(), grown_domain_box,
                m_num_ghosts * IntVect::Unit, m_num_ghosts * IntVect::Unit);
            a_coarse_state.copyTo(a_coarse_state.interval(), coarsened_fine,
                                  coarsened_fine.interval(), boundary_copier);

            // iterate through the coarse boxes, shared amongst threads
            DataIterator dit = coarsened_layout.dataIterator();
            int nbox = dit.size();
#pragma omp parallel for default(shared)
            for (int ibox = 0; ibox < nbox; ++ibox)
            {
                DataIndex dind = dit[ibox];
                amrex::FArrayBox &m_fine_box = a_fine_state[dind];
                amrex::FArrayBox &m_coarse_box = coarsened_fine[dind];
                amrex::Box this_box = m_coarse_box.box();
                amrex::Box fine_box = m_fine_box.box();
                amrex::IntVect offset_lo =
                    -this_box.smallEnd() + coarse_domain_box.smallEnd();
                amrex::IntVect offset_hi =
                    +this_box.bigEnd() - coarse_domain_box.bigEnd();

                // reduce box to the intersection of the box and the
                // problem domain ie remove all outer ghost cells
                this_box &= coarse_domain_box;

                // get the boundary box - remove one cell as we only want 2
                // coarse cells filled in each direction, to fill the 3 fine
                // cells on the level above
                amrex::Box boundary_box = get_boundary_box(a_side, idir, offset_lo,
                                                    offset_hi, this_box, 1);

                // define standard stencil for interp where not near
                // boundaries in other dirs
                amrex::IntVect default_offset =
                    IntVect::Zero + sign(a_side) * 2 * BASISV(idir);
                FourthOrderInterpStencil default_stencil(default_offset,
                                                         ref_ratio);

                // now interp the box from coarse to fine
                BoxIterator bit(boundary_box);
                for (bit.begin(); bit.ok(); ++bit)
                {
                    amrex::IntVect iv = bit();
                    amrex::IntVect lo_local_offset = iv - m_coarse_box.smallEnd();
                    amrex::IntVect hi_local_offset = m_coarse_box.bigEnd() - iv;

                    // bit of work to get the right stencils for near the
                    // edges of the box
                    bool near_boundary = false;
                    amrex::IntVect local_boundary_offset = IntVect::Zero;
                    FOR(idir2)
                    {
                        if (idir2 == idir)
                        {
                            local_boundary_offset[idir2] =
                                default_offset[idir2];
                        }
                        else if ((idir2 != idir) &&
                                 (lo_local_offset[idir2] > 1) &&
                                 (hi_local_offset[idir2] > 1))
                        {
                            local_boundary_offset[idir2] = 0;
                        }
                        else if ((idir2 != idir) &&
                                 (lo_local_offset[idir2] == 1))
                        {
                            local_boundary_offset[idir2] = -2;
                            near_boundary = true;
                        }
                        else if ((idir2 != idir) &&
                                 (hi_local_offset[idir2] == 1))
                        {
                            local_boundary_offset[idir2] = +2;
                            near_boundary = true;
                        }
                        else
                        {
                            amrex::Abort(
                                "BoundaryConditions::define bad boxes");
                        }
                    }

                    // if not near the boundary use the default stencil,
                    // otherwise use the one calculated locally
                    if (!near_boundary)
                    {
                        default_stencil.fillFine(m_fine_box, m_coarse_box, iv);
                    }
                    else
                    {
                        FourthOrderInterpStencil local_stencil(
                            local_boundary_offset, ref_ratio);
                        local_stencil.fillFine(m_fine_box, m_coarse_box, iv);
                    }
                } // end loop box
            }     // end loop boxes
        }         // end if is_periodic
    }             // end loop idir
}
#endif

#if 0
//xxxxx
/// get the boundary box to fill if we are at a boundary
Box BoundaryConditions::get_boundary_box(
    const Side::LoHiSide a_side, const int a_dir, const amrex::IntVect &offset_lo,
    const amrex::IntVect &offset_hi, amrex::Box &this_ghostless_box, int shrink_for_coarse)
{
    // default constructor gives empty box
    amrex::Box boundary_box;

    // check if we are over the edges of the domain - are we a boundary box?
    // if so create the box of the cells we want to fill
    if (((a_side == Side::Hi) && (offset_hi[a_dir] > 0)) ||
        ((a_side == Side::Lo) && (offset_lo[a_dir] > 0)))
    {
        // Get just the boundary box to iterate over, m_num_ghosts ghost
        // cells unless we are filling the coarse cells in the interp case
        // where we want to fill only two coarse ghost cells (to cover 3
        // fine ones)
        if (a_side == Side::Lo)
        {
            boundary_box = adjCellLo(this_ghostless_box, a_dir,
                                     m_num_ghosts - shrink_for_coarse);
        }
        else
        {
            boundary_box = adjCellHi(this_ghostless_box, a_dir,
                                     m_num_ghosts - shrink_for_coarse);
        }

        // adjust for any offsets - catches the corners etc
        // but only want to fill them once, so y fills x, z fills y and x
        // etc. Required in periodic direction corners in cases where there
        // are mixed boundaries, (otherwise these corners are full of nans)
        FOR(idir)
        {
            if (offset_lo[idir] > 0) // this direction is a low end boundary
            {
                if ((idir < a_dir) || (m_params.is_periodic[idir]))
                {
                    // grow it to fill the corners
                    boundary_box.growLo(idir, m_num_ghosts - shrink_for_coarse);
                }
            }
            else // cut off end ghost cell
            {
                if (idir != a_dir)
                {
                    boundary_box.growLo(idir, -shrink_for_coarse);
                }
            }

            if (offset_hi[idir] > 0) // this direction is a high end
                                     // boundary
            {
                if ((idir < a_dir) || (m_params.is_periodic[idir]))
                {
                    // grow it to fill the corners
                    boundary_box.growHi(idir, m_num_ghosts - shrink_for_coarse);
                }
            }
            else // cut off end ghost cell
            {
                if (idir != a_dir)
                {
                    boundary_box.growHi(idir, -shrink_for_coarse);
                }
            }
        }
    }
    return boundary_box;
}
#endif



================================================
FILE: Source/Grids/BoundaryConditions.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef BOUNDARYCONDITIONS_HPP_
#define BOUNDARYCONDITIONS_HPP_

// Our includes
#include "BCParity.hpp"
#include "DimensionDefinitions.hpp"
#include "GRParmParse.hpp"
#include "StateVariables.hpp"
#include "VariableType.hpp"

#include <AMReX_MultiFab.H>

/// Class which deals with the boundaries at the edge of the physical domain in
/// cases where they are not periodic. Currently only options are static BCs,
/// sommerfeld (outgoing radiation) and reflective. The conditions can differ in
/// the high and low directions.
/// In cases where different variables/boundaries are required, the user should
/// (usually) write their own conditions class which inherits from this one.
/// Note that these conditions enforce a certain rhs based on the current values
/// of the grid variables. (Another option would be to enforce grid values, e.g.
/// by extrapolating from within the grid.)
class BoundaryConditions
{
  public:
    /// enum for possible boundary states
    enum
    {
        STATIC_BC,
        SOMMERFELD_BC,
        REFLECTIVE_BC,
        EXTRAPOLATING_BC,
        MIXED_BC
    };

    /// Structure containing the boundary condition params
    struct params_t
    {
        std::array<int, AMREX_SPACEDIM> hi_boundary{};
        std::array<int, AMREX_SPACEDIM> lo_boundary{};
        std::array<bool, AMREX_SPACEDIM> is_periodic{};
        bool nonperiodic_boundaries_exist{false};
        bool boundary_solution_enforced{false};
        bool boundary_rhs_enforced{false};
        bool reflective_boundaries_exist{false};
        bool sommerfeld_boundaries_exist{false};
        bool extrapolating_boundaries_exist{};
        bool mixed_boundaries_exist{};

        std::array<double, NUM_VARS> vars_asymptotic_values{};
        std::map<int, int> mixed_bc_vars_map;
        int extrapolation_order{1};
        params_t(); // sets the defaults
        void set_is_periodic(
            const std::array<int, AMREX_SPACEDIM> &a_is_periodic_int);
        void
        set_hi_boundary(const std::array<int, AMREX_SPACEDIM> &a_hi_boundary);
        void
        set_lo_boundary(const std::array<int, AMREX_SPACEDIM> &a_lo_boundary);
        void read_params(GRParmParse &pp);
    };

  protected:
    // Member values
    int m_num_ghosts{};       // the number of ghosts (usually 3)
    params_t m_params;        // the boundary params
    amrex::RealVect m_center; // the position of the center of the grid
    amrex::Geometry m_geom;   // the problem domain (excludes boundary cells)
    bool is_defined{
        false}; // whether the BoundaryConditions class members are defined
    mutable amrex::Gpu::DeviceVector<double> m_asymptotic_values;

  public:
    /// Default constructor - need to call define afterwards
    BoundaryConditions()  = default;
    ~BoundaryConditions() = default;

    BoundaryConditions(const BoundaryConditions &)            = delete;
    BoundaryConditions(BoundaryConditions &&)                 = delete;
    BoundaryConditions &operator=(const BoundaryConditions &) = delete;
    BoundaryConditions &operator=(BoundaryConditions &&)      = delete;

    /// define function sets members and is_defined set to true
    void define(std::array<double, AMREX_SPACEDIM> a_center,
                const params_t &a_params, const amrex::Geometry &a_geom,
                int a_num_ghosts);

    /// change the asymptotic values of the variables for the Sommerfeld BCs
    /// this will allow them to evolve during a simulation if necessary
    void set_vars_asymptotic_values(
        std::array<double, NUM_VARS> &vars_asymptotic_values);

    /// write out boundary params (used during setup for debugging)
    static void write_boundary_conditions(const params_t &a_params);

    /// The function which returns the parity of each of the vars in
    /// StateVariables.hpp (It is only required for reflective boundary
    /// conditions.)
    static int get_state_var_parity(int a_comp, int a_dir);

    /// Get the boundary condition for given face
    int get_boundary_condition(amrex::Orientation face) const;

    /// Apply Sommerfeld BC to RHS
    void apply_sommerfeld_boundaries(amrex::MultiFab &a_rhs,
                                     const amrex::MultiFab &a_soln) const;

#if 0
//xxxxx
    /// Fill the rhs boundary values appropriately based on the params set
    void fill_rhs_boundaries(const Side::LoHiSide a_side,
                             const GRLevelData &a_soln, GRLevelData &a_rhs);

    /// enforce solution boundary conditions, e.g. after interpolation
    void fill_solution_boundaries(
        const Side::LoHiSide a_side, GRLevelData &a_state,
        const Interval &a_comps = Interval(0, NUM_VARS - 1));

    /// fill diagnostic boundaries - used in AMRInterpolator
    void fill_diagnostic_boundaries(
        const Side::LoHiSide a_side, GRLevelData &a_state,
        const Interval &a_comps = Interval(0, NUM_DIAGNOSTIC_VARS - 1));

    /// Fill the boundary values appropriately based on the params set
    /// in the direction dir
    void fill_boundary_cells_dir(const Side::LoHiSide a_side,
                                 const GRLevelData &a_soln, GRLevelData &a_out,
                                 const int dir, const int boundary_condition,
                                 const Interval &a_comps,
                                 const VariableType var_type,
                                 const bool filling_rhs);

    /// Copy the boundary values from src to dest
    /// NB assumes same box layout of input and output data
    void copy_boundary_cells(const Side::LoHiSide a_side,
                             const GRLevelData &a_src, GRLevelData &a_dest);

    /// Fill the fine boundary values in a_state
    /// Required for interpolating onto finer levels at boundaries
    void interp_boundaries(GRLevelData &a_fine_state,
                           GRLevelData &a_coarse_state,
                           const Side::LoHiSide a_side);

    /// Get the boundary condition for a_dir and a_side
    int get_boundary_condition(const Side::LoHiSide a_side, const int a_dir);

    /// get the boundary box to fill if we are at a boundary
    amrex::Box get_boundary_box(const Side::LoHiSide a_side, const int a_dir,
                         const amrex::IntVect &offset_lo, const amrex::IntVect &offset_hi,
                         amrex::Box &this_ghostless_box, int shrink_for_coarse = 0);

    /// This function takes a default constructed open DisjointBoxLayout and
    /// grows the boxes lying along the boundary to include the boundaries if
    /// necessary (i.e. in the Sommerfeld BC case). It is used to define the
    /// correct DisjointBoxLayout for the exchange copier so that shared
    /// boundary ghosts are exchanged correctly.
//xxxxx    void expand_grids_to_boundaries(DisjointBoxLayout &a_out_grids,
//                                    const DisjointBoxLayout &a_in_grids);
#endif

    friend class ExpandGridsToBoundaries;

  private:
    /// write out reflective conditions
    static void write_reflective_conditions(int idir);

    /// write out sommerfeld conditions
    static void write_sommerfeld_conditions(int idir, const params_t &a_params);

    /// write out mixed conditions
    static void write_mixed_conditions(int idir, const params_t &a_params);

    static void fill_sommerfeld_cell(amrex::FArrayBox &rhs_box,
                                     const amrex::FArrayBox &soln_box,
                                     const amrex::IntVect a_iv,
                                     const std::vector<int> &sommerfeld_comps);

#if 0
//xxxxx    void fill_extrapolating_cell(amrex::FArrayBox &out_box, const amrex::IntVect iv,
                                 const Side::LoHiSide a_side, const int dir,
                                 const std::vector<int> &extrapolating_comps,
                                 const int order = 1) const;

    void fill_reflective_cell(
        amrex::FArrayBox &out_box, const amrex::IntVect iv, const Side::LoHiSide a_side,
        const int dir, const std::vector<int> &reflective_comps,
        const VariableType var_type = VariableType::state) const;
#endif
};

#endif /* BOUNDARYCONDITIONS_HPP_ */



================================================
FILE: Source/Grids/Cell.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef CELL_HPP_
#define CELL_HPP_

#include <AMReX_Array4.H>

using namespace amrex::disabled;
// TODO: Remove these functions once we refactor the vars

template <class vars_t>
AMREX_GPU_HOST_DEVICE void store_vars(const amrex::CellData<amrex::Real> &cell,
                                      vars_t &vars)
{
    vars.enum_mapping(
        [&](const int &ivar, const amrex::Real &var)
        {
            // NOLINTNEXTLINE(clang-analyzer-core.uninitialized.Assign)
            cell[ivar] = var;
        });
}

template <template <typename> class vars_t, class data_t>
AMREX_GPU_HOST_DEVICE void load_vars(const amrex::CellData<data_t> &cell,
                                     vars_t<std::remove_const_t<data_t>> &vars)
{
    vars.enum_mapping([&](const int &ivar, std::remove_const_t<data_t> &var)
                      { var = cell[ivar]; });
}

template <template <typename> class vars_t, class data_t>
AMREX_GPU_HOST_DEVICE auto load_vars(const amrex::CellData<data_t> &cell)
{
    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)
    vars_t<std::remove_const_t<data_t>> vars;
    load_vars(cell, vars);
    return vars;
}

#endif /* CELL_HPP_ */



================================================
FILE: Source/Grids/Coordinates.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef COORDINATES_HPP_
#define COORDINATES_HPP_

// Other includes
#include "DimensionDefinitions.hpp"

#include <AMReX_IntVect.H>

#include <array>
#include <cmath>

class Coordinates
{
  public:
    amrex::Real x{};
    amrex::Real y{};
    amrex::Real z{};
    std::array<double, AMREX_SPACEDIM> m_center;

    AMREX_GPU_HOST_DEVICE
    Coordinates(amrex::IntVect integer_coords, double dx,
                std::array<amrex::Real, AMREX_SPACEDIM> center = {0})
        : m_center(center)
    {
        compute_coord(x, integer_coords[0], dx, center[0]);

// The below code allows for 2D Cartoon reduction:
#if DEFAULT_TENSOR_DIM == AMREX_SPACEDIM && AMREX_SPACEDIM == 3
        compute_coord(y, integer_coords[1], dx, center[1]);
        compute_coord(z, integer_coords[2], dx, center[2]);
#elif DEFAULT_TENSOR_DIM == AMREX_SPACEDIM + 1 && AMREX_SPACEDIM == 2
        y = 0;
        compute_coord(z, integer_coords[1], dx, center[1]);
#else
#ifdef AMREX_SPACEDIM
#error compute_coord has not got your dimension combination implemented.
#endif
#endif
    }

    AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE static void
    compute_coord(amrex::Real &out, int position, double dx,
                  double center_distance = 0)
    {
        out = (position + 0.5) * dx - center_distance;
    }

    /// This function returns the radius subject to a floor for a given
    /// Coordinates object.
    [[nodiscard]] AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE amrex::Real
    get_radius() const
    {
        // Note that this is not currently dimension independent
        amrex::Real r = sqrt(x * x + y * y + z * z);
        return std::max(r, 1e-6);
    }

    /// This static function returns the radius subject to a floor
    /// for when no coordinates object exists.
    AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE static amrex::Real
    get_radius(amrex::IntVect integer_coords, double dx,
               std::array<double, AMREX_SPACEDIM> center = {0})
    {
        amrex::Real x = NAN;
        amrex::Real y = NAN;
        amrex::Real z = NAN;

        // Note that this is not currently dimension independent
        compute_coord(x, integer_coords[0], dx, center[0]);
        compute_coord(y, integer_coords[1], dx, center[1]);
        compute_coord(z, integer_coords[2], dx, center[2]);

        amrex::Real r = std::sqrt(x * x + y * y + z * z);
        return std::max(r, 1e-6);
    }
};

AMREX_FORCE_INLINE std::ostream &operator<<(std::ostream &a_os,
                                            const Coordinates &in_coords)
{
    a_os << "(x,y,z) = (" << in_coords.x << "," << in_coords.y << ","
         << in_coords.z << ")"
         << " r = " << in_coords.get_radius();
    return a_os;
}
#endif /* COORDINATES_HPP_ */



================================================
FILE: Source/Grids/DimensionDefinitions.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef GRUTILS_HPP_
#define GRUTILS_HPP_

// #ifndef GR_SPACEDIM
// #define GR_SPACEDIM 3
// #endif
constexpr int GR_SPACEDIM = 3;

#ifndef DEFAULT_TENSOR_DIM
#define DEFAULT_TENSOR_DIM AMREX_SPACEDIM
#endif

// NOLINTBEGIN(cppcoreguidelines-macro-usage)
// Fancy 'for' loop macros to iterate through spatial tensors
// use as "FOR(i, j) { ... }"
// We don't need parentheses around args as IDX will be a single symbol
// NOLINTNEXTLINE(bugprone-macro-parentheses)
#define FOR1(IDX) for (int IDX = 0; IDX < DEFAULT_TENSOR_DIM; ++IDX)
#define FOR2(IDX1, IDX2)                                                       \
    FOR1 (IDX1)                                                                \
        FOR1 (IDX2)
#define FOR3(IDX1, IDX2, IDX3)                                                 \
    FOR2 (IDX1, IDX2)                                                          \
        FOR1 (IDX3)
#define FOR4(IDX1, IDX2, IDX3, IDX4)                                           \
    FOR2 (IDX1, IDX2)                                                          \
        FOR2 (IDX3, IDX4)
#define FOR5(IDX1, IDX2, IDX3, IDX4, IDX5)                                     \
    FOR4 (IDX1, IDX2, IDX3, IDX4)                                              \
        FOR1 (IDX5)
#define DUMMYFOR() // prevents warning that appeared in debug mode:
                   // 'ISO C++11 requires at least one argument for the "..." in
                   // a variadic macro'

#define GET_MACRO6(_1, _2, _3, _4, _5, NAME, ...) NAME
#define FOR(...)                                                               \
    GET_MACRO6(__VA_ARGS__, FOR5, FOR4, FOR3, FOR2, FOR1, DUMMYFOR)(__VA_ARGS__)
// NOLINTEND(cppcoreguidelines-macro-usage)

#endif /* GRUTILS_HPP_*/



================================================
FILE: Source/Grids/FourthOrderDerivatives.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef FOURTHORDERDERIVATIVES_HPP_
#define FOURTHORDERDERIVATIVES_HPP_

#include "Cell.hpp"
#include "DimensionDefinitions.hpp"
#include "Tensor.hpp"
#include <AMReX_REAL.H>
#include <array>

using namespace amrex::literals;

class FourthOrderDerivatives
{
  private:
    amrex::Real m_dx;
    amrex::Real m_one_over_dx;
    amrex::Real m_one_over_dx2;

  public:
    AMREX_GPU_HOST_DEVICE FourthOrderDerivatives(double dx)
        : m_dx(dx), m_one_over_dx(1 / dx), m_one_over_dx2(1 / (dx * dx))
    {
    }

    AMREX_GPU_DEVICE AMREX_FORCE_INLINE amrex::Real
    diff1(const amrex::Real *in_ptr, const int idx, const int stride) const
    {
        amrex::Real weight_far  = 8.33333333333333333333e-2_rt;
        amrex::Real weight_near = 6.66666666666666666667e-1_rt;

        return (weight_far * in_ptr[idx - 2 * stride] -
                weight_near * in_ptr[idx - stride] +
                weight_near * in_ptr[idx + stride] -
                weight_far * in_ptr[idx + 2 * stride]) *
               m_one_over_dx;
    }

    /// Calculates all first derivatives and returns as variable type specified
    /// by the template parameter
    template <template <typename> class vars_t>
    [[nodiscard]] AMREX_GPU_DEVICE AMREX_FORCE_INLINE auto
    diff1(int i, int j, int k,
          const amrex::Array4<const amrex::Real> &state) const
    {
        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)
        vars_t<Tensor<1, amrex::Real>> d1;
        const auto *state_ptr_ijk = state.ptr(i, j, k);
        d1.enum_mapping(
            [&](const int &ivar, Tensor<1, amrex::Real> &var)
            {
                AMREX_D_TERM(
                    var[0] = diff1(state_ptr_ijk + ivar * state.nstride, 0, 1);
                    , var[1] = diff1(state_ptr_ijk + ivar * state.nstride, 0,
                                     static_cast<int>(state.jstride));
                    , var[2] = diff1(state_ptr_ijk + ivar * state.nstride, 0,
                                     static_cast<int>(state.kstride)));
            });
        return d1;
    }

    AMREX_GPU_DEVICE AMREX_FORCE_INLINE amrex::Real
    diff2(const amrex::Real *in_ptr, const int idx, const int stride) const
    {
        amrex::Real weight_far   = 8.33333333333333333333e-2_rt;
        amrex::Real weight_near  = 1.33333333333333333333e+0_rt;
        amrex::Real weight_local = 2.50000000000000000000e+0_rt;

        return (-weight_far * in_ptr[idx - 2 * stride] +
                weight_near * in_ptr[idx - stride] -
                weight_local * in_ptr[idx] +
                weight_near * in_ptr[idx + stride] -
                weight_far * in_ptr[idx + 2 * stride]) *
               m_one_over_dx2;
    }

    AMREX_GPU_DEVICE AMREX_FORCE_INLINE amrex::Real
    mixed_diff2(const amrex::Real *in_ptr, const int idx, const int stride1,
                const int stride2) const
    {
        amrex::Real weight_far_far   = 6.94444444444444444444e-3_rt;
        amrex::Real weight_near_far  = 5.55555555555555555556e-2_rt;
        amrex::Real weight_near_near = 4.44444444444444444444e-1_rt;

        return (weight_far_far * in_ptr[idx - 2 * stride1 - 2 * stride2] -
                weight_near_far * in_ptr[idx - 2 * stride1 - stride2] +
                weight_near_far * in_ptr[idx - 2 * stride1 + stride2] -
                weight_far_far * in_ptr[idx - 2 * stride1 + 2 * stride2]

                - weight_near_far * in_ptr[idx - stride1 - 2 * stride2] +
                weight_near_near * in_ptr[idx - stride1 - stride2] -
                weight_near_near * in_ptr[idx - stride1 + stride2] +
                weight_near_far * in_ptr[idx - stride1 + 2 * stride2]

                + weight_near_far * in_ptr[idx + stride1 - 2 * stride2] -
                weight_near_near * in_ptr[idx + stride1 - stride2] +
                weight_near_near * in_ptr[idx + stride1 + stride2] -
                weight_near_far * in_ptr[idx + stride1 + 2 * stride2]

                - weight_far_far * in_ptr[idx + 2 * stride1 - 2 * stride2] +
                weight_near_far * in_ptr[idx + 2 * stride1 - stride2] -
                weight_near_far * in_ptr[idx + 2 * stride1 + stride2] +
                weight_far_far * in_ptr[idx + 2 * stride1 + 2 * stride2]) *
               m_one_over_dx2;
    }

    /// Calculates all second derivatives for a single variable
    [[nodiscard]] AMREX_GPU_DEVICE AMREX_FORCE_INLINE Tensor<2, amrex::Real>
    diff2(int i, int j, int k, const amrex::Array4<amrex::Real const> &state,
          const int ivar) const
    {
        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)
        Tensor<2, amrex::Real> d2;
        const auto *state_ptr_ijk = state.ptr(i, j, k);
        amrex::GpuArray<int, AMREX_SPACEDIM> strides{
            1, static_cast<int>(state.jstride),
            static_cast<int>(state.kstride)};
        const auto *pvar = state_ptr_ijk + ivar * state.nstride;
        FOR (dir1) // First calculate the repeated derivatives
        {
            d2[dir1][dir1] = diff2(pvar, 0, strides[dir1]);
            for (int dir2 = 0; dir2 < dir1; ++dir2)
            {
                auto tmp = mixed_diff2(pvar, 0, strides[dir1], strides[dir2]);
                d2[dir1][dir2] = tmp;
                d2[dir2][dir1] = tmp;
            }
        }
        return d2;
    }

    template <template <typename> class vars_t>
    [[nodiscard]] AMREX_GPU_DEVICE AMREX_FORCE_INLINE auto
    diff2(int i, int j, int k,
          const amrex::Array4<amrex::Real const> &state) const
    {
        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)
        vars_t<Tensor<2, amrex::Real>> d2;
        const auto *state_ptr_ijk = state.ptr(i, j, k);
        amrex::GpuArray<int, AMREX_SPACEDIM> strides{
            1, static_cast<int>(state.jstride),
            static_cast<int>(state.kstride)};
        d2.enum_mapping(
            [&](const int &ivar, Tensor<2, amrex::Real> &var)
            {
                const auto *pvar = state_ptr_ijk + ivar * state.nstride;
                FOR (dir1) // First calculate the repeated derivatives
                {
                    var[dir1][dir1] = diff2(pvar, 0, strides[dir1]);
                    for (int dir2 = 0; dir2 < dir1; ++dir2)
                    {
                        auto tmp =
                            mixed_diff2(pvar, 0, strides[dir1], strides[dir2]);
                        var[dir1][dir2] = tmp;
                        var[dir2][dir1] = tmp;
                    }
                }
            });
        return d2;
    }

  protected: // Let's keep this protected ... we may want to change the
             // advection calculation
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE amrex::Real
    advection_term(const amrex::Real *in_ptr, const int idx,
                   const amrex::Real &vec_comp, const int stride,
                   const bool shift_positive) const
    {
        const amrex::Real in_left   = in_ptr[idx - stride];
        const amrex::Real in_centre = in_ptr[idx];
        const amrex::Real in_right  = in_ptr[idx + stride];

        amrex::Real weight_0 = -2.50000000000000000000e-1_rt;
        amrex::Real weight_1 = -8.33333333333333333333e-1_rt;
        amrex::Real weight_2 = +1.50000000000000000000e+0_rt;
        amrex::Real weight_3 = -5.00000000000000000000e-1_rt;
        amrex::Real weight_4 = +8.33333333333333333333e-2_rt;

        amrex::Real upwind =
            vec_comp *
            (weight_0 * in_left + weight_1 * in_centre + weight_2 * in_right +
             weight_3 * in_ptr[idx + 2 * stride] +
             weight_4 * in_ptr[idx + 3 * stride]) *
            m_one_over_dx;

        amrex::Real downwind =
            vec_comp *
            (-weight_4 * in_ptr[idx - 3 * stride] -
             weight_3 * in_ptr[idx - 2 * stride] - weight_2 * in_left -
             weight_1 * in_centre - weight_0 * in_right) *
            m_one_over_dx;

        return (shift_positive) ? upwind : downwind;
    }

  public:

    /// Calculates all second derivatives and returns as variable type specified
    /// by the template parameter
    template <template <typename> class vars_t>
    [[nodiscard]] AMREX_GPU_DEVICE AMREX_FORCE_INLINE auto
    advection(int i, int j, int k,
              const amrex::Array4<amrex::Real const> &state,
              const Tensor<1, amrex::Real> &vector) const
    {
        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)
        vars_t<amrex::Real> advec;
        const auto *state_ptr_ijk = state.ptr(i, j, k);
        amrex::GpuArray<int, AMREX_SPACEDIM> strides{
            1, static_cast<int>(state.jstride),
            static_cast<int>(state.kstride)};
        advec.enum_mapping(
            [&](const int &ivar, amrex::Real &var)
            {
                var              = 0.;
                const auto *pvar = state_ptr_ijk + ivar * state.nstride;
                FOR (dir)
                {
                    const bool shift_positive = (vector[dir] > 0.0);
                    var += advection_term(pvar, 0, vector[dir], strides[dir],
                                          shift_positive);
                }
            });
        return advec;
    }

    AMREX_GPU_DEVICE AMREX_FORCE_INLINE amrex::Real
    dissipation_term(const double *in_ptr, const int idx,
                     const int stride) const
    {
        amrex::Real weight_vfar  = 1.56250e-2_rt;
        amrex::Real weight_far   = 9.37500e-2_rt;
        amrex::Real weight_near  = 2.34375e-1_rt;
        amrex::Real weight_local = 3.12500e-1_rt;

        return (weight_vfar * in_ptr[idx - 3 * stride] -
                weight_far * in_ptr[idx - 2 * stride] +
                weight_near * in_ptr[idx - stride] -
                weight_local * in_ptr[idx] +
                weight_near * in_ptr[idx + stride] -
                weight_far * in_ptr[idx + 2 * stride] +
                weight_vfar * in_ptr[idx + 3 * stride]) *
               m_one_over_dx;
    }

    template <template <typename> class vars_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
    add_dissipation(int i, int j, int k, vars_t<amrex::Real> &vars,
                    const amrex::Array4<amrex::Real const> &state,
                    const double factor) const
    {
        const auto *state_ptr_ijk = state.ptr(i, j, k);
        amrex::GpuArray<int, AMREX_SPACEDIM> strides{
            1, static_cast<int>(state.jstride),
            static_cast<int>(state.kstride)};
        vars.enum_mapping(
            [&](const int &ivar, amrex::Real &var)
            {
                FOR (dir)
                {
                    const auto stride  = strides[dir];
                    var               += factor *
                           dissipation_term(
                               state_ptr_ijk + ivar * state.nstride, 0, stride);
                }
            });
    }
};

#endif /* FOURTHORDERDERIVATIVES_HPP_ */



================================================
FILE: Source/Grids/Make.package
================================================
GRTECLYN_CEXE_sources += BoundaryConditions.cpp

GRTECLYN_CEXE_headers += BCParity.hpp \
                         BoundaryConditions.hpp \
                         Cell.hpp \
                         Coordinates.hpp \
                         DimensionDefinitions.hpp \
                         FourthOrderDerivatives.hpp \
                         NullBCFill.hpp \
                         SixthOrderDerivatives.hpp \
                         Tensor.hpp \
                         VarsTools.hpp



================================================
FILE: Source/Grids/NullBCFill.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef NULLBCFILL_HPP_
#define NULLBCFILL_HPP_

#include <AMReX_PhysBCFunct.H>

// AMReX requires us to set a boundary fill function even though we are not
// using Dirichlet or "User" BCs (see docs)

struct NullBCFill
{
    AMREX_GPU_DEVICE
    void operator()(const amrex::IntVect & /*iv*/,
                    const amrex::Array4<amrex::Real> & /*dest*/,
                    const int /*dcomp*/, const int /*numcomp*/,
                    const amrex::GeometryData & /*geom*/,
                    const amrex::Real /*time*/, const amrex::BCRec * /*bcr*/,
                    const int /*bcomp*/, const int /*orig_comp*/) const
    {
        // We don't have any external Dirichlet BC
    }
};

void null_bc_fill(const amrex::Box &box, amrex::FArrayBox &data,
                  const int dcomp, const int numcomp,
                  const amrex::Geometry &geom, const amrex::Real time,
                  const amrex::Vector<amrex::BCRec> &bcr, const int bcomp,
                  const int scomp)
{
    amrex::GpuBndryFuncFab<NullBCFill> bndry_func(NullBCFill{});
    bndry_func(box, data, dcomp, numcomp, geom, time, bcr, bcomp, scomp);
}

#endif /* NULLBCFILL_HPP_ */


================================================
FILE: Source/Grids/SixthOrderDerivatives.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SIXTHORDERDERIVATIVES_HPP_
#define SIXTHORDERDERIVATIVES_HPP_

#include "Cell.hpp"
#include "DimensionDefinitions.hpp"
#include "StateVariables.hpp"
#include "Tensor.hpp"
#include <array>

class SixthOrderDerivatives
{
    static_assert(false, "SixthOrderDerivatives todo");

  public:
    const double m_dx;

  private:
    const double m_one_over_dx;
    const double m_one_over_dx2;

  public:
    SixthOrderDerivatives(double dx)
        : m_dx(dx), m_one_over_dx(1 / dx), m_one_over_dx2(1 / (dx * dx))
    {
    }

    template <class data_t>
    ALWAYS_INLINE data_t diff1(const double *in_ptr, const int idx,
                               const int stride) const
    {
        auto in = SIMDIFY<data_t>(in_ptr);

        data_t weight_vfar = 1.66666666666666666667e-2;
        data_t weight_far  = 1.50000000000000000000e-1;
        data_t weight_near = 7.50000000000000000000e-1;

        // NOTE: if you have been sent here by the debugger because of
        // EXC_BAD_ACCESS  or something similar you might be trying to take
        // derivatives without ghost points.
        return (-weight_vfar * in[idx - 3 * stride] +
                weight_far * in[idx - 2 * stride] -
                weight_near * in[idx - stride] +
                weight_near * in[idx + stride] -
                weight_far * in[idx + 2 * stride] +
                weight_vfar * in[idx + 3 * stride]) *
               m_one_over_dx;
    }

    // Writes directly into the vars object - use this wherever possible
    template <class data_t, template <typename> class vars_t>
    void diff1(vars_t<Tensor<1, data_t>> &d1, const Cell<data_t> &current_cell,
               int direction) const
    {
        const int stride =
            current_cell.get_box_pointers().m_in_stride[direction];
        const int in_index = current_cell.get_in_index();
        d1.enum_mapping(
            [&](const int &ivar, Tensor<1, data_t> &var)
            {
                var[direction] = diff1<data_t>(
                    current_cell.get_box_pointers().m_in_ptr[ivar], in_index,
                    stride);
            });
    }

    /// Calculates all first derivatives and returns as variable type specified
    /// by the template parameter
    template <template <typename> class vars_t, class data_t>
    auto diff1(const Cell<data_t> &current_cell) const
    {
        const auto in_index = current_cell.get_in_index();
        const auto strides  = current_cell.get_box_pointers().m_in_stride;
        vars_t<Tensor<1, data_t>> d1;
        d1.enum_mapping(
            [&](const int &ivar, Tensor<1, data_t> &var)
            {
                FOR (idir)
                {
                    var[idir] = diff1<data_t>(
                        current_cell.get_box_pointers().m_in_ptr[ivar],
                        in_index, strides[idir]);
                }
            });
        return d1;
    }

    template <class data_t>
    void diff1(Tensor<1, data_t> &diff_value, const Cell<data_t> &current_cell,
               int direction, int ivar) const
    {
        const int stride =
            current_cell.get_box_pointers().m_in_stride[direction];
        const int in_index    = current_cell.get_in_index();
        diff_value[direction] = diff1<data_t>(
            current_cell.get_box_pointers().m_in_ptr[ivar], in_index, stride);
    }

    template <class data_t, int num_vars>
    void diff1(Tensor<1, data_t> (&diff_array)[num_vars],
               const Cell<data_t> &current_cell, int direction,
               int start_var = 0) const
    {
        const int stride =
            current_cell.get_box_pointers().m_in_stride[direction];
        const int in_index = current_cell.get_in_index();
        for (int i = start_var; i < start_var + num_vars; ++i)
        {
            diff_array[i][direction] = diff1<data_t>(
                current_cell.get_box_pointers().m_in_ptr[i], in_index, stride);
        }
    }

    template <class data_t>
    ALWAYS_INLINE data_t diff2(const double *in_ptr, const int idx,
                               const int stride) const
    {
        auto in = SIMDIFY<data_t>(in_ptr);

        data_t weight_vfar  = 1.11111111111111111111e-2;
        data_t weight_far   = 1.50000000000000000000e-1;
        data_t weight_near  = 1.50000000000000000000e+0;
        data_t weight_local = 2.72222222222222222222e+0;

        return (weight_vfar * in[idx - 3 * stride] -
                weight_far * in[idx - 2 * stride] +
                weight_near * in[idx - stride] - weight_local * in[idx] +
                weight_near * in[idx + stride] -
                weight_far * in[idx + 2 * stride] +
                weight_vfar * in[idx + 3 * stride]) *
               m_one_over_dx2;
    }

    // Writes 2nd deriv directly into the vars object - use this wherever
    // possible
    template <class data_t, template <typename> class vars_t>
    void diff2(vars_t<Tensor<2, data_t>> &d2, const Cell<data_t> &current_cell,
               int direction) const
    {
        const int stride =
            current_cell.get_box_pointers().m_in_stride[direction];
        const int in_index = current_cell.get_in_index();
        d2.enum_mapping(
            [&](const int &ivar, Tensor<2, data_t> &var)
            {
                var[direction][direction] = diff2<data_t>(
                    current_cell.get_box_pointers().m_in_ptr[ivar], in_index,
                    stride);
            });
    }

    template <class data_t>
    void diff2(Tensor<2, data_t> (&diffArray)[NUM_VARS],
               const Cell<data_t> &current_cell, int direction) const
    {
        const int stride =
            current_cell.get_box_pointers().m_in_stride[direction];
        const int in_index = current_cell.get_in_index();
        for (int ivar = 0; ivar < NUM_VARS; ++ivar)
        {
            diffArray[ivar][direction][direction] =
                diff2<data_t>(current_cell.get_box_pointers().m_in_ptr[ivar],
                              in_index, stride);
        }
    }

    template <class data_t>
    ALWAYS_INLINE data_t mixed_diff2(const double *in_ptr, const int idx,
                                     const int stride1, const int stride2) const
    {
        auto in = SIMDIFY<data_t>(in_ptr);

        data_t weight_vfar_vfar = 2.77777777777777777778e-4;
        data_t weight_vfar_far  = 2.50000000000000000000e-3;
        data_t weight_vfar_near = 1.25000000000000000000e-2;
        data_t weight_far_far   = 2.25000000000000000000e-2;
        data_t weight_far_near  = 1.12500000000000000000e-1;
        data_t weight_near_near = 5.62500000000000000000e-1;

        return (weight_vfar_vfar * in[idx - 3 * stride1 - 3 * stride2] -
                weight_vfar_far * in[idx - 3 * stride1 - 2 * stride2] +
                weight_vfar_near * in[idx - 3 * stride1 - stride2] -
                weight_vfar_near * in[idx - 3 * stride1 + stride2] +
                weight_vfar_far * in[idx - 3 * stride1 + 2 * stride2] -
                weight_vfar_vfar * in[idx - 3 * stride1 + 3 * stride2]

                - weight_vfar_far * in[idx - 2 * stride1 - 3 * stride2] +
                weight_far_far * in[idx - 2 * stride1 - 2 * stride2] -
                weight_far_near * in[idx - 2 * stride1 - stride2] +
                weight_far_near * in[idx - 2 * stride1 + stride2] -
                weight_far_far * in[idx - 2 * stride1 + 2 * stride2] +
                weight_vfar_far * in[idx - 2 * stride1 + 3 * stride2]

                + weight_vfar_near * in[idx - stride1 - 3 * stride2] -
                weight_far_near * in[idx - stride1 - 2 * stride2] +
                weight_near_near * in[idx - stride1 - stride2] -
                weight_near_near * in[idx - stride1 + stride2] +
                weight_far_near * in[idx - stride1 + 2 * stride2] -
                weight_vfar_near * in[idx - stride1 + 3 * stride2]

                - weight_vfar_near * in[idx + stride1 - 3 * stride2] +
                weight_far_near * in[idx + stride1 - 2 * stride2] -
                weight_near_near * in[idx + stride1 - stride2] +
                weight_near_near * in[idx + stride1 + stride2] -
                weight_far_near * in[idx + stride1 + 2 * stride2] +
                weight_vfar_near * in[idx + stride1 + 3 * stride2]

                + weight_vfar_far * in[idx + 2 * stride1 - 3 * stride2] -
                weight_far_far * in[idx + 2 * stride1 - 2 * stride2] +
                weight_far_near * in[idx + 2 * stride1 - stride2] -
                weight_far_near * in[idx + 2 * stride1 + stride2] +
                weight_far_far * in[idx + 2 * stride1 + 2 * stride2] -
                weight_vfar_far * in[idx + 2 * stride1 + 3 * stride2]

                - weight_vfar_vfar * in[idx + 3 * stride1 - 3 * stride2] +
                weight_vfar_far * in[idx + 3 * stride1 - 2 * stride2] -
                weight_vfar_near * in[idx + 3 * stride1 - stride2] +
                weight_vfar_near * in[idx + 3 * stride1 + stride2] -
                weight_vfar_far * in[idx + 3 * stride1 + 2 * stride2] +
                weight_vfar_vfar * in[idx + 3 * stride1 + 3 * stride2]) *
               m_one_over_dx2;
    }

    template <class data_t, template <typename> class vars_t>
    void mixed_diff2(vars_t<Tensor<2, data_t>> &d2,
                     const Cell<data_t> &current_cell, int direction1,
                     int direction2) const
    {
        const int stride1 =
            current_cell.get_box_pointers().m_in_stride[direction1];
        const int stride2 =
            current_cell.get_box_pointers().m_in_stride[direction2];
        const int in_index = current_cell.get_in_index();
        d2.enum_mapping(
            [&](const int &ivar, Tensor<2, data_t> &var)
            {
                auto tmp = mixed_diff2<data_t>(
                    current_cell.get_box_pointers().m_in_ptr[ivar], in_index,
                    stride1, stride2);
                var[direction1][direction2] = tmp;
                var[direction2][direction1] = tmp;
            });
    }

    template <class data_t>
    void mixed_diff2(Tensor<2, data_t> (&diffArray)[NUM_VARS],
                     const Cell<data_t> &current_cell, int direction1,
                     int direction2) const
    {
        const int stride1 =
            current_cell.get_box_pointers().m_in_stride[direction1];
        const int stride2 =
            current_cell.get_box_pointers().m_in_stride[direction2];
        const int in_index = current_cell.get_in_index();
        for (int ivar = 0; ivar < NUM_VARS; ++ivar)
        {
            data_t diff2_value = mixed_diff2<data_t>(
                current_cell.get_box_pointers().m_in_ptr[ivar], in_index,
                stride1, stride2);
            diffArray[ivar][direction1][direction2] = diff2_value;
            diffArray[ivar][direction2][direction1] = diff2_value;
        }
    }

    template <typename data_t> struct Detector;

    /// Calculates all second derivatives and returns as variable type specified
    /// by the template parameter
    template <template <typename> class vars_t, class data_t>
    auto diff2(const Cell<data_t> &current_cell) const
    {
        vars_t<Tensor<2, data_t>> d2;
        const auto in_index = current_cell.get_in_index();
        const auto strides  = current_cell.get_box_pointers().m_in_stride;
        d2.enum_mapping(
            [&](const int &ivar, Tensor<2, data_t> &var)
            {
                FOR (dir1) // First calculate the repeated derivatives
                {
                    var[dir1][dir1] = diff2<data_t>(
                        current_cell.get_box_pointers().m_in_ptr[ivar],
                        in_index, strides[dir1]);
                    for (int dir2 = 0; dir2 < dir1; ++dir2)
                    {
                        auto tmp = mixed_diff2<data_t>(
                            current_cell.get_box_pointers().m_in_ptr[ivar],
                            in_index, strides[dir1], strides[dir2]);
                        var[dir1][dir2] = tmp;
                        var[dir2][dir1] = tmp;
                    }
                }
            });
        return d2;
    }

  protected: // Let's keep this protected ... we may want to change the
             // advection calculation
    template <class data_t, class mask_t>
    ALWAYS_INLINE data_t advection_term(const double *in_ptr, const int idx,
                                        const data_t &vec_comp,
                                        const int stride,
                                        const mask_t shift_positive) const
    {
        const auto in             = SIMDIFY<data_t>(in_ptr);
        const data_t in_left_far  = in[idx - 2 * stride];
        const data_t in_left      = in[idx - stride];
        const data_t in_centre    = in[idx];
        const data_t in_right     = in[idx + stride];
        const data_t in_right_far = in[idx + 2 * stride];

        data_t weight_0 = +3.33333333333333333333e-2;
        data_t weight_1 = -4.00000000000000000000e-1;
        data_t weight_2 = -5.83333333333333333333e-1;
        data_t weight_3 = +1.33333333333333333333e0;
        data_t weight_4 = -5.00000000000000000000e-1;
        data_t weight_5 = +1.33333333333333333333e-1;
        data_t weight_6 = -1.66666666666666666667e-2;

        data_t upwind;
        upwind = vec_comp *
                 (weight_0 * in_left_far + weight_1 * in_left +
                  weight_2 * in_centre + weight_3 * in_right +
                  weight_4 * in_right_far + weight_5 * in[idx + 3 * stride] +
                  weight_6 * in[idx + 4 * stride]) *
                 m_one_over_dx;

        data_t downwind;
        downwind = vec_comp *
                   (-weight_6 * in[idx - 4 * stride] -
                    weight_5 * in[idx - 3 * stride] - weight_4 * in_left_far -
                    weight_3 * in_left - weight_2 * in_centre -
                    weight_1 * in_right - weight_0 * in_right_far) *
                   m_one_over_dx;

        return simd_conditional(shift_positive, upwind, downwind);
    }

  public:
    template <class data_t, template <typename> class vars_t>
    void add_advection(vars_t<data_t> &vars, const Cell<data_t> &current_cell,
                       const data_t &vec_comp, const int dir) const
    {
        const int stride    = current_cell.get_box_pointers().m_in_stride[dir];
        auto shift_positive = simd_compare_gt(vec_comp, 0.0);
        const int in_index  = current_cell.get_in_index();
        vars.enum_mapping(
            [&](const int &ivar, data_t &var)
            {
                var += advection_term(
                    current_cell.get_box_pointers().m_in_ptr[ivar], in_index,
                    vec_comp, stride, shift_positive);
            });
    }

    template <class data_t>
    void add_advection(data_t (&out)[NUM_VARS],
                       const Cell<data_t> &current_cell, const data_t &vec_comp,
                       const int dir) const
    {
        const int stride    = current_cell.get_box_pointers().m_in_stride[dir];
        auto shift_positive = simd_compare_gt(vec_comp, 0.0);
        const int in_index  = current_cell.get_in_index();
        for (int ivar = 0; ivar < NUM_VARS; ++ivar)
        {
            out[ivar] +=
                advection_term(current_cell.get_box_pointers().m_in_ptr[ivar],
                               in_index, vec_comp, stride, shift_positive);
        }
    }

    /// Calculates all second derivatives and returns as variable type specified
    /// by the template parameter
    template <template <typename> class vars_t, class data_t>
    auto advection(const Cell<data_t> &current_cell,
                   const Tensor<1, data_t> &vector) const
    {
        const auto in_index = current_cell.get_in_index();
        const auto strides  = current_cell.get_box_pointers().m_in_stride;
        vars_t<data_t> advec;
        advec.enum_mapping(
            [&](const int &ivar, data_t &var)
            {
                var = 0.;
                FOR (dir)
                {
                    const auto shift_positive =
                        simd_compare_gt(vector[dir], 0.0);
                    var += advection_term(
                        current_cell.get_box_pointers().m_in_ptr[ivar],
                        in_index, vector[dir], strides[dir], shift_positive);
                }
            });
        return advec;
    }

    /*
    // Eighth order dissipation: remember to change sign in front of factor in
    // add_dissipation functions below if using this
    template <class data_t>
    ALWAYS_INLINE data_t dissipation_term(const double *in_ptr, const int idx,
                                          const int stride) const
    {
        const auto in = SIMDIFY<data_t>(in_ptr);
        data_t weight_vvfar = 3.906250e-3;
        data_t weight_vfar = 3.125000e-2;
        data_t weight_far = 1.093750e-1;
        data_t weight_near = 2.187500e-1;
        data_t weight_local = 2.734375e-1;

        return (weight_vvfar * in[idx - 4 * stride] -
                weight_vfar * in[idx - 3 * stride] +
                weight_far * in[idx - 2 * stride] -
                weight_near * in[idx - stride] + weight_local * in[idx] -
                weight_near * in[idx + stride] +
                weight_far * in[idx + 2 * stride] -
                weight_vfar * in[idx + 3 * stride] +
                weight_vvfar * in[idx + 4 * stride]) *
               m_one_over_dx;
    }
    */

    // Sixth order dissipation
    template <class data_t>
    ALWAYS_INLINE data_t dissipation_term(const double *in_ptr, const int idx,
                                          const int stride) const
    {
        const auto in       = SIMDIFY<data_t>(in_ptr);
        data_t weight_vfar  = 1.56250e-2;
        data_t weight_far   = 9.37500e-2;
        data_t weight_near  = 2.34375e-1;
        data_t weight_local = 3.12500e-1;

        return (weight_vfar * in[idx - 3 * stride] -
                weight_far * in[idx - 2 * stride] +
                weight_near * in[idx - stride] - weight_local * in[idx] +
                weight_near * in[idx + stride] -
                weight_far * in[idx + 2 * stride] +
                weight_vfar * in[idx + 3 * stride]) *
               m_one_over_dx;
    }

    template <class data_t, template <typename> class vars_t>
    void add_dissipation(vars_t<data_t> &vars, const Cell<data_t> &current_cell,
                         const double factor, const int direction) const
    {
        const int stride =
            current_cell.get_box_pointers().m_in_stride[direction];
        const int in_index = current_cell.get_in_index();
        vars.enum_mapping(
            [&](const int &ivar, data_t &var)
            {
                // change sign for eigth order dissipation
                var += /*-*/ factor *
                       dissipation_term<data_t>(
                           current_cell.get_box_pointers().m_in_ptr[ivar],
                           in_index, stride);
            });
    }

    template <class data_t, template <typename> class vars_t>
    void add_dissipation(vars_t<data_t> &vars, const Cell<data_t> &current_cell,
                         const double factor) const
    {
        const auto in_index = current_cell.get_in_index();
        vars.enum_mapping(
            [&](const int &ivar, data_t &var)
            {
                FOR (dir)
                {
                    const auto stride =
                        current_cell.get_box_pointers().m_in_stride[dir];
                    // change sign for eighth order dissipation
                    var += /*-*/ factor *
                           dissipation_term<data_t>(
                               current_cell.get_box_pointers().m_in_ptr[ivar],
                               in_index, stride);
                }
            });
    }

    template <class data_t>
    void add_dissipation(data_t (&out)[NUM_VARS],
                         const Cell<data_t> &current_cell, const double factor,
                         const int direction) const
    {
        const int stride =
            current_cell.get_box_pointers().m_in_stride[direction];
        const int in_index = current_cell.get_in_index();
        for (int ivar = 0; ivar < NUM_VARS; ++ivar)
        {
            // change sign for eighth order dissipation
            out[ivar] +=
                /*-*/ factor *
                dissipation_term<data_t>(
                    current_cell.get_box_pointers().m_in_ptr[ivar], in_index,
                    stride);
        }
    }
};

#endif /* SIXTHORDERDERIVATIVES_HPP_ */



================================================
FILE: Source/Grids/Tensor.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef TENSOR_HPP_
#define TENSOR_HPP_

#include "AlwaysInline.hpp"
#include "DimensionDefinitions.hpp"

// AMReX includes
#include "AMReX_GpuQualifiers.H"

/// This class implements a Tensor with given rank, element data type, and
/// dimension.  By default the dimension is equal to DEFAULT_TENSOR_DIM.
template <int rank, class data_t, int size = DEFAULT_TENSOR_DIM> class Tensor
{
    template <int, class, int> friend class Tensor;
    // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
    using arr_t = typename Tensor<rank - 1, data_t, size>::arr_t[size];
    arr_t arr;

  public:
    // We don't want to initialize Tensor objects for performance
    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)
    AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE constexpr Tensor() = default;

    //    ALWAYS_INLINE
    //    Tensor(std::initializer_list<data_t> list) :
    //        arr (list)
    //    {}

    template <typename... T>
    AMREX_GPU_HOST_DEVICE Tensor(T... data) : arr{data...}
    {
    }

    constexpr operator arr_t &() { return arr; }

    constexpr operator const arr_t &() const { return arr; }
};

template <class data_t, int size> class Tensor<0, data_t, size>
{
    template <int, class, int> friend class Tensor;
    using arr_t = data_t;
    arr_t arr;

  public:
    constexpr Tensor() = default;

    constexpr Tensor(data_t val) : arr(val) {}

    constexpr operator arr_t &() { return arr; }

    constexpr operator const arr_t &() const { return arr; }
};

#endif /* TENSOR_HPP_ */



================================================
FILE: Source/Grids/VarsTools.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef VARSTOOLS_HPP_
#define VARSTOOLS_HPP_

// Our includes
#include "GRInterval.hpp"
#include "StateVariables.hpp"
#include "Tensor.hpp"

// AMReX includes
#include "AMReX_Print.H" //Gives us amrex::Print()

namespace VarsTools
{
template <typename mapping_function_t, typename data_t>
AMREX_GPU_HOST_DEVICE void
define_enum_mapping(mapping_function_t mapping_function, const int &ivar,
                    data_t &scalar)
{
    mapping_function(ivar, scalar);
}

template <typename mapping_function_t, typename data_t, int start_var,
          int end_var>
AMREX_GPU_HOST_DEVICE void
define_enum_mapping(mapping_function_t mapping_function,
                    const GRInterval<start_var, end_var> interval,
                    Tensor<1, data_t, end_var - start_var + 1> &tensor)
{
    for (int ivar = 0; ivar < interval.size(); ++ivar)
    {
        mapping_function(start_var + ivar, tensor[ivar]);
    }
}

template <typename mapping_function_t, typename data_t, int start_var,
          int end_var>
AMREX_GPU_HOST_DEVICE void
define_symmetric_enum_mapping(mapping_function_t mapping_function,
                              const GRInterval<start_var, end_var> interval,
                              Tensor<2, data_t> &tensor)
{
    static_assert(interval.size() ==
                      DEFAULT_TENSOR_DIM * (DEFAULT_TENSOR_DIM + 1) / 2,
                  "Interval has wrong size");
#if DEFAULT_TENSOR_DIM == 3
    mapping_function(start_var, tensor[0][0]);

    mapping_function(start_var + 1, tensor[0][1]);
    mapping_function(start_var + 1, tensor[1][0]);

    mapping_function(start_var + 2, tensor[0][2]);
    mapping_function(start_var + 2, tensor[2][0]);

    mapping_function(start_var + 3, tensor[1][1]);

    mapping_function(start_var + 4, tensor[1][2]);
    mapping_function(start_var + 4, tensor[2][1]);

    mapping_function(start_var + 5, tensor[2][2]);
#else
#error DEFAULT_TENSOR_DIM not equal to three not implemented yet...
#endif
}

//--> Begin: Helper for the assign function
template <class nested_template> struct strip_nested_template;

template <template <typename> class outermost_layer, class inner_part>
struct strip_nested_template<outermost_layer<inner_part>>
{
    using type = inner_part;
};
//<-- End: Helper for the assign function

/// Writes data directly into all variables
/**if this variables has multiple components (e.g. if it is an array of
 *derivatives) the data can be written directly into these components by
 *specifying an arbitrary number of icomps
 */
template <class vars_t, typename value_t>
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE void assign(vars_t &vars,
                                                     const value_t &value)
{
    // The template magic below is needed to make sure that we can write
    // assign(vars, 0.)  and 0. gets correctly cast from double to simd<double>
    // if necessary.
    using data_t = typename strip_nested_template<vars_t>::type;
    vars.enum_mapping([&value](const int & /*ivar*/, data_t &var)
                      { var = static_cast<data_t>(value); });
}

/// Prints all elements of the vars element with component names
/// (Very useful for debugging)
template <template <typename> class vars_t, typename data_t>
void print(const vars_t<data_t> &vars)
{
    vars.enum_mapping(
        [](const int &ivar, data_t &var)
        {
            amrex::Print() << StateVariables::names[ivar] << ": " << var
                           << "\n";
        });
}
} // namespace VarsTools

#endif /* VARSTOOLS_HPP_ */



================================================
FILE: Source/GRTeclynCore/AlwaysInline.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef ALWAYS_INLINE_HPP_
#define ALWAYS_INLINE_HPP_

#include <AMReX_Extension.H>

#define ALWAYS_INLINE AMREX_FORCE_INLINE

#if 0
#if defined(__GNUC__)
#define ALWAYS_INLINE __attribute__((always_inline)) __inline__
#else
#define ALWAYS_INLINE inline
#endif
#endif

#endif /* ALWAYS_INLINE_HPP_ */



================================================
FILE: Source/GRTeclynCore/AMReXParameters.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef AMREXPARAMETERS_HPP_
#define AMREXPARAMETERS_HPP_

// General includes
#include "ArrayTools.hpp"
#include "BoundaryConditions.hpp"
#include "FilesystemTools.hpp"
#include "GRParmParse.hpp"
#include "StateVariables.hpp"
#include "VariableType.hpp"

#include <algorithm>
#include <cmath>
#include <string>
#include <unistd.h> // gives 'access'

class AMReXParameters
{
  public:
    AMReXParameters(GRParmParse &pp)
    {
        read_params(pp);
        check_params();
        set_amrex_params();
    }

    void read_params(GRParmParse &pp)
    {
        // must be before any amrex::Print() in the code to setPoutBaseName
        read_filesystem_params(pp);

        pp.load("verbosity", verbosity, 0);
        // Grid setup
        pp.load("max_spatial_derivative_order", max_spatial_derivative_order,
                4);
        pp.load("num_ghosts", num_ghosts,
                (max_spatial_derivative_order == 6) ? 4 : 3);
        pp.load("tag_buffer_size", tag_buffer_size, 3);
        pp.load("grid_buffer_size", grid_buffer_size, 8);
        pp.load("dt_multiplier", dt_multiplier, 0.25);
        pp.load("fill_ratio", fill_ratio, 0.7);

        // Periodicity and boundaries
        boundary_params.read_params(pp);

        // L's, N's and center
        read_grid_params(pp);

        pp.load("max_level", max_level, 0);
        // the reference ratio is hard coded to 2
        // in principle it can be set to other values, but this is
        // not recommended since we do not test GRChombo with other
        // refinement ratios - use other values at your own risk
        ref_ratios.resize(max_level + 1, 2);
        pp.getarr("regrid_interval", regrid_interval, 0, max_level);
        // Regridding on max_level does nothing but Chombo's AMR class
        // expects this Vector to be of length max_level + 1
        // so just set the final value to 0.
        regrid_interval.resize(max_level + 1);
        regrid_interval[max_level] = 0;

        if (pp.contains("regrid_thresholds"))
        {
            amrex::Print() << "Using multiple regrid thresholds." << '\n';
            // As for regrid_interval, the last element is irrelevant
            pp.getarr("regrid_thresholds", regrid_thresholds, 0, max_level);
            regrid_thresholds.resize(max_level + 1);
            regrid_thresholds[max_level] = regrid_thresholds[max_level - 1];
        }
        else
        {
            amrex::Print() << "Using single regrid threshold." << '\n';
            double regrid_threshold = NAN;
            pp.load("regrid_threshold", regrid_threshold, 0.5);
            regrid_thresholds =
                amrex::Vector<double>(max_level + 1, regrid_threshold);
        }

        // time stepping outputs and regrid data
        pp.load("checkpoint_interval", checkpoint_interval, 1);
        pp.load("plot_interval", plot_interval, 0);
        pp.load("stop_time", stop_time, 1.0);
        pp.load("max_steps", max_steps, 1000000);
        // alias the weird chombo names to something more descriptive
        // for these box params, and default to some reasonable values
        if (pp.contains("max_grid_size"))
        {
            pp.load("max_grid_size", max_grid_size);
        }
        else
        {
            pp.load("max_box_size", max_grid_size, 64);
        }
        if (pp.contains("block_factor"))
        {
            pp.load("block_factor", block_factor);
        }
        else
        {
            pp.load("min_box_size", block_factor, 8);
        }

        if (pp.contains("check_params"))
        {
            just_check_params = true;
        }

        pp.load("print_progress_only_to_rank_0", print_progress_only_to_rank_0,
                false);
    }

    void read_filesystem_params(GRParmParse &pp)
    {
        // In this function, cannot use default value - it may print a 'default
        // message' to pout and a 'setPoutBaseName' must happen before
        restart_from_checkpoint = pp.contains("restart_file");

#ifdef AMREX_USE_MPI
        // Again, cannot use default value
        if (pp.contains("pout_prefix"))
        {
            pp.load("pout_prefix", pout_prefix);
        }
        else
        {
            pout_prefix = "pout";
        }
#endif

        std::string default_path;
        if (pp.contains("output_path"))
        {
            pp.load("output_path", output_path);
        }
        else
        {
            output_path = default_path;
        }

#ifdef AMREX_USE_MPI
        // user sets the 'subpath', we prepend 'output_path'
        if (pp.contains("pout_subpath"))
        {
            pp.load("pout_subpath", pout_path);
        }
        else
        {
            pout_path = default_path;
        }
#endif

        // add backslash to paths
        if (!output_path.empty() && output_path.back() != '/')
        {
            output_path += "/";
        }
#ifdef AMREX_USE_MPI
        if (!pout_path.empty() && pout_path.back() != '/')
        {
            pout_path += "/";
        }
#endif
#if 0 
        if (!hdf5_path.empty() && hdf5_path.back() != '/')
            hdf5_path += "/";
#endif

        if (output_path != "./" && !output_path.empty())
        {
#ifdef AMREX_USE_MPI
            pout_path = output_path + pout_path;
#endif
        }

#ifdef AMREX_USE_MPI
        // change pout base name!
        if (!FilesystemTools::directory_exists(pout_path))
        {
            FilesystemTools::mkdir_recursive(pout_path);
        }
        // xxxxx setPoutBaseName(pout_path + pout_prefix);
#endif

        // only create hdf5 directory in setupAMRObject (when it becomes needed)
    }

    // NOLINTBEGIN(readability-function-cognitive-complexity)
    void read_grid_params(GRParmParse &pp)
    {
        // Grid N
        std::array<int, AMREX_SPACEDIM> Ni_full{};
        std::array<int, AMREX_SPACEDIM> Ni{};
        ivN = amrex::IntVect::TheUnitVector();

        // cannot contain both
        if ((pp.contains("N_full") && pp.contains("N")))
        {
            amrex::Abort("Please only provide 'N' or 'N_full', not both");
        }

        int N_full = -1;
        int N      = -1;
        if (pp.contains("N_full"))
        {
            pp.load("N_full", N_full);
        }
        else if (pp.contains("N"))
        {
            pp.load("N", N);
        }

        // read all options (N, N_full, Ni_full and Ni) and then choose
        // accordingly
        FOR (dir)
        {
            std::string name      = ("N" + std::to_string(dir + 1));
            std::string name_full = ("N" + std::to_string(dir + 1) + "_full");
            Ni_full[dir]          = -1;
            Ni[dir]               = -1;

            // only one of them exists - this passes if none of the 4 exist, but
            // that is asserted below
            // NOLINTBEGIN(readability-simplify-boolean-expr)
            if (!((N_full > 0 || N > 0) && !pp.contains(name.c_str()) &&
                  !pp.contains(name_full.c_str())) &&
                !((N_full < 0 && N < 0) && !(pp.contains(name.c_str()) &&
                                             pp.contains(name_full.c_str()))))
            // NOLINTEND(readability-simplify-boolean-expr)
            {
                error("Please provide 'N' or 'N_full' or a set of "
                      "'N1/N1_full', 'N2/N2_full', 'N3/N3_full'");
            }

            if (N_full < 0 && N < 0)
            {
                if (pp.contains(name_full.c_str()))
                {
                    pp.load(name_full.c_str(), Ni_full[dir]);
                }
                else
                {
                    pp.load(name.c_str(), Ni[dir]);
                }
            }
            if (N < 0 && N_full < 0 && Ni[dir] < 0 && Ni_full[dir] < 0)
            { // sanity check
                error("Please provide 'N' or 'N_full' or a set of "
                      "'N1/N1_full', 'N2/N2_full', 'N3/N3_full'");
            }

            if (N_full > 0)
            {
                Ni_full[dir] = N_full;
            }
            else if (N > 0)
            {
                Ni[dir] = N;
            }

            if (Ni[dir] > 0)
            {
                if (boundary_params.lo_boundary[dir] ==
                        BoundaryConditions::REFLECTIVE_BC ||
                    boundary_params.hi_boundary[dir] ==
                        BoundaryConditions::REFLECTIVE_BC)
                {

                    Ni_full[dir] = Ni[dir] * 2;
                }
                else
                {
                    Ni_full[dir] = Ni[dir];
                }
            }
            else
            {
                if (boundary_params.lo_boundary[dir] ==
                        BoundaryConditions::REFLECTIVE_BC ||
                    boundary_params.hi_boundary[dir] ==
                        BoundaryConditions::REFLECTIVE_BC)
                {
                    check_parameter("N" + std::to_string(dir) + "_full",
                                    Ni_full[dir], Ni_full[dir] % 2 == 0,
                                    "must be a multiple of 2");

                    Ni[dir] = Ni_full[dir] / 2;
                }
                else
                {
                    Ni[dir] = Ni_full[dir];
                }
            }
            ivN[dir] = Ni[dir] - 1;
        }
        int max_N_full = *std::max_element(Ni_full.begin(), Ni_full.end());
        int max_N      = ivN.max() + 1;

        // Grid L
        // cannot contain both
        if ((pp.contains("L_full") && pp.contains("L")))
        {
            error("Please only provide 'L' or 'L_full', not both");
        }

        double L_full = -1.;
        if (pp.contains("L_full"))
        {
            pp.load("L_full", L_full);
        }
        else
        {
            pp.load("L", L, 1.0);
        }

        if (L_full > 0.)
        {
            // necessary for some reflective BC cases, as 'L' is the
            // length of the longest side of the box
            L = (L_full * max_N) / max_N_full;
        }

        coarsest_dx = L / max_N;
        coarsest_dt = coarsest_dx * dt_multiplier;

        // grid spacing params
        dx.fill(coarsest_dx);
        origin.fill(coarsest_dx / 2.0);

        // These aren't parameters but used in parameter checks
        FOR (idir)
        {
            reflective_domain_lo[idir] = ((boundary_params.lo_boundary[idir] ==
                                           BoundaryConditions::REFLECTIVE_BC)
                                              ? -1.0
                                              : 0.0) *
                                         (ivN[idir] + 1) * coarsest_dx;
            reflective_domain_hi[idir] = ((boundary_params.hi_boundary[idir] ==
                                           BoundaryConditions::REFLECTIVE_BC)
                                              ? 2.0
                                              : 1.0) *
                                         (ivN[idir] + 1) * coarsest_dx;
        }

        // First work out the default center ignoring reflective BCs
        // but taking into account different grid lengths in each direction
        std::array<double, AMREX_SPACEDIM> default_center{};
#if AMREX_SPACEDIM == 3
        default_center = {0.5 * Ni[0] * coarsest_dx, 0.5 * Ni[1] * coarsest_dx,
                          0.5 * Ni[2] * coarsest_dx};
#elif AMREX_SPACEDIM == 2
        default_center = {0.5 * Ni[0] * coarsest_dx, 0.5 * Ni[1] * coarsest_dx};
#endif
        // Now take into account reflective BCs
        FOR (idir)
        {
            if ((boundary_params.lo_boundary[idir] ==
                 BoundaryConditions::REFLECTIVE_BC) &&
                (boundary_params.hi_boundary[idir] !=
                 BoundaryConditions::REFLECTIVE_BC))
            {
                default_center[idir] = 0.;
            }
            else if ((boundary_params.hi_boundary[idir] ==
                      BoundaryConditions::REFLECTIVE_BC) &&
                     (boundary_params.lo_boundary[idir] !=
                      BoundaryConditions::REFLECTIVE_BC))
            {
                default_center[idir] = coarsest_dx * Ni[idir];
            }
        }

        pp.load("center", center, default_center); // default to center
    }
    // NOLINTEND(readability-function-cognitive-complexity)

    void check_params()
    {
        check_parameter("L", L, L > 0.0, "must be > 0.0");
        check_parameter("max_level", max_level, max_level >= 0, "must be >= 0");
        check_parameter("max_spatial_derivative_order",
                        max_spatial_derivative_order,
                        max_spatial_derivative_order == 4 ||
                            max_spatial_derivative_order == 6,
                        "only 4 and 6 are supported");
        // the following check assumes you will be taking one-sided derivatives
        // of the order given by max_spatial_derivative_order
        check_parameter(
            "num_ghosts", num_ghosts,
            (num_ghosts >= ((max_spatial_derivative_order == 6) ? 4 : 3)) &&
                (num_ghosts <= block_factor),
            "must be >= 3 (4th order derivatives) or 4 (6th order derivatives) "
            "and <= min_box_size (aka block_factor)");
        check_parameter("tag_buffer_size", tag_buffer_size,
                        tag_buffer_size >= 0, "must be >= 0");
        // assume ref_ratio is always 2
        check_parameter(
            "grid_buffer_size", grid_buffer_size,
            grid_buffer_size >= ceil(num_ghosts / 2.0),
            "must be >= ceil(num_ghosts/max_ref_ratio) for proper nesting");

        // check the restart_file exists and can be read if restarting from a
        // checkpoint
#if 0 // TODO
        if (restart_from_checkpoint)
        {
            bool restart_file_exists =
                (access((restart_file).c_str(), R_OK) == 0);
            check_parameter("restart_file", restart_file, restart_file_exists,
                            "file cannot be opened for reading");
        }
#endif

        check_parameter("dt_multiplier", dt_multiplier, dt_multiplier > 0.0,
                        "must be > 0.0");
        check_parameter("max_grid_size/max_box_size", max_grid_size,
                        max_grid_size >= 0, "must be >= 0");
        check_parameter("block_factor/min_box_size", block_factor,
                        block_factor >= 1, "must be >= 1");
        //        check_parameter("block_factor/min_box_size", block_factor,
        // xxxxx                        Misc::isPower2(block_factor), "must be a
        // power of 2");
        // note that this also enforces block_factor <= max_grid_size
        // if max_grid_size > 0
        check_parameter("block_factor/min_box_size", block_factor,
                        max_grid_size % block_factor == 0,
                        "must divide max_grid_size/max_box_size = " +
                            std::to_string(max_grid_size));
        FOR (idir)
        {
            std::string Ni_string       = "N" + std::to_string(idir + 1);
            std::string invalid_message = "must divide " + Ni_string;
            if (boundary_params.reflective_boundaries_exist)
            {
                invalid_message += " (or " + Ni_string + "_full/2)";
            }
            invalid_message += " = " + std::to_string(ivN[idir] + 1);
            check_parameter("block_factor/min_box_size", block_factor,
                            (ivN[idir] + 1) % block_factor == 0,
                            invalid_message);
        }
        check_parameter("fill_ratio", fill_ratio,
                        (fill_ratio > 0.0) && (fill_ratio <= 1.0),
                        "must be > 0 and <= 1");

        check_parameter("output_path", output_path,
                        FilesystemTools::directory_exists(output_path),
                        "should be a valid directory");
        // pout directory exists - we create it in read_filesystem_params()
        // can't check hdf5 directory yet - only created after
    }

    void set_amrex_params()
    {
        // Set up parameters for AMReX
        {
            amrex::ParmParse pp("geometry");

            amrex::Vector<double> prob_extent(AMREX_SPACEDIM);
            int nmax = ivN.max() + 1;
            for (int i = 0; i < AMREX_SPACEDIM; ++i)
            {
                prob_extent[i] = L * (static_cast<double>(ivN[i] + 1) /
                                      static_cast<double>(nmax));
            }
            pp.addarr("prob_extent", prob_extent);

            amrex::Vector<int> is_periodic(AMREX_SPACEDIM);
            for (int i = 0; i < AMREX_SPACEDIM; ++i)
            {
                is_periodic[i] =
                    static_cast<int>(boundary_params.is_periodic[i]);
            }
            pp.addarr("is_periodic", is_periodic);
        }
        {
            amrex::ParmParse pp("amr");
            pp.add("v", verbosity);
            pp.add("max_level", max_level);
            pp.add("n_error_buf", tag_buffer_size);
            pp.add("ref_ratio", 2);
            pp.add("max_grid_size", max_grid_size);
            pp.add("blocking_factor", block_factor);
            pp.addarr("n_cell",
                      std::vector<int>{ivN[0] + 1, ivN[1] + 1, ivN[2] + 1});
            pp.addarr("regrid_int", regrid_interval);
            pp.add("check_int", checkpoint_interval);
            pp.add("plot_int", plot_interval);
        }
    }

    // General parameters
    int verbosity{};
    double L{}; // Physical sidelength of the grid
    std::array<double, AMREX_SPACEDIM> center{}; // grid center
    amrex::IntVect ivN; // The number of grid cells in each dimension
    double coarsest_dx{},
        coarsest_dt{}; // The coarsest resolution in space and time
    int max_level{};   // the max number of regriddings to do
    int max_spatial_derivative_order{}; // The maximum order of the spatial
                                        // derivatives - does nothing
                                        // in Chombo but can be used in examples
    int num_ghosts{};       // min dependent on max_spatial_derivative_order
    int tag_buffer_size{};  // Amount the tagged region is grown by
    int grid_buffer_size{}; // Number of cells between level
    amrex::Vector<int> ref_ratios; // ref ratios between levels
    // boundaries.
    amrex::Vector<int> regrid_interval; // steps between regrid at each level
    int max_steps{};
    bool restart_from_checkpoint{}; // whether or not to restart or start afresh
    double dt_multiplier{}, stop_time{}; // The Courant factor and stop time
    int checkpoint_interval{}, plot_interval{}; // Steps between outputs
    int max_grid_size{}, block_factor{};        // max and min box sizes
    double fill_ratio{}; // determines how fussy the regridding is about tags
    std::string output_path; // base path to use for all files
#ifdef AMREX_USE_MPI
    std::string pout_prefix; // pout file prefix
    std::string pout_path;   // base path for pout files
#endif

    std::array<double, AMREX_SPACEDIM> origin{},
        dx{}; // location of coarsest origin and dx

    // Boundary conditions
    BoundaryConditions::params_t boundary_params; // set boundaries in each dir

    // For tagging
    amrex::Vector<double> regrid_thresholds;

    // For checking parameters and then exiting rather before instantiating
    // GRAMR (or child) object
    bool just_check_params = false;
    bool print_progress_only_to_rank_0{};

  protected:
    // the low and high corners of the domain taking into account reflective BCs
    // only used in parameter checks hence protected
    std::array<double, AMREX_SPACEDIM> reflective_domain_lo{},
        reflective_domain_hi{};

    // use this error function instead of MayDay::error as this will only
    // print from rank 0
    static void error(const std::string &a_error_message)
    {
        if (amrex::ParallelDescriptor::MyProc() == 0)
        {
            amrex::Abort(a_error_message.c_str());
        }
    }

    template <typename T>
    void check_parameter(const std::string &a_name, const T &a_value,
                         const bool a_valid,
                         const std::string &a_invalid_explanation)
    {
        if (a_valid)
        {
            return;
        }
        std::ostringstream error_message_ss;
        error_message_ss << "Parameter: " << a_name << " = " << a_value
                         << " is invalid: " << a_invalid_explanation;
        error(error_message_ss.str());
    }

    template <typename T>
    void warn_parameter(const std::string &a_name, T a_value,
                        const bool a_nowarn,
                        const std::string &a_warning_explanation)
    {
        if (a_nowarn)
        {
            return;
        }
        // only print the warning from rank 0
        if (amrex::ParallelDescriptor::MyProc() == 0)
        {
            std::ostringstream warning_message_ss;
            warning_message_ss << "Parameter: " << a_name << " = " << a_value
                               << " warning: " << a_warning_explanation;
            amrex::Warning(warning_message_ss.str().c_str());
        }
    }

    template <typename T, size_t N>
    void check_array_parameter(const std::string &a_name,
                               const std::array<T, N> &a_value,
                               const bool a_valid,
                               const std::string &a_invalid_explanation)
    {
        std::string value_str = ArrayTools::to_string(a_value);
        check_parameter(a_name, value_str, a_valid, a_invalid_explanation);
    }

    template <typename T, size_t N>
    void warn_array_parameter(const std::string &a_name,
                              const std::array<T, N> &a_value,
                              const bool a_nowarn,
                              const std::string &a_warning_explanation)
    {
        std::string value_str = ArrayTools::to_string(a_value);
        check_parameter(a_name, value_str, a_nowarn, a_warning_explanation);
    }
};

#endif /* CHOMBOPARAMETERS_HPP_ */



================================================
FILE: Source/GRTeclynCore/ArrayTools.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef ARRAYTOOLS_HPP
#define ARRAYTOOLS_HPP

#include <algorithm>
#include <array>
#include <string>
#include <type_traits>
#include <vector>

/// A place for tools that operate on std::arrays and std::vectors
namespace ArrayTools
{
/// This just concantenates two arrays together.
/// MR: I have no idea why this or something similar isn't in the standard
/// library
template <typename T, size_t N, size_t M>
std::array<T, N + M> concatenate(const std::array<T, N> &first,
                                 const std::array<T, M> &second)
{
    std::array<T, N + M> out;
    std::copy(first.cbegin(), first.cend(), out.begin());
    std::copy(second.cbegin(), second.cend(), out.begin() + N);
    return out;
}

/// This can concatenate two std::vectors or amrex::Vectors
template <template <typename, typename> class vec_t, typename elem_t,
          typename alloc_t,
          typename = std::enable_if_t<std::is_base_of_v<
              std::vector<elem_t, alloc_t>, vec_t<elem_t, alloc_t>>>>
vec_t<elem_t, alloc_t> concatenate(const vec_t<elem_t, alloc_t> &first,
                                   const vec_t<elem_t, alloc_t> &second)
{
    vec_t<elem_t, alloc_t> out(first.size() + second.size());
    std::copy(first.cbegin(), first.cend(), out.begin());
    std::copy(second.cbegin(), second.cend(), out.begin() + first.size());
    return out;
}

template <typename T, size_t N,
          std::enable_if_t<std::is_arithmetic_v<T>, bool> = true>
T norm2(const std::array<T, N> &a_array)
{
    T out = 0;
    for (auto &elem : a_array)
    {
        out += elem * elem;
    }
    return out;
}

template <typename T, size_t N,
          std::enable_if_t<std::is_arithmetic_v<T>, bool> = true>
std::string to_string(const std::array<T, N> a_array)
{
    std::string out;
    for (auto x : a_array)
    {
        out += std::to_string(x) + " ";
    }
    out += std::to_string(a_array[N - 1]);
    return out;
}

// SFINAE for std::arrays and std::vectors
template <typename T> struct is_std_array_or_vector : std::false_type
{
};

template <typename elem_t>
struct is_std_array_or_vector<std::vector<elem_t>> : std::true_type
{
};

template <typename elem_t, std::size_t N>
struct is_std_array_or_vector<std::array<elem_t, N>> : std::true_type
{
};
} // namespace ArrayTools

#endif /* ARRAYTOOLS_HPP */



================================================
FILE: Source/GRTeclynCore/DefaultLevelFactory.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef DEFAULTLEVELFACTORY_HPP_
#define DEFAULTLEVELFACTORY_HPP_

#include <AMReX_LevelBld.H>

template <class level_t> class DefaultLevelFactory : public amrex::LevelBld
{
  public:
    void variableSetUp() override;
    void variableCleanUp() override;
    amrex::AmrLevel *operator()() override;
    amrex::AmrLevel *
    operator()(amrex::Amr &papa, int lev, const amrex::Geometry &level_geom,
               const amrex::BoxArray &box_array,
               const amrex::DistributionMapping &distribution_mapping,
               amrex::Real time) override;
};

template <class level_t> void DefaultLevelFactory<level_t>::variableSetUp()
{
    level_t::variableSetUp();
}

template <class level_t> void DefaultLevelFactory<level_t>::variableCleanUp()
{
    level_t::variableCleanUp();
}

template <class level_t>
amrex::AmrLevel *DefaultLevelFactory<level_t>::operator()()
{
    // NOLINTNEXTLINE(cppcoreguidelines-owning-memory)
    return new level_t;
}

template <class level_t>
amrex::AmrLevel *DefaultLevelFactory<level_t>::operator()(
    amrex::Amr &papa, int lev, const amrex::Geometry &level_geom,
    const amrex::BoxArray &box_array,
    const amrex::DistributionMapping &distribution_mapping, amrex::Real time)
{
    // NOLINTNEXTLINE(cppcoreguidelines-owning-memory)
    return new level_t(papa, lev, level_geom, box_array, distribution_mapping,
                       time);
}

#endif /* DEFAULTLEVELFACTORY_HPP_ */



================================================
FILE: Source/GRTeclynCore/GRAMR.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#include "GRAMR.hpp"
#include "GRAMRLevel.hpp"
#include "SimulationParameters.hpp"

// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
const SimulationParameters *GRAMR::m_sim_params = nullptr;

GRAMR::GRAMR(amrex::LevelBld *a_levelbld) : amrex::Amr(a_levelbld) {}

GRAMR::~GRAMR() = default;

void GRAMR::set_simulation_parameters(const SimulationParameters &a_sim_params)
{
    m_sim_params = &a_sim_params;
}

const SimulationParameters &GRAMR::get_simulation_parameters()
{
    return *m_sim_params;
}

void GRAMR::init(amrex::Real a_strt_time, amrex::Real a_stop_time)
{
    amrex::Amr::init(a_strt_time, a_stop_time);

    m_start_walltime = amrex::second();
}

double GRAMR::get_walltime_since_start() const
{
    return amrex::second() - m_start_walltime;
}

double GRAMR::get_restart_time() const { return m_restart_time; }

void GRAMR::set_restart_time(double a_restart_time)
{
    m_restart_time = a_restart_time;
}


================================================
FILE: Source/GRTeclynCore/GRAMR.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef GRAMR_HPP_
#define GRAMR_HPP_

// xxxxx#include "Lagrange.hpp"
#include "VariableType.hpp"
#include <AMReX_Amr.H>
#include <algorithm>
#include <chrono>
#include <ratio>
#include <vector>

/// A child of AMReX's AMR class to interface with tools which require
/// access to the whole AMR hierarchy
/**
 *It is necessary for many experimental features and allows us to
 *add said features later without breaking any user code.
 */

// Forward declaration for get_gramrlevels function declarations
class GRAMRLevel;

class SimulationParameters;

// NOLINTNEXTLINE(cppcoreguidelines-special-member-functions)
class GRAMR : public amrex::Amr
{
    friend class GRAMRLevel;

  public:

    GRAMR(amrex::LevelBld *a_levelbld);
    ~GRAMR() override;

    void init(amrex::Real a_strt_time, amrex::Real a_stop_time) override;

    static void
    set_simulation_parameters(const SimulationParameters &a_sim_params);
    static const SimulationParameters &get_simulation_parameters();

    double get_walltime_since_start() const;

    double get_restart_time() const;

  private:
    // NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
    static const SimulationParameters *m_sim_params;

    void set_restart_time(double a_restart_time);

    double m_start_walltime{std::nan("0.0")};
    double m_restart_time{0.0};
};

#endif /* GRAMR_HPP_ */



================================================
FILE: Source/GRTeclynCore/GRAMRLevel.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#include "GRAMRLevel.hpp"
#include "NullBCFill.hpp"

void GRAMRLevel::stateVariableSetUp()
{
    const int nghost = simParams().num_ghosts;
    desc_lst.addDescriptor(State_Type, amrex::IndexType::TheCellType(),
                           amrex::StateDescriptor::Point, nghost, NUM_VARS,
                           &amrex::cell_quartic_interp);

    BoundaryConditions::params_t bparms = simParams().boundary_params;
    BoundaryConditions boundary_conditions;
    boundary_conditions.define(simParams().center, bparms,
                               amrex::DefaultGeometry(), nghost);

    amrex::Vector<amrex::BCRec> bcs(NUM_VARS);
    for (int icomp = 0; icomp < NUM_VARS; ++icomp)
    {
        auto &bc = bcs[icomp];
        for (amrex::OrientationIter oit; oit.isValid(); ++oit)
        {
            amrex::Orientation face = oit();
            const int idim          = face.coordDir();
            const int bctype = boundary_conditions.get_boundary_condition(face);
            if (amrex::DefaultGeometry().isPeriodic(idim))
            {
                bc.set(face, amrex::BCType::int_dir);
            }
            else if (bctype == BoundaryConditions::STATIC_BC ||
                     bctype == BoundaryConditions::SOMMERFELD_BC ||
                     bctype == BoundaryConditions::MIXED_BC)
            {
                bc.set(face, amrex::BCType::foextrap);
            }
            else if (bctype == BoundaryConditions::REFLECTIVE_BC)
            {
                int parity =
                    BoundaryConditions::get_state_var_parity(icomp, idim);
                if (parity == 1)
                {
                    bc.set(face, amrex::BCType::reflect_even);
                }
                else
                {
                    bc.set(face, amrex::BCType::reflect_odd);
                }
            }
            else if (bctype == BoundaryConditions::EXTRAPOLATING_BC)
            {
                amrex::Abort("xxxxx EXTRAPOLATING_BC todo");
            }
            else
            {
                amrex::Abort("Unknow BC type " + std::to_string(bctype));
            }
        }
    }

    amrex::StateDescriptor::BndryFunc bndryfunc(null_bc_fill);
    bndryfunc.setRunOnGPU(true); // Run the bc function on gpu.

    desc_lst.setComponent(State_Type, 0, StateVariables::names, bcs, bndryfunc);
}

void GRAMRLevel::variableCleanUp()
{
    desc_lst.clear();
    derive_lst.clear();
}

GRAMRLevel::GRAMRLevel() = default;

GRAMRLevel::GRAMRLevel(amrex::Amr &papa, int lev, const amrex::Geometry &geom,
                       const amrex::BoxArray &box_array,
                       const amrex::DistributionMapping &distribution_mapping,
                       amrex::Real time)
    : amrex::AmrLevel(papa, lev, geom, box_array, distribution_mapping, time),
      m_num_ghosts(simParams().num_ghosts)
{

    m_boundaries.define(simParams().center, simParams().boundary_params, geom,
                        m_num_ghosts);
}

GRAMRLevel::~GRAMRLevel() = default;

const SimulationParameters &GRAMRLevel::simParams()
{
    return GRAMR::get_simulation_parameters();
}

GRAMR *GRAMRLevel::get_gramr_ptr()
{
    if (m_gramr_ptr == nullptr)
    {
        if (parent == nullptr)
        {
            amrex::Abort("AmrLevel::parent is null");
        }
        m_gramr_ptr = dynamic_cast<GRAMR *>(parent);
    }
    return m_gramr_ptr;
}

void GRAMRLevel::computeInitialDt(
    int finest_level, int /*sub_cycle*/, amrex::Vector<int> & /*n_cycle*/,
    const amrex::Vector<amrex::IntVect> & /*ref_ratio*/,
    amrex::Vector<amrex::Real> &dt_level, amrex::Real /*stop_time*/)
{
    // Level 0 will do it for all levels
    if (Level() == 0)
    {
        double dt_multiplier = simParams().dt_multiplier;
        for (int i = 0; i <= finest_level; ++i)
        {
            dt_level[i] = dt_multiplier * parent->Geom(i).CellSize(0);
        }
    }
}

void GRAMRLevel::computeNewDt(
    int finest_level, int /*sub_cycle*/, amrex::Vector<int> & /*n_cycle*/,
    const amrex::Vector<amrex::IntVect> & /*ref_ratio*/,
    amrex::Vector<amrex::Real> &dt_min, amrex::Vector<amrex::Real> &dt_level,
    amrex::Real /*stop_time*/, int /*post_regrid_flag*/)
{
    // This is called at the end of a coarse time step
    // Level 0 will do it for all levels
    if (Level() == 0)
    {
        double dt_multiplier = simParams().dt_multiplier;
        for (int i = 0; i <= finest_level; ++i)
        {
            dt_min[i] = dt_level[i] =
                dt_multiplier * parent->Geom(i).CellSize(0);
        }
    }
}

amrex::Real GRAMRLevel::advance(amrex::Real time, amrex::Real dt, int iteration,
                                int ncycle)
{
    BL_PROFILE("GRAMRLevel::advance()");
    double seconds_per_hour = 3600;
    double evolution_speed  = (time - get_gramr_ptr()->get_restart_time()) *
                             seconds_per_hour /
                             get_gramr_ptr()->get_walltime_since_start();
    amrex::Print() << "[Level " << Level() << " step "
                   << parent->levelSteps(Level()) + 1
                   << "] average evolution speed = " << evolution_speed
                   << " code units/h\n";

    for (int k = 0; k < NUM_STATE_TYPE; k++)
    {
        state[k].allocOldData();
        state[k].swapTimeLevels(dt);
    }

    amrex::AmrLevel::RK(
        4, State_Type, time, dt, iteration, ncycle,
        [&](int /*stage*/, amrex::MultiFab &rhs, const amrex::MultiFab &soln,
            amrex::Real t, amrex::Real /*dtsub*/)
        {
            // NOLINTNEXTLINE(cppcoreguidelines-pro-type-const-cast)
            specificEvalRHS(const_cast<amrex::MultiFab &>(soln), rhs, t);
            m_boundaries.apply_sommerfeld_boundaries(rhs, soln);
        },
        [&](int /*stage*/, amrex::MultiFab &soln) { specificUpdateODE(soln); });

    specificAdvance();

    return dt;
}

void GRAMRLevel::post_timestep(int /*iteration*/)
{
    BL_PROFILE("GRAMRLevel::post_timestep()");
    const int lev = Level();
    if (lev < parent->finestLevel())
    {
        auto &fine_level        = parent->getLevel(Level() + 1);
        amrex::MultiFab &S_fine = fine_level.get_new_data(State_Type);
        amrex::MultiFab &S_crse = this->get_new_data(State_Type);
        amrex::Real t           = get_state_data(State_Type).curTime();

        amrex::IntVect ratio = parent->refRatio(lev);
        AMREX_ASSERT(ratio == 2 || ratio == 4);
        if (ratio == 2)
        {
            // Need to fill one ghost cell for the high-order interpolation
            // below
            FillPatch(fine_level, S_fine, 1, t, State_Type, 0, S_fine.nComp());
        }

        FourthOrderInterpFromFineToCoarse(S_crse, 0, NUM_VARS, S_fine, ratio);
    }
    if (simParams().nan_check)
    {
        amrex::MultiFab &state_new = get_new_data(State_Type);
        if (state_new.contains_nan(0, state_new.nComp(), amrex::IntVect(0),
                                   true))
        {
            amrex::Abort("NaN in GRAMRLevel::post_timestep");
        }
    }

    specificPostTimeStep();
}

void GRAMRLevel::post_regrid(int a_lbase, int a_new_finest)
{
    specific_post_regrid(a_lbase, a_new_finest);
}

void GRAMRLevel::post_init(amrex::Real /*stop_time*/)
{
    if (Level() == 0)
    {
        get_gramr_ptr()->set_restart_time(get_gramr_ptr()->cumTime());
    }
    specific_post_init();
}

void GRAMRLevel::post_restart()
{
    if (Level() == 0)
    {
        get_gramr_ptr()->set_restart_time(get_gramr_ptr()->cumTime());
    }
    specific_post_restart();
}

void GRAMRLevel::init(amrex::AmrLevel &old)
{
    BL_PROFILE("GRAMRLevel::init()");
    amrex::Real dt_new    = parent->dtLevel(level);
    amrex::Real cur_time  = old.get_state_data(State_Type).curTime();
    amrex::Real prev_time = old.get_state_data(State_Type).prevTime();
    amrex::Real dt_old    = cur_time - prev_time;
    setTimeLevel(cur_time, dt_old, dt_new);

    amrex::MultiFab &S_new = get_new_data(State_Type);
    FillPatch(old, S_new, 0, cur_time, State_Type, 0, S_new.nComp());
}

void GRAMRLevel::init()
{
    BL_PROFILE("GRAMRLevel::init()");
    amrex::Real dt = parent->dtLevel(level);
    const auto &coarse_state =
        parent->getLevel(level - 1).get_state_data(State_Type);
    amrex::Real cur_time  = coarse_state.curTime();
    amrex::Real prev_time = coarse_state.prevTime();
    amrex::Real dt_old =
        (cur_time - prev_time) /
        static_cast<amrex::Real>(parent->MaxRefRatio(level - 1));
    setTimeLevel(cur_time, dt_old, dt);

    amrex::MultiFab &S_new = get_new_data(State_Type);
    FillCoarsePatch(S_new, 0, cur_time, State_Type, 0, S_new.nComp());
}

void GRAMRLevel::errorEst(amrex::TagBoxArray &a_tag_box_array,
                          int /*a_clearval*/, int /*a_tagval*/,
                          amrex::Real /*a_time*/, int /*a_n_error_buf*/,
                          int /*a_ngrow*/)
{
    BL_PROFILE("GRAMRLevel::errorEst()");

    pre_tag_cells();

    // It is up to the derived class to use regrid_threshold in tag_cells()
    amrex::Real regrid_threshold = simParams().regrid_thresholds[Level()];
    tag_cells(a_tag_box_array, regrid_threshold);
}

void GRAMRLevel::writePlotFilePre(const std::string &a_dir, std::ostream &a_os)
{
    specific_pre_plotfile(a_dir, a_os);
}

void GRAMRLevel::writePlotFilePost(const std::string &a_dir, std::ostream &a_os)
{
    specific_post_plotfile(a_dir, a_os);
}

void GRAMRLevel::checkPointPre(const std::string &a_dir, std::ostream &a_os)
{
    specific_pre_checkpoint(a_dir, a_os);
}

void GRAMRLevel::checkPointPost(const std::string &a_dir, std::ostream &a_os)
{
    specific_post_checkpoint(a_dir, a_os);
}

bool GRAMRLevel::at_level_timestep_multiple(int a_level)
{
    // handle both the case a_level < Level() and a_level >= Level()
    int coarser_level     = std::min(a_level, Level());
    int finer_level       = std::max(a_level, Level());
    int finer_level_steps = get_gramr_ptr()->levelSteps(finer_level);

    // work out what the coarser level step number corresponds to on the finer
    // level
    int coarser_level_steps_at_finer_level =
        get_gramr_ptr()->levelSteps(coarser_level);

    for (int ilev = coarser_level + 1; ilev <= finer_level; ++ilev)
    {
        coarser_level_steps_at_finer_level *= get_gramr_ptr()->nCycle(ilev);
    }
    // finer_level_steps will be > coarser_level_steps
    return (finer_level_steps == coarser_level_steps_at_finer_level);
}


================================================
FILE: Source/GRTeclynCore/GRAMRLevel.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef GRAMRLEVEL_HPP_
#define GRAMRLEVEL_HPP_

// Other includes
#include "BoundaryConditions.hpp"
#include "GRAMR.hpp"
// xxxxx#include "InterpSource.hpp"
#include "SimulationParameters.hpp"
#include "StateVariables.hpp" // need NUM_VARS

#include <AMReX_AmrLevel.H>

#include <fstream>
#include <limits>
#include <sys/time.h>

enum StateType
{
    State_Type = 0,
    NUM_STATE_TYPE
};

// NOLINTNEXTLINE(cppcoreguidelines-special-member-functions)
class GRAMRLevel : public amrex::AmrLevel
{
  public:
    /**
     * \brief Set up the state variables from StateVariables.hpp.
     * This should be called by the child's variableSetUp().
     */
    static void stateVariableSetUp();

    static void variableCleanUp();

    GRAMRLevel();

    GRAMRLevel(amrex::Amr &papa, int lev, const amrex::Geometry &geom,
               const amrex::BoxArray &box_array,
               const amrex::DistributionMapping &distribution_mapping,
               amrex::Real time);

    ~GRAMRLevel() override;

    static const SimulationParameters &simParams();

    GRAMR *get_gramr_ptr();

    /**
     * \brief Compute the initial time step.
     */
    void computeInitialDt(int finest_level, int sub_cycle,
                          amrex::Vector<int> &n_cycle,
                          const amrex::Vector<amrex::IntVect> &ref_ratio,
                          amrex::Vector<amrex::Real> &dt_level,
                          amrex::Real stop_time) override;
    /**
     * \brief Compute the next time step.
     */
    void computeNewDt(int finest_level, int sub_cycle,
                      amrex::Vector<int> &n_cycle,
                      const amrex::Vector<amrex::IntVect> &ref_ratio,
                      amrex::Vector<amrex::Real> &dt_min,
                      amrex::Vector<amrex::Real> &dt_level,
                      amrex::Real stop_time, int post_regrid_flag) override;
    /**
     * \brief Do an integration step on this level.  Returns maximum safe
     * time step.  This is a pure virtual function and hence MUST
     * be implemented by derived classes.
     */
    amrex::Real advance(amrex::Real time, amrex::Real dt, int iteration,
                        int ncycle) override;

    /**
     * \brief Contains operations to be done after a timestep.  This is a
     * pure virtual function and hence MUST be implemented by derived
     * classes.
     */
    void post_timestep(int iteration) override;
    /**
     * \brief Operations to be done after regridding
     * This is a pure virtual function and hence MUST be
     * implemented by derived classes.
     */
    void post_regrid(int lbase, int new_finest) override;
    /**
     * \brief Operations to be done after initialization.
     * This is a pure virtual function and hence MUST be
     * implemented by derived classes.
     */
    void post_init(amrex::Real stop_time) override;
    /**
     * \brief Operations to be done after restart.
     */
    void post_restart() override;
    /**
     * \brief Init data on this level from another AmrLevel (during regrid).
     * This is a pure virtual function and hence MUST be
     * implemented by derived classes.
     */
    void init(amrex::AmrLevel &old) override;
    /**
     * Init data on this level after regridding if old AmrLevel
     * did not previously exist. This is a pure virtual function
     * and hence MUST be implemented by derived classes.
     */
    void init() override;
    /**
     * Do error estimation/tagging for regridding
     * Most examples should not need to override this and instead override
     * pre_tag_cells() and tag_cells()
     */
    virtual void errorEst(amrex::TagBoxArray &a_tag_box_array, int a_clearval,
                          int a_tagval, amrex::Real a_time,
                          int a_n_error_buf = 0, int a_ngrow = 0) override;

    /**
     * Do any necessary work before tagging cells (e.g. calling FillPatch for
     * any variables for which derivatives are calculated).
     */
    virtual void pre_tag_cells() {}

    /**
     * Tag cells for regridding. This is a pure virtual function and hence MUST
     * be implemented by derived classes.
     */
    virtual void tag_cells(amrex::TagBoxArray &a_tag_box_array,
                           amrex::Real a_regrid_threshold) = 0;

    //! Do pre-plotfile work
    void writePlotFilePre(const std::string &dir,
                          std::ostream & /*os*/) override;

    //! Do post-plotfile work
    void writePlotFilePost(const std::string &dir,
                           std::ostream & /*os*/) override;

    //! Do pre-checkpoint work
    void checkPointPre(const std::string &a_dir, std::ostream &a_os) override;

    //! Do post-checkpoint work
    void checkPointPost(const std::string &a_dir, std::ostream &a_os) override;

    /// Virtual function for the problem specific parts of Advance
    virtual void specificAdvance() {}

    /// Virtual function for the problem specific parts of postTimeStep
    virtual void specificPostTimeStep() {}

    virtual void specificEvalRHS(amrex::MultiFab &a_soln,
                                 amrex::MultiFab &a_rhs,
                                 const double a_time) = 0;

    virtual void specificUpdateODE(amrex::MultiFab & /*a_soln*/) {}

    //! Problem specific post restart
    virtual void specific_post_restart() {}

    //! Problem specific post init
    virtual void specific_post_init() {}

    //! Problem specific post-regrid
    // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
    virtual void specific_post_regrid(int a_lbase, int a_new_finest) {}

    //! Problem specific pre plotfile
    virtual void specific_pre_plotfile(const std::string &a_dir,
                                       std::ostream &a_os)
    {
    }

    //! Problem specific post plotfile
    virtual void specific_post_plotfile(const std::string &a_dir,
                                        std::ostream &a_os)
    {
    }

    //! Problem specific pre checkpoint
    virtual void specific_pre_checkpoint(const std::string &a_dir,
                                         std::ostream &a_os)
    {
    }

    //! Problem specific post checkpoint
    virtual void specific_post_checkpoint(const std::string &a_dir,
                                          std::ostream &a_os)
    {
    }

    /// Returns true if m_time is the same as the time at the end of the current
    /// timestep on level a_level and false otherwise
    /// Useful to check whether to calculate something in postTimeStep (which
    /// might only be needed at the end of a_level's timestep)
    bool at_level_timestep_multiple(int a_level);

    BoundaryConditions m_boundaries; // the class for implementing BCs

    int m_verbosity = 0; //!< Level of verbosity of the output
    int m_num_ghosts{};  //!< Number of ghost cells

  private:

    GRAMR *m_gramr_ptr = nullptr;
};

#endif /* GRAMRLEVEL_HPP_ */



================================================
FILE: Source/GRTeclynCore/GRInterval.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef GRINTERVAL_HPP_
#define GRINTERVAL_HPP_

/// A templated version of Chombo's Interval - allows compile time checking.
/**Note: iend is included in the interval, i.e. the interval <1,3> has
 * values 1,2,3 and therefore size 3.
 */
template <int ibegin, int iend> struct GRInterval
{
    static constexpr int begin() { return ibegin; }

    /// The largest component contained in the interval
    static constexpr int end() { return iend; }

    /// Returns the size of the interval
    static constexpr int size() { return iend - ibegin + 1; }

    /// Checks whether a values is in the interval (Note: the end component is
    /// also contained)
    static constexpr bool contains(int i)
    {
        return ((i > ibegin) && (i <= iend));
    }
};
#endif /* GRINTERVAL_HPP_ */



================================================
FILE: Source/GRTeclynCore/Interval.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */
#ifndef INTERVAL_H_
#define INTERVAL_H_

#include <AMReX_Extension.H>
#include <AMReX_GpuQualifiers.H>

struct Interval
{
    Interval() = default;

    // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
    Interval(int a_firstComp, int a_lastComp)
        : m_begin(a_firstComp), m_end(a_lastComp)
    {
    }

    // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
    void define(int a_firstComp, int a_lastComp)
    {
        m_begin = a_firstComp;
        m_end   = a_lastComp;
    }

    [[nodiscard]] AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE int begin() const
    {
        return m_begin;
    }

    //! return last component number
    [[nodiscard]] AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE int end() const
    {
        return m_end;
    }

    [[nodiscard]] AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE int size() const
    {
        return m_end - m_begin + 1;
    }

    [[nodiscard]] bool contains(int a_val) const
    {
        return a_val >= m_begin && a_val <= m_end;
    }

    bool operator==(const Interval &a_interval) const
    {
        return ((m_begin == a_interval.m_begin) && (m_end == a_interval.m_end));
    }

  private:
    int m_begin{0}, m_end{-1};
};

#endif



================================================
FILE: Source/GRTeclynCore/Make.package
================================================
GRTECLYN_CEXE_sources += GRAMR.cpp \
                         GRAMRLevel.cpp

GRTECLYN_CEXE_headers += AMReXParameters.hpp \
                         AlwaysInline.hpp \
                         ArrayTools.hpp \
                         DefaultLevelFactory.hpp \
                         GRAMR.hpp \
                         GRAMRLevel.hpp \
                         GRInterval.hpp \
                         Interval.hpp \
                         NullBCFill.hpp \
                         SetupFunctions.hpp \
                         SimulationParametersBase.hpp \
                         VariableType.hpp



================================================
FILE: Source/GRTeclynCore/SetupFunctions.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SETUP_FUNCTIONS_HPP_
#define SETUP_FUNCTIONS_HPP_
// This file incldues several functions that need to be called to
// set up the runs but aren't very interesting for the normal user.

// xxxxx various setups
#include "AMReXParameters.hpp"
#include "DerivativeSetup.hpp"
#include "FilesystemTools.hpp"
#include "GRAMR.hpp"
#include "GRParmParse.hpp"
#include "IntegrationMethodSetup.hpp"

#ifdef EQUATION_DEBUG_MODE
#include "DebuggingTools.hpp"
#endif

#ifdef _OPENMP
#include <omp.h>
#endif

#include <iostream>

// NOLINTBEGIN(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
/// This function calls MPI_Init
void mainSetup(int argc, char *argv[]);

/// This function calls all finalisations
void mainFinalize();

void mainSetup(int argc, char *argv[])
{
    // NOLINTEND(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
    // NOLINTNEXTLINE(bugprone-casting-through-void)
    amrex::Initialize(argc, argv);

#ifdef EQUATION_DEBUG_MODE
    EquationDebugging::check_no_omp();
    amrex::Warning("GRTeclyn is running in equation debug mode. This mode is "
                   "intended only for debugging and leads to significantly "
                   "worse performance.");
#endif

    const int required_argc = 2;
    if (argc < required_argc)
    {
        amrex::Finalize();
        std::cerr << " usage " << argv[0] << " <input_file_name> " << '\n';
        exit(0);
    }
}

void mainFinalize() { amrex::Finalize(); }

#endif /* SETUP_FUNCTIONS_HPP_ */



================================================
FILE: Source/GRTeclynCore/SimulationParametersBase.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SIMULATIONPARAMETERSBASE_HPP_
#define SIMULATIONPARAMETERSBASE_HPP_

// General includes
#include "AMReXParameters.hpp"
#include "BoundaryConditions.hpp"
#include "CCZ4RHS.hpp"
#include "GRParmParse.hpp"
#include "SphericalExtraction.hpp"
#include <limits>

// add this type alias here for backwards compatibility
using extraction_params_t = SphericalExtraction::params_t;

class SimulationParametersBase : public AMReXParameters
{
  public:
    SimulationParametersBase(GRParmParse &pp) : AMReXParameters(pp)
    {
        read_params(pp);
        check_params();
    }

  private:
    void read_params(GRParmParse &pp)
    {
        // Lapse evolution
        pp.load("lapse_advec_coeff", ccz4_params.lapse_advec_coeff, 1.0);
        pp.load("lapse_coeff", ccz4_params.lapse_coeff, 2.0);
        pp.load("lapse_power", ccz4_params.lapse_power, 1.0);

        // Shift Evolution
        pp.load("shift_advec_coeff", ccz4_params.shift_advec_coeff, 0.0);
        pp.load("shift_Gamma_coeff", ccz4_params.shift_Gamma_coeff, 0.75);
        pp.load("eta", ccz4_params.eta, 1.0);

        // CCZ4 parameters
        pp.load("formulation", formulation, 0);
        pp.load("kappa1", ccz4_base_params.kappa1, 0.1);
        pp.load("kappa2", ccz4_base_params.kappa2, 0.0);
        pp.load("kappa3", ccz4_base_params.kappa3, 1.0);
        pp.load("covariantZ4", ccz4_base_params.covariantZ4, true);
        ccz4_params.kappa1      = ccz4_base_params.kappa1;
        ccz4_params.kappa2      = ccz4_base_params.kappa2;
        ccz4_params.kappa3      = ccz4_base_params.kappa3;
        ccz4_params.covariantZ4 = ccz4_base_params.covariantZ4;

        // Dissipation
        pp.load("sigma", sigma, 0.1);

        // Nan Check and min chi and lapse values
        pp.load("nan_check", nan_check, true);
        pp.load("min_chi", min_chi, 1e-4);
        pp.load("min_lapse", min_lapse, 1e-4);

        // directory to store data (extraction files, puncture data, constraint
        // norms)
        pp.load("data_subpath", data_path, std::string(""));
        if (!data_path.empty() && data_path.back() != '/')
        {
            data_path += "/";
        }
        if (output_path != "./" && !output_path.empty())
        {
            data_path = output_path + data_path;
        }

        // Extraction params
        pp.load("activate_extraction", activate_extraction, false);

        if (activate_extraction)
        {
            pp.load("num_extraction_radii",
                    extraction_params.num_extraction_radii(), 1);

            // Check for multiple extraction radii, otherwise load single
            // radius/level (for backwards compatibility).
            std::vector<int> extraction_levels_stdvect;
            if (pp.contains("extraction_levels"))
            {
                pp.load("extraction_levels", extraction_levels_stdvect,
                        extraction_params.num_extraction_radii());
            }
            else
            {
                pp.load("extraction_level", extraction_levels_stdvect, 1, 0);
            }
            extraction_params.extraction_levels.resize(
                extraction_params.num_extraction_radii());
            std::copy(extraction_levels_stdvect.begin(),
                      extraction_levels_stdvect.end(),
                      extraction_params.extraction_levels.begin());

            std::vector<double> extraction_radii_stdvect;
            if (pp.contains("extraction_radii"))
            {
                pp.load("extraction_radii", extraction_radii_stdvect,
                        extraction_params.num_extraction_radii());
            }
            else
            {
                pp.load("extraction_radius", extraction_radii_stdvect, 1, 0.1);
            }
            extraction_params.extraction_radii().resize(
                extraction_params.num_extraction_radii());
            std::copy(extraction_radii_stdvect.begin(),
                      extraction_radii_stdvect.end(),
                      extraction_params.extraction_radii().begin());

            pp.load("num_points_phi", extraction_params.num_points_phi(), 2);
            pp.load("num_points_theta", extraction_params.num_points_theta(),
                    5);
            if (extraction_params.num_points_theta() % 2 == 0)
            {
                extraction_params.num_points_theta() += 1;
                amrex::Print()
                    << "Parameter: num_points_theta incompatible with "
                       "Simpson's "
                    << "rule so increased by 1.\n";
            }
            pp.load("extraction_center", extraction_params.center, center);

            if (pp.contains("modes"))
            {
                pp.load("num_modes", extraction_params.num_modes);
                std::vector<int> extraction_modes_vect(
                    static_cast<size_t>(2 * extraction_params.num_modes));
                pp.load("modes", extraction_modes_vect,
                        2 * extraction_params.num_modes);
                extraction_params.modes.resize(extraction_params.num_modes);
                for (size_t i = 0; i < extraction_params.num_modes; ++i)
                {
                    extraction_params.modes[i].first =
                        extraction_modes_vect[2 * i];
                    extraction_params.modes[i].second =
                        extraction_modes_vect[2 * i + 1];
                }
            }
            else
            {
                // by default extraction (l,m) = (2,0), (2,1) and (2,2)
                extraction_params.num_modes = 3;
                extraction_params.modes.resize(3);
                for (size_t i = 0; i < 3; ++i)
                {
                    extraction_params.modes[i].first  = 2;
                    extraction_params.modes[i].second = static_cast<int>(i);
                }
            }

            pp.load("write_extraction", extraction_params.write_extraction,
                    false);

            std::string extraction_path;
            pp.load("extraction_subpath", extraction_path, data_path);
            if (!extraction_path.empty() && extraction_path.back() != '/')
            {
                extraction_path += "/";
            }
            if (output_path != "./" && !output_path.empty())
            {
                extraction_path = output_path + extraction_path;
            }

            extraction_params.data_path       = data_path;
            extraction_params.extraction_path = extraction_path;

            // default names to Weyl extraction
            pp.load("extraction_file_prefix",
                    extraction_params.extraction_file_prefix,
                    std::string("Weyl4_extraction_"));
            pp.load("integral_file_prefix",
                    extraction_params.integral_file_prefix,
                    std::string("Weyl4_mode_"));
        }
    }

    void check_params()
    {
        check_parameter("dt_multiplier", dt_multiplier, dt_multiplier < 1.0,
                        "must be < 1.0 for stability");
        warn_parameter("dt_multiplier", dt_multiplier, dt_multiplier <= 0.5,
                       "is unlikely to be stable for > 0.5");

        check_parameter("sigma", sigma,
                        (sigma >= 0.0) && (sigma <= 2.0 / dt_multiplier),
                        "must be >= 0.0 and <= 2 / dt_multiplier for stability "
                        "(see Alcubierre p344)");
        warn_parameter("nan_check", nan_check, nan_check,
                       "should not normally be disabled");
        // not sure these are necessary hence commented out
        // check_parameter("min_chi", min_chi, (min_chi >= 0.0), "must be >=
        // 0.0"); check_parameter("min_lapse", min_lapse, (min_lapse >= 0.0)
        // "must be >= 0.0");
        check_parameter("formulation", formulation,
                        (formulation == CCZ4RHS<>::USE_CCZ4) ||
                            (formulation == CCZ4RHS<>::USE_BSSN),
                        "must be 0 or 1");
        if (formulation == CCZ4RHS<>::USE_CCZ4)
        {
            warn_parameter(
                "kappa1", ccz4_params.kappa1, ccz4_params.kappa1 > 0.0,
                "should be greater than 0.0 to damp constraints (see "
                "arXiv:1106.2254).");
            warn_parameter("kappa2", ccz4_params.kappa2,
                           ccz4_params.kappa2 > -1.0,
                           "should be greater than -1.0 to damp constraints "
                           "(see arXiv:1106.2254)");
        }
        else if (formulation == CCZ4RHS<>::USE_BSSN)
        {
            // maybe we should just set these to zero and print a warning
            // in the BSSN case
            warn_parameter("kappa1", ccz4_params.kappa1,
                           ccz4_params.kappa1 == 0.0,
                           "setting to 0.0 as required for BSSN");
            warn_parameter("kappa2", ccz4_params.kappa2,
                           ccz4_params.kappa2 == 0.0,
                           "setting to 0.0 as required for BSSN");
            warn_parameter("kappa3", ccz4_params.kappa3,
                           ccz4_params.kappa3 == 0.0,
                           "setting to 0.0 as required for BSSN");
            // no warning necessary for ccz4_params.covariantZ4
            ccz4_params.kappa1 = 0.0;
            ccz4_params.kappa2 = 0.0;
            ccz4_params.kappa3 = 0.0;
        }

        // only warn for gauge parameters as there are legitimate cases you may
        // want to deviate from the norm
        warn_parameter("lapse_advec_coeff", ccz4_params.lapse_advec_coeff,
                       std::min(std::abs(ccz4_params.lapse_advec_coeff),
                                std::abs(ccz4_params.lapse_advec_coeff - 1.0)) <
                           std::numeric_limits<double>::epsilon(),
                       "usually set to 0.0 or 1.0");
        warn_parameter("lapse_power", ccz4_params.lapse_power,
                       std::abs(ccz4_params.lapse_power - 1.0) <
                           std::numeric_limits<double>::epsilon(),
                       "set to 1.0 for 1+log slicing");
        warn_parameter("lapse_coeff", ccz4_params.lapse_coeff,
                       std::abs(ccz4_params.lapse_coeff - 2.0) <
                           std::numeric_limits<double>::epsilon(),
                       "set to 2.0 for 1+log slicing");
        warn_parameter("shift_Gamma_coeff", ccz4_params.shift_Gamma_coeff,
                       std::abs(ccz4_params.shift_Gamma_coeff - 0.75) <
                           std::numeric_limits<double>::epsilon(),
                       "usually set to 0.75");
        warn_parameter("shift_advec_coeff", ccz4_params.shift_advec_coeff,
                       std::min(std::abs(ccz4_params.shift_advec_coeff),
                                std::abs(ccz4_params.shift_advec_coeff - 1.0)) <
                           std::numeric_limits<double>::epsilon(),
                       "usually set to 0.0 or 1.0");
        warn_parameter("eta", ccz4_params.eta,
                       ccz4_params.eta > 0.1 && ccz4_params.eta < 10,
                       "usually O(1/M_ADM) so typically O(1) in code units");

        // Now extraction parameters
        if (activate_extraction)
        {
            check_parameter(
                "num_extraction_radii",
                extraction_params.num_extraction_radii(),
                extraction_params.num_extraction_radii() > 0,
                "must be bigger than 0 when activate_extraction = 1");

            FOR (idir)
            {
                std::string center_name =
                    "extraction_center[" + std::to_string(idir) + "]";
                double center_in_dir = extraction_params.center[idir];
                check_parameter(
                    center_name, center_in_dir,
                    (center_in_dir >= reflective_domain_lo[idir]) &&
                        (center_in_dir <= reflective_domain_hi[idir]),
                    "must be in the computational domain after "
                    "applying reflective symmetry");
                for (int iradius = 0;
                     iradius < extraction_params.num_extraction_radii();
                     ++iradius)
                {
                    std::string radius_name =
                        "extraction_radii[" + std::to_string(iradius) + "]";
                    double radius =
                        extraction_params.extraction_radii()[iradius];
                    if (idir == 0)
                    {
                        check_parameter(radius_name, radius, radius >= 0.0,
                                        "must be >= 0.0");
                    }
                    check_parameter(
                        radius_name, radius,
                        (center_in_dir - radius >=
                         reflective_domain_lo[idir]) &&
                            (center_in_dir + radius <=
                             reflective_domain_hi[idir]),
                        "extraction sphere must lie within the computational "
                        "domain after applying reflective symmetry");
                }
            }
            for (int imode = 0; imode < extraction_params.num_modes; ++imode)
            {
                auto &mode            = extraction_params.modes[imode];
                int l                 = mode.first;
                int m                 = mode.second;
                std::string mode_name = "modes[" + std::to_string(imode) + "]";
                std::string value_str = "(" + std::to_string(mode.first) +
                                        ", " + std::to_string(mode.second) +
                                        ")";
                check_parameter(
                    mode_name, value_str, (l >= 2) && (std::abs(m) <= l),
                    "l must be >= 2 and m must satisfy -l <= m <= l");
            }
        }
    }

  protected:
    // This is just the CCZ4 damping parameters in case you want to use
    // a different gauge (with different parameters)
    CCZ4_base_params_t ccz4_base_params{};

  public:
    double sigma{}; // Kreiss-Oliger dissipation parameter

    bool nan_check{};

    double min_chi{}, min_lapse{};

    int formulation{}; // Whether to use BSSN or CCZ4

    // Collection of parameters necessary for the CCZ4 RHS
    // Note the gauge parameters are specific to MovingPunctureGauge
    // If you are using a different gauge, you need to load your parameters
    // in your own SimulationParameters class.
    CCZ4_params_t<> ccz4_params;

    bool activate_extraction{};
    SphericalExtraction::params_t extraction_params;

    std::string data_path;
};

#endif /* SIMULATIONPARAMETERSBASE_HPP_ */



================================================
FILE: Source/GRTeclynCore/VariableType.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef VARIABLETYPE_HPP
#define VARIABLETYPE_HPP

// enum for state or derived variables
enum class VariableType
{
    state,
    derived
};

#endif /* VARIABLETYPE_HPP */



================================================
FILE: Source/IO/DebuggingTools.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef DEBUGGINGTOOLS_HPP_
#define DEBUGGINGTOOLS_HPP_

#ifdef EQUATION_DEBUG_MODE
#include <AMReX_IntVect.H>
#endif

// Other includes
#include <cstring>

/// This file contains a collection of helpful #defines and other definitions
/// that are hepful for debugging.

// Unfortunately, most of the functionality can only be achieved with macros
// (e.g. including the variable and filename).

#define FILENAME                                                               \
    (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)

#define DEBUG_SHOW(VAR) amrex::Print() << #VAR << ": " << (VAR) << " "
#define DEBUG_FILE amrex::Print() << FILENAME << ": "
#define DEBUG_END amrex::Print() << std::endl
#define DEBUG_DOUBLE_PRECISION amrex::Print() << std::setprecision(16)

/// The macros DEBUG_OUT make debugging quicker and allow easy printing of a
/// variable.
#define DEBUG_OUT(VAR)                                                         \
    DEBUG_FILE;                                                                \
    DEBUG_SHOW(VAR);                                                           \
    DEBUG_END
#define DEBUG_OUT2(VAR1, VAR2)                                                 \
    DEBUG_FILE;                                                                \
    DEBUG_SHOW(VAR1);                                                          \
    DEBUG_SHOW(VAR2);                                                          \
    DEBUG_END
#define DEBUG_OUT3(VAR1, VAR2, VAR3)                                           \
    DEBUG_FILE;                                                                \
    DEBUG_SHOW(VAR1);                                                          \
    DEBUG_SHOW(VAR2);                                                          \
    DEBUG_SHOW(VAR3);                                                          \
    DEBUG_END
#define DEBUG_OUT4(VAR1, VAR2, VAR3, VAR4)                                     \
    DEBUG_FILE;                                                                \
    DEBUG_SHOW(VAR1);                                                          \
    DEBUG_SHOW(VAR2);                                                          \
    DEBUG_SHOW(VAR3);                                                          \
    DEBUG_SHOW(VAR4);                                                          \
    DEBUG_END

//
#ifdef EQUATION_DEBUG_MODE
#define DEBUG_HEADER                                                           \
    amrex::Print() << "Debug output in " << FILENAME                           \
                   << " at: " << s_current_integer_coords << "." << std::endl
static amrex::IntVect s_current_integer_coords;
namespace EquationDebugging
{
inline void check_no_omp()
{
#ifdef _OPENMP
    if (omp_get_max_threads() > 1)
        amrex::Abort("Equation debug mode can  only be used with one thread.");
#endif
}

inline void
set_global_cell_coordinates(const amrex::IntVect current_integer_coords)
{
    check_no_omp();
    s_current_integer_coords = current_integer_coords;
}
} // namespace EquationDebugging
#endif

#endif /* DEBUGGINGTOOLS_HPP_ */



================================================
FILE: Source/IO/FilesystemTools.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef FILESYSTEMTOOLS_HPP_
#define FILESYSTEMTOOLS_HPP_

#include <AMReX_Utility.H>

// Some filesystem useful functions

namespace FilesystemTools
{

static bool directory_exists(const std::string &path)
{
    return amrex::FileSystem::Exists(path);
}

static void mkdir_recursive(const std::string &path)
{
    amrex::UtilCreateDirectoryDestructive(path);
}
} // namespace FilesystemTools

#endif /* FILESYSTEMTOOLS_HPP_ */



================================================
FILE: Source/IO/GRParmParse.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef GRPARMPARSE_HPP_
#define GRPARMPARSE_HPP_

#include "ArrayTools.hpp"

#include <AMReX_ParmParse.H>
#include <AMReX_Print.H>

#include <algorithm>
#include <memory>
#include <type_traits>

class GRParmParse : public amrex::ParmParse
{
  public:
    using amrex::ParmParse::ParmParse; // Just use ParmParse's constructor

    // (MK): I called the functions below "load" rather than "get" to avoid
    // clashes with the many  different overloads of "get" in ParmParse. Also, I
    // think load is a more intuitive name.

    /// Loads an array from the parameter file
    template <class data_t, long unsigned int n_comp>
    void load(const char *name, std::array<data_t, n_comp> &array) const
    {
        get<data_t, n_comp>(name, array);
    }

    template <long unsigned int n_comp>
    void load(const char *name, std::array<bool, n_comp> &array) const
    {
        std::array<int, n_comp> tmp{};
        get<int, n_comp>(name, tmp);
        for (long unsigned int i = 0; i < n_comp; ++i)
        {
            array[i] = tmp[i];
        }
    }

    /// Loads a vector with num_comp components from the parameter file
    template <class data_t>
    void load(const char *name, std::vector<data_t> &vector,
              const int num_comp) const
    {
        getarr(name, vector, 0, num_comp);
    }

    template <class data_t>
    void load(const char *name, std::vector<bool> &vector,
              const int num_comp) const
    {
        std::vector<int> tmp(num_comp);
        getarr(name, tmp, 0, num_comp);
        for (long unsigned int i = 0; i < num_comp; ++i)
        {
            vector[i] = tmp[i];
        }
    }

    /// Loads a value from the parameter file
    template <class data_t>
    typename std::enable_if_t<
        !std::is_enum_v<data_t>> // Can't use for enum types
    load(const char *name, data_t &parameter) const
    {
        get(name, parameter);
    }

    /// Loads an enum value from the parameter file
    template <typename enum_type>
    typename std::enable_if_t<
        std::is_enum_v<enum_type>> // Only enabled for enum types
    load(const char *name, enum_type &parameter) const
    {
        int iparam = 0;
        get(name, iparam);
        parameter = static_cast<enum_type>(iparam);
    }

    /// Loads a value from the parameter file, if the value isn't defined it
    /// sets to the supplied default
    template <class data_t>
    void load(const char *name, data_t &parameter, const data_t default_value)
    {
        if (contains(name))
        {
            load(name, parameter);
        }
        else
        {
            parameter = default_value;
            // Add the default value to the ParmParse table
            this->queryAdd(name, parameter);
            default_message(name, default_value);
        }
    }

    /// Loads a vector with num_comp components from the parameter file, if the
    /// vector isn't defined, it is set to the supplied default
    template <class data_t>
    void load(const char *name, std::vector<data_t> &vector, const int num_comp,
              const std::vector<data_t> &default_vector)
    {
        if (contains(name))
        {
            load(name, vector, num_comp);
        }
        else
        {
            vector = default_vector;
            // Add the default value to the ParmParse table
            this->queryAdd(name, vector);
            default_message(name, default_vector);
        }
    }

    /// Loads a vector with num_comp components from the parameter file, if the
    /// vector isn't defined it sets all components to the supplied default
    template <class data_t>
    void load(const char *name, std::vector<data_t> &vector, const int num_comp,
              const data_t default_value)
    {
        load(name, vector, num_comp,
             std::vector<data_t>(num_comp, default_value));
    }

  protected:
    template <typename data_t,
              std::enable_if_t<
                  !ArrayTools::is_std_array_or_vector<data_t>::value,
                  bool> = true> // this won't work for std::arrays and vectors
    void default_message(const char *name, const data_t &default_value) const
    {
        amrex::Print() << "Parameter: " << name
                       << " not found in parameter file. "
                       << "It has been set to its default value = "
                       << default_value << "." << std::endl;
    }

    template <typename data_t,
              std::enable_if_t<
                  ArrayTools::is_std_array_or_vector<data_t>::value,
                  bool> = true> // use this code for std::arrays and vectors
    void default_message(const char *name, const data_t &default_value) const
    {
        amrex::Print() << "Parameter: " << name
                       << " not found in parameter file. "
                       << "It has been set to its default "
                          "value =";
        for (const auto &elem : default_value)
        {
            amrex::Print() << " " << elem;
        }
        amrex::Print() << "." << '\n';
    }
};

#endif /* GRPARMPARSE_HPP_ */



================================================
FILE: Source/IO/Make.package
================================================
GRTECLYN_CEXE_sources += SmallDataIO.cpp
GRTECLYN_CEXE_headers += DebuggingTools.hpp \
                         FilesystemTools.hpp \
                         GRParmParse.hpp \
                         MultiLevelTask.hpp \
                         SmallDataIO.hpp \
                         StateVariablesParmParse.hpp



================================================
FILE: Source/IO/MultiLevelTask.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef MULTILEVELTASK_HPP_
#define MULTILEVELTASK_HPP_

#include "GRAMRLevel.hpp"
#include <AMReX_Amr.H>

#include <limits> // std::numeric_limits

//! This is just an interface for the AMR scheduler to call some GRAMRLevel (or
//! any other Example specific level) function on every AMRLevel
//! Satisfies syntax of Chombo's Scheduler such that it can be passed to GRAMR
//! and be scheduled
template <class level_t = GRAMRLevel>
class MultiLevelTask // xxxxx: public Scheduler::PeriodicFunction
{
#if 0
//xxxxx
    std::function<void(level_t *)> m_func;
    bool m_reverse_levels;

    // Use default condstructor of PeriodicFunction
    using PeriodicFunction::PeriodicFunction;

    amrex::Amr *m_amr_ptr; //! pointer to amrex::Amr object

  public:
    MultiLevelTask(std::function<void(level_t *)> a_func,
                   bool a_reverse_levels = true)
        : m_func(a_func), m_reverse_levels(a_reverse_levels)
    {
    }

    // required from Scheduler::PeriodicFunction
    virtual void setUp(amrex::Amr &a_AMR, int a_interval = -1) override
    {
        m_amr_ptr = &a_AMR;
    }

    // required from Scheduler::PeriodicFunction
    virtual void operator()(int a_step = 0, Real a_time = 0.) override
    {
        auto amr_level_ptrs = m_amr_ptr->getAMRLevels();

        // need to reverse this vector so that m_func is called in order of
        // finest level to coarsest. This is important for example for
        // 'specificPostTimeStep', which is always run in reverse order of
        // levels
        if (m_reverse_levels)
            std::reverse(std::begin(amr_level_ptrs), std::end(amr_level_ptrs));

        for (AMRLevel *amr_level_ptr : amr_level_ptrs)
            m_func(level_t::gr_cast(amr_level_ptr));
    }
#endif
};

#if 0
//xxxxx

//! This is just an interface for the AMR scheduler to call some level_t
//! function on every AMRLevel
//! This can either be called directly by calling execute, or passed to an AMR
//! (as GRAMR) by doing gr_amr.schedule(me) (this version will make it be called
//! only after plot files are written, if that is ever an interest)
template <class level_t = GRAMRLevel>
class MultiLevelTaskPtr : public RefCountedPtr<Scheduler>
{
    RefCountedPtr<MultiLevelTask<level_t>> m_ptr_to_func;

  public:
    //! interval defines the frequency with which the scheduler will be called
    //! if added to an AMR
    MultiLevelTaskPtr(std::function<void(level_t *)> a_func,
                      bool a_reverse_levels = true,
                      int a_interval = std::numeric_limits<int>::max())
        : RefCountedPtr<Scheduler>(new Scheduler),
          m_ptr_to_func(new MultiLevelTask<level_t>(a_func, a_reverse_levels))
    // the two 'new' pointers are deleted by RefCountedPtr, no memory leak
    {
        if (a_interval <= 0) // the user probably means "never again"
            a_interval = std::numeric_limits<int>::max();
        (*this)->schedule(m_ptr_to_func, a_interval);
    }

    // run immediately!
    void execute(AMR &amr)
    {
        m_ptr_to_func->setUp(amr);
        (*m_ptr_to_func)();
    }
};

#endif

#endif /* MULTILEVELTASK_HPP_ */



================================================
FILE: Source/IO/SmallDataIO.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// Other includes
#include "SmallDataIO.hpp"

#include <AMReX_ParallelDescriptor.H>
#include <AMReX_Print.H>
#include <AMReX_Utility.H>
#include <AMReX_Vector.H>

#include <cmath>
#include <random>
// (MR): if it were up to me, I'd be using the C++17 filesystems library
// instead of cstdio but I'm sure someone would tell me off for not maintaining
// backwards compatability.
#include <cstdio> // for std::rename and std::remove
#include <sstream>
#include <utility>

// ------------ Constructors -----------------

// NOLINTBEGIN(bugprone-easily-swappable-parameters)
// This has to be initialised outside the class declaration in C++14
const std::string SmallDataIO::s_default_file_extension = ".dat";

SmallDataIO::SmallDataIO(const std::string &a_filename_prefix, double a_dt,
                         double a_time, double a_restart_time, Mode a_mode,
                         bool a_first_step,
                         const file_structure_t *a_file_structure,
                         const std::string &a_file_extension,
                         int a_data_precision, int a_coords_precision,
                         int a_filename_steps_width)
    : m_filename(a_filename_prefix + a_file_extension), m_dt(a_dt),
      m_time(a_time), m_restart_time(a_restart_time), m_mode(a_mode),
      m_first_step(a_first_step), m_data_precision(a_data_precision),
      // data columns need extra space for scientific notation
      // compared to coords columns
      m_data_width(m_data_precision + 10),
      m_data_epsilon(std::pow(10.0, -a_data_precision)),
      m_coords_precision(a_coords_precision),
      m_coords_width(m_coords_precision + 5),
      m_coords_epsilon(std::pow(10.0, -a_coords_precision)),
      // this is for reading only
      m_structure_defined{false}
{

    if (amrex::ParallelDescriptor::IOProcessor())
    {
        std::ios::openmode file_openmode = std::ios::out;
        if (m_mode == APPEND)
        {
            if (m_first_step)
            {
                // overwrite any existing file if this is the first step
                file_openmode = std::ios::out;
            }
            else if (m_restart_time > 0. &&
                     m_time < m_restart_time + m_dt + m_coords_epsilon)
            {
                // allow reading in the restart case so that duplicate time
                // data may be removed
                file_openmode = std::ios::app | std::ios::in;
            }
            else
            {
                // default mode is just appending to existing file
                file_openmode = std::ios::app;
            }
        }
        else if (m_mode == NEW)
        {
            file_openmode = std::ios::out;
            m_filename =
                get_new_filename(a_filename_prefix, m_dt, m_time,
                                 a_file_extension, a_filename_steps_width);
        }
        else if (m_mode == READ)
        {
            file_openmode = std::ios::in;
        }
        else
        {
            amrex::Abort("SmallDataIO: mode not supported");
        }
        if (m_mode == APPEND && m_first_step || m_mode == NEW)
        {
            // Rather than overwriting files from previous simulations, we
            // rename the old files to "filename.old.<random string>" like AMReX
            // does for checkpoints and plotfiles
            bool call_mpi_barrier = false;
            // Even though "directory" is in this function name, it works fine
            // for any type of file.
            amrex::UtilRenameDirectoryToOld(m_filename, call_mpi_barrier);
        }
        m_file.open(m_filename, file_openmode);

        if (!m_file)
        {
            amrex::Abort("SmallDataIO: error opening file " + m_filename);
        }
        if (m_mode == READ)
        {
            read_file();
            if (a_file_structure == nullptr)
            {
                determine_file_structure();
            }
            else
            {
                set_file_structure(*a_file_structure);
            }
        }
    }
}

SmallDataIO::SmallDataIO(const std::string &a_filename_prefix, double a_dt,
                         double a_time, double a_restart_time, Mode a_mode,
                         bool a_first_step, const std::string &a_file_extension,
                         int a_data_precision, int a_coords_precision,
                         int a_filename_steps_width)
    : SmallDataIO(a_filename_prefix, a_dt, a_time, a_restart_time, a_mode,
                  a_first_step, nullptr, a_file_extension, a_data_precision,
                  a_coords_precision, a_filename_steps_width)
{
}

SmallDataIO::SmallDataIO(const std::string &a_filename_prefix, double a_dt,
                         double a_time, double a_restart_time, Mode a_mode,
                         const std::string &a_file_extension,
                         int a_data_precision, int a_coords_precision,
                         int a_filename_steps_width)
    : SmallDataIO(a_filename_prefix, a_dt, a_time, a_restart_time, a_mode,
                  (a_time == a_dt), nullptr, a_file_extension, a_data_precision,
                  a_coords_precision, a_filename_steps_width)
{
}

SmallDataIO::SmallDataIO(const std::string &a_filename_prefix,
                         const std::string &a_file_extension,
                         int a_data_precision, int a_coords_precision)
    : SmallDataIO(a_filename_prefix, 0.0, 0.0, 0.0, READ, false, nullptr,
                  a_file_extension, a_data_precision, a_coords_precision, 0)
{
}

SmallDataIO::SmallDataIO(const std::string &a_filename_prefix,
                         const file_structure_t *a_file_structure,
                         const std::string &a_file_extension,
                         int a_data_precision, int a_coords_precision)
    : SmallDataIO(a_filename_prefix, 0.0, 0.0, 0.0, READ, false,
                  a_file_structure, a_file_extension, a_data_precision,
                  a_coords_precision, 0)
{
}

//! Destructor (closes file)
SmallDataIO::~SmallDataIO()
{
    m_filename.clear();
    m_structure_defined = false;

    if (amrex::ParallelDescriptor::IOProcessor())
    {
        m_file.close();
        m_file_structure.clear();
        m_file_contents.clear();
    }
}

// NOLINTEND(bugprone-easily-swappable-parameters)

// ------------ Writing Functions ------------

void SmallDataIO::write_header_line(
    const std::vector<std::string> &a_header_strings,
    const std::string &a_pre_header_string)
{
    std::vector<std::string> pre_header_strings;
    if (!a_pre_header_string.empty())
    {
        pre_header_strings.push_back(a_pre_header_string);
    }
    write_header_line(a_header_strings, pre_header_strings);
}

// NOLINTBEGIN(bugprone-easily-swappable-parameters)
void SmallDataIO::write_header_line(
    const std::vector<std::string> &a_header_strings,
    const std::vector<std::string> &a_pre_header_strings)
// NOLINTEND(bugprone-easily-swappable-parameters)
{
    if (amrex::ParallelDescriptor::IOProcessor())
    {
        // all header lines start with a '#'.
        m_file << "#";
        for (std::size_t istr = 0; istr < a_pre_header_strings.size(); ++istr)
        {
            // first column header is shorter due to preceeding #
            if (istr == 0)
            {
                m_file << std::setw(m_coords_width - 1)
                       << a_pre_header_strings[istr];
            }
            else
            {
                m_file << std::setw(m_coords_width)
                       << a_pre_header_strings[istr];
            }
        }
        for (const std::string &header_item : a_header_strings)
        {
            m_file << std::setw(m_data_width) << header_item;
        }
        m_file << "\n";
    }
}

void SmallDataIO::write_data_line(const std::vector<double> &a_data,
                                  const double a_coord)
{
    const std::vector<double> coords(1, a_coord);
    write_data_line(a_data, coords);
}

void SmallDataIO::write_time_data_line(const std::vector<double> &a_data)
{
    write_data_line(a_data, m_time);
}

// NOLINTBEGIN(bugprone-easily-swappable-parameters)
void SmallDataIO::write_data_line(const std::vector<double> &a_data,
                                  const std::vector<double> &a_coords)
// NOLINTEND(bugprone-easily-swappable-parameters)
{
    if (amrex::ParallelDescriptor::IOProcessor())
    {
        m_file << std::fixed << std::setprecision(m_coords_precision);
        for (double coord : a_coords)
        {
            m_file << std::setw(m_coords_width) << coord;
        }
        m_file << std::scientific << std::setprecision(m_data_precision);
        for (double data : a_data)
        {
            m_file << std::setw(m_data_width) << data;
        }
        m_file << "\n";
    }
}

void SmallDataIO::line_break()
{
    if (amrex::ParallelDescriptor::IOProcessor())
    {
        m_file << "\n\n";
    }
}

void SmallDataIO::remove_duplicate_time_data(const bool keep_m_time_data)
{
    if (amrex::ParallelDescriptor::IOProcessor() && m_restart_time > 0. &&
        m_mode == APPEND && m_time < m_restart_time + m_dt + m_coords_epsilon)
    {
        // copy lines with time < m_time into a temporary file
        m_file.seekg(0);
        std::string line;
        // adding a random integer might make this a little more robust...
        const unsigned long random_int = std::default_random_engine()();
        std::string temp_filename =
            m_filename + ".temp" + std::to_string(random_int);
        std::ofstream temp_file(temp_filename);
        int sign = -1;
        if (keep_m_time_data)
        {
            sign = 1;
        }
        while (std::getline(m_file, line))
        {
            if (!(line.find('#') == std::string::npos) ||
                std::stod(line.substr(0, m_coords_width)) <
                    m_time + sign * m_coords_epsilon)
            {
                temp_file << line << "\n";
            }
        }

        m_file.close();
        temp_file.close();

        // now delete the original file and rename the temporary file with the
        // original filename
        std::remove(m_filename.data());
        std::rename(temp_filename.data(), m_filename.data());
        // reopen the file in append mode
        m_file.open(m_filename, std::ios::app);
    }
}

// ------------ Reading Functions ------------

void SmallDataIO::file_structure_t::clear()
{
    num_blocks = 0;
    block_starts.clear();
    num_data_rows.clear();
    num_header_rows.clear();
    num_data_columns.clear();
}

// Only for use in the constructor - this assumes that the file is already open
void SmallDataIO::read_file()
{

    AMREX_ASSERT_WITH_MESSAGE(
        m_file, "This function can only be called from the constructor! \n");

    m_file.seekg(0, std::ios::end);

    auto size = m_file.tellg();

    AMREX_ALWAYS_ASSERT_WITH_MESSAGE(
        size < max_file_size,
        "SmallDataIO: File size is too large. Max file size is 1 GB. \n");

    std::string file_contents(size,
                              '\0'); // construct string to stream size
    m_file.seekg(0);
    m_file.read(file_contents.data(), size);
    AMREX_ALWAYS_ASSERT_WITH_MESSAGE(!file_contents.empty(),
                                     "SmallDataIO: File contents of " +
                                         m_filename + " could not be read");

    m_file_contents = file_contents;
}

// Parses the file and determines its structure
// Don't call this directly, it will automatically be called when you open a
// file
void SmallDataIO::determine_file_structure()
{
    // first check that the file has been read
    AMREX_ASSERT(m_file_contents.empty() == false);

    std::istringstream file_stream(m_file_contents);
    // go through each line and determine structure
    std::string line;
    int block_counter        = 0; // assume we always have one block
    auto current_position    = file_stream.tellg();
    int block_start_position = current_position;
    int header_row_counter   = 0;
    int data_row_counter     = 0;

    while (std::getline(file_stream, line))
    {
        if (!line.empty())
        {
            // header rows start with '#'
            if (line.find('#') == 0)
            {
                if (header_row_counter == 0)
                {
                    block_start_position = current_position;
                }

                ++header_row_counter;
            }
            else
            {
                if (data_row_counter++ == 0)
                {

                    // only count a new block if it contains a data row
                    m_file_structure.block_starts.push_back(
                        block_start_position);
                    ++block_counter;
                    // determine column structure from first data row in
                    // block get a vector of the widths of the columns
                    // including preceeding whitespace
                    std::string::size_type start_whitespace = 0;

                    int ncols{0};
                    while (!(start_whitespace == std::string::npos))
                    {
                        std::string::size_type start_non_whitespace =
                            line.find_first_not_of(' ', start_whitespace);
                        std::string::size_type next_start_whitespace =
                            line.find_first_of(' ', start_non_whitespace);
                        start_whitespace = next_start_whitespace;
                        ncols++;
                    }

                    m_file_structure.num_data_columns.push_back(ncols);
                }
            }
        }
        else
        {
            if (header_row_counter > 0 || data_row_counter > 0)

            {
                // end of previous block
                m_file_structure.num_header_rows.push_back(header_row_counter);
                m_file_structure.num_data_rows.push_back(data_row_counter);
                // reset the counters
                header_row_counter = 0;
                data_row_counter   = 0;
            }
        }
        current_position = file_stream.tellg();
    }
    // Just in case the file ends without a line break:
    if (data_row_counter > 0)
    {
        m_file_structure.num_header_rows.push_back(header_row_counter);
        m_file_structure.num_data_rows.push_back(data_row_counter);
    }

    m_file_structure.num_blocks = block_counter;

    AMREX_ASSERT(m_file_structure.num_data_rows.size() ==
                 m_file_structure.num_blocks);
    AMREX_ASSERT(m_file_structure.num_header_rows.size() ==
                 m_file_structure.num_blocks);
    AMREX_ASSERT(m_file_structure.num_data_columns.size() ==
                 m_file_structure.num_blocks);
    AMREX_ASSERT(m_file_structure.block_starts.size() ==
                 m_file_structure.num_blocks);

    m_structure_defined = true;
}

// Set structure if known already (e.g. same as another file already
// determined)
void SmallDataIO::set_file_structure(
    const SmallDataIO::file_structure_t &a_file_structure)
{
    m_file_structure    = a_file_structure;
    m_structure_defined = true;
}

// File struture getter
const SmallDataIO::file_structure_t &SmallDataIO::get_file_structure() const
{
    return m_file_structure;
}

// Utility for viewing the file struture

void SmallDataIO::print_file_structure() const
{
    if (amrex::ParallelDescriptor::IOProcessor())
    {
        AMREX_ASSERT(m_structure_defined);

        amrex::Print() << "Total number of blocks: "
                       << m_file_structure.num_blocks << "\n";

        for (int i = 0; i < m_file_structure.num_blocks; i++)
        {

            // Printing info on file structure:
            amrex::Print() << "#######" << "\n";
            amrex::Print() << "Info on Block " << i << ":" << "\n";
            amrex::Print() << "Block start: "
                           << m_file_structure.block_starts[i] << "\n";
            amrex::Print() << "Number of columns in Block " << i << ": "
                           << m_file_structure.num_data_columns[i] << "\n";
            amrex::Print() << "Number of rows in Block " << i << ": "
                           << m_file_structure.num_data_rows[i] << "\n";
            amrex::Print() << "Number of header rows in Block " << i << ": "
                           << m_file_structure.num_header_rows[i] << "\n";

            // Printing column names:

            std::vector<std::string> header;
            get_header_strings(header, i);

            amrex::Print() << "Header strings found: ";
            for (auto &column_name : header)
            {
                amrex::Print() << column_name << " ";
            }
            amrex::Print() << "\n";
            amrex::Print() << "#######" << "\n";
        }
    }
}

// Get an interval of columns (inclusive) from a block
// NOLINTBEGIN(bugprone-easily-swappable-parameters)
void SmallDataIO::get_columns(std::vector<SmallDataIO::column_t> &out,
                              int a_min_column, int a_max_column, int a_block)
// NOLINTEND(bugprone-easily-swappable-parameters)
{
    if (amrex::ParallelDescriptor::IOProcessor())
    {
        AMREX_ASSERT(m_file_contents.empty() == false);
        AMREX_ASSERT(m_structure_defined);
        AMREX_ASSERT(0 <= a_min_column);
        AMREX_ASSERT(a_max_column <=
                     m_file_structure.num_data_columns[a_block]);
        AMREX_ASSERT(a_min_column <= a_max_column);
        const int num_columns = a_max_column - a_min_column + 1;

        out.resize(num_columns);
        for (auto &column : out)
        {
            column.resize(m_file_structure.num_data_rows[a_block]);
        }

        std::istringstream file_stream(m_file_contents);
        skip_ahead(file_stream, m_file_structure.num_header_rows[a_block],
                   a_block);

        double discard = 0.0;
        for (int irow = 0; irow < m_file_structure.num_data_rows[a_block];
             ++irow)
        {

            for (int icolumn = 0;
                 icolumn < m_file_structure.num_data_columns[a_block];
                 ++icolumn)
            {
                if (a_min_column <= icolumn && icolumn <= a_max_column)
                {

                    file_stream >> out[icolumn - a_min_column][irow];
                }
                else
                {
                    file_stream >> discard;
                }
            }
        }
    }
}

// Get columns from a block based on their names in the header
// NOLINTBEGIN(bugprone-easily-swappable-parameters)
void SmallDataIO::get_columns(std::vector<SmallDataIO::column_t> &out,
                              const std::vector<std::string> &column_names,
                              const int a_block)
// NOLINTEND(bugprone-easily-swappable-parameters)
{

    if (amrex::ParallelDescriptor::IOProcessor())
    {
        // Resize for the number of requested columns
        out.resize(column_names.size());

        // Resize for the total number of rows
        for (auto &column : out)
        {
            column.resize(m_file_structure.num_data_rows[a_block]);
        }

        AMREX_ASSERT(m_file_contents.empty() == false);
        AMREX_ASSERT(m_structure_defined);

        // Get column names from header
        // Assume that the column names are in the line immediately proceeding
        // the data, like this:
        // # blah blah this is my data blah blah
        // # blah blah more things to say blah blah
        // # x y z

        std::vector<std::string> header;
        get_header_strings(header, a_block);

        // Associate each column name with the number
        // of where they are in the file

        // First entry in the std::map is the column number in the file
        // (file_column) Second entry in the std::map is the column number given
        // by the user (input_column)
        std::map<int, int> column_mapping;

        bool found{false};

        for (int input_column = 0; input_column < column_names.size();
             input_column++)
        {
            for (int file_column = 0; file_column < header.size();
                 file_column++)
            {
                if (header[file_column] == column_names[input_column])
                {
                    column_mapping.emplace(file_column, input_column);
                    found = true;
                }
            }
            // If all header_names have been checked but column_name has not
            // been found...
            if (!found)
            {
                std::string error_message{
                    "SmallDataIO: " + column_names[input_column] +
                    " could not be read. Please double check "
                    "your inputs to SmallDataIO::get_columns"};
                amrex::Abort(error_message);
            }
        }

        const int ncols = m_file_structure.num_data_columns[a_block];

        // To avoid calling std::map::find for each row of data,
        // we define a bool for each column (in the original file ordering) so
        // we know if that value needs to be saved or not.
        std::vector<bool> columns_requested(ncols, false);

        for (auto const &[file_order, user_order] : column_mapping)
        {
            columns_requested[file_order] = true;
        }

        std::istringstream file_stream(m_file_contents);

        skip_ahead(file_stream, m_file_structure.num_header_rows[a_block],
                   a_block);

        double discard = 0.0;
        for (int row = 0; row < m_file_structure.num_data_rows[a_block]; ++row)
        {
            for (int file_column = 0;
                 file_column < m_file_structure.num_data_columns[a_block];
                 ++file_column)
            {
                if (columns_requested[file_column])
                {
                    // The mapping is there to return the columns in the same
                    // order as the user input

                    file_stream >> out[column_mapping.at(file_column)][row];
                }
                else
                {
                    file_stream >> discard;
                }
            }
        }
    }
}

// Get a data column from a block
void SmallDataIO::get_all_data_columns(std::vector<SmallDataIO::column_t> &out,
                                       int a_block)
{
    assert(m_structure_defined);
    int min_data_column = 0;
    int max_data_column = m_file_structure.num_data_columns[a_block];
    get_columns(out, min_data_column, max_data_column, a_block);
}

void SmallDataIO::get_column(std::vector<SmallDataIO::column_t> &out,
                             int a_column, int a_block)
{
    get_columns(out, a_column, a_column, a_block);
}

// Returns a vector of numeric values from a header row
// NOLINTBEGIN(bugprone-easily-swappable-parameters)
void SmallDataIO::get_data_from_header(std::vector<amrex::Real> &out,
                                       int a_header_row_number,
                                       int a_block) const
// NOLINTEND(bugprone-easily-swappable-parameters)
{
    if (amrex::ParallelDescriptor::IOProcessor())
    {

        assert(m_file_contents.empty() == false);
        assert(m_structure_defined);
        assert(a_header_row_number < m_file_structure.num_header_rows[a_block]);

        std::istringstream file_stream(m_file_contents);
        skip_ahead(file_stream, a_header_row_number, a_block);

        // get desired header line
        std::string line;
        std::getline(file_stream, line);

        // find numbers in header using regex
        // I think this takes a long time to compile...
        std::regex number("[+-]?([0-9]*\\.)?[0-9]+");
        auto numbers_begin =
            std::sregex_iterator(line.begin(), line.end(), number);
        auto numbers_end = std::sregex_iterator();

        for (std::sregex_iterator rit = numbers_begin; rit != numbers_end;
             ++rit)
        {
            // put matches in vector
            out.push_back(std::stod((*rit).str()));
        }
    }
}

// NOLINTBEGIN(bugprone-easily-swappable-parameters)
void SmallDataIO::get_header_strings(std::vector<std::string> &header,
                                     int a_block) const
// NOLINTEND(bugprone-easily-swappable-parameters)
{

    if (amrex::ParallelDescriptor::IOProcessor())
    {
        assert(m_file_contents.empty() == false);
        assert(m_structure_defined);

        header.resize(m_file_structure.num_data_columns[0]);

        std::istringstream file_stream(m_file_contents);
        int nlines_to_skip = m_file_structure.num_header_rows[a_block] - 1;
        skip_ahead(file_stream, nlines_to_skip, a_block);

        std::string hashes; // remove the #s at the beginning of the line
        file_stream >> hashes;

        for (auto &icol : header)
        {
            file_stream >> icol;
        }
    }
}
// Helper function to skip lines e.g. header lines
// NOLINTBEGIN(bugprone-easily-swappable-parameters)
void SmallDataIO::skip_ahead(std::istringstream &file_stream,
                             int nlines_to_skip, int a_block) const
// NOLINTEND(bugprone-easily-swappable-parameters)
{
    // rewind to the beginning of the block
    file_stream.seekg(m_file_structure.block_starts[a_block], std::ios::beg);

    // assume header rows are at start of block
    for (int irow = 0; irow < nlines_to_skip; ++irow)
    {
        // skip lines before desired row
        file_stream.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    }
}

void SmallDataIO::get_specific_data_line(std::vector<double> &a_out_data,
                                         const std::vector<double> &a_coords)
{
    if (amrex::ParallelDescriptor::IOProcessor())
    {
        bool line_found = false;
        // first set the current position to the beginning of the file
        m_file.seekg(0);

        // get a string of the coords as they are in the file
        std::stringstream coords_ss;
        coords_ss << std::fixed << std::setprecision(m_coords_precision);
        for (double coord : a_coords)
        {
            coords_ss << std::setw(m_coords_width) << coord;
        }
        std::string coords_string = coords_ss.str();

        // now search for lines that start with coords_string and put the data
        // in a_out_data
        std::string line;
        while (std::getline(m_file, line))
        {
            if (!(line.find(coords_string) == std::string::npos))
            {
                for (std::size_t ichar = a_coords.size() * m_coords_width;
                     ichar < line.size(); ichar += m_data_width)
                {
                    double data_value =
                        std::stod(line.substr(ichar, m_data_width));
                    a_out_data.push_back(data_value);
                }
                line_found = true;
                // only want the first occurrence so break the while loop
                break;
            }
        }
        if (!line_found)
        {
            amrex::Abort(
                "SmallDataIO : Data to be read in at coord not found in file");
        }
    }
    // now broadcast the vector to all ranks using Chombo broadcast function
    // need to convert std::vector to Vector first
    // xxxxx    amrex::Vector<double> data_Vect(a_out_data);
    // xxxxx    int broadcast_rank = 0;
    // xxxxx broadcast(data_Vect, broadcast_rank);
    // xxxxx    a_out_data = data_Vect;
}

void SmallDataIO::get_specific_data_line(std::vector<double> &a_out_data,
                                         const double a_coord)
{
    std::vector<double> coords(1, a_coord);
    get_specific_data_line(a_out_data, coords);
}

// ------------ Other Functions --------------

// NOLINTBEGIN(bugprone-easily-swappable-parameters)
std::string SmallDataIO::get_new_filename(const std::string &a_file_prefix,
                                          double a_dt, double a_time,
                                          const std::string &a_file_extension,
                                          int a_filename_steps_width)
// NOLINTEND(bugprone-easily-swappable-parameters)
{
    AMREX_ASSERT(a_dt > 0);
    const int step = static_cast<int>(std::round(a_time / a_dt));

    // append step number to filename (pad to make it
    // a_filename_steps_width digits).
    std::string step_string = std::to_string(step);
    if (a_filename_steps_width < static_cast<int>(step_string.length()))
    {
        amrex::Abort("SmallDataIO: a_filename_steps_width too small "
                     "for step number");
    }
    std::string step_string_padded =
        std::string(a_filename_steps_width - step_string.length(), '0') +
        step_string;
    // append step number to filename if in NEW mode
    return a_file_prefix + step_string_padded + a_file_extension;
}

// returns m_data_epsilon
double SmallDataIO::get_data_epsilon() const { return m_data_epsilon; }

// returns the default data_epsilon
double SmallDataIO::get_default_data_epsilon()
{
    return pow(10.0, -s_default_data_precision);
}

// returns m_coords_epsilon
double SmallDataIO::get_coords_epsilon() const { return m_coords_epsilon; }

// returns the default coords epsilon
double SmallDataIO::get_default_coords_epsilon()
{
    return pow(10.0, -s_default_coords_precision);
}

// Helper function to redistribute data amongst all ranks
void SmallDataIO::broadcast_data(std::vector<SmallDataIO::column_t> &data)
{
    int nrows{0};
    int ncols{0};

    if (amrex::ParallelDescriptor::IOProcessor())
    {
        nrows = data[0].size();
        ncols = data.size();
    }
    amrex::ParallelDescriptor::Bcast(
        &ncols, 1, amrex::ParallelDescriptor::IOProcessorNumber());

    amrex::ParallelDescriptor::Bcast(
        &nrows, 1, amrex::ParallelDescriptor::IOProcessorNumber());

    data.resize(ncols);

    for (auto &column : data)
    {
        column.resize(nrows);
        amrex::ParallelDescriptor::Bcast(
            column.data(), nrows,
            amrex::ParallelDescriptor::IOProcessorNumber());
    }
}



================================================
FILE: Source/IO/SmallDataIO.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SMALLDATAIO_HPP_
#define SMALLDATAIO_HPP_

#include <algorithm>
#include <cassert>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <limits>
#include <regex>
#include <string>
#include <vector>

//! A class for reading and writing small data to a file in ASCII format.
/*!
    A class for reading and writing small data, usually 0D, 1D or 2D, in ASCII
    format. For an example on how to use it, see the WeylExtraction class.
*/
class SmallDataIO
{
  public:
    using column_t = std::vector<double>;

    //! Choose between appending data to the same file, writing to a new file
    //! at each timestep or reading a file.
    enum Mode
    {
        APPEND, // data is APPENDed to the same file at each timestep
        NEW,    // data is written to a NEW file at each timestep
        READ    // read data
    };

    // A struct for information about the structure of a SmallDataIO file
    struct file_structure_t
    {
        int num_blocks{0}; // a block is separated by 2 blank lines
        std::vector<std::streamoff>
            block_starts; // position offsets from the beginning of the file

        std::vector<int> num_header_rows;  // the number of header rows in
                                           // each block
        std::vector<int> num_data_rows;    // the number of data rows in each
                                           // block
        std::vector<int> num_data_columns; // number of data columns in each
                                           // block
        void clear();
    };

    // Maximum allowed file size in bytes when reading
    static constexpr int max_file_size = 1024 * 1024 * 1024;

  protected:
    std::string m_filename;
    double m_dt;
    double m_time;
    double m_restart_time;
    int m_step{};
    Mode m_mode;
    bool m_first_step; // this should be set to true if this is the first
                       // timestep
    static const std::string s_default_file_extension;
    static constexpr int s_default_data_precision = 10;
    int m_data_precision;
    int m_data_width;
    double m_data_epsilon; //!< the maximum data precision error
    static constexpr int s_default_coords_precision = 7;
    int m_coords_precision;
    int m_coords_width;
    double m_coords_epsilon; //!< the maximum coords precision error
    static constexpr int s_default_filename_steps_width = 6;

    std::fstream m_file;

    // These used for reading SmallDataIO files
    [[maybe_unused]] std::string m_file_contents;
    [[maybe_unused]] file_structure_t m_file_structure;
    [[maybe_unused]] bool m_structure_defined;

    // Reads the entire file
    [[maybe_unused]] void read_file();

    // Parses the file and determines its structure
    [[maybe_unused]] void determine_file_structure();

  public:
    //! The full constructor (reading and writing)
    SmallDataIO(const std::string &a_filename_prefix, double a_dt,
                double a_time, double a_restart_time, Mode a_mode,
                bool a_first_step, const file_structure_t *a_file_structure,
                const std::string &a_file_extension = s_default_file_extension,
                int a_data_precision                = s_default_data_precision,
                int a_coords_precision     = s_default_coords_precision,
                int a_filename_steps_width = s_default_filename_steps_width);

    //! Constructors for writing (opens file)
    SmallDataIO(const std::string &a_filename_prefix, double a_dt,
                double a_time, double a_restart_time, Mode a_mode,
                bool a_first_step,
                const std::string &a_file_extension = s_default_file_extension,
                int a_data_precision                = s_default_data_precision,
                int a_coords_precision     = s_default_coords_precision,
                int a_filename_steps_width = s_default_filename_steps_width);

    //! Old constructor which assumes SmallDataIO is called in
    //! specificPostTimeStep
    SmallDataIO(const std::string &a_filename_prefix, double a_dt,
                double a_time, double a_restart_time, Mode a_mode,
                const std::string &a_file_extension = s_default_file_extension,
                int a_data_precision                = s_default_data_precision,
                int a_coords_precision     = s_default_coords_precision,
                int a_filename_steps_width = s_default_filename_steps_width);

    //! Constructors for reading, when m_time, m_dt, m_restart_time are
    //! irrelevant
    SmallDataIO(const std::string &a_filename_prefix,
                const std::string &a_file_extension = s_default_file_extension,
                int a_data_precision                = s_default_data_precision,
                int a_coords_precision = s_default_coords_precision);

    // This version accepts an argument for the file structure as well (if
    // known)
    SmallDataIO(const std::string &a_filename_prefix,
                const file_structure_t *a_file_structure,
                const std::string &a_file_extension = s_default_file_extension,
                int a_data_precision                = s_default_data_precision,
                int a_coords_precision = s_default_coords_precision);

    //! Destructor (closes file)
    ~SmallDataIO();

    // disable default copy/move constructors and assignment operators
    SmallDataIO(const SmallDataIO &)            = delete;
    SmallDataIO &operator=(const SmallDataIO &) = delete;
    SmallDataIO(SmallDataIO &&)                 = delete;
    SmallDataIO &operator=(SmallDataIO &&)      = delete;

    // ------------ Writing Functions ------------

    //! Writes a header_line
    //! Use this for 0D or 1D data, where the first column is either the time
    //! or another coordinate whose name should be provided in
    //! a_pre_header_string.
    void write_header_line(const std::vector<std::string> &a_header_strings,
                           const std::string &a_pre_header_string = "time");

    //! Writes a header line
    //! Use this for 1D or 2D data when the first two or more columns are
    //! coordinates whose names should be provided in the vector of strings
    //! a_pre_header_strings
    void
    write_header_line(const std::vector<std::string> &a_header_strings,
                      const std::vector<std::string> &a_pre_header_strings);

    //! Writes a data line
    //! Use this for 0D or 1D data, where the first column is either the time or
    //! another coordinate.
    void write_data_line(const std::vector<double> &a_data,
                         const double a_coord);

    //! Writes a data line for a specific time.
    void write_time_data_line(const std::vector<double> &a_data);

    //! Writes a data line
    //! Use this for 1D or 2D data when the first two or more columns are
    //! coordinates.
    void write_data_line(const std::vector<double> &a_data,
                         const std::vector<double> &a_coords = {});

    //! This just adds a double line break to the file.
    void line_break();

    //! if restarting from an earlier checkpoint file, this function removes
    //! any time data that will be replaced.
    void remove_duplicate_time_data(const bool keep_m_time_data = false);

    // ------------ Reading Functions ------------

    //! Get the data associated to specific coordinates from the file
    //! Note only the first line with the given coordinates is obtained
    void get_specific_data_line(std::vector<double> &a_out_data,
                                const std::vector<double> &a_coords);

    //! Get the data associated to a specific coordinate (e.g. time) from the
    //! file
    void get_specific_data_line(std::vector<double> &a_out_data,
                                const double a_coord);

    // Set structure if known already (e.g. same as another file already
    // determined)
    void set_file_structure(const file_structure_t &a_file_structure);

    // File struture getter
    const file_structure_t &get_file_structure() const;

    // Print file structure
    void print_file_structure() const;

    // Get an interval of columns (inclusive) from a block
    void get_columns(std::vector<column_t> &out, int a_min_column,
                     int a_max_column, int a_block = 0);

    // Get columns based on their names in the header
    // (does not assume continguous column numbers)
    void get_columns(std::vector<column_t> &out,
                     const std::vector<std::string> &column_names,
                     const int a_block = 0);

    // Get all data columns from a block
    void get_all_data_columns(std::vector<column_t> &out, int a_block = 0);

    // Get a single column from a block
    void get_column(std::vector<column_t> &out, int a_column, int a_block = 0);

    // Get same data column from all blocks
    void get_data_column_from_all_blocks(std::vector<column_t> &out,
                                         int a_data_column);

    // Returns a vector of numeric values from a header row
    void get_data_from_header(std::vector<double> &out, int a_header_row_number,
                              int a_block) const;

    // Returns a vector of strings from a header row
    void get_header_strings(std::vector<std::string> &header,
                            int a_block = 0) const;

    // Utility function to skip the header rows to start reading where the data
    // is located
    void skip_ahead(std::istringstream &file_stream, int nlines_to_skip,
                    int a_block) const;

    // ------------ Other Functions --------------

    // Only rank designated as the IOProcessor reads. This is a helper function
    // to redistribute data amongst all ranks
    static void broadcast_data(std::vector<column_t> &data);

    //! returns the full filename of a file created in NEW mode at time=a_time
    //! with dt=a_dt
    static std::string get_new_filename(
        const std::string &a_file_prefix, double a_dt, double a_time,
        const std::string &a_file_extension = s_default_file_extension,
        int a_filename_steps_width          = s_default_filename_steps_width);

    //! returns m_data_epsilon
    double get_data_epsilon() const;

    //! returns the default data_epsilon
    static double get_default_data_epsilon();

    //! returns m_coords_epsilon
    double get_coords_epsilon() const;

    //! returns the default coords epsilon
    static double get_default_coords_epsilon();
};

#endif /* SMALLDATAIO_HPP_ */



================================================
FILE: Source/IO/StateVariablesParmParse.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef STATEVARIABLESPARMPARSE_HPP
#define STATEVARIABLESPARMPARSE_HPP

#include "StateVariables.hpp"

// Other includes
#include "GRParmParse.hpp"
#include "VariableType.hpp"
#include <algorithm>
#include <array>
#include <string>

//! Some functions to help loading state variables from a ParmParse
namespace StateVariablesParmParse
{
/// Takes a string and returns the variable enum number if the string
/// matches one of those in StateVariables::names, or returns -1
/// otherwise
static int name_to_enum(const std::string &a_var_name)
{
    const auto var_name_it =
        std::find(StateVariables::names.cbegin(), StateVariables::names.cend(),
                  a_var_name);

    auto var = std::distance(StateVariables::names.begin(), var_name_it);
    if (var != NUM_VARS)
    {
        return static_cast<int>(var);
    }
    return -1;
}

// where one has read in a subset of variables with some feature
// this reads in a set of associated values and assigns it into a full
// array of all NUM_VARS vars (setting other values to a default value)
template <class T>
void load_values_to_array(GRParmParse &pp, const char *a_values_vector_string,
                          const std::vector<int> &a_vars_vector,
                          std::array<T, NUM_VARS> &a_values_array,
                          const T a_default_value)
{
    // how many values do I need to get?
    auto num_values = a_vars_vector.size();
    // make a container for them, and load
    std::vector<T> vars_values(num_values, a_default_value);
    pp.load(a_values_vector_string, vars_values, num_values, vars_values);

    // populate the values_array for the NUM_VARS values with those read in
    a_values_array.fill(a_default_value);
    for (int i = 0; i < num_values; i++)
    {
        int icomp             = a_vars_vector[i];
        a_values_array[icomp] = vars_values[i];
    }
}

// function to create a vector of enums of vars by reading in their
// names as strings from the params file and converting it to the enums
inline void load_vars_to_vector(GRParmParse &pp,
                                const char *a_vars_vector_string,
                                std::vector<int> &a_vars_vector)
{
    int num_values = pp.countval(a_vars_vector_string);
    if (num_values > 0)
    {
        std::vector<std::string> var_names(num_values, "");
        pp.load(a_vars_vector_string, var_names, num_values, var_names);
        for (const std::string &var_name : var_names)
        {
            int var = name_to_enum(var_name);
            if (var < 0)
            {
                amrex::Print()
                    << "Variable with name " << var_name << " not found.\n";
            }
            else
            {
                a_vars_vector.push_back(var);
            }
        }
    }
}

} // namespace StateVariablesParmParse

#endif /* STATEVARIABLESPARMPARSE_HPP */



================================================
FILE: Source/Maths/Combinatorics.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef COMBINATORICS_HPP_
#define COMBINATORICS_HPP_

#include <AMReX_BLassert.H>

namespace Combinatorics
{
// Calculate factorials
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE double factorial(int n)
{
    double out = 1.0;
    for (int i = 1; i <= n; i++)
    {
        out *= i;
    }
    return out;
}

// Calculate combinatorics
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE double n_choose_r(int n, int r)
{
    AMREX_ASSERT((r >= 0) && (n >= r)); // sense check values

    double out = factorial(n) / (factorial(r) * factorial(n - r));
    return out;
}
} // namespace Combinatorics

#endif /* COMBINATORICS_HPP_ */



================================================
FILE: Source/Maths/CoordinateTransformations.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef COORDINATETRANSFORMATIONS_HPP_
#define COORDINATETRANSFORMATIONS_HPP_

#include "DimensionDefinitions.hpp"
#include "Tensor.hpp"
#include "TensorAlgebra.hpp"
#include <cmath>

namespace CoordinateTransformations
{

// Jacobian transformation matrix
static Tensor<2, amrex::Real> spherical_jacobian(const amrex::Real x,
                                                 const double y, const double z)
{
    // calculate useful position quantities
    amrex::Real rho2 = x * x + y * y;
    rho2             = std::max(rho2, 1e-12);
    amrex::Real rho  = std::sqrt(rho2);
    amrex::Real r2   = x * x + y * y + z * z;
    r2               = std::max(r2, 1e-12);
    amrex::Real r    = std::sqrt(r2);

    // And the sines and cosines of phi and theta
    amrex::Real cos_phi = x / rho;
    amrex::Real sin_phi = y / rho;

    // derivatives for jacobian matrix - drdx etc
    Tensor<2, amrex::Real> jac;
    jac[0][0] = x / r;
    jac[1][0] = cos_phi * z / r2;
    jac[2][0] = -y / rho2;
    jac[0][1] = y / r;
    jac[1][1] = sin_phi * z / r2;
    jac[2][1] = x / rho2;
    jac[0][2] = z / r;
    jac[1][2] = -rho / r2;
    jac[2][2] = 0.0;
    return jac;
}

// Inverse Jacobian
static Tensor<2, amrex::Real>
inverse_spherical_jacobian(const amrex::Real x, const double y, const double z)
{
    // calculate useful position quantities
    amrex::Real rho2 = x * x + y * y;
    amrex::Real rho  = std::sqrt(rho2);
    rho              = std::max(rho, 1e-6);
    amrex::Real r2   = x * x + y * y + z * z;
    amrex::Real r    = std::sqrt(r2);
    r                = std::max(r, 1e-6);

    // And the sines and cosines of phi and theta
    // data_t sin_theta = rho / r;
    amrex::Real cos_phi = x / rho;
    amrex::Real sin_phi = y / rho;

    // derivatives for inverse jacobian matrix - drdx etc
    Tensor<2, amrex::Real> inv_jac;
    inv_jac[0][0] = x / r;
    inv_jac[1][0] = y / r;
    inv_jac[2][0] = z / r;
    inv_jac[0][1] = z * cos_phi;
    inv_jac[1][1] = z * sin_phi;
    inv_jac[2][1] = -rho;
    inv_jac[0][2] = -y;
    inv_jac[1][2] = x;
    inv_jac[2][2] = 0.0;
    return inv_jac;
}

// Convert a Tensor (with two lower indices) in spherical coords to cartesian
// coords
static Tensor<2, amrex::Real>
spherical_to_cartesian_LL(const Tensor<2, amrex::Real> &spherical_g,
                          const amrex::Real x, const double y, const double z)
{
    Tensor<2, amrex::Real> cartesian_g;

    // derivatives for jacobian matrix - drdx etc
    Tensor<2, amrex::Real> jac = spherical_jacobian(x, y, z);

    // Convert the Tensor to cartesian coords
    FOR (i, j)
    {
        cartesian_g[i][j] = 0.;
        FOR (k, l)
        {
            cartesian_g[i][j] += spherical_g[k][l] * jac[k][i] * jac[l][j];
        }
    }
    return cartesian_g;
}

// Convert a Tensor (with two upper indices) in spherical coords to cartesian
// coords
static Tensor<2, amrex::Real>
spherical_to_cartesian_UU(const Tensor<2, amrex::Real> &spherical_g_UU,
                          const amrex::Real x, const double y, const double z)
{
    Tensor<2, amrex::Real> cartesian_g_UU;

    // derivatives for jacobian matrix - drdx etc
    Tensor<2, amrex::Real> inv_jac = inverse_spherical_jacobian(x, y, z);

    // Convert the Tensor to cartesian coords
    FOR (i, j)
    {
        cartesian_g_UU[i][j] = 0.;
        FOR (k, l)
        {
            cartesian_g_UU[i][j] +=
                spherical_g_UU[k][l] * inv_jac[i][k] * inv_jac[j][l];
        }
    }
    return cartesian_g_UU;
}

// Convert a Tensor (with two lower indices) in cartesian coords to spherical
// coords
static Tensor<2, amrex::Real>
cartesian_to_spherical_LL(const Tensor<2, amrex::Real> &cartesian_g,
                          const amrex::Real x, const double y, const double z)
{
    Tensor<2, amrex::Real> spherical_g;

    // derivatives for inverse jacobian matrix - drdx etc
    Tensor<2, amrex::Real> inv_jac = inverse_spherical_jacobian(x, y, z);

    // Convert the Tensor to spherical coords
    FOR (i, j)
    {
        spherical_g[i][j] = 0.;
        FOR (k, l)
        {
            spherical_g[i][j] +=
                cartesian_g[k][l] * inv_jac[k][i] * inv_jac[l][j];
        }
    }
    return spherical_g;
}

// Convert a Tensor (with two upper indices) in cartesian coords to spherical
// coords
static Tensor<2, amrex::Real>
cartesian_to_spherical_UU(const Tensor<2, amrex::Real> &cartesian_g_UU,
                          amrex::Real x, double y, double z)
{
    Tensor<2, amrex::Real> spherical_g_UU;

    // derivatives for jacobian matrix - drdx etc
    Tensor<2, amrex::Real> jac = spherical_jacobian(x, y, z);

    // Convert the Tensor to spherical coords
    FOR (i, j)
    {
        spherical_g_UU[i][j] = 0.;
        FOR (k, l)
        {
            spherical_g_UU[i][j] +=
                cartesian_g_UU[k][l] * jac[i][k] * jac[j][l];
        }
    }
    return spherical_g_UU;
}

// Convert a vector (with one upper index) in spherical coords to cartesian
// coords
Tensor<1, amrex::Real>
spherical_to_cartesian_U(const Tensor<1, amrex::Real> &spherical_v_U,
                         amrex::Real x, double y, double z)
{
    Tensor<1, amrex::Real> cartesian_v_U;

    // derivatives for inverse jacobian matrix - drdx etc
    Tensor<2, amrex::Real> inv_jac = inverse_spherical_jacobian(x, y, z);

    // transform the vector to cartesian coords
    FOR (i)
    {
        cartesian_v_U[i] = 0.0;
        FOR (j)
        {
            cartesian_v_U[i] += inv_jac[i][j] * spherical_v_U[j];
        }
    }
    return cartesian_v_U;
}

// Convert a vector (with one lower index) in spherical coords to cartesian
// coords
Tensor<1, amrex::Real>
spherical_to_cartesian_L(const Tensor<1, amrex::Real> &spherical_v_L,
                         amrex::Real x, double y, double z)
{
    Tensor<1, amrex::Real> cartesian_v_L;

    // derivatives for jacobian matrix - drdx etc
    Tensor<2, amrex::Real> jac = spherical_jacobian(x, y, z);

    // transform the vector to cartesian coords
    FOR (i)
    {
        cartesian_v_L[i] = 0.0;
        FOR (j)
        {
            cartesian_v_L[i] += spherical_v_L[j] * jac[j][i];
        }
    }
    return cartesian_v_L;
}

// Convert a vector (with one upper index) in cartesian coords to spherical
// coords
Tensor<1, amrex::Real>
cartesian_to_spherical_U(const Tensor<1, amrex::Real> &cartesian_v_U,
                         amrex::Real x, double y, double z)
{
    Tensor<1, amrex::Real> spherical_v_U;

    // derivatives for jacobian matrix - drdx etc
    Tensor<2, amrex::Real> jac = spherical_jacobian(x, y, z);

    // transform the vector to cartesian coords
    FOR (i)
    {
        spherical_v_U[i] = 0.0;
        FOR (j)
        {
            spherical_v_U[i] += jac[i][j] * cartesian_v_U[j];
        }
    }
    return spherical_v_U;
}

// Convert a vector (with one lower index) in cartesian coords to spherical
// coords
Tensor<1, amrex::Real>
cartesian_to_spherical_L(const Tensor<1, amrex::Real> &cartesian_v_L,
                         amrex::Real x, double y, double z)
{
    Tensor<1, amrex::Real> spherical_v_L;

    // derivatives for inverse jacobian matrix - drdx etc
    Tensor<2, amrex::Real> inv_jac = inverse_spherical_jacobian(x, y, z);

    // transform the vector to cartesian coords
    FOR (i)
    {
        spherical_v_L[i] = 0.0;
        FOR (j)
        {
            spherical_v_L[i] += cartesian_v_L[j] * inv_jac[j][i];
        }
    }
    return spherical_v_L;
}

// The area element of a sphere
amrex::Real area_element_sphere(const Tensor<2, amrex::Real> &spherical_g)
{
    return std::sqrt(spherical_g[1][1] * spherical_g[2][2] -
                     spherical_g[1][2] * spherical_g[2][1]);
}

} // namespace CoordinateTransformations
#endif /* COORDINATETRANSFORMATIONS_HPP_ */



================================================
FILE: Source/Maths/Make.package
================================================
GRTECLYN_CEXE_headers += Combinatorics.hpp \
                         CoordinateTransformations.hpp \
                         SphericalHarmonics.hpp  \
                         TensorAlgebra.hpp



================================================
FILE: Source/Maths/SphericalHarmonics.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SPHERICALHARMONICS_HPP_
#define SPHERICALHARMONICS_HPP_

#include "Combinatorics.hpp"
#include "Coordinates.hpp"
#include "Tensor.hpp"

// Functions for the spin weighted spherical harmonics
// See paper arXiv:gr-qc/0610128 eqn 40
namespace SphericalHarmonics
{
struct Y_lm_t
{
    amrex::Real Real;
    amrex::Real Im;
    amrex::Real magnitude;
};

// NOLINTBEGIN(bugprone-easily-swappable-parameters)
// Calculates the spin weight es, el, em spherical harmonic
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE Y_lm_t
spin_Y_lm(const amrex::Real x, const double y, const double z, const int es,
          const int el, const int em)
{

    AMREX_ASSERT((el >= 0) && (el >= std::abs(em)));

    Y_lm_t Y_lm{};

    // calculate useful position quantities
    amrex::Real r     = sqrt(x * x + y * y + z * z);
    r                 = std::max(r, 1.0e-6);
    amrex::Real theta = acos(z / r);
    amrex::Real phi   = atan2(y, x);

    using namespace Combinatorics;
    double coefficient  = pow(-1.0, es) * sqrt((2.0 * el + 1.0) / (4.0 * M_PI));
    coefficient        *= sqrt(factorial(el + em) * factorial(el - em) /
                               factorial(el + es) / factorial(el - es));

    amrex::Real sum = 0.0;
    int lower_limit = em + es > 0 ? em + es : 0;
    int upper_limit = el + em < el + es ? el + em : el + es;

    for (int i = lower_limit; i <= upper_limit; i++)
    {
        double temp = n_choose_r(el + es, i) * n_choose_r(el - es, i - es - em);
        sum += temp * pow(-1.0, i) *
               pow(cos(theta / 2.0), 2 * (el - i) + es + em) *
               pow(sin(theta / 2.0), 2 * i - em - es);
    }

    Y_lm.Real      = coefficient * sum * cos(em * phi);
    Y_lm.Im        = coefficient * sum * sin(em * phi);
    Y_lm.magnitude = sqrt(Y_lm.Real * Y_lm.Real + Y_lm.Im * Y_lm.Im);

    return Y_lm;
}
// NOLINTEND(bugprone-easily-swappable-parameters)

} // namespace SphericalHarmonics

#endif /* SPHERICALHARMONICS_HPP_ */



================================================
FILE: Source/Maths/TensorAlgebra.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef TENSORALGEBRA_HPP_
#define TENSORALGEBRA_HPP_

#include "AlwaysInline.hpp"
#include "DimensionDefinitions.hpp"
#include "Tensor.hpp"
#include <AMReX_REAL.H>
#include <array>

struct chris_t
{
    Tensor<3, amrex::Real> ULL;        //!< standard christoffel symbols
    Tensor<3, amrex::Real> LLL;        //!< 3 lower indices
    Tensor<1, amrex::Real> contracted; //!< contracted christoffel
};

namespace TensorAlgebra
{
/// Computes determinant of a symmetric 3x3 matrix
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE amrex::Real
compute_determinant_sym(const Tensor<2, amrex::Real, 3> &matrix)
{
    amrex::Real det = matrix[0][0] * matrix[1][1] * matrix[2][2] +
                      2 * matrix[0][1] * matrix[0][2] * matrix[1][2] -
                      matrix[0][0] * matrix[1][2] * matrix[1][2] -
                      matrix[1][1] * matrix[0][2] * matrix[0][2] -
                      matrix[2][2] * matrix[0][1] * matrix[0][1];

    return det;
}

/// Computes the determinant of a general 3x3 matrix.
/// Note: for a symmetric matrix use the simplified function
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE amrex::Real
compute_determinant(const Tensor<2, amrex::Real, 3> &matrix)
{
    amrex::Real det =
        matrix[0][0] *
            (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1]) -
        matrix[0][1] *
            (matrix[2][2] * matrix[1][0] - matrix[1][2] * matrix[2][0]) +
        matrix[0][2] *
            (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]);
    return det;
}

/// Computes the inverse of a symmetric 3x3 matrix directly.
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE Tensor<2, amrex::Real>
compute_inverse_sym(const Tensor<2, amrex::Real, 3> &matrix)
{
    amrex::Real deth         = compute_determinant_sym(matrix);
    amrex::Real deth_inverse = 1. / deth;
    Tensor<2, amrex::Real> h_UU;
    h_UU[0][0] = (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[1][2]) *
                 deth_inverse;
    h_UU[0][1] = (matrix[0][2] * matrix[1][2] - matrix[0][1] * matrix[2][2]) *
                 deth_inverse;
    h_UU[0][2] = (matrix[0][1] * matrix[1][2] - matrix[0][2] * matrix[1][1]) *
                 deth_inverse;
    h_UU[1][1] = (matrix[0][0] * matrix[2][2] - matrix[0][2] * matrix[0][2]) *
                 deth_inverse;
    h_UU[1][2] = (matrix[0][1] * matrix[0][2] - matrix[0][0] * matrix[1][2]) *
                 deth_inverse;
    h_UU[2][2] = (matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[0][1]) *
                 deth_inverse;
    h_UU[1][0] = h_UU[0][1];
    h_UU[2][0] = h_UU[0][2];
    h_UU[2][1] = h_UU[1][2];

    return h_UU;
}

/// Computes the inverse of a general 3x3 matrix.
/// Note: for a symmetric matrix use the simplified function
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE Tensor<2, amrex::Real>
compute_inverse(const Tensor<2, amrex::Real, 3> &matrix)
{
    amrex::Real deth         = compute_determinant(matrix);
    amrex::Real deth_inverse = 1. / deth;
    Tensor<2, amrex::Real> h_UU;
    h_UU[0][0] = (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1]) *
                 deth_inverse;
    h_UU[1][1] = (matrix[0][0] * matrix[2][2] - matrix[0][2] * matrix[2][0]) *
                 deth_inverse;
    h_UU[2][2] = (matrix[0][0] * matrix[1][1] - matrix[1][0] * matrix[0][1]) *
                 deth_inverse;
    h_UU[1][0] = (matrix[2][0] * matrix[1][2] - matrix[1][0] * matrix[2][2]) *
                 deth_inverse;
    h_UU[0][1] = (matrix[0][2] * matrix[2][1] - matrix[0][1] * matrix[2][2]) *
                 deth_inverse;
    h_UU[2][0] = (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]) *
                 deth_inverse;
    h_UU[0][2] = (matrix[0][1] * matrix[1][2] - matrix[1][1] * matrix[0][2]) *
                 deth_inverse;
    h_UU[2][1] = (matrix[0][1] * matrix[2][0] - matrix[0][0] * matrix[2][1]) *
                 deth_inverse;
    h_UU[1][2] = (matrix[1][0] * matrix[0][2] - matrix[0][0] * matrix[1][2]) *
                 deth_inverse;

    return h_UU;
}

/// Computes the trace of a 2-Tensor with lower indices given an inverse metric.
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE amrex::Real
compute_trace(const Tensor<2, amrex::Real> &tensor_LL,
              const Tensor<2, amrex::Real> &inverse_metric)
{
    amrex::Real trace = 0.;
    FOR (i, j)
    {
        trace += inverse_metric[i][j] * tensor_LL[i][j];
    }
    return trace;
}

/// Computes the trace of a 1,1 Tensor (a matrix) - no metric required.
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE amrex::Real
compute_trace(const Tensor<2, amrex::Real> &tensor_UL)
{
    amrex::Real trace = 0.;
    FOR (i)
        trace += tensor_UL[i][i];
    return trace;
}

AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE amrex::Real
compute_trace(const Tensor<1, Tensor<1, amrex::Real>> &tensor_UL)
{
    amrex::Real trace = 0.;
    FOR (i)
        trace += tensor_UL[i][i];
    return trace;
}

/// Computes dot product of a vector and a covector (no metric required)
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE amrex::Real
compute_dot_product(const Tensor<1, amrex::Real> &vector_U,
                    const Tensor<1, amrex::Real> &covector_L)
{
    amrex::Real dot_product = 0.;
    FOR (i)
        dot_product += vector_U[i] * covector_L[i];
    return dot_product;
}

/// Computes dot product of two covectors given an inverse metric or
/// the dot product of two vectors given a metric.
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE amrex::Real
compute_dot_product(const Tensor<1, amrex::Real> &covector1_L,
                    const Tensor<1, amrex::Real> &covector2_L,
                    const Tensor<2, amrex::Real> &inverse_metric)
{
    amrex::Real dot_product = 0.;
    FOR (m, n)
    {
        dot_product += inverse_metric[m][n] * covector1_L[m] * covector2_L[n];
    }
    return dot_product;
}

/// Removes the trace of a 2-Tensor with lower indices given a metric and an
/// inverse metric.  Or a Tensor with upper indices given an inverse metric and
/// a metric.
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE void
// NOLINTBEGIN(bugprone-easily-swappable-parameters)
make_trace_free(Tensor<2, amrex::Real> &tensor_LL,
                const Tensor<2, amrex::Real> &metric,
                const Tensor<2, amrex::Real> &inverse_metric)
// NOLINTEND(bugprone-easily-swappable-parameters)
{
    auto trace                  = compute_trace(tensor_LL, inverse_metric);
    double one_over_gr_spacedim = 1. / ((double)GR_SPACEDIM);
    FOR (i, j)
    {
        tensor_LL[i][j] -= one_over_gr_spacedim * metric[i][j] * trace;
    }
}

/// Makes a 2-Tensor symmetric
template <int size>
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE void
make_symmetric(Tensor<2, amrex::Real, size> &tensor_LL)
{
    for (int i = 0; i < size; ++i)
    {
        for (int j = 0; j < i; ++j)
        {
            tensor_LL[i][j] = 0.5 * (tensor_LL[i][j] + tensor_LL[j][i]);
            tensor_LL[j][i] = tensor_LL[i][j];
        }
    }
}

/// Raises the index of a covector
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE Tensor<1, amrex::Real>
raise_all(const Tensor<1, amrex::Real> &tensor_L,
          const Tensor<2, amrex::Real> &inverse_metric)
{
    Tensor<1, amrex::Real> tensor_U = 0.;
    FOR (i, j)
    {
        tensor_U[i] += inverse_metric[i][j] * tensor_L[j];
    }
    return tensor_U;
}

/// Raises the indices of a 2-Tensor
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE Tensor<2, amrex::Real>
raise_all(const Tensor<2, amrex::Real> &tensor_LL,
          const Tensor<2, amrex::Real> &inverse_metric)
{
    Tensor<2, amrex::Real> tensor_UU = 0.;
    FOR (i, j, k, l)
    {
        tensor_UU[i][j] +=
            inverse_metric[i][k] * inverse_metric[j][l] * tensor_LL[k][l];
    }
    return tensor_UU;
}

/// Lowers the indices of a vector
/// Note: same functionality as raise; included to improve readibility
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE Tensor<1, amrex::Real>
lower_all(const Tensor<1, amrex::Real> &tensor_U,
          const Tensor<2, amrex::Real> &metric)
{ // The code for lowering is exactly the same as for raising
    return raise_all(tensor_U, metric);
}

/// Lowers the indices of a 2-Tensor
/// Note: same functionality as raise; included to improve readibility
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE Tensor<2, amrex::Real>
lower_all(const Tensor<2, amrex::Real> &tensor_UU,
          const Tensor<2, amrex::Real> &metric)
{ // The code for lowering is exactly the same as for raising
    return raise_all(tensor_UU, metric);
}

/// Computes the (i,j) component of the Kronecker delta
constexpr int delta(int i, int j) { return static_cast<int>(i == j); }

/// Computes the levi-civita symbol (3D, NB, symbol, not the Tensor)
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE Tensor<3, double> epsilon()
{
    Tensor<3, double> epsilon = {0.};
    epsilon[0][1][2]          = 1.0;
    epsilon[1][2][0]          = 1.0;
    epsilon[2][0][1]          = 1.0;
    epsilon[0][2][1]          = -1.0;
    epsilon[2][1][0]          = -1.0;
    epsilon[1][0][2]          = -1.0;

    return epsilon;
}

/// Computes the levi-civita symbol (4D, NB, symbol, not the Tensor)
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE Tensor<4, double, 4> epsilon4D()
{
    Tensor<4, double, 4> epsilon4D = {0.0};
    epsilon4D[0][1][2][3]          = 1.0;
    epsilon4D[0][1][3][2]          = -1.0;
    epsilon4D[0][3][1][2]          = 1.0;
    epsilon4D[0][3][2][1]          = -1.0;
    epsilon4D[0][2][1][3]          = -1.0;
    epsilon4D[0][2][3][1]          = 1.0;

    epsilon4D[1][0][2][3] = -1.0;
    epsilon4D[1][2][0][3] = 1.0;
    epsilon4D[1][2][3][0] = -1.0;
    epsilon4D[1][3][2][0] = 1.0;
    epsilon4D[1][3][0][2] = -1.0;
    epsilon4D[1][0][3][2] = 1.0;

    epsilon4D[2][0][1][3] = 1.0;
    epsilon4D[2][0][3][1] = -1.0;
    epsilon4D[2][3][0][1] = 1.0;
    epsilon4D[2][3][1][0] = -1.0;
    epsilon4D[2][1][3][0] = 1.0;
    epsilon4D[2][1][0][3] = -1.0;

    epsilon4D[3][0][1][2] = -1.0;
    epsilon4D[3][1][0][2] = 1.0;
    epsilon4D[3][1][2][0] = -1.0;
    epsilon4D[3][2][1][0] = 1.0;
    epsilon4D[3][2][0][1] = -1.0;
    epsilon4D[3][0][2][1] = 1.0;

    return epsilon4D;
}

/// Computes the conformal christoffel symbol
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE chris_t
compute_christoffel(const Tensor<2, Tensor<1, amrex::Real>> &d1_metric,
                    const Tensor<2, amrex::Real> &h_UU)
{
    chris_t out{};

    FOR (i, j, k)
    {
        out.LLL[i][j][k] = 0.5 * (d1_metric[j][i][k] + d1_metric[k][i][j] -
                                  d1_metric[j][k][i]);
    }
    FOR (i, j, k)
    {
        out.ULL[i][j][k] = 0;
        FOR (l)
        {
            out.ULL[i][j][k] += h_UU[i][l] * out.LLL[l][j][k];
        }
    }
    FOR (i)
    {
        out.contracted[i] = 0;
        FOR (j, k)
        {
            out.contracted[i] += h_UU[j][k] * out.ULL[i][j][k];
        }
    }

    return out;
}

AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE Tensor<3, amrex::Real>
compute_phys_chris(const Tensor<1, amrex::Real> &d1_chi,
                   const amrex::Real &vars_chi,
                   const Tensor<2, amrex::Real> &vars_h,
                   const Tensor<2, amrex::Real> &h_UU,
                   const Tensor<3, amrex::Real> &chris_ULL)
{
    Tensor<3, amrex::Real> chris_phys;
    FOR (i, j, k)
    {
        chris_phys[i][j][k] =
            chris_ULL[i][j][k] -
            0.5 / vars_chi *
                (delta(i, k) * d1_chi[j] + delta(i, j) * d1_chi[k]);
        FOR (m)
        {
            chris_phys[i][j][k] +=
                0.5 / vars_chi * vars_h[j][k] * h_UU[i][m] * d1_chi[m];
        }
    }
    return chris_phys;
}
} // namespace TensorAlgebra

#endif /* TENSORALGEBRA_HPP_ */



================================================
FILE: Source/Matter/CCZ4RHSWithMatter.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef CCZ4RHSWITHMATTER_HPP_
#define CCZ4RHSWITHMATTER_HPP_

#include "CCZ4Geometry.hpp"
#include "CCZ4RHS.hpp"
#include "Cell.hpp"
#include "FourthOrderDerivatives.hpp"
#include "MovingPunctureGaugeWithMatter.hpp"
#include "StateVariables.hpp" //This files needs NUM_VARS - total number of components
#include "Tensor.hpp"
#include "TensorAlgebra.hpp"
#include "VarsTools.hpp"

//!  Calculates RHS using CCZ4 including matter terms, and matter variable
//!  evolution
/*!
     The class calculates the RHS evolution for all the variables. It inherits
   from the CCZ4RHS class, which it uses to do the non matter evolution of
   variables. It then adds in the additional matter terms to the CCZ4 evolution
   (those including the stress energy tensor), and calculates the evolution of
   the matter variables. It does not assume a specific form of matter but is
   templated over a matter class matter_t. Please see the class ScalarField as
   an example of a matter_t. \sa CCZ4RHS(), ScalarField()
*/

template <class matter_t, class gauge_t = MovingPunctureGaugeWithMatter,
          class deriv_t = FourthOrderDerivatives>
class CCZ4RHSWithMatter : public CCZ4RHS<gauge_t, deriv_t>
{
  public:
    // Use this alias for the same template instantiation as this class
    using CCZ4 = CCZ4RHS<gauge_t, deriv_t>;

    using params_t = CCZ4_params_t<typename gauge_t::params_t>;

    template <class data_t>
    using MatterVars = typename matter_t::template Vars<data_t>;

    template <class data_t>
    using MatterDiff2Vars = typename matter_t::template Diff2Vars<data_t>;

    template <class data_t>
    using CCZ4Vars = typename CCZ4::template Vars<data_t>;

    template <class data_t>
    using CCZ4Diff2Vars = typename CCZ4::template Diff2Vars<data_t>;

    // Inherit the variable definitions from CCZ4RHS + matter_t
    template <class data_t>
    struct Vars : public CCZ4Vars<data_t>, public MatterVars<data_t>
    {
        /// Defines the mapping between members of Vars and Chombo grid
        /// variables (enum in User_Variables)
        template <typename mapping_function_t>
        AMREX_GPU_DEVICE void enum_mapping(mapping_function_t mapping_function)
        {
            CCZ4Vars<data_t>::enum_mapping(mapping_function);
            MatterVars<data_t>::enum_mapping(mapping_function);
        }
    };

    template <class data_t>
    struct Diff2Vars : public CCZ4Diff2Vars<data_t>,
                       public MatterDiff2Vars<data_t>
    {
        /// Defines the mapping between members of Vars and Chombo grid
        /// variables (enum in User_Variables)
        template <typename mapping_function_t>
        AMREX_GPU_DEVICE void enum_mapping(mapping_function_t mapping_function)
        {
            CCZ4Diff2Vars<data_t>::enum_mapping(mapping_function);
            MatterDiff2Vars<data_t>::enum_mapping(mapping_function);
        }
    };

    //!  Constructor of class MatterCCZ4
    /*!
       Inputs are the grid spacing, plus the CCZ4 evolution parameters and a
       matter object. It also takes the dissipation parameter sigma, and allows
       the formulation to be toggled between CCZ4 and BSSN. The default is CCZ4.
       It allows the user to set the value of Newton's constant, which is set to
       one by default.
    */
    CCZ4RHSWithMatter(params_t a_params, double a_dx, double a_sigma,
                      int a_formulation = CCZ4RHS<>::USE_CCZ4,
                      double a_G_Newton = 1.0);

    //!  The compute member which calculates the RHS at each point in the box
    //!  \sa matter_rhs_equation()
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
    compute(int i, int j, int k, const amrex::Array4<amrex::Real> &rhs_arrays,
            const amrex::Array4<amrex::Real const> &state_arrays) const;

  protected:
    //! The function which adds in the EM Tensor terms to the CCZ4 rhs \sa
    //! compute()
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void add_emtensor_rhs(
        Vars<amrex::Real>
            &matter_rhs, //!< the RHS data for each variable at that point.
        const Vars<amrex::Real>
            &vars, //!< the value of the variables at the point.
        const Vars<Tensor<1, amrex::Real>>
            &d1 //!< the value of the first derivatives of the variables.
    ) const;

    // Class members
    matter_t m_matter; //!< The matter object, e.g. a scalar field.
    double m_G_Newton; //!< Newton's constant, set to one by default.
};

#include "CCZ4RHSWithMatter.impl.hpp"

#endif /* CCZ4RHSWITHMATTER_HPP_ */



================================================
FILE: Source/Matter/CCZ4RHSWithMatter.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(CCZ4RHSWITHMATTER_HPP_)
#error "This file should only be included through MatterCCZ4RHS.hpp"
#endif

#ifndef CCZ4RHSWITHMATTER_IMPL_HPP_
#define CCZ4RHSWITHMATTER_IMPL_HPP_
#include "DimensionDefinitions.hpp"

template <class matter_t, class gauge_t, class deriv_t>
CCZ4RHSWithMatter<matter_t, gauge_t, deriv_t>::CCZ4RHSWithMatter(
    CCZ4_params_t<typename gauge_t::params_t> a_params, double a_dx,
    double a_sigma, int a_formulation, double a_G_Newton)
    : CCZ4RHS<gauge_t, deriv_t>(a_params, a_dx, a_sigma, a_formulation,
                                0.0 /*No cosmological constant*/),
      m_G_Newton(a_G_Newton)
{
}

template <class matter_t, class gauge_t, class deriv_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
CCZ4RHSWithMatter<matter_t, gauge_t, deriv_t>::compute(
    int i, int j, int k, const amrex::Array4<amrex::Real> &rhs_arrays,
    const amrex::Array4<amrex::Real const> &state_arrays) const
{
    // copy data from chombo gridpoint into local variables
    const auto matter_vars = load_vars<Vars>(state_arrays.cellData(i, j, k));
    const auto d1 = this->m_deriv.template diff1<Vars>(i, j, k, state_arrays);
    const auto d2 =
        this->m_deriv.template diff2<Diff2Vars>(i, j, k, state_arrays);
    const auto advec = this->m_deriv.template advection<Vars>(
        i, j, k, state_arrays, matter_vars.shift);

    // Call CCZ4 RHS - work out RHS without matter, no dissipation
    Vars<amrex::Real> matter_rhs;
    this->rhs_equation(matter_rhs, matter_vars, d1, d2, advec);

    // add RHS matter terms from EM Tensor
    add_emtensor_rhs(matter_rhs, matter_vars, d1);

    // add evolution of matter fields themselves
    m_matter.add_matter_rhs(matter_rhs, matter_vars, d1, d2, advec);

    // Add dissipation to all terms
    this->m_deriv.add_dissipation(i, j, k, matter_rhs, state_arrays,
                                  this->m_sigma);

    // Write the rhs into the output FArrayBox
    store_vars(rhs_arrays.cellData(i, j, k), matter_rhs);
}

// Function to add in EM Tensor matter terms to CCZ4 rhs
template <class matter_t, class gauge_t, class deriv_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
CCZ4RHSWithMatter<matter_t, gauge_t, deriv_t>::add_emtensor_rhs(
    Vars<amrex::Real> &matter_rhs, const Vars<amrex::Real> &matter_vars,
    const Vars<Tensor<1, amrex::Real>> &d1) const
{
    using namespace TensorAlgebra;

    const auto h_UU  = compute_inverse_sym(matter_vars.h);
    const auto chris = compute_christoffel(d1.h, h_UU);

    // Calculate elements of the decomposed stress energy tensor
    const auto emtensor =
        m_matter.compute_emtensor(matter_vars, d1, h_UU, chris.ULL);

    // Update RHS for K and Theta depending on formulation
    if (this->m_formulation == CCZ4RHS<>::USE_BSSN)
    {
        matter_rhs.K += 4.0 * M_PI * m_G_Newton * matter_vars.lapse *
                        (emtensor.trS + emtensor.rho);
        matter_rhs.Theta += 0.0;
    }
    else
    {
        matter_rhs.K += 4.0 * M_PI * m_G_Newton * matter_vars.lapse *
                        (emtensor.trS - 3 * emtensor.rho);
        matter_rhs.Theta +=
            -8.0 * M_PI * m_G_Newton * matter_vars.lapse * emtensor.rho;
    }

    // Update RHS for other variables
    Tensor<2, amrex::Real> S_TF = emtensor.S;
    make_trace_free(S_TF, matter_vars.h, h_UU);

    FOR (i, j)
    {
        matter_rhs.A[i][j] += -8.0 * M_PI * m_G_Newton * matter_vars.chi *
                              matter_vars.lapse * S_TF[i][j];
    }

    FOR (i)
    {
        amrex::Real matter_term_Gamma = 0.0;
        FOR (j)
        {
            matter_term_Gamma += -16.0 * M_PI * m_G_Newton * matter_vars.lapse *
                                 h_UU[i][j] * emtensor.j[j];
        }

        matter_rhs.Gamma[i] += matter_term_Gamma;
    }
    // Add matter contribution to RHS of gauge evolution
    this->m_gauge.rhs_gauge_add_matter_terms(matter_rhs, matter_vars, h_UU,
                                             emtensor, m_G_Newton);
}

#endif /* CCZ4RHSWITHMATTER_IMPL_HPP_ */



================================================
FILE: Source/Matter/ConstraintsWithMatter.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef CONSTRAINTSWITHMATTER_HPP_
#define CONSTRAINTSWITHMATTER_HPP_

#include "CCZ4Geometry.hpp"
#include "Cell.hpp"
#include "Constraints.hpp"
#include "FourthOrderDerivatives.hpp"
#include "GRInterval.hpp"
#include "Tensor.hpp"
#include <array>

//!  Calculates the Hamiltonian and Momentum constraints with matter fields
/*!
     The class calculates the Hamiltonian and Momentum constraints at each point
   in a box. It inherits from the Constraints class which calculates the
   constraints without the matter terms. It adds in the matter terms for a given
   matter class matter_t, which must provide it with the Energy Momentum Tensor.
   For an example of a matter_t class see ScalarField. \sa Constraints(),
   ScalarField()
*/
template <class matter_t> class ConstraintsWithMatter : public Constraints
{
  public:
    template <class data_t>
    using MatterVars = typename matter_t::template Vars<data_t>;

    // Inherit the variable definitions from CCZ4 + matter_t
    template <class data_t>
    struct BSSNMatterVars : public Constraints::MetricVars<data_t>,
                            public MatterVars<data_t>
    {
        /// Defines the mapping between members of Vars and Chombo grid
        /// variables (enum in User_Variables)
        template <typename mapping_function_t>
        AMREX_GPU_DEVICE void enum_mapping(mapping_function_t mapping_function)
        {
            Constraints::MetricVars<data_t>::enum_mapping(mapping_function);
            MatterVars<data_t>::enum_mapping(mapping_function);
        }
    };

    //! Constructor of class ConstraintsWithMatter
    /*!
        Can specify the vars of the constraint vars instead of using the
        hardcoded ones.
    */
    ConstraintsWithMatter(double dx, double G_Newton, int a_c_Ham,
                          const Interval &a_c_Moms, int a_c_Ham_abs_terms = -1,
                          const Interval &a_c_Moms_abs_terms = Interval());

    //! The compute member which calculates the constraints at each point in the
    //! box
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
    compute(int i, int j, int k, const amrex::Array4<amrex::Real> &out_arrays,
            const amrex::Array4<amrex::Real const> &state_arrays) const;

    static void set_up(int a_state_index, bool a_calc_mom_norm = false);

    // Has signature of DeriveFuncMF so that it can be stored in the derive_lst
    static void compute_mf(amrex::MultiFab &out_mf, int dcomp, int ncomp,
                           const amrex::MultiFab &src_mf,
                           const amrex::Geometry &geomdata,
                           amrex::Real /*time*/, const int * /*bcrec*/,
                           int /*level*/);

  protected:
    matter_t my_matter; //!< The matter object, e.g. a scalar field
    double m_G_Newton;  //!< Newton's constant, set to one by default.
};

#include "ConstraintsWithMatter.impl.hpp"

#endif /* CONSTRAINTSWITHMATTER_HPP_ */



================================================
FILE: Source/Matter/ConstraintsWithMatter.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(CONSTRAINTSWITHMATTER_HPP_)
#error "This file should only be included through ConstraintsWithMatter.hpp"
#endif

#ifndef CONSTRAINTSWITHMATTER_IMPL_HPP_
#define CONSTRAINTSWITHMATTER_IMPL_HPP_

#include "ConstraintsWithMatter.hpp"
#include "DimensionDefinitions.hpp"
#include "GRParmParse.hpp"

template <class matter_t>
ConstraintsWithMatter<matter_t>::ConstraintsWithMatter(
    double dx, double G_Newton, int a_c_Ham, const Interval &a_c_Moms,
    int a_c_Ham_abs_terms /* defaulted*/,
    const Interval &a_c_Moms_abs_terms /*defaulted*/)
    : Constraints(dx, a_c_Ham, a_c_Moms, a_c_Ham_abs_terms, a_c_Moms_abs_terms,
                  0.0 /*No cosmological constant*/),
      m_G_Newton(G_Newton)
{
}

template <class matter_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
ConstraintsWithMatter<matter_t>::compute(
    int i, int j, int k, const amrex::Array4<amrex::Real> &out_arrays,
    const amrex::Array4<amrex::Real const> &state_arrays) const
{
    // Load local vars and calculate derivs
    const auto vars = load_vars<BSSNMatterVars>(state_arrays.cellData(i, j, k));
    const auto d1 =
        m_deriv.template diff1<BSSNMatterVars>(i, j, k, state_arrays);
    const auto d2 =
        m_deriv.template diff2<BSSNMatterVars>(i, j, k, state_arrays);

    // Inverse metric and Christoffel symbol
    const auto h_UU  = TensorAlgebra::compute_inverse_sym(vars.h);
    const auto chris = TensorAlgebra::compute_christoffel(d1.h, h_UU);

    // Get the non matter terms for the constraints
    Vars out = constraint_equations(vars, d1, d2, h_UU, chris);

    // Energy Momentum Tensor
    const auto emtensor = my_matter.compute_emtensor(vars, d1, h_UU, chris.ULL);

    // Hamiltonian constraint
    if (m_c_Ham >= 0 || m_c_Ham_abs_terms >= 0)
    {
        out.Ham           += -16.0 * M_PI * m_G_Newton * emtensor.rho;
        out.Ham_abs_terms += 16.0 * M_PI * m_G_Newton * std::abs(emtensor.rho);
    }

    // Momentum constraints
    if (m_c_Moms.size() > 0 || m_c_Moms_abs_terms.size() > 0)
    {
        FOR (i)
        {
            out.Mom[i] += -8.0 * M_PI * m_G_Newton * emtensor.j[i];
            out.Mom_abs_terms[i] +=
                8.0 * M_PI * m_G_Newton * std::abs(emtensor.j[i]);
        }
    }
    // Write the constraints into the output FArrayBox
    store_vars(out, out_arrays.cellData(i, j, k));
}

template <class matter_t>
void ConstraintsWithMatter<matter_t>::set_up(int a_state_index,
                                             bool a_calc_mom_norm)
{

    int num_ghosts = 2;

    auto &derive_lst     = amrex::AmrLevel::get_derive_lst();
    const auto &desc_lst = amrex::AmrLevel::get_desc_lst();

    const auto &comp_names = (a_calc_mom_norm) ? Constraints::var_names_norm
                                               : Constraints::var_names;
    // Add Constraints to the derive list
    derive_lst.add(
        Constraints::name, amrex::IndexType::TheCellType(),
        static_cast<int>(comp_names.size()), comp_names,
        ConstraintsWithMatter::compute_mf, [=](const amrex::Box &box)
        { return amrex::grow(box, num_ghosts); }, &amrex::cell_quartic_interp);

    derive_lst.addComponent(Constraints::name, desc_lst, a_state_index, 0,
                            NUM_VARS);
}
template <class matter_t>
void ConstraintsWithMatter<matter_t>::compute_mf(
    amrex::MultiFab &out_mf, int dcomp, int ncomp,
    const amrex::MultiFab &src_mf, const amrex::Geometry &geomdata,
    amrex::Real /*time*/, const int * /*bcrec*/, int /*level*/)
{
    const auto &out_arrays = out_mf.arrays();
    const auto &src_arrays = src_mf.const_arrays();

    GRParmParse pp;
    amrex::Real G_Newton = 0;

    pp.get("G_Newton", G_Newton, 0);

    amrex::Real dx = geomdata.CellSize(0);
    int iham       = dcomp; // Ham
    Interval imom =
        Interval(dcomp + 1, dcomp + AMREX_SPACEDIM); // Mom1, Mom2, Mom3

    AMREX_ALWAYS_ASSERT(ncomp == (1 + AMREX_SPACEDIM));

    ConstraintsWithMatter<matter_t> my_matter_constraints(dx, G_Newton, iham,
                                                          imom);

    amrex::ParallelFor(
        out_mf,
        [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k) noexcept
        {
            my_matter_constraints.compute(i, j, k, out_arrays[box_no],
                                          src_arrays[box_no]);
        });
}

#endif /* CONSTRAINTSWITHMATTER_IMPL_HPP_ */



================================================
FILE: Source/Matter/DefaultPotential.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef DEFAULTPOTENTIAL_HPP_
#define DEFAULTPOTENTIAL_HPP_

#include "Tensor.hpp"
#include <AMReX_REAL.H>

class DefaultPotential
{
  public:
    //! The constructor
    DefaultPotential() = default;

    //! Set the potential function for the scalar field here to zero
    template <class vars_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
    // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
    compute_potential(amrex::Real &V_of_phi, amrex::Real &dVdphi,
                      const vars_t &vars) const
    {
        // The potential value at phi
        V_of_phi = 0.0;

        // The potential gradient at phi
        dVdphi = 0.0;
    }
};

#endif /* DEFAULTPOTENTIAL_HPP_ */



================================================
FILE: Source/Matter/EMTensor.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef EMTENSOR_HPP
#define EMTENSOR_HPP

#include "CCZ4Geometry.hpp"
#include "CCZ4RHSWithMatter.hpp"
#include "Cell.hpp"
#include "FourthOrderDerivatives.hpp"
#include "Interval.hpp"
#include "VarsTools.hpp"

// AMReX Includes
#include <AMReX_MultiFab.H>

//! Calculates the EM tensor and then saves the ones specified in the
//! constructor on the grid

//! Parts of the EMTensor to store
enum class EMTensorOptions
{
    justEnergyDensity,          //! just the energy density
    energyAndMomentumDensities, //! both the energy density and the momentum
                                //! density
    allDensities, //! the energy density, momentum density and the stress tensor
};

//! Calculates the EM tensor and then saves the parts depending on the
//! em_tensor_options_t template argument
template <class matter_t, enum EMTensorOptions em_tensor_options> class EMTensor
{
  public:
    template <class data_t>
    using Vars = typename CCZ4RHSWithMatter<matter_t>::template Vars<data_t>;

    /// derive record name
    static inline const std::string name = "EMTensor";

    /// Variable names
    static amrex::Vector<std::string> var_names();

    //! Constructor
    EMTensor(double dx, int a_dcomp);

    // NOLINTBEGIN(bugprone-easily-swappable-parameters)
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
    compute(int i, int j, int k, const amrex::Array4<amrex::Real> &out_arrays,
            const amrex::Array4<const amrex::Real> &in_arrays) const;
    // NOLINTEND(bugprone-easily-swappable-parameters)

    // Set do_all_components to true to calculate the momentum density
    // and stress energy tensors as well
    AMREX_FORCE_INLINE static void set_up(int a_state_index);

    AMREX_FORCE_INLINE static void
    compute_mf(amrex::MultiFab &out_mf, int dcomp, int ncomp,
               const amrex::MultiFab &src_mf, const amrex::Geometry &geomdata,
               amrex::Real /*time*/, const int * /*bcrec*/, int /*level*/);

  protected:
    matter_t m_matter;
    FourthOrderDerivatives m_deriv;
    int m_dcomp; //!< which component in the MultiFab to store the first
                 //!< variable
};

#include "EMTensor.impl.hpp"

#endif /* EMTENSOR_HPP */



================================================
FILE: Source/Matter/EMTensor.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(EMTENSOR_HPP)
#error "This file should only be included through EMTensor.hpp"
#endif

#ifndef EMTENSOR_IMPL_HPP
#define EMTENSOR_IMPL_HPP

#include <AMReX_AmrLevel.H>

#include "CCZ4Geometry.hpp"
#include "Cell.hpp"
#include "DimensionDefinitions.hpp"
#include "FourthOrderDerivatives.hpp"
#include "Interval.hpp"
#include "simd.hpp"

template <class matter_t, enum EMTensorOptions em_tensor_options>
amrex::Vector<std::string> EMTensor<matter_t, em_tensor_options>::var_names()
{
    if constexpr (em_tensor_options == EMTensorOptions::justEnergyDensity)
    {
        return {"rho"};
    }
    else if (em_tensor_options == EMTensorOptions::energyAndMomentumDensities)
    {
        return {"rho", "j_1", "j_2", "j_3"};
    }
    else
    {
        return {"rho",  "j_1",  "j_2",  "j_3",  "S_11",
                "S_12", "S_13", "S_22", "S_23", "S_33"};
    }
}

template <class matter_t, enum EMTensorOptions em_tensor_options>
EMTensor<matter_t, em_tensor_options>::EMTensor(double a_dx, int a_dcomp)
    : m_deriv(a_dx), m_dcomp(a_dcomp)
{
}

// NOLINTBEGIN(bugprone-easily-swappable-parameters)
template <class matter_t, enum EMTensorOptions em_tensor_options>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
EMTensor<matter_t, em_tensor_options>::compute(
    int i, int j, int k, const amrex::Array4<amrex::Real> &out_arrays,
    const amrex::Array4<const amrex::Real> &in_arrays) const
// NOLINTEND(bugprone-easily-swappable-parameters)
{
    const auto vars = load_vars<Vars>(in_arrays.cellData(i, j, k));
    const auto d1   = m_deriv.template diff1<Vars>(i, j, k, in_arrays);

    using namespace TensorAlgebra;

    const auto h_UU  = compute_inverse_sym(vars.h);
    const auto chris = compute_christoffel(d1.h, h_UU);

    const auto emtensor = m_matter.compute_emtensor(vars, d1, h_UU, chris.ULL);

    out_arrays(i, j, k, m_dcomp) = emtensor.rho;

    if constexpr (em_tensor_options ==
                      EMTensorOptions::energyAndMomentumDensities ||
                  em_tensor_options == EMTensorOptions::allDensities)
    {
#if DEFAULT_TENSOR_DIM == 3
        FOR (i)
        {
            out_arrays(i, j, k, m_dcomp + 1 + i) = emtensor.j[i];
        }
#endif
    }

    if constexpr (em_tensor_options == EMTensorOptions::allDensities)
    {
#if DEFAULT_TENSOR_DIM == 3
        out_arrays(i, j, k, m_dcomp + 4) = emtensor.S[0][0];
        out_arrays(i, j, k, m_dcomp + 5) = emtensor.S[0][1];
        out_arrays(i, j, k, m_dcomp + 6) = emtensor.S[0][2];
        out_arrays(i, j, k, m_dcomp + 7) = emtensor.S[1][1];
        out_arrays(i, j, k, m_dcomp + 8) = emtensor.S[1][2];
        out_arrays(i, j, k, m_dcomp + 9) = emtensor.S[2][2];
    }
}
#endif

template <class matter_t, enum EMTensorOptions em_tensor_options>
AMREX_FORCE_INLINE void
EMTensor<matter_t, em_tensor_options>::set_up(int a_state_index)
{
    int num_ghosts = 2;

    auto derive_var_names = var_names();

    auto &derive_lst     = amrex::AmrLevel::get_derive_lst();
    const auto &desc_lst = amrex::AmrLevel::get_desc_lst();

    // Add EMTensor to the derive list
    derive_lst.add(
        name, amrex::IndexType::TheCellType(), derive_var_names.size(),
        derive_var_names, EMTensor::compute_mf, [=](const amrex::Box &box)
        { return amrex::grow(box, num_ghosts); }, &amrex::cell_quartic_interp);

    derive_lst.addComponent(name, desc_lst, a_state_index, 0, NUM_VARS);
}

template <class matter_t, enum EMTensorOptions em_tensor_options>
AMREX_FORCE_INLINE void EMTensor<matter_t, em_tensor_options>::compute_mf(
    amrex::MultiFab &out_mf, int dcomp, int ncomp,
    const amrex::MultiFab &src_mf, const amrex::Geometry &geomdata,
    amrex::Real /*time*/, const int * /*bcrec*/, int /*level*/)
{
    const auto &out_arrays = out_mf.arrays();
    const auto &src_arrays = src_mf.const_arrays();

    EMTensor<matter_t, em_tensor_options> em_tensor(geomdata.CellSize(0),
                                                    dcomp);

    amrex::ParallelFor(
        out_mf,
        [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k) noexcept
        {
            em_tensor.compute(i, j, k, out_arrays[box_no], src_arrays[box_no]);
        });
}

#endif /* EMTENSOR_IMPL_HPP */



================================================
FILE: Source/Matter/Make.package
================================================
GRTECLYN_CEXE_headers += ConstraintsWithMatter.hpp \
                         ConstraintsWithMatter.impl.hpp \
                         DefaultPotential.hpp \
                         EMTensor.hpp \
                         EMTensor.impl.hpp \
                         CCZ4RHSWithMatter.hpp \
                         CCZ4RHSWithMatter.impl.hpp \
                         Weyl4WithMatter.hpp \
                         Weyl4WithMatter.impl.hpp \
                         MovingPunctureGaugeWithMatter \
                         ScalarField.hpp \
                         ScalarField.impl.hpp


================================================
FILE: Source/Matter/MovingPunctureGaugeWithMatter.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef MOVINGPUNCTUREGAUGEWITHMATTER_HPP_
#define MOVINGPUNCTUREGAUGEWITHMATTER_HPP_

#include "CCZ4RHSWithMatter.hpp"
#include "DimensionDefinitions.hpp"
// #include "EMTensor.hpp"
#include "Tensor.hpp"

#include <cmath>

/**
 * This class implements a slightly more generic version of the moving puncture
 * gauge. In particular it uses a Bona-Masso slicing condition of the form
 * f(lapse) = -c*lapse^(p-2)
 * and a Gamma-driver shift condition
 **/

/// This class adds the matter terms to the RHS of the gauge equation
/// for the moving puncture gauge

class MovingPunctureGaugeWithMatter : public MovingPunctureGauge
{

  public:
    MovingPunctureGaugeWithMatter(const params_t &a_params)
        : MovingPunctureGauge(a_params)
    {
    }

    // NOLINTBEGIN(bugprone-easily-swappable-parameters)
    template <class vars_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
    rhs_gauge_add_matter_terms(vars_t &matter_rhs, const vars_t &matter_vars,
                               Tensor<2, amrex::Real, 3> h_UU,
                               const emtensor_t emtensor,
                               const double G_Newton) const
    // NOLINTEND(bugprone-easily-swappable-parameters)
    {
        FOR (i)
        {
            amrex::Real matter_term_Gamma = 0.0;
            FOR (j)
            {
                matter_term_Gamma += -16.0 * M_PI * G_Newton *
                                     matter_vars.lapse * h_UU[i][j] *
                                     emtensor.j[j];
            }

            matter_rhs.B[i] += matter_term_Gamma;
        }
    }
};

#endif /* MOVINGPUNCTUREGAUGEWITHMATTER_HPP_ */



================================================
FILE: Source/Matter/ScalarField.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SCALARFIELD_HPP_
#define SCALARFIELD_HPP_

#include "CCZ4Geometry.hpp"
#include "DefaultPotential.hpp"
#include "DimensionDefinitions.hpp"
#include "FourthOrderDerivatives.hpp"
#include "StateVariables.hpp" //This files needs NUM_VARS, total num of components
#include "Tensor.hpp"
#include "TensorAlgebra.hpp"
#include "VarsTools.hpp"

//!  Calculates the matter type specific elements such as the EMTensor and
//   matter evolution
/*!
     This class is an example of a matter_t object which calculates the
     matter type specific elements for the RHS update and the evaluation
     of the constraints. This includes the Energy Momentum Tensor, and
     the matter evolution terms. In this case, a scalar field,
     the matter elements are phi and (minus) its conjugate momentum, Pi.
     It is templated over a potential function potential_t which the
     user must specify in a class, although a default is provided which
     sets dVdphi and V_of_phi to zero.
     It assumes minimal coupling of the field to gravity.
     \sa MatterCCZ4(), ConstraintsMatter()
*/
template <class potential_t = DefaultPotential> class ScalarField
{
  protected:
    potential_t m_potential;
    //! The local copy of the potential

  public:

    //!  Constructor of class ScalarField, inputs are the matter parameters.
    ScalarField() = default;

    //! Structure containing the rhs variables for the matter fields
    template <class data_t> struct Vars
    {
        data_t phi;
        data_t Pi;

        /// Defines the mapping between members of Vars and Chombo grid
        /// variables (enum in User_Variables)
        template <typename mapping_function_t>
        AMREX_GPU_DEVICE void enum_mapping(mapping_function_t mapping_function)
        {
            VarsTools::define_enum_mapping(mapping_function, c_phi, phi);
            VarsTools::define_enum_mapping(mapping_function, c_Pi, Pi);
        }
    };

    //! Structure containing the rhs variables for the matter fields requiring
    //!  2nd derivs
    template <class data_t> struct Diff2Vars
    {
        data_t phi;

        /// Defines the mapping between members of Vars and Chombo grid
        ///  variables (enum in User_Variables)
        template <typename mapping_function_t>
        AMREX_GPU_DEVICE void enum_mapping(mapping_function_t mapping_function)
        {
            VarsTools::define_enum_mapping(mapping_function, c_phi, phi);
        }
    };

    //! The function which calculates the EM Tensor, given the vars and
    //! derivatives, including the potential
    template <template <class> class vars_t>
    AMREX_GPU_DEVICE emtensor_t compute_emtensor(
        const vars_t<amrex::Real> &vars, //!< the value of the variables
        const vars_t<Tensor<1, amrex::Real>>
            &d1, //!< the value of the 1st derivs
        const Tensor<2, amrex::Real>
            &h_UU, //!< the inverse metric (raised indices)
        const Tensor<3, amrex::Real> &chris_ULL)
        const; //!< the conformal christoffel symbol

    //! The function which adds in the RHS for the matter field vars,
    //! including the potential
    template <template <class> class vars_t, class rhs_vars_t, class d2_vars_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void add_matter_rhs(
        rhs_vars_t &rhs,                 //!< value of the RHS for all vars
        const vars_t<amrex::Real> &vars, //!< value of the variables
        const vars_t<Tensor<1, amrex::Real>> &d1, //!< value of the 1st derivs
        const d2_vars_t &d2,                      //!< value of the 2nd derivs
        const vars_t<amrex::Real> &advec)
        const; //!< the value of the advection terms
};

#include "ScalarField.impl.hpp"

#endif /* SCALARFIELD_HPP_ */



================================================
FILE: Source/Matter/ScalarField.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(SCALARFIELD_HPP_)
#error "This file should only be included through ScalarField.hpp"
#endif

#ifndef SCALARFIELD_IMPL_HPP_
#define SCALARFIELD_IMPL_HPP_

// Calculate the stress energy tensor elements
template <class potential_t>
template <template <class> class vars_t>
AMREX_GPU_DEVICE emtensor_t ScalarField<potential_t>::compute_emtensor(
    const vars_t<amrex::Real> &vars, const vars_t<Tensor<1, amrex::Real>> &d1,
    const Tensor<2, amrex::Real> &h_UU,
    const Tensor<3, amrex::Real> &chris_ULL) const
{
    emtensor_t out;

    //    Useful quantity Vt
    amrex::Real Vt = -vars.Pi * vars.Pi;
    FOR (i, j)
    {
        Vt += vars.chi * h_UU[i][j] * d1.phi[i] * d1.phi[j];
    }

    // set the potential values
    amrex::Real V_of_phi = 0.0;
    amrex::Real dVdphi   = 0.0;

    // compute potential and add constributions to EM Tensor
    m_potential.compute_potential(V_of_phi, dVdphi, vars);

    // Calculate components of EM Tensor
    // S = T_ij
    FOR (i, j)
    {
        out.S[i][j] = -0.5 * vars.h[i][j] * Vt / vars.chi +
                      d1.phi[i] * d1.phi[j] -
                      vars.h[i][j] * V_of_phi / vars.chi;
    }

    // rho = n^a n^b T_ab
    out.rho = vars.Pi * vars.Pi + 0.5 * Vt + V_of_phi;

    // trS = Tr_S_ij
    out.trS =
        vars.chi * TensorAlgebra::compute_trace(out.S, h_UU) - 3.0 * V_of_phi;

    //    j_i (note lower index) = - n^a T_ai
    FOR (i)
    {
        out.j[i] = -d1.phi[i] * vars.Pi;
    }

    return out;
}

// Adds in the RHS for the matter vars
template <class potential_t>
template <template <class> class vars_t, class rhs_vars_t, class d2_vars_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
ScalarField<potential_t>::add_matter_rhs(
    rhs_vars_t &rhs, const vars_t<amrex::Real> &vars,
    const vars_t<Tensor<1, amrex::Real>> &d1, const d2_vars_t &d2,
    const vars_t<amrex::Real> &advec) const
{
    using namespace TensorAlgebra;

    // call the function for the rhs excluding the potential
    const auto h_UU  = compute_inverse_sym(vars.h);
    const auto chris = compute_christoffel(d1.h, h_UU);

    // set the potential values
    amrex::Real V_of_phi = 0.0;
    amrex::Real dVdphi   = 0.0;
    m_potential.compute_potential(V_of_phi, dVdphi, vars);

    // evolution equations for scalar field and (minus) its conjugate momentum
    rhs.phi = vars.lapse * vars.Pi + advec.phi;
    rhs.Pi  = vars.lapse * (vars.K * vars.Pi - dVdphi) + advec.Pi;

    FOR (i, j)
    {
        // includes non conformal parts of chris not included in chris_ULL
        rhs.Pi += h_UU[i][j] * (-0.5 * d1.chi[j] * vars.lapse * d1.phi[i] +
                                vars.chi * vars.lapse * d2.phi[i][j] +
                                vars.chi * d1.lapse[i] * d1.phi[j]);
        FOR (k)
        {
            rhs.Pi += -vars.chi * vars.lapse * h_UU[i][j] * chris.ULL[k][i][j] *
                      d1.phi[k];
        }
    }
}

#endif /* SCALARFIELD_IMPL_HPP_ */



================================================
FILE: Source/Matter/Weyl4WithMatter.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef WEYL4WITHMATTER_HPP_
#define WEYL4WITHMATTER_HPP_

#include "CCZ4RHSWithMatter.hpp"
#include "Weyl4.hpp"

//!  Calculates the Weyl4 scalar for spacetimes with matter content
/*!
   This class calculates the Weyl4 scalar real and im parts. It inherits from
   the Weyl4 class and adds in the matter terms as appropriate depending on the
   formulation
*/
template <class matter_t> class Weyl4WithMatter : public Weyl4
{
  public:
    template <class data_t>
    using Vars = typename CCZ4RHSWithMatter<matter_t>::template Vars<data_t>;

    //! Constructor
    Weyl4WithMatter(const std::array<double, AMREX_SPACEDIM> a_center,
                    const double a_dx, const int a_dcomp,
                    const int a_formulation = CCZ4RHS<>::USE_CCZ4,
                    double a_G_Newton       = 1.0)
        : Weyl4(a_center, a_dx, a_dcomp, a_formulation), m_dcomp(a_dcomp),
          m_G_Newton(a_G_Newton)
    {
    }

    //! The compute member which calculates the wave quantities at each point on
    //! the grid
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
    compute(int i, int j, int k,
            const amrex::Array4<amrex::Real> &derive_arrays,
            const amrex::Array4<amrex::Real const> &state_arrays) const;

    static void set_up(int a_state_index);

    // Has signature of DeriveFuncMF so that it can be stored in the derive_lst
    static void compute_mf(amrex::MultiFab &out_mf, int dcomp, int ncomp,
                           const amrex::MultiFab &src_mf,
                           const amrex::Geometry &geomdata,
                           amrex::Real /*time*/, const int * /*bcrec*/,
                           int /*level*/);

  protected:

    matter_t m_matter;
    int m_dcomp;       //!< index for storing the results of compute
    double m_G_Newton; //!< Newton's constant, set to one by default

    //! Add matter terms to electric and magnetic parts
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
    add_matter_EB(EBFields_t &eb_fields, const Vars<amrex::Real> &vars,
                  const Vars<Tensor<1, amrex::Real>> &d1,
                  const Tensor<3, amrex::Real> &epsilon3_LUU,
                  const Tensor<2, amrex::Real> &h_UU,
                  const chris_t &chris) const;
};

#include "Weyl4WithMatter.impl.hpp"

#endif /* WEYL4WITHMATTER_HPP_ */



================================================
FILE: Source/Matter/Weyl4WithMatter.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(WEYL4WITHMATTER_HPP_)
#error "This file should only be included through Weyl4WithMatter.hpp"
#endif

#ifndef WEYL4WITHMATTER_IMPL_HPP_
#define WEYL4WITHMATTER_IMPL_HPP_

template <class matter_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE void Weyl4WithMatter<matter_t>::compute(
    int i, int j, int k, const amrex::Array4<amrex::Real> &derive_arrays,
    const amrex::Array4<amrex::Real const> &state_arrays) const
{

    // copy data from chombo gridpoint into local variables
    const auto vars = load_vars<Vars>(state_arrays.cellData(i, j, k));
    const auto d1   = m_deriv.template diff1<Vars>(i, j, k, state_arrays);
    const auto d2   = m_deriv.template diff2<Diff2Vars>(i, j, k, state_arrays);

    // Get the coordinates
    const Coordinates coords(amrex::IntVect{AMREX_D_DECL(i, j, k)}, m_dx,
                             m_center);

    // Compute the inverse metric
    using namespace TensorAlgebra;
    const auto h_UU  = compute_inverse_sym(vars.h);
    const auto chris = compute_christoffel(d1.h, h_UU);

    // Compute the spatial volume element
    const auto epsilon3_LUU = compute_epsilon3_LUU(vars, h_UU);

    // Compute the E and B fields
    EBFields_t ebfields =
        compute_EB_fields(vars, d1, d2, epsilon3_LUU, h_UU, chris);

    // Add in matter terms to E and B fields
    add_matter_EB(ebfields, vars, d1, epsilon3_LUU, h_UU, chris);

    // work out the Newman Penrose scalar
    NPScalar_t out = compute_Weyl4(ebfields, vars, d1, d2, h_UU, coords);

    // Write the rhs into the output FArrayBox
    derive_arrays(i, j, k, m_dcomp)     = out.Real;
    derive_arrays(i, j, k, m_dcomp + 1) = out.Im;
}

template <class matter_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
Weyl4WithMatter<matter_t>::add_matter_EB(
    EBFields_t &ebfields, const Vars<amrex::Real> &vars,
    const Vars<Tensor<1, amrex::Real>> &d1,
    const Tensor<3, amrex::Real> &epsilon3_LUU,
    const Tensor<2, amrex::Real> &h_UU, const chris_t &chris) const
{
    // Calculate decomposed energy momentum tensor components
    const auto emtensor = m_matter.compute_emtensor(vars, d1, h_UU, chris.ULL);

    Tensor<2, amrex::Real> S_TF = emtensor.S;
    TensorAlgebra::make_trace_free(S_TF, vars.h, h_UU);

    // as we made the vacuum expression of Bij explictly symmetric and Eij
    // explictly trace-free, only Eij has matter terms
    FOR (i, j)
    {
        ebfields.E[i][j] += -4.0 * M_PI * m_G_Newton * S_TF[i][j];
    }
}

template <class matter_t>
void Weyl4WithMatter<matter_t>::set_up(int a_state_index)
{

    int num_ghosts = 2;

    auto &derive_lst     = amrex::AmrLevel::get_derive_lst();
    const auto &desc_lst = amrex::AmrLevel::get_desc_lst();

    // Add MatterWeyl4 to the derive list
    derive_lst.add(
        Weyl4::name, amrex::IndexType::TheCellType(),
        static_cast<int>(Weyl4::var_names.size()), Weyl4::var_names,
        Weyl4WithMatter::compute_mf, [=](const amrex::Box &box)
        { return amrex::grow(box, num_ghosts); }, &amrex::cell_quartic_interp);

    derive_lst.addComponent(Weyl4::name, desc_lst, a_state_index, 0, NUM_VARS);
}

template <class matter_t>
void Weyl4WithMatter<matter_t>::compute_mf(amrex::MultiFab &out_mf, int dcomp,
                                           int ncomp,
                                           const amrex::MultiFab &src_mf,
                                           const amrex::Geometry &geomdata,
                                           amrex::Real /*time*/,
                                           const int * /*bcrec*/, int /*level*/)
{
    const auto &out_arrays = out_mf.arrays();
    const auto &src_arrays = src_mf.const_arrays();

    GRParmParse pp;
    std::array<double, AMREX_SPACEDIM> center{};
    int formulation      = 0;
    amrex::Real G_Newton = 0;

    pp.get("extraction_center", center);
    pp.get("formulation", formulation);
    pp.queryAdd("G_newton", G_Newton);

    Weyl4WithMatter<matter_t> my_weyl4_with_matter(
        center, geomdata.CellSize(0), dcomp, formulation, G_Newton);

    amrex::ParallelFor(
        out_mf,
        [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k) noexcept
        {
            my_weyl4_with_matter.compute(i, j, k, out_arrays[box_no],
                                         src_arrays[box_no]);
        });
}

#endif /* WEYL4WITHMATTER_IMPL_HPP_ */



================================================
SYMLINK: Source/Matter/MatterCCZ4.hpp -> MatterCCZ4RHS.hpp
================================================



================================================
FILE: Source/Tagging/ChiTagger.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef CHITAGGER_HPP_
#define CHITAGGER_HPP_

#include "Cell.hpp"
#include "Coordinates.hpp"
#include "DimensionDefinitions.hpp"
#include "FourthOrderDerivatives.hpp"
#include "SphericalExtraction.hpp"
#include "Tensor.hpp"

#include <AMReX_Array4.H>
#include <AMReX_Gpu.H>
#include <AMReX_REAL.H>
#include <AMReX_TagBox.H>

class ChiTagger
{
  protected:
    double m_dx;
    FourthOrderDerivatives m_deriv;
    amrex::Real m_threshold;

  public:
    // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
    ChiTagger(const double dx, const amrex::Real a_threshold)
        : m_dx(dx), m_deriv(dx), m_threshold(a_threshold)
    {
    }

    AMREX_GPU_DEVICE void
    operator()(int i, int j, int k,
               const amrex::Array4<amrex::TagBox::TagType> &tags,
               const amrex::Array4<amrex::Real const> &state) const
    {
        const auto d2_chi      = m_deriv.diff2(i, j, k, state, c_chi);
        amrex::Real mod_d2_chi = 0;
        FOR (idir, jdir)
        {
            mod_d2_chi += d2_chi[idir][jdir] * d2_chi[idir][jdir];
        }
        amrex::Real criterion = m_dx * std::sqrt(mod_d2_chi);

        if (criterion >= m_threshold)
        {
            tags(i, j, k) = amrex::TagBox::SET;
        }
    }
};

#endif /* CHITAGGER_HPP_ */



================================================
FILE: Source/Tagging/ExtractionTagger.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef EXTRACTIONTAGGER_HPP_
#define EXTRACTIONTAGGER_HPP_

#include "Cell.hpp"
#include "Coordinates.hpp"
#include "DimensionDefinitions.hpp"
#include "SphericalExtraction.hpp"
#include "Tensor.hpp"

#include <AMReX_Array4.H>
#include <AMReX_Gpu.H>
#include <AMReX_REAL.H>
#include <AMReX_TagBox.H>

class ExtractionTagger
{
  protected:
    double m_dx;
    int m_num_extraction_radii;
    const double *m_extraction_radii_ptr;
    const int *m_extraction_levels_ptr;
    std::array<double, AMREX_SPACEDIM> m_center;
    int m_level;

  public:
    // Constructor takes only what it needs for extraction tagging
    // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
    ExtractionTagger(const double dx, const int a_level,
                     const SphericalExtraction::params_t &a_params,
                     const bool activate_extraction = false)
        : m_dx(dx), m_num_extraction_radii(a_params.num_extraction_radii()),
          m_extraction_radii_ptr(a_params.extraction_radii().data()),
          m_extraction_levels_ptr(a_params.extraction_levels.data()),
          m_center(a_params.center), m_level(a_level)
    {
        if (!activate_extraction)
        {
            // Avoids conditionals in the kernel by setting num to 0
            m_num_extraction_radii = 0;
        }
    }

    AMREX_GPU_DEVICE void
    operator()(int i, int j, int k,
               const amrex::Array4<amrex::TagBox::TagType> &tags) const
    {
        // Enforce a given resolution at the extraction radii
        amrex::IntVect cell(AMREX_D_DECL(i, j, k));
        for (int iradius = 0; iradius < m_num_extraction_radii; ++iradius)
        {
            // Regrid if current level is not the required refinement level
            if (m_level < m_extraction_levels_ptr[iradius])
            {
                const Coordinates coords(cell, m_dx, m_center);
                const amrex::Real r = coords.get_radius();

                // Add a 20% buffer to extraction zone so not too near boundary
                if (r < 1.2 * m_extraction_radii_ptr[iradius])
                {
                    tags(i, j, k) = amrex::TagBox::SET;
                    // Once tagged, no need to check other radii for this cell
                    break;
                }
            }
        }
    }
};

#endif /* EXTRACTIONTAGGER_HPP_ */



================================================
FILE: Source/Tagging/FixedGridsTagger.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef FIXEDGRIDSTAGGER_HPP_
#define FIXEDGRIDSTAGGER_HPP_

#include "Cell.hpp"
#include "Coordinates.hpp"
#include "DimensionDefinitions.hpp"
#include "Tensor.hpp"

// AMReX includes
#include <AMReX_TagBox.H>

class FixedGridsTagger
{
  protected:
    double m_dx;
    double m_L;
    int m_level;
    std::array<double, AMREX_SPACEDIM> m_center;

  public:
    // NOLINTBEGIN(bugprone-easily-swappable-parameters)
    FixedGridsTagger(const double dx, const int a_level, const double a_L,
                     const std::array<double, AMREX_SPACEDIM> a_center)
        : m_dx(dx), m_L(a_L), m_level(a_level), m_center(a_center) {};
    // NOLINTEND(bugprone-easily-swappable-parameters)
    AMREX_GPU_DEVICE void
    operator()(int i, int j, int k,
               const amrex::Array4<amrex::TagBox::TagType> &tags) const
    {
        // make sure the inner part is regridded around the horizon
        // take L as the length of full grid, so tag inner 1/2
        // of it, which means inner \pm L/4
        double ratio = pow(2.0, -(m_level + 2.0));

        amrex::IntVect cell(AMREX_D_DECL(i, j, k));

        const Coordinates coords(cell, m_dx, m_center);
        const amrex::Real max_abs_xy =
            std::max(std::abs(coords.x), std::abs(coords.y));
        const amrex::Real max_abs_xyz =
            std::max(max_abs_xy, std::abs(coords.z));

        if (max_abs_xyz < m_L * ratio)
        {
            tags(i, j, k) = amrex::TagBox::SET;
        }
    }
};

#endif /* FIXEDGRIDSTAGGER_HPP_ */



================================================
FILE: Source/Tagging/Make.package
================================================
GRTECLYN_CEXE_headers += ChiTagger.hpp \
                         ExtractionTagger.hpp \
                         FixedGridsTagger.hpp \
                         PunctureTagger.hpp



================================================
FILE: Source/Tagging/PunctureTagger.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef PUNCTURETAGGER_HPP_
#define PUNCTURETAGGER_HPP_

#include "Coordinates.hpp"
#include "DimensionDefinitions.hpp"
#include "FourthOrderDerivatives.hpp"
#include "Tensor.hpp"

#include <AMReX_Array4.H>
#include <AMReX_TagBox.H>

//! This class tags cells near the punctures so that the BH apparent horizons
//! are covered
template <unsigned int num_punctures> class PunctureTagger
{
  protected:
    amrex::Real m_dx;
    int m_level;
    int m_max_level;
    static constexpr unsigned int num_puncture_coords =
        AMREX_SPACEDIM * num_punctures;
    std::array<amrex::Real, num_punctures> m_puncture_masses;
    std::array<amrex::Real, num_puncture_coords> m_puncture_coords;

  public:

    // The constructor
    // NOLINTBEGIN(bugprone-easily-swappable-parameters)
    PunctureTagger(
        const amrex::Real a_dx, const int a_level, const int a_max_level,
        const std::array<amrex::Real, num_puncture_coords> &a_puncture_coords,
        const std::array<amrex::Real, num_punctures> &a_puncture_masses)
        // NOLINTEND(bugprone-easily-swappable-parameters)
        : m_dx(a_dx), m_level(a_level), m_max_level(a_max_level),
          m_puncture_masses(a_puncture_masses),
          m_puncture_coords(a_puncture_coords) {};

    AMREX_GPU_DEVICE void
    // NOLINTBEGIN(bugprone-easily-swappable-parameters)
    operator()(int i, int j, int k,
               const amrex::Array4<amrex::TagBox::TagType> &tags) const
    // NOLINTEND(bugprone-easily-swappable-parameters)
    {
        // ensure that the horizons of the punctures are covered
        // by the max level - for this we need
        // only check the puncture locations on the top 2 levels
        // which regrid (ie, max_level - 1 to max_level - 2)
        // (just the top level would be ok, but doing two ensures
        // the top levels are well spaced)

        // we want each level to be double the innermost one in size
        const int exponent  = std::min(m_max_level - m_level - 1, 1);
        const double factor = std::pow(2.0, exponent);

        amrex::IntVect current_cell(AMREX_D_DECL(i, j, k));
        // loop over puncture masses
        for (int ipuncture = 0; ipuncture < num_punctures; ++ipuncture)
        {
            std::array<amrex::Real, AMREX_SPACEDIM> current_puncture_coords = {
                AMREX_D_DECL(
                    m_puncture_coords[ipuncture * AMREX_SPACEDIM + 0],
                    m_puncture_coords[ipuncture * AMREX_SPACEDIM + 1],
                    m_puncture_coords[ipuncture * AMREX_SPACEDIM + 2])};

            const Coordinates coords(current_cell, m_dx,
                                     current_puncture_coords);
            const amrex::Real r = coords.get_radius();
            // decide whether to tag based on distance to horizon
            // plus a fudge factor of 1.5
            amrex::Real fudge_factor = 1.5;
            if (r < fudge_factor * factor * m_puncture_masses[ipuncture])
            {
                tags(current_cell) = amrex::TagBox::SET;
            }
        }
    }
};

#endif /* PUNCTURETAGGER_HPP_ */



================================================
FILE: Tests/README.md
================================================
# GRTeclyn Tests

The tests in this repository are implemented using the [doctest
framework](https://github.com/doctest/doctest). If you want to just build and
run the tests skip to the section on [Building and running the
tests](#building-and-running-the-tests).

## doctest

### Source

The doctest code is contained within a single header: [doctest.h](../External/doctest/doctest.h).

### Basic doctest syntax

A simple doctest test case is created by adding code such as

```cpp
TEST_CASE("<test case name>")
{
    <test code>

    CHECK(<condition that is true if test passes and false if test fail>);    
}
```

In practice, due to device kernel linking issues with
[HIP](https://github.com/GRTLCollaboration/GRTeclyn/issues/48) and
[SYCL](https://github.com/GRTLCollaboration/GRTeclyn/issues/46) we have instead
created each test case as function declared in a header and defined in a cpp
file:

```cpp
void run_my_test_case()
{
    <test code>

    CHECK(<condition that is true if test passes and false if test fail>);    
}
```

The header is included in [TestCases.hpp](./TestCases.hpp) and this function is
called inside a `TEST_CASE` there:

```cpp
TEST_CASE("<test case name>")
{
   run_my_test_case();
}
```


Instead of a `CHECK()` clause which will report failure in the output and return
value but not abort the application (thereby allowing later tests to run), one
can instead use a `REQUIRE()` clause which will immediately abort the
application if the relevant test fails (i.e. if the condition is false).
Unless, there is a good reason, one should default to using `CHECK()` clauses.

A common scenario is that one wishes to compare a floating point value produced
by the code to a known correct value. In this case, one can test equality with
the a `doctest::Approx` (see [this docs
page](https://github.com/doctest/doctest/blob/ae7a13539fb71f270b87eb2e874fbac80bc8dda2/doc/markdown/assertions.md#floating-point-comparisons))
object, for example
```cpp
double tol = 1e-10;
CHECK(computed_value == doctest::Approx(correct_value).epsilon(tol));
```

### doctest documentation

The doctest documentation can be found in the doctest repository
[here](https://bit.ly/doctest-docs).

## Building and running the tests

### Prerequisites

You will need the usual AMReX prerequisites:

* Git
* GNU Make >= 3.81
* Python >= 2.7
* A Unix-like environment with perl and sed commands
* C compiler with C99 support
* C++ compiler with C++17 support

Additionally, you will need to make sure you have cloned the [AMReX
repository](https://github.com/AMReX-Codes/amrex) locally. The makefile assumes
you have cloned it into the same directory you cloned this repository (i.e.
[../../amrex](../../amrex/) relative to where this `README.md` file is located)
but you can instead clone it elsewhere and set the `AMREX_HOME` environment
variable appropriately:
```bash 
export AMREX_HOME=/path/to/amrex
```

### Building

The tests are all contained in one AMReX application with its `main()` defined
in [`Tests.cpp`](./Tests.cpp). To build this application, simply run
```
make -j <number of build jobs>
```
Like any other AMReX GNU Make application, one can pass [AMReX configuration
options](https://amrex-codes.github.io/amrex/docs_html/BuildingAMReX.html#id1)
such as `USE_OMP=TRUE` on the command line e.g.
```
make -j 4 USE_OMP=TRUE
```
or modify these directly in the [GNUmakefile](./GNUmakefile). Alternatively if
one wishes to use the same configuration options for all AMReX
applications, one can set configuration options in
[`${AMREX_HOME}/Tools/GNUMake/Make.local-pre`](../../amrex/Tools/GNUMake/Make.local-pre)
(this file will need to be created if it doesn't exist).

### Running

One can run all the tests by simply executing the created executable (e.g.
`Tests3d.gnu.ex`) without any arguments. To run a specific test, pass its name
as an argument to the `-dt-tc` flag:
```
./Tests3d.gnu.ex -dt-tc="CCZ4 RHS"
```
and multiple tests can be run by passing their names in a comma separated list
e.g.
```
./Tests3d.gnu.ex -dt-tc="CCZ4 RHS,Derivative*"
```

doctest provides a plethora of command line flags to customize the output which
can be found by passing the `-dt-h` flag e.g.
```
./Tests3d.gnu.ex -dt-h
```
Some particularly useful ones include
```
-dt-s,   --dt-success              include successful tests in output
-dt-aa,  --dt-abort-after=<int>    abort after <int> failed assertions
-dt-ltc, --dt-list-test-cases      list all/matching test cases
```
All doctest flags are prefixed with `-dt-` or `--dt-`. Any unprefixed arguments
may be passed as command line arguments to test cases so that one can pass
arguments to AMReX e.g.
```bash
./Tests3d.gnu.ex amrex.verbose=1 -dt-tc="CCZ4 RHS"
```

## Adding a new test

See the [CCZ4 RHS test](./CCZ4RHSTest/) as an example. Here is an outline of the
basic steps to adding a new test to the [Tests application](./Tests.cpp).

1. Create a new test directory with an appropriate name (e.g. `NewGRTeclynTest`).
   Make sure that the directory name ends with `Test` or `Tests` (so that Make
   can find it).
2. In that directory, create a cpp file with the appropriate name (e.g.
   `NewGRTeclynTest.cpp`). In that file make sure you include the doctest
   and base AMReX headers (if you are using any AMReX classes).
   ```cpp
   // Doctest header
   #include "doctest.h"

   // Provides doctest::cli_args
   #include "doctestCLIArgs.hpp"
   
   // AMReX includes
   #include "AMReX.H"
   ```
3. In the cpp file, create a new `run_my_new_grteclyn_test()` as described
   [above](#basic-doctest-syntax). Make sure to initialize and finalize AMReX if
   using any AMReX data structures (otherwise no memory will be allocated):
   ```cpp
    void run_my_new_grteclyn_test()
    {
        // doctest::cli_args stores the non -dt- command line args
        int amrex_argc    = doctest::cli_args.argc();
        char **amrex_argv = doctest::cli_args.argv();
        // MPI_COMM_WORLD defined in AMReX_ccse-mpi.H even when compiling 
        // without MPI
        amrex::Initialize(amrex_argc, amrex_argv, true, MPI_COMM_WORLD);
        {

            bool test_passes = true;

            // This code should set test_passes = false if some failure happens
            <test code>

            CHECK(test_passes);
        }
        amrex::Finalize();
    }
    ```
4. Create a hpp header file with the same filename stem (e.g.
   `NewGRTeclynTest.hpp`).  In that file, declare the test function:
   ```cpp
   void run_my_new_grteclyn_test();
   ```
   Don't forget to include a header guard!
5. Create a `Make.package` file in the same directory with the following
   content: 
   ```makefile
   GRTECLYN_CEXE_headers += NewGRTeclynTest.hpp <any other headers>

   GRTECLYN_CEXE_sources += NewGRTeclynTest.cpp <any other cpp files>
   ```
6. Include the header file in [TestCases.hpp](./TestCases.hpp), create the test
   case and call the test function:
   ```cpp
   #include "NewGRTeclynTest.hpp"

   ...

   TEST_CASE("New GRTeclyn")
   {
      run_my_new_grteclyn_test();
   }
   ```
7. In the GNUmakefile, one may need to uncomment some lines of the form
   ```makefile
   # include $(AMREX_HOME)/Src/<component>/Make.package
   ```
   depending on which AMReX subcomponents are required.
8. Build and run the test as described [above](#building-and-running-the-tests).


================================================
FILE: Tests/GNUmakefile
================================================
GRTECLYN_HOME = $(realpath ..)

include $(GRTECLYN_HOME)/Tools/GNUMake/Make.defaults

# We don't want to use MPI by default for the tests
USE_MPI = FALSE
USE_PARTICLES = TRUE

EBASE = Tests

AMREX_HOME ?= $(realpath ../../amrex)

include $(AMREX_HOME)/Tools/GNUMake/Make.defs

include ./Make.package
include $(AMREX_HOME)/Src/Amr/Make.package
include $(AMREX_HOME)/Src/AmrCore/Make.package
include $(AMREX_HOME)/Src/Base/Make.package
include $(AMREX_HOME)/Src/Boundary/Make.package
include $(AMREX_HOME)/Src/Particle/Make.package

GRTECLYN_SOURCE = $(GRTECLYN_HOME)/Source

GRTECLYN_TESTS_HOME = $(GRTECLYN_HOME)/Tests

src_dirs := $(GRTECLYN_SOURCE)/AMRInterpolator \
            $(GRTECLYN_SOURCE)/BlackHoles \
            $(GRTECLYN_SOURCE)/CCZ4 \
            $(GRTECLYN_SOURCE)/Grids \
            $(GRTECLYN_SOURCE)/GRTeclynCore \
            $(GRTECLYN_SOURCE)/IO \
            $(GRTECLYN_SOURCE)/Maths \
            $(GRTECLYN_SOURCE)/Matter \
            $(GRTECLYN_SOURCE)/Tagging

# Find all directories that end in "Test" or "Tests"
# Note that hidden directories (i.e. those starting with a '.') are not included
test_dirs_match := $(wildcard $(GRTECLYN_TESTS_HOME)/*Test/ $(GRTECLYN_TESTS_HOME)/*Tests/)

# Strip the trailing path separator (probably not necessary)
test_dirs := $(patsubst %/, %, $(test_dirs_match))

# Finally add in the Common directory
test_dirs += $(GRTECLYN_TESTS_HOME)/Common

src_pack := $(foreach dir, $(src_dirs), $(dir)/Make.package)
test_pack := $(foreach dir, $(test_dirs), $(dir)/Make.package)
include $(src_pack)
include $(test_pack)

doctest_dir := $(GRTECLYN_HOME)/external/doctest
doctest_headers := doctest.h

CEXE_sources += $(GRTECLYN_CEXE_sources)
CEXE_headers += $(GRTECLYN_CEXE_headers) $(doctest_headers)
VPATH_LOCATIONS += $(src_dirs) $(test_dirs)
INCLUDE_LOCATIONS += $(realpath .) $(src_dirs) $(test_dirs)
SYSTEM_INCLUDE_LOCATIONS += $(doctest_dir)

include $(GRTECLYN_HOME)/Tools/GNUMake/Make.rules

ifeq ($(USE_MPI), TRUE)
  ifeq ($(origin SLURM_NTASKS),undefined)
    LAUNCH = mpiexec -n 2 ./
  else
    LAUNCH = mpiexec -n ${SLURM_NTASKS} ./
  endif 
else
LAUNCH = ./
endif

DOCTEST_OPTIONS := -dt-d=yes

run: $(executable)
	$(info Running tests for configuration: $(optionsSuffix))
	$(SILENT) $(LAUNCH)$(executable) $(DOCTEST_OPTIONS)




================================================
FILE: Tests/Make.package
================================================
GRTECLYN_CEXE_headers += TestCases.hpp

GRTECLYN_CEXE_sources += Tests.cpp


================================================
FILE: Tests/TestCases.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */
#ifndef TESTCASES_HPP_
#define TESTCASES_HPP_

// doctest header
#include "doctest.h"

// AMReX includes
#include <AMReX.H>

// Test cases
#include "BSSNMatterTest.hpp"
#include "CCZ4GeometryUnitTest.hpp"
#include "CCZ4RHSTest.hpp"
#include "ConstraintsTest.hpp"
#include "CoordinateTransformationsTest.hpp"
#include "DerivativeUnitTests.hpp"
#include "EMTensorTest.hpp"
#include "PositiveChiAndLapseUnitTest.hpp"
#include "PunctureTrackerTest.hpp"
#include "SmallDataIOTest.hpp"
#include "SphericalHarmonicTest.hpp"
#include "Weyl4Test.hpp"
#include "Weyl4WithMatterTest.hpp"

TEST_CASE("CCZ4Geometry") { run_ccz4_geometry_unit_tests(); }

TEST_CASE("BSSNMatter"
#ifndef AMREX_USE_HDF5
          * doctest::skip()
#endif
)
{
    run_bssn_matter_test();
}

TEST_CASE("CCZ4 Geometry") { run_ccz4_geometry_unit_tests(); }

TEST_CASE("CCZ4RHS") { run_ccz4_rhs_test(); }

TEST_CASE("Constraints"
#ifndef AMREX_USE_HDF5
          * doctest::skip()
#endif
)
{
    run_constraints_test();
}

TEST_CASE("CoordinateTransformations")
{
    run_coordinate_transformations_test();
}

TEST_CASE("DerivativeUnitTests") { run_derivative_unit_tests(); }

TEST_CASE("EMTensor"
#ifndef AMREX_USE_HDF5
          * doctest::skip()
#endif
)
{
    run_emtensor_test();
}

TEST_CASE("PositiveChiAndLapse") { run_positive_chi_and_lapse_unit_test(); }

TEST_CASE("PunctureTracker") { run_puncture_tracker_test(); }

TEST_CASE("SmallDataIO") { run_small_data_io_test(); }

TEST_CASE("SphericalHarmonics") { run_spherical_harmonic_test(); }

TEST_CASE("Weyl4"
#ifndef AMREX_USE_HDF5
          * doctest::skip()
#endif
)
{
    run_weyl4_test();
}

TEST_CASE("Weyl4WithMatter"
#ifndef AMREX_USE_HDF5
          * doctest::skip()
#endif
)
{
    run_matter_weyl4_test();
}

#endif /* TESTCASES_HPP_ */



================================================
FILE: Tests/Tests.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */
// Doctest header
#ifdef AMREX_USE_SYCL
// Intel's GPU runtime uses SIGSEGV to trigger migration of managed memory
#define DOCTEST_CONFIG_NO_POSIX_SIGNALS
#endif
#define DOCTEST_CONFIG_IMPLEMENT
#define DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS
#include "doctest.h"

#include "TestCases.hpp" // Test cases are defined here
#include "doctestCLIArgs.hpp"
#include "doctestOutput.hpp"

// system headers
#include <iomanip>
#include <iostream>

#include "AMReX.H"
#include "AMReX_REAL.H"
#include "AMReX_ccse-mpi.H"

namespace doctest
{
// Unfortunately the following has to be global and non-const
// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
CLIArgs cli_args;
} // namespace doctest

// NOLINTBEGIN(bugprone-exception-escape)
int main(int argc, char *argv[])
{
#ifdef BL_USE_MPI
    // We can only initialize and finalize MPI once so do it here
    MPI_Init(&argc, &argv);
#endif
    doctest::cli_args.set(argv);

    doctest::Context doctest_context(argc, argv);
#ifdef BL_USE_MPI
    doctest_context.setCout(
        &doctest::hide_output_from_non_zero_ranks(std::cout));
#endif

    // Default AMReX verbosity to 0 to avoid the "Initialized", "Finalized" and
    // memory usage messages
    amrex::system::verbose = 0;

    // increase output precision
    constexpr int output_precision = 17;
    std::cout << std::setprecision(output_precision);

    // also increase precision of doctest's stringmaker
    std::ostream *doctest_stringstream = doctest::detail::tlssPush();
    doctest_stringstream->precision(output_precision);
    doctest::detail::tlssPop();

    int result = doctest_context.run();

#ifdef BL_USE_MPI
    MPI_Finalize();
#endif

    return result;
}
// NOLINTEND(bugprone-exception-escape)


================================================
FILE: Tests/BSSNMatterTest/BSSNMatterTest.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// Doctest header
#include "doctest.h"

// Test header
#include "BSSNMatterTest.hpp"

// Common test headers
#include "InitialData.hpp"
#include "doctestCLIArgs.hpp"

// GRTeclyn headers
#include "CCZ4RHSWithMatter.hpp"
#include "ConstraintsWithMatter.hpp"
#include "DefaultPotential.hpp"
#include "GRParmParse.hpp"
#include "ScalarField.hpp"

// AMReX headers
#include "AMReX.H"
#include "AMReX_FArrayBox.H"
#include "AMReX_MultiFab.H"

#ifdef AMREX_USE_HDF5
#include <AMReX_PlotFileUtilHDF5.H>
#endif

// System headers
#include <array>
#include <cstdlib>
#include <iostream>
#include <string>

void run_bssn_matter_test()
{
    int amrex_argc    = doctest::cli_args.argc();
    char **amrex_argv = doctest::cli_args.argv();

    // NOLINTNEXTLINE(bugprone-casting-through-void) // Open MPI triggers this
    amrex::Initialize(amrex_argc, amrex_argv);
    {

        constexpr int num_cells  = 32;
        constexpr int num_ghosts = 3;
        constexpr double dx      = 0.5 / (num_cells - 1);

        amrex::Box box(
            amrex::IntVect(0, 0, 0),
            amrex::IntVect(num_cells - 1, num_cells - 1, num_cells - 1));

        amrex::Box ghosted_box = box;
        ghosted_box.grow(num_ghosts);

        amrex::BoxArray box_array{box};
        amrex::RealVect dx_Vect{dx};
        amrex::RealBox real_box{box, dx_Vect.dataPtr(),
                                amrex::RealVect::Zero.dataPtr()};
        int coord_sys = 0;
        amrex::Geometry geom{box, &real_box, coord_sys};
        amrex::DistributionMapping distribution_mapping{box_array};
        amrex::MFInfo mf_info;
        mf_info.SetArena(amrex::The_Managed_Arena());

        amrex::MultiFab in_mf{box_array, distribution_mapping, NUM_VARS,
                              num_ghosts, mf_info};

        const auto &in_array = in_mf.arrays();

        // NOLINTBEGIN(bugprone-easily-swappable-parameters)
        amrex::ParallelFor(
            in_mf, in_mf.nGrowVect(),
            [=] AMREX_GPU_DEVICE(int ibox, int i, int j, int k)
            // NOLINTEND(bugprone-easily-swappable-parameters)
            {
                const amrex::IntVect iv{i, j, k};
                const amrex::RealVect coords = amrex::RealVect{iv} * dx;
                amrex::Real x                = coords[0];
                amrex::Real y                = coords[1];
                amrex::Real z                = coords[2];

                random_ccz4_initial_data(iv, in_array[ibox], coords);

                random_matter_bssn_initial_data(iv, in_array[ibox], coords);
            });

        CCZ4_params_t<MovingPunctureGaugeWithMatter::params_t> ccz4_params;
        ccz4_params.kappa1            = 0.0;
        ccz4_params.kappa2            = 0.0;
        ccz4_params.kappa3            = 0.0;
        ccz4_params.shift_Gamma_coeff = 0.75;
        ccz4_params.lapse_advec_coeff = 1.0;
        ccz4_params.lapse_power       = 1.0;
        ccz4_params.lapse_coeff       = 2.0;
        ccz4_params.shift_advec_coeff = 0.0;
        ccz4_params.eta               = 1.0;

        amrex::Real sigma = 0.1;

        using DefaultScalarField = ScalarField<DefaultPotential>;

        double G_Newton = 1.0;
        GRParmParse pp;
        pp.queryAdd("G_Newton", G_Newton);

        CCZ4RHSWithMatter<DefaultScalarField, MovingPunctureGaugeWithMatter,
                          FourthOrderDerivatives>
            current_ccz4_rhs{ccz4_params, dx, sigma, CCZ4RHS<>::USE_BSSN,
                             G_Newton};

        // Set up the constraints
        constexpr int dcomp = NUM_VARS;

        int num_comp_constraints = 1 + AMREX_SPACEDIM; // ham + moms
        int num_comp             = NUM_VARS + num_comp_constraints;

        amrex::MultiFab out_mf{box_array, distribution_mapping, num_comp, 0,
                               mf_info};

        amrex::FArrayBox out_fab{box, num_comp, amrex::The_Managed_Arena()};

        const auto &in_c_array    = in_mf.const_arrays();
        const auto &out_mf_array  = out_mf.arrays();
        const auto &out_fab_array = out_fab.array();

        amrex::ParallelFor(out_mf,
                           [=] AMREX_GPU_DEVICE(int ibox, int i, int j, int k)
                           {
                               current_ccz4_rhs.compute(i, j, k,
                                                        out_mf_array[ibox],
                                                        in_c_array[ibox]);
                           });

        double time = 0.0;
        int *bcrec  = nullptr;
        int level   = 0;

        ConstraintsWithMatter<DefaultScalarField>::compute_mf(
            out_mf, dcomp, num_comp_constraints, in_mf, geom, time, bcrec,
            level);

        // GPU barrier
        amrex::Gpu::streamSynchronize();

        CHECK(!out_mf.contains_nan());

#if AMREX_USE_HDF5

        amrex::Vector<std::string> var_names = ArrayTools::concatenate(
            StateVariables::names, Constraints::var_names);

        std::string grteclyn_hdf5_file = "BSSNMatterTest/BSSNMatterTest";

        // open the hdf5 file for writing
        amrex::WriteSingleLevelPlotfileHDF5(grteclyn_hdf5_file, out_mf,
                                            var_names, geom, 0.0, 0);

        std::cout.flush();

        std::string h5diff_tol         = "1e-10";
        std::string grchombo_hdf5_file = "BSSNMatterTest/"
                                         "GRChomboBSSNMatterTest.h5";
        // the GRChombo comparison file is created in
        // GRChombo/Tests/MatterCCZ4Test

        std::string hdf5_internal_path = "/level_0/data:datatype=0";

        std::string h5diff_command  = "h5diff";
        h5diff_command             += " -d " + h5diff_tol;
        h5diff_command +=
            " " + grteclyn_hdf5_file + ".h5" + " " + grchombo_hdf5_file;
        h5diff_command += " " + hdf5_internal_path + " " + hdf5_internal_path;

        INFO("Test command: " << h5diff_command);

        int h5diff_status = std::system(h5diff_command.c_str());
        int h5diff_retval = -1;

        // Use POSIX macros to get the exit code
        if (WIFEXITED(h5diff_status))
        {
            h5diff_retval = WEXITSTATUS(h5diff_status);
        }

        CHECK(h5diff_retval == 0);

#endif
    }
    amrex::Finalize();
}



================================================
FILE: Tests/BSSNMatterTest/BSSNMatterTest.hpp
================================================
/* GRChombo
 * Copyright 2012 The GRChombo collaboration.
 * Please refer to LICENSE in GRChombo's root directory.
 */
#ifndef BSSNMATTERTEST_HPP_
#define BSSNMATTERTEST_HPP_

void run_bssn_matter_test();

#endif /* BSSNMATTERTEST_HPP_ */



================================================
FILE: Tests/BSSNMatterTest/Make.package
================================================
GRTECLYN_CEXE_headers += BSSNMatterTest.hpp

GRTECLYN_CEXE_sources += BSSNMatterTest.cpp



================================================
FILE: Tests/CCZ4GeometryUnitTests/CCZ4GeometryMathematicaValues.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */
////Autogenerated by Mathematica
// NOLINTBEGIN
vars.chi                = 0.8098494058704866;
vars.h[0][0]            = 0.8835588277590876;
vars.h[0][1]            = 0.08361461822881999;
vars.h[0][2]            = 0.38886697060963504;
vars.h[1][0]            = 0.08361461822881999;
vars.h[1][1]            = 0.6027246068108858;
vars.h[1][2]            = 0.7440619616868669;
vars.h[2][0]            = 0.38886697060963504;
vars.h[2][1]            = 0.7440619616868669;
vars.h[2][2]            = 0.16618118423320594;
vars.Gamma[0]           = 0.11852049835440681;
vars.Gamma[1]           = 0.40790914671361445;
vars.Gamma[2]           = 0.9765677714895276;
d1.chi[0]               = 0.4600884595025587;
d1.chi[1]               = 0.7554023773780052;
d1.chi[2]               = 0.4409754598401465;
d1.h[0][0][0]           = 0.5372306054887224;
d1.h[0][0][1]           = 0.5909096935865703;
d1.h[0][0][2]           = 0.4787681304918079;
d1.h[0][1][0]           = 0.20313847223241965;
d1.h[0][1][1]           = 0.4961906537893035;
d1.h[0][1][2]           = 0.7978452715681448;
d1.h[0][2][0]           = 0.9725150952129742;
d1.h[0][2][1]           = 0.5181200411122575;
d1.h[0][2][2]           = 0.8717998920021486;
d1.h[1][0][0]           = 0.20313847223241965;
d1.h[1][0][1]           = 0.4961906537893035;
d1.h[1][0][2]           = 0.7978452715681448;
d1.h[1][1][0]           = 0.2737835903138639;
d1.h[1][1][1]           = 0.48755460956465146;
d1.h[1][1][2]           = 0.8519183872242864;
d1.h[1][2][0]           = 0.9056640771711735;
d1.h[1][2][1]           = 0.40674210075595885;
d1.h[1][2][2]           = 0.7629434549718792;
d1.h[2][0][0]           = 0.9725150952129742;
d1.h[2][0][1]           = 0.5181200411122575;
d1.h[2][0][2]           = 0.8717998920021486;
d1.h[2][1][0]           = 0.9056640771711735;
d1.h[2][1][1]           = 0.40674210075595885;
d1.h[2][1][2]           = 0.7629434549718792;
d1.h[2][2][0]           = 0.7256564337118006;
d1.h[2][2][1]           = 0.49812865531219463;
d1.h[2][2][2]           = 0.7398273911839663;
d1.Gamma[0][0]          = 0.06532790938004873;
d1.Gamma[0][1]          = 0.6115092578563868;
d1.Gamma[0][2]          = 0.7998366644456663;
d1.Gamma[1][0]          = 0.3709595478176717;
d1.Gamma[1][1]          = 0.186532496416832;
d1.Gamma[1][2]          = 0.3602841034609692;
d1.Gamma[2][0]          = 0.45294022389338884;
d1.Gamma[2][1]          = 0.871231925926413;
d1.Gamma[2][2]          = 0.8468368669591098;
d2.chi[0][0]            = 0.7776472676111048;
d2.chi[1][0]            = 0.7693289916301791;
d2.chi[2][0]            = 0.9185663805720314;
d2.chi[0][1]            = 0.7693289916301791;
d2.chi[1][1]            = 0.692537349684144;
d2.chi[2][1]            = 0.46661656857473055;
d2.chi[0][2]            = 0.9185663805720314;
d2.chi[1][2]            = 0.46661656857473055;
d2.chi[2][2]            = 0.4001566882825074;
d2.h[0][0][0][0]        = 0.1312709269544423;
d2.h[0][0][1][0]        = 0.5156829825269511;
d2.h[0][0][2][0]        = 0.9438366234751414;
d2.h[0][0][0][1]        = 0.5156829825269511;
d2.h[0][0][1][1]        = 0.119228972163826;
d2.h[0][0][2][1]        = 0.18947516379948337;
d2.h[0][0][0][2]        = 0.9438366234751414;
d2.h[0][0][1][2]        = 0.18947516379948337;
d2.h[0][0][2][2]        = 0.31317441327358453;
d2.h[0][1][0][0]        = 0.9893451249531833;
d2.h[0][1][1][0]        = 0.1346103613912475;
d2.h[0][1][2][0]        = 0.46504863256104745;
d2.h[0][1][0][1]        = 0.1346103613912475;
d2.h[0][1][1][1]        = 0.42421788101615765;
d2.h[0][1][2][1]        = 0.36906663129113926;
d2.h[0][1][0][2]        = 0.46504863256104745;
d2.h[0][1][1][2]        = 0.36906663129113926;
d2.h[0][1][2][2]        = 0.8308204842951561;
d2.h[0][2][0][0]        = 0.37427721021008753;
d2.h[0][2][1][0]        = 0.24590082890967602;
d2.h[0][2][2][0]        = 0.5036847032471885;
d2.h[0][2][0][1]        = 0.24590082890967602;
d2.h[0][2][1][1]        = 0.5616665789066719;
d2.h[0][2][2][1]        = 0.0236355710706464;
d2.h[0][2][0][2]        = 0.5036847032471885;
d2.h[0][2][1][2]        = 0.0236355710706464;
d2.h[0][2][2][2]        = 0.1653935535910971;
d2.h[1][0][0][0]        = 0.9893451249531833;
d2.h[1][0][1][0]        = 0.1346103613912475;
d2.h[1][0][2][0]        = 0.46504863256104745;
d2.h[1][0][0][1]        = 0.1346103613912475;
d2.h[1][0][1][1]        = 0.42421788101615765;
d2.h[1][0][2][1]        = 0.36906663129113926;
d2.h[1][0][0][2]        = 0.46504863256104745;
d2.h[1][0][1][2]        = 0.36906663129113926;
d2.h[1][0][2][2]        = 0.8308204842951561;
d2.h[1][1][0][0]        = 0.5606616842496865;
d2.h[1][1][1][0]        = 0.3311058401393394;
d2.h[1][1][2][0]        = 0.7774060413360173;
d2.h[1][1][0][1]        = 0.3311058401393394;
d2.h[1][1][1][1]        = 0.5365608294656778;
d2.h[1][1][2][1]        = 0.014882274853628141;
d2.h[1][1][0][2]        = 0.7774060413360173;
d2.h[1][1][1][2]        = 0.014882274853628141;
d2.h[1][1][2][2]        = 0.883775870416718;
d2.h[1][2][0][0]        = 0.4947451229911777;
d2.h[1][2][1][0]        = 0.9920325120079332;
d2.h[1][2][2][0]        = 0.8266033368889165;
d2.h[1][2][0][1]        = 0.9920325120079332;
d2.h[1][2][1][1]        = 0.060939730062044895;
d2.h[1][2][2][1]        = 0.4796890718117883;
d2.h[1][2][0][2]        = 0.8266033368889165;
d2.h[1][2][1][2]        = 0.4796890718117883;
d2.h[1][2][2][2]        = 0.47674772924885556;
d2.h[2][0][0][0]        = 0.37427721021008753;
d2.h[2][0][1][0]        = 0.24590082890967602;
d2.h[2][0][2][0]        = 0.5036847032471885;
d2.h[2][0][0][1]        = 0.24590082890967602;
d2.h[2][0][1][1]        = 0.5616665789066719;
d2.h[2][0][2][1]        = 0.0236355710706464;
d2.h[2][0][0][2]        = 0.5036847032471885;
d2.h[2][0][1][2]        = 0.0236355710706464;
d2.h[2][0][2][2]        = 0.1653935535910971;
d2.h[2][1][0][0]        = 0.4947451229911777;
d2.h[2][1][1][0]        = 0.9920325120079332;
d2.h[2][1][2][0]        = 0.8266033368889165;
d2.h[2][1][0][1]        = 0.9920325120079332;
d2.h[2][1][1][1]        = 0.060939730062044895;
d2.h[2][1][2][1]        = 0.4796890718117883;
d2.h[2][1][0][2]        = 0.8266033368889165;
d2.h[2][1][1][2]        = 0.4796890718117883;
d2.h[2][1][2][2]        = 0.47674772924885556;
d2.h[2][2][0][0]        = 0.29285200380140775;
d2.h[2][2][1][0]        = 0.12090991364315329;
d2.h[2][2][2][0]        = 0.11839822831093305;
d2.h[2][2][0][1]        = 0.12090991364315329;
d2.h[2][2][1][1]        = 0.5777485076926592;
d2.h[2][2][2][1]        = 0.24842636089202075;
d2.h[2][2][0][2]        = 0.11839822831093305;
d2.h[2][2][1][2]        = 0.24842636089202075;
d2.h[2][2][2][2]        = 0.2540349225617704;
d2.Gamma[0][0][0]       = 0.5832629795220816;
d2.Gamma[0][1][0]       = 0.5451395979287363;
d2.Gamma[0][2][0]       = 0.44609650013234714;
d2.Gamma[0][0][1]       = 0.5451395979287363;
d2.Gamma[0][1][1]       = 0.005536991195764784;
d2.Gamma[0][2][1]       = 0.7782775610471948;
d2.Gamma[0][0][2]       = 0.44609650013234714;
d2.Gamma[0][1][2]       = 0.7782775610471948;
d2.Gamma[0][2][2]       = 0.9175655065074693;
d2.Gamma[1][0][0]       = 0.5995425172563482;
d2.Gamma[1][1][0]       = 0.04965146427072176;
d2.Gamma[1][2][0]       = 0.3321539095194892;
d2.Gamma[1][0][1]       = 0.04965146427072176;
d2.Gamma[1][1][1]       = 0.2832306067234527;
d2.Gamma[1][2][1]       = 0.49493334032340486;
d2.Gamma[1][0][2]       = 0.3321539095194892;
d2.Gamma[1][1][2]       = 0.49493334032340486;
d2.Gamma[1][2][2]       = 0.19914806231901938;
d2.Gamma[2][0][0]       = 0.7468580387267745;
d2.Gamma[2][1][0]       = 0.9560134102995277;
d2.Gamma[2][2][0]       = 0.5330113907298353;
d2.Gamma[2][0][1]       = 0.9560134102995277;
d2.Gamma[2][1][1]       = 0.5693660421299729;
d2.Gamma[2][2][1]       = 0.6773359763226581;
d2.Gamma[2][0][2]       = 0.5330113907298353;
d2.Gamma[2][1][2]       = 0.6773359763226581;
d2.Gamma[2][2][2]       = 0.8575026932400331;
Z_over_chi[0]           = 0.9714722806238749;
Z_over_chi[1]           = 0.22416071457755882;
Z_over_chi[2]           = 0.4157863432473834;
double h_UU_known[3][3] = {
    {1.0199830810977317, -0.6195608073272221,  0.38725141574587546},
    {-0.619560807327222, 0.009866937328582433, 1.4056051085871113 },
    {0.3872514157458755, 1.4056051085871115,   -1.1821228754882414}
};
double chris_known[3][3][3] = {
    {{0.6150847009576254, 0.33774400611398936, 0.017463058869977177},
     {0.33774400611398936, 0.20800204668867533, 0.04179305080028098},
     {0.017463058869977177, 0.04179305080028098, 0.3440127327405543}},
    {{0.8631583272745078, 0.25820987965868775, 0.36752829143134497},
     {0.25820987965868775, -0.24721379942844915, 0.2271857216284019},
     {0.36752829143134497, 0.2271857216284019, 0.20968409144382238} },
    {{-0.8923896726645622, -0.0631372003735095, 0.49688891638807914},
     {-0.0631372003735095, 0.5045105817065746, 0.38375064656711905},
     {0.49688891638807914, 0.38375064656711905, 0.48212768681060697}}
};
double chris_contracted_known[3] = {-0.06472864749199342, 1.2334603671435462,
                                    0.06670171976977868};
double ricciZ_known[3][3]        = {
    {0.29990127189964605, 2.312404097070375,  3.373303725848343},
    {2.312404097070375,   2.2495977445717625, 2.007842169171936},
    {3.373303725848343,   2.007842169171936,  2.945044043069241}
};
double ricciZ_scalar_known = 1.8127966637815929;
// NOLINTEND


================================================
FILE: Tests/CCZ4GeometryUnitTests/CCZ4GeometryUnitTest.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// Doctest header
#include "doctest.h"

// Test header
#include "CCZ4GeometryUnitTest.hpp"

// System includes
// #include <iostream>

// Our includes
#include "CCZ4Geometry.hpp"
#include "DimensionDefinitions.hpp"
#include "Tensor.hpp"

template <class data_t> struct vars_t
{
    data_t chi;
    Tensor<2, data_t> h;
    Tensor<1, data_t> Gamma;
};

// NOLINTNEXTLINE(readability-function-cognitive-complexity)
void run_ccz4_geometry_unit_tests()
{
    vars_t<double> vars{};
    vars_t<Tensor<1, double>> d1{};
    vars_t<Tensor<2, double>> d2{};
    Tensor<1, double> Z_over_chi;

#include "CCZ4GeometryMathematicaValues.hpp" //Including the auto generated file with values

    auto h_UU = TensorAlgebra::compute_inverse_sym(vars.h);

    auto chris = TensorAlgebra::compute_christoffel(d1.h, h_UU);

    auto ricciZ =
        CCZ4Geometry::compute_ricci_Z(vars, d1, d2, h_UU, chris, Z_over_chi);

    double test_threshold = 1e-14;

    // Compare
    FOR (i, j)
    {
        INFO("h_UU[" << i << "][" << j << "]");
        CHECK(h_UU[i][j] ==
              doctest::Approx(h_UU_known[i][j]).epsilon(test_threshold));
    }

    FOR (i, j, k)
    {
        INFO("chris.ULL[" << i << "][" << j << "][" << k << "]");
        CHECK(chris.ULL[i][j][k] ==
              doctest::Approx(chris_known[i][j][k]).epsilon(test_threshold));
    }

    FOR (i)
    {
        INFO("chris.contracted[" << i << "]");
        CHECK(
            chris.contracted[i] ==
            doctest::Approx(chris_contracted_known[i]).epsilon(test_threshold));
    }

    FOR (i, j)
    {
        INFO("ricciZ.LL[" << i << "][" << j << "]");
        CHECK(ricciZ.LL[i][j] ==
              doctest::Approx(ricciZ_known[i][j]).epsilon(test_threshold));
    }

    CHECK(ricciZ.scalar ==
          doctest::Approx(ricciZ_scalar_known).epsilon(test_threshold));
}



================================================
FILE: Tests/CCZ4GeometryUnitTests/CCZ4GeometryUnitTest.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */
#ifndef CCZ4GEOMETRYUNITTEST_HPP_
#define CCZ4GEOMETRYUNITTEST_HPP_

void run_ccz4_geometry_unit_tests();

#endif /* CCZ4GEOMETRYUNITTEST_HPP_ */


================================================
FILE: Tests/CCZ4GeometryUnitTests/Make.package
================================================
GRTECLYN_CEXE_headers += CCZ4GeometryMathematicaValues.hpp \
                         CCZ4GeometryUnitTest.hpp

GRTECLYN_CEXE_sources += CCZ4GeometryUnitTest.cpp


================================================
FILE: Tests/CCZ4GeometryUnitTests/Mathematica_comparison.nb
================================================
(* Content-type: application/vnd.wolfram.mathematica *)

(*** Wolfram Notebook File ***)
(* http://www.wolfram.com/nb *)

(* CreatedBy='Mathematica 10.3' *)

(*CacheID: 234*)
(* Internal cache information:
NotebookFileLineBreakTest
NotebookFileLineBreakTest
NotebookDataPosition[       158,          7]
NotebookDataLength[     27773,        768]
NotebookOptionsPosition[     26757,        747]
NotebookOutlinePosition[     27150,        763]
CellTagsIndexPosition[     27107,        760]
WindowFrame->Normal*)

(* Beginning of Notebook Content *)
Notebook[{
Cell[BoxData[{
 RowBox[{
  RowBox[{"chi", "=", 
   RowBox[{"RandomReal", "[", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"h", "=", 
   RowBox[{"Table", "[", 
    RowBox[{
     RowBox[{"Table", "[", 
      RowBox[{
       RowBox[{"RandomReal", "[", "]"}], ",", 
       RowBox[{"{", 
        RowBox[{"i", ",", "1", ",", "3"}], "}"}]}], "]"}], ",", 
     RowBox[{"{", 
      RowBox[{"j", ",", "1", ",", "3"}], "}"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"Do", "[", 
  RowBox[{
   RowBox[{"Do", "[", 
    RowBox[{
     RowBox[{
      RowBox[{"h", "[", 
       RowBox[{"[", 
        RowBox[{"i", ",", "j"}], "]"}], "]"}], "=", 
      RowBox[{"h", "[", 
       RowBox[{"[", 
        RowBox[{"j", ",", "i"}], "]"}], "]"}]}], ",", 
     RowBox[{"{", 
      RowBox[{"i", ",", 
       RowBox[{"j", "+", "1"}], ",", "3"}], "}"}]}], "]"}], ",", 
   RowBox[{"{", 
    RowBox[{"j", ",", "1", ",", "3"}], "}"}]}], 
  "]"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"gamma", "=", 
   RowBox[{"Table", "[", 
    RowBox[{
     RowBox[{"RandomReal", "[", "]"}], ",", 
     RowBox[{"{", 
      RowBox[{"i", ",", "1", ",", "3"}], "}"}]}], "]"}]}], ";"}]}], "Input",
 CellChangeTimes->{{3.673958984098711*^9, 3.673959008003194*^9}, {
   3.673959051015613*^9, 3.6739590560546007`*^9}, 3.673959435251597*^9, {
   3.6739621513311357`*^9, 3.673962158818715*^9}},
 CellLabel->
  "In[101]:=",ExpressionUUID->"3dbb60ec-8cbc-487c-9d68-b35f177576ce"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"dchi", "=", 
   RowBox[{"Table", "[", 
    RowBox[{
     RowBox[{"RandomReal", "[", "]"}], ",", 
     RowBox[{"{", 
      RowBox[{"i", ",", "1", ",", "3"}], "}"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"dh", "=", 
   RowBox[{"Table", "[", 
    RowBox[{
     RowBox[{"RandomReal", "[", "]"}], ",", 
     RowBox[{"{", 
      RowBox[{"i", ",", "1", ",", "3"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"j", ",", "1", ",", "3"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"k", ",", "1", ",", "3"}], "}"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"Do", "[", 
   RowBox[{
    RowBox[{"Do", "[", 
     RowBox[{
      RowBox[{"Do", "[", 
       RowBox[{
        RowBox[{
         RowBox[{"dh", "[", 
          RowBox[{"[", 
           RowBox[{"k", ",", "i", ",", "j"}], "]"}], "]"}], "=", 
         RowBox[{"dh", "[", 
          RowBox[{"[", 
           RowBox[{"k", ",", "j", ",", "i"}], "]"}], "]"}]}], ",", 
        RowBox[{"{", 
         RowBox[{"i", ",", 
          RowBox[{"j", "+", "1"}], ",", "3"}], "}"}]}], "]"}], ",", 
      RowBox[{"{", 
       RowBox[{"j", ",", "1", ",", "3"}], "}"}]}], "]"}], ",", 
    RowBox[{"{", 
     RowBox[{"k", ",", "1", ",", "3"}], "}"}]}], "]"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"dgamma", "=", 
   RowBox[{"Table", "[", 
    RowBox[{
     RowBox[{"RandomReal", "[", "]"}], ",", 
     RowBox[{"{", 
      RowBox[{"i", ",", "1", ",", "3"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"j", ",", "1", ",", "3"}], "}"}]}], "]"}]}], ";"}]}], "Input",
 CellChangeTimes->{{3.6739590623596573`*^9, 3.673959178256919*^9}, {
  3.6739593922752953`*^9, 3.6739594016484118`*^9}, {3.6739621490813837`*^9, 
  3.6739622274091253`*^9}, {3.673962260745741*^9, 3.67396227899988*^9}, {
  3.673962766705855*^9, 3.6739627844393*^9}, {3.6739628437640133`*^9, 
  3.673962844032935*^9}, {3.673962924094265*^9, 3.673962927179356*^9}},
 CellLabel->
  "In[105]:=",ExpressionUUID->"971ec12a-7f6f-4536-900f-f7aac480f0c0"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"d2chi", "=", 
   RowBox[{"Table", "[", 
    RowBox[{
     RowBox[{"RandomReal", "[", "]"}], ",", 
     RowBox[{"{", 
      RowBox[{"i", ",", "1", ",", "3"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"j", ",", "1", ",", "3"}], "}"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"d2h", "=", 
   RowBox[{"Table", "[", 
    RowBox[{
     RowBox[{"RandomReal", "[", "]"}], ",", 
     RowBox[{"{", 
      RowBox[{"i", ",", "1", ",", "3"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"j", ",", "1", ",", "3"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"k", ",", "1", ",", "3"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"l", ",", "1", ",", "3"}], "}"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"Do", "[", 
   RowBox[{
    RowBox[{"Do", "[", 
     RowBox[{
      RowBox[{"Do", "[", 
       RowBox[{
        RowBox[{
         RowBox[{"d2h", "[", 
          RowBox[{"[", 
           RowBox[{"l", ",", "k", ",", "i", ",", "j"}], "]"}], "]"}], "=", 
         RowBox[{"d2h", "[", 
          RowBox[{"[", 
           RowBox[{"l", ",", "k", ",", "j", ",", "i"}], "]"}], "]"}]}], ",", 
        RowBox[{"{", 
         RowBox[{"i", ",", 
          RowBox[{"j", "+", "1"}], ",", "3"}], "}"}]}], "]"}], ",", 
      RowBox[{"{", 
       RowBox[{"j", ",", "1", ",", "3"}], "}"}]}], "]"}], ",", 
    RowBox[{"{", 
     RowBox[{"k", ",", "1", ",", "3"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"l", ",", "1", ",", "3"}], "}"}]}], "]"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"d2gamma", "=", 
    RowBox[{"Table", "[", 
     RowBox[{
      RowBox[{"RandomReal", "[", "]"}], ",", 
      RowBox[{"{", 
       RowBox[{"i", ",", "1", ",", "3"}], "}"}], ",", 
      RowBox[{"{", 
       RowBox[{"j", ",", "1", ",", "3"}], "}"}], ",", 
      RowBox[{"{", 
       RowBox[{"l", ",", "1", ",", "3"}], "}"}]}], "]"}]}], ";"}], 
  "\[IndentingNewLine]", 
  RowBox[{"(*", 
   RowBox[{"Make", " ", "the", " ", "derivatives", " ", "symmetric"}], 
   "*)"}]}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"Do", "[", 
   RowBox[{
    RowBox[{
     RowBox[{"d2chi", "[", 
      RowBox[{"[", 
       RowBox[{"i", ",", "j"}], "]"}], "]"}], "=", 
     RowBox[{"d2chi", "[", 
      RowBox[{"[", 
       RowBox[{"j", ",", "i"}], "]"}], "]"}]}], ",", 
    RowBox[{"{", 
     RowBox[{"i", ",", "1", ",", "3"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"j", ",", "1", ",", "3"}], "}"}]}], "]"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"Do", "[", 
   RowBox[{
    RowBox[{
     RowBox[{"d2h", "[", 
      RowBox[{"[", 
       RowBox[{"i", ",", "j", ",", "All", ",", "All"}], "]"}], "]"}], "=", 
     RowBox[{"d2h", "[", 
      RowBox[{"[", 
       RowBox[{"j", ",", "i", ",", "All", ",", "All"}], "]"}], "]"}]}], ",", 
    RowBox[{"{", 
     RowBox[{"i", ",", "1", ",", "3"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"j", ",", "1", ",", "3"}], "}"}]}], "]"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"Do", "[", 
   RowBox[{
    RowBox[{
     RowBox[{"d2gamma", "[", 
      RowBox[{"[", 
       RowBox[{"i", ",", "j", ",", "All"}], "]"}], "]"}], "=", 
     RowBox[{"d2gamma", "[", 
      RowBox[{"[", 
       RowBox[{"j", ",", "i", ",", "All"}], "]"}], "]"}]}], ",", 
    RowBox[{"{", 
     RowBox[{"i", ",", "1", ",", "3"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"j", ",", "1", ",", "3"}], "}"}]}], "]"}], ";"}]}], "Input",
 CellChangeTimes->{{3.674044304478036*^9, 3.674044383331047*^9}, {
  3.674044556931326*^9, 3.674044648919847*^9}},
 CellLabel->
  "In[109]:=",ExpressionUUID->"aa47d32e-27bb-4d91-b17e-a174ce450e9c"],

Cell[BoxData[
 RowBox[{
  RowBox[{"(*", 
   RowBox[{
   "For", " ", "Ricci", " ", "we", " ", "also", " ", "need", " ", "the", " ", 
    "Z", " ", "term"}], "*)"}], "\[IndentingNewLine]", 
  RowBox[{
   RowBox[{"zOverChi", "=", 
    RowBox[{"Table", "[", 
     RowBox[{
      RowBox[{"RandomReal", "[", "]"}], ",", 
      RowBox[{"{", 
       RowBox[{"i", ",", "1", ",", "3"}], "}"}]}], "]"}]}], ";"}]}]], "Input",\

 CellChangeTimes->{{3.6740450459264507`*^9, 3.6740450734744577`*^9}},
 CellLabel->
  "In[116]:=",ExpressionUUID->"65b53cd1-a144-476e-892e-125ab0213f1e"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"stream", "=", 
   RowBox[{"OpenWrite", "[", 
    RowBox[{
     RowBox[{"NotebookDirectory", "[", "]"}], "<>", 
     "\"\<CCZ4GeometryMathematicaValues.hpp\>\""}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"WriteLine", "[", 
   RowBox[{"stream", ",", "\"\<////Autogenerated by Mathematica\>\""}], "]"}],
   ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"Close", "[", "stream", "]"}], ";"}]}], "Input",
 CellChangeTimes->{{3.6740420026925697`*^9, 3.674042076906424*^9}, {
  3.674042285548603*^9, 3.674042352173203*^9}, {3.8950461848047132`*^9, 
  3.895046193121941*^9}},ExpressionUUID->"d6693653-1920-47ed-900d-\
53b8598c964e"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"stream", " ", "=", " ", 
   RowBox[{"OpenAppend", "[", 
    RowBox[{
     RowBox[{"NotebookDirectory", "[", "]"}], "<>", 
     "\"\<CCZ4GeometryMathematicaValues.hpp\>\""}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"WriteLine", "[", 
   RowBox[{"stream", ",", 
    RowBox[{"\"\<vars.chi = \>\"", "<>", " ", 
     RowBox[{"ToString", "[", 
      RowBox[{"chi", "//", "InputForm"}], "]"}], "<>", "\"\<;\>\""}]}], "]"}],
   ";"}], "\[IndentingNewLine]", 
 RowBox[{"Do", "[", 
  RowBox[{
   RowBox[{"WriteLine", "[", 
    RowBox[{"stream", ",", 
     RowBox[{"\"\<vars.h[\>\"", "<>", 
      RowBox[{"ToString", "[", 
       RowBox[{"i", "-", "1"}], "]"}], "<>", "\"\<][\>\"", "<>", 
      RowBox[{"ToString", "[", 
       RowBox[{"j", "-", "1"}], "]"}], "<>", "\"\<] = \>\"", "<>", " ", 
      RowBox[{"ToString", "[", 
       RowBox[{
        RowBox[{"h", "[", 
         RowBox[{"[", 
          RowBox[{"i", ",", "j"}], "]"}], "]"}], "//", "InputForm"}], "]"}], 
      "<>", "\"\<;\>\""}]}], "]"}], ",", 
   RowBox[{"{", 
    RowBox[{"i", ",", "1", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"j", ",", "1", ",", "3"}], "}"}]}], 
  "]"}], "\[IndentingNewLine]", 
 RowBox[{"Do", "[", 
  RowBox[{
   RowBox[{"WriteLine", "[", 
    RowBox[{"stream", ",", 
     RowBox[{"\"\<vars.Gamma[\>\"", "<>", 
      RowBox[{"ToString", "[", 
       RowBox[{"j", "-", "1"}], "]"}], "<>", "\"\<] = \>\"", "<>", " ", 
      RowBox[{"ToString", "[", 
       RowBox[{
        RowBox[{"gamma", "[", 
         RowBox[{"[", "j", "]"}], "]"}], "//", "InputForm"}], "]"}], "<>", 
      " ", "\"\<;\>\""}]}], "]"}], ",", 
   RowBox[{"{", 
    RowBox[{"j", ",", "1", ",", "3"}], "}"}]}], 
  "]"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"Do", "[", 
   RowBox[{
    RowBox[{"WriteLine", "[", 
     RowBox[{"stream", ",", 
      RowBox[{"\"\<d1.chi[\>\"", "<>", 
       RowBox[{"ToString", "[", 
        RowBox[{"j", "-", "1"}], "]"}], "<>", "\"\<] = \>\"", "<>", " ", 
       RowBox[{"ToString", "[", 
        RowBox[{
         RowBox[{"dchi", "[", 
          RowBox[{"[", "j", "]"}], "]"}], "//", "InputForm"}], "]"}], "<>", 
       "\"\<;\>\""}]}], "]"}], ",", 
    RowBox[{"{", 
     RowBox[{"j", ",", "1", ",", "3"}], "}"}]}], "]"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"Do", "[", 
  RowBox[{
   RowBox[{"WriteLine", "[", 
    RowBox[{"stream", ",", 
     RowBox[{"\"\<d1.h[\>\"", "<>", 
      RowBox[{"ToString", "[", 
       RowBox[{"i", "-", "1"}], "]"}], "<>", "\"\<][\>\"", "<>", 
      RowBox[{"ToString", "[", 
       RowBox[{"j", "-", "1"}], "]"}], "<>", "\"\<][\>\"", "<>", 
      RowBox[{"ToString", "[", 
       RowBox[{"k", "-", "1"}], "]"}], "<>", "\"\<] = \>\"", "<>", " ", 
      RowBox[{"ToString", "[", 
       RowBox[{
        RowBox[{"dh", "[", 
         RowBox[{"[", 
          RowBox[{"k", ",", "i", ",", "j"}], "]"}], "]"}], "//", 
        "InputForm"}], "]"}], "<>", "\"\<;\>\""}]}], "]"}], ",", 
   RowBox[{"{", 
    RowBox[{"i", ",", "1", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"j", ",", "1", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"k", ",", "1", ",", "3"}], "}"}]}], 
  "]"}], "\[IndentingNewLine]", 
 RowBox[{"Do", "[", 
  RowBox[{
   RowBox[{"WriteLine", "[", 
    RowBox[{"stream", ",", 
     RowBox[{"\"\<d1.Gamma[\>\"", "<>", 
      RowBox[{"ToString", "[", 
       RowBox[{"j", "-", "1"}], "]"}], "<>", "\"\<][\>\"", "<>", 
      RowBox[{"ToString", "[", 
       RowBox[{"k", "-", "1"}], "]"}], "<>", "\"\<] = \>\"", "<>", " ", 
      RowBox[{"ToString", "[", 
       RowBox[{
        RowBox[{"dgamma", "[", 
         RowBox[{"[", 
          RowBox[{"k", ",", "j"}], "]"}], "]"}], "//", "InputForm"}], "]"}], 
      "<>", "\"\<;\>\""}]}], "]"}], ",", 
   RowBox[{"{", 
    RowBox[{"j", ",", "1", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"k", ",", "1", ",", "3"}], "}"}]}], 
  "]"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"Do", "[", 
   RowBox[{
    RowBox[{"WriteLine", "[", 
     RowBox[{"stream", ",", 
      RowBox[{"\"\<d2.chi[\>\"", "<>", 
       RowBox[{"ToString", "[", 
        RowBox[{"l", "-", "1"}], "]"}], "<>", "\"\<][\>\"", "<>", 
       RowBox[{"ToString", "[", 
        RowBox[{"j", "-", "1"}], "]"}], "<>", "\"\<] = \>\"", "<>", " ", 
       RowBox[{"ToString", "[", 
        RowBox[{
         RowBox[{"d2chi", "[", 
          RowBox[{"[", 
           RowBox[{"l", ",", "j"}], "]"}], "]"}], "//", "InputForm"}], "]"}], 
       "<>", "\"\<;\>\""}]}], "]"}], ",", 
    RowBox[{"{", 
     RowBox[{"j", ",", "1", ",", "3"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"l", ",", "1", ",", "3"}], "}"}]}], "]"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"Do", "[", 
   RowBox[{
    RowBox[{"WriteLine", "[", 
     RowBox[{"stream", ",", 
      RowBox[{"\"\<d2.h[\>\"", "<>", 
       RowBox[{"ToString", "[", 
        RowBox[{"i", "-", "1"}], "]"}], "<>", "\"\<][\>\"", "<>", 
       RowBox[{"ToString", "[", 
        RowBox[{"j", "-", "1"}], "]"}], "<>", "\"\<][\>\"", "<>", 
       RowBox[{"ToString", "[", 
        RowBox[{"l", "-", "1"}], "]"}], "<>", "\"\<][\>\"", "<>", 
       RowBox[{"ToString", "[", 
        RowBox[{"k", "-", "1"}], "]"}], "<>", "\"\<] = \>\"", "<>", " ", 
       RowBox[{"ToString", "[", 
        RowBox[{
         RowBox[{"d2h", "[", 
          RowBox[{"[", 
           RowBox[{"l", ",", "k", ",", "i", ",", "j"}], "]"}], "]"}], "//", 
         "InputForm"}], "]"}], "<>", "\"\<;\>\""}]}], "]"}], ",", 
    RowBox[{"{", 
     RowBox[{"i", ",", "1", ",", "3"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"j", ",", "1", ",", "3"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"k", ",", "1", ",", "3"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"l", ",", "1", ",", "3"}], "}"}]}], "]"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"Do", "[", 
   RowBox[{
    RowBox[{"WriteLine", "[", 
     RowBox[{"stream", ",", 
      RowBox[{"\"\<d2.Gamma[\>\"", "<>", 
       RowBox[{"ToString", "[", 
        RowBox[{"j", "-", "1"}], "]"}], "<>", "\"\<][\>\"", "<>", 
       RowBox[{"ToString", "[", 
        RowBox[{"l", "-", "1"}], "]"}], "<>", "\"\<][\>\"", "<>", 
       RowBox[{"ToString", "[", 
        RowBox[{"k", "-", "1"}], "]"}], "<>", "\"\<] = \>\"", "<>", " ", 
       RowBox[{"ToString", "[", 
        RowBox[{
         RowBox[{"d2gamma", "[", 
          RowBox[{"[", 
           RowBox[{"l", ",", "k", ",", "j"}], "]"}], "]"}], "//", 
         "InputForm"}], "]"}], "<>", "\"\<;\>\""}]}], "]"}], ",", 
    RowBox[{"{", 
     RowBox[{"j", ",", "1", ",", "3"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"k", ",", "1", ",", "3"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"l", ",", "1", ",", "3"}], "}"}]}], "]"}], ";", 
  RowBox[{"Do", "[", 
   RowBox[{
    RowBox[{"WriteLine", "[", 
     RowBox[{"stream", ",", 
      RowBox[{"\"\<Z_over_chi[\>\"", "<>", 
       RowBox[{"ToString", "[", 
        RowBox[{"j", "-", "1"}], "]"}], "<>", "\"\<] = \>\"", "<>", " ", 
       RowBox[{"ToString", "[", 
        RowBox[{
         RowBox[{"zOverChi", "[", 
          RowBox[{"[", "j", "]"}], "]"}], "//", "InputForm"}], "]"}], "<>", 
       " ", "\"\<;\>\""}]}], "]"}], ",", 
    RowBox[{"{", 
     RowBox[{"j", ",", "1", ",", "3"}], "}"}]}], "]"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"Close", "[", "stream", "]"}], ";"}]}], "Input",
 CellChangeTimes->{{3.6739592645972633`*^9, 3.673959476943025*^9}, {
   3.673959692487702*^9, 3.6739597078005257`*^9}, {3.67396231448236*^9, 
   3.673962470437146*^9}, {3.673962516389493*^9, 3.67396252169112*^9}, {
   3.67396261322029*^9, 3.673962613520461*^9}, {3.673962695657453*^9, 
   3.673962725839312*^9}, {3.6739628711326733`*^9, 3.673962885091589*^9}, 
   3.6739629745268393`*^9, {3.674041231148275*^9, 3.674041397986896*^9}, {
   3.6740414297327223`*^9, 3.6740415291505632`*^9}, {3.674041644169159*^9, 
   3.674041784849491*^9}, {3.674041961721694*^9, 3.6740419674422417`*^9}, 
   3.6740421372995777`*^9, {3.674044406476741*^9, 3.674044544272881*^9}, {
   3.674045086075034*^9, 3.674045175552557*^9}, {3.82758086478257*^9, 
   3.827580955961705*^9}, {3.8950462101458187`*^9, 
   3.8950462380482283`*^9}},ExpressionUUID->"bd5c41aa-a13b-46bc-a199-\
764c996d874e"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"hu", "=", 
   RowBox[{"Inverse", "[", "h", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"chris", " ", "=", "  ", 
   RowBox[{
    FractionBox["1", "2"], 
    RowBox[{"hu", ".", 
     RowBox[{"(", 
      RowBox[{
       RowBox[{"Transpose", "[", 
        RowBox[{"dh", ",", 
         RowBox[{"{", 
          RowBox[{"2", ",", "3", ",", "1"}], "}"}]}], "]"}], "+", 
       RowBox[{"Transpose", "[", 
        RowBox[{"dh", ",", 
         RowBox[{"{", 
          RowBox[{"3", ",", "2", ",", "1"}], "}"}]}], "]"}], "-", "dh"}], 
      ")"}]}]}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"chrisContr", " ", "=", " ", 
   RowBox[{"TensorContract", "[", 
    RowBox[{
     RowBox[{"Outer", "[", 
      RowBox[{"Times", ",", "hu", ",", "chris"}], "]"}], ",", 
     RowBox[{"{", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"1", ",", "4"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"2", ",", "5"}], "}"}]}], "}"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"stream", "=", 
   RowBox[{"OpenAppend", "[", 
    RowBox[{
     RowBox[{"NotebookDirectory", "[", "]"}], "<>", 
     "\"\<CCZ4GeometryMathematicaValues.hpp\>\""}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"WriteLine", "[", 
   RowBox[{"stream", ",", 
    RowBox[{"\"\<double h_UU_known[3][3] = \>\"", "<>", 
     RowBox[{"ToString", "[", 
      RowBox[{"hu", "//", "InputForm"}], "]"}], "<>", "\"\<;\>\""}]}], "]"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"WriteLine", "[", 
   RowBox[{"stream", ",", 
    RowBox[{"\"\<double chris_known[3][3][3] = \>\"", "<>", 
     RowBox[{"ToString", "[", 
      RowBox[{"chris", "//", "InputForm"}], "]"}], "<>", "\"\<;\>\""}]}], 
   "]"}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"WriteLine", "[", 
   RowBox[{"stream", ",", 
    RowBox[{"\"\<double chris_contracted_known[3] = \>\"", "<>", 
     RowBox[{"ToString", "[", 
      RowBox[{"chrisContr", "//", "InputForm"}], "]"}], "<>", "\"\<;\>\""}]}],
    "]"}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"Close", "[", "stream", "]"}], ";"}]}], "Input",
 CellChangeTimes->{{3.673960625043317*^9, 3.673960627938899*^9}, {
   3.6739608035339003`*^9, 3.673960805701221*^9}, {3.674040698039809*^9, 
   3.674040698531793*^9}, {3.674040844345147*^9, 3.674040858931782*^9}, 
   3.674042453509678*^9, {3.674042484724638*^9, 3.674042557046445*^9}, {
   3.674042600288547*^9, 3.674042670283389*^9}, {3.674043118876886*^9, 
   3.674043125866755*^9}, {3.674043192134695*^9, 3.674043228879302*^9}, {
   3.674044834160006*^9, 3.6740448565349207`*^9}, {3.8950462436274757`*^9, 
   3.8950462592610683`*^9}},ExpressionUUID->"0259388c-095e-40c2-9f83-\
211c9d4efcae"],

Cell[BoxData[
 RowBox[{
  RowBox[{"(*", 
   RowBox[{"Calculate", " ", "ricci"}], "*)"}], "\[IndentingNewLine]", 
  RowBox[{
   RowBox[{
    RowBox[{"dims", "=", "4"}], ";", 
    RowBox[{"\[Chi]", "=", "chi"}], ";", 
    RowBox[{"d\[Chi]", "=", "dchi"}], ";", 
    RowBox[{"d2\[Chi]", "=", "d2chi"}], ";", 
    RowBox[{"hh", "=", "h"}], ";"}], "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"dHh", "=", "dh"}], ";", 
    RowBox[{"d2Hh", "=", "d2h"}], ";", 
    RowBox[{"gam", "=", "gamma"}], ";", 
    RowBox[{"dGam", "=", "dgamma"}], ";"}], "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"zz", "=", 
     RowBox[{"zOverChi", "*", "chi"}]}], ";"}], "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"ricChi", " ", "=", " ", 
     RowBox[{
      RowBox[{
       RowBox[{
        RowBox[{"(", 
         RowBox[{"dims", "-", "3"}], ")"}], "/", 
        RowBox[{"(", 
         RowBox[{"2", "\[Chi]"}], ")"}]}], " ", 
       RowBox[{"(", 
        RowBox[{"d2\[Chi]", "-", 
         RowBox[{"d\[Chi]", ".", "chris"}]}], ")"}]}], "-", 
      RowBox[{
       RowBox[{
        RowBox[{"(", 
         RowBox[{"dims", "-", "3"}], ")"}], "/", 
        RowBox[{"(", 
         RowBox[{"4", 
          SuperscriptBox["\[Chi]", "2"]}], ")"}]}], " ", 
       RowBox[{"Outer", "[", 
        RowBox[{"Times", ",", "d\[Chi]", ",", "d\[Chi]"}], "]"}]}], "+", 
      RowBox[{"hh", 
       RowBox[{"(", 
        RowBox[{
         RowBox[{
          RowBox[{"1", "/", 
           RowBox[{"(", 
            RowBox[{"2", "\[Chi]"}], ")"}]}], " ", 
          RowBox[{"Tr", "[", 
           RowBox[{"hu", ".", "d2\[Chi]"}], "]"}]}], "-", 
         RowBox[{
          RowBox[{
           RowBox[{"(", 
            RowBox[{"dims", "-", "1"}], ")"}], "/", 
           RowBox[{"(", 
            RowBox[{"4", 
             SuperscriptBox["\[Chi]", "2"]}], ")"}]}], " ", 
          RowBox[{
           RowBox[{"(", 
            RowBox[{"hu", ".", "d\[Chi]"}], ")"}], ".", "d\[Chi]"}]}]}], 
        ")"}]}], "-", 
      RowBox[{
       RowBox[{"1", "/", 
        RowBox[{"(", 
         RowBox[{"2", "\[Chi]"}], ")"}]}], " ", "hh", " ", 
       RowBox[{"chrisContr", ".", "d\[Chi]"}]}]}]}], " ", ";"}], "\n", 
   RowBox[{"(*", 
    RowBox[{
    "RicBar", " ", "calculated", " ", "as", " ", "in", " ", "Alcubierre", " ",
      "2.8", ".17"}], "*)"}], "\n", 
   RowBox[{
    RowBox[{"ricBar", " ", "=", " ", 
     RowBox[{
      RowBox[{
       RowBox[{"-", 
        RowBox[{"(", 
         RowBox[{"1", "/", "2"}], ")"}]}], 
       RowBox[{"TensorContract", "[", 
        RowBox[{
         RowBox[{"hu", ".", "d2Hh"}], ",", 
         RowBox[{"{", 
          RowBox[{"1", ",", "2"}], "}"}]}], "]"}]}], "+", 
      RowBox[{"Symmetrize", "[", 
       RowBox[{"dGam", ".", "hh"}], "]"}], "+", 
      RowBox[{
       RowBox[{"(", 
        RowBox[{"1", "/", "2"}], ")"}], " ", 
       RowBox[{"gam", ".", "dHh"}]}], "+", 
      RowBox[{"2", "*", 
       RowBox[{"Symmetrize", "[", 
        RowBox[{"TensorContract", "[", 
         RowBox[{
          RowBox[{"Outer", "[", 
           RowBox[{"Times", ",", "chris", ",", 
            RowBox[{
             RowBox[{"(", 
              RowBox[{"hh", ".", "chris"}], ")"}], ".", "hu"}]}], "]"}], ",", 
          
          RowBox[{"{", 
           RowBox[{
            RowBox[{"{", 
             RowBox[{"1", ",", "5"}], "}"}], ",", 
            RowBox[{"{", 
             RowBox[{"2", ",", "6"}], "}"}]}], "}"}]}], "]"}], "]"}]}], "+", 
      RowBox[{"TensorContract", "[", 
       RowBox[{
        RowBox[{"Outer", "[", 
         RowBox[{"Times", ",", "chris", ",", 
          RowBox[{
           RowBox[{"(", 
            RowBox[{"hh", ".", "chris"}], ")"}], ".", "hu"}]}], "]"}], ",", 
        RowBox[{"{", 
         RowBox[{
          RowBox[{"{", 
           RowBox[{"1", ",", "4"}], "}"}], ",", 
          RowBox[{"{", 
           RowBox[{"3", ",", "6"}], "}"}]}], "}"}]}], "]"}]}]}], ";"}], "\n", 
   
   RowBox[{
    RowBox[{"zterms", " ", "=", " ", 
     RowBox[{
      SuperscriptBox["\[Chi]", 
       RowBox[{"-", "2"}]], " ", 
      RowBox[{"(", 
       RowBox[{
        RowBox[{"2", " ", 
         RowBox[{"Symmetrize", "[", 
          RowBox[{"Outer", "[", 
           RowBox[{"Times", ",", 
            RowBox[{"zz", ".", "hh"}], ",", "d\[Chi]"}], "]"}], "]"}]}], " ", 
        "-", " ", 
        RowBox[{"hh", " ", 
         RowBox[{"zz", ".", "d\[Chi]"}]}]}], ")"}]}]}], " ", ";"}], "\n", 
   RowBox[{
    RowBox[{"ricciZ", " ", "=", " ", 
     RowBox[{"ricBar", "+", "ricChi", "+", "zterms"}]}], " ", ";"}], 
   "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"ricciSZ", " ", "=", " ", 
     RowBox[{"Tr", "[", 
      RowBox[{"\[Chi]", " ", 
       RowBox[{"hu", ".", "ricciZ"}]}], "]"}]}], ";"}], "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"stream", "=", 
     RowBox[{"OpenAppend", "[", 
      RowBox[{
       RowBox[{"NotebookDirectory", "[", "]"}], "<>", 
       "\"\<CCZ4GeometryMathematicaValues.hpp\>\""}], "]"}]}], ";"}], 
   "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"WriteLine", "[", 
     RowBox[{"stream", ",", 
      RowBox[{"\"\<double ricciZ_known[3][3] = \>\"", "<>", 
       RowBox[{"ToString", "[", 
        RowBox[{"ricciZ", "//", "InputForm"}], "]"}], "<>", "\"\<;\>\""}]}], 
     "]"}], ";"}], "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"WriteLine", "[", 
     RowBox[{"stream", ",", 
      RowBox[{"\"\<double ricciZ_scalar_known = \>\"", "<>", 
       RowBox[{"ToString", "[", 
        RowBox[{"ricciSZ", "//", "InputForm"}], "]"}], "<>", "\"\<;\>\""}]}], 
     "]"}], ";"}], "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"Close", "[", "stream", "]"}], ";"}]}]}]], "Input",
 CellChangeTimes->{{3.6740448591918573`*^9, 3.6740450196886168`*^9}, {
   3.674045199073616*^9, 3.674045203328549*^9}, {3.6740452854850063`*^9, 
   3.674045319880831*^9}, {3.6740497140208893`*^9, 3.674049887172719*^9}, {
   3.6740499187502213`*^9, 3.6740499595135736`*^9}, {3.674049992778508*^9, 
   3.67404999336996*^9}, {3.674050111762424*^9, 3.674050115700314*^9}, {
   3.674051253323957*^9, 3.674051257913859*^9}, 3.674051311381283*^9, {
   3.6740513535921183`*^9, 3.674051368588213*^9}, {3.674051763962434*^9, 
   3.674051764407851*^9}, {3.6740524406272697`*^9, 3.674052451969912*^9}, {
   3.674052506812701*^9, 3.674052532169784*^9}, {3.674053161756274*^9, 
   3.6740531828424673`*^9}, {3.674053255936688*^9, 3.674053257958578*^9}, {
   3.7959525030462723`*^9, 3.795952517112131*^9}, {3.827580551503574*^9, 
   3.827580559422234*^9}, {3.827580594423608*^9, 3.827580631441595*^9}, {
   3.827580698694351*^9, 3.827580727173737*^9}, {3.8275950352640676`*^9, 
   3.827595062632444*^9}, 3.827595173494932*^9, {3.827595713765167*^9, 
   3.82759572953244*^9}, {3.895046915321095*^9, 
   3.8950469234599133`*^9}},ExpressionUUID->"a0cfe398-4ecd-4892-8c0a-\
e470f4cacd84"]
},
WindowSize->{807.75, 609.},
WindowMargins->{{-139.5, 1023.75}, {372., 147.}},
FrontEndVersion->"13.1 for Linux x86 (64-bit) (June 16, 2022)",
StyleDefinitions->"Default.nb",
ExpressionUUID->"9e27fb79-dbfd-4fe0-a781-b8b4fc5e2ac3"
]
(* End of Notebook Content *)

(* Internal cache information *)
(*CellTagsOutline
CellTagsIndex->{}
*)
(*CellTagsIndex
CellTagsIndex->{}
*)
(*NotebookFileOutline
Notebook[{
Cell[558, 20, 1456, 44, 92, "Input",ExpressionUUID->"3dbb60ec-8cbc-487c-9d68-b35f177576ce"],
Cell[2017, 66, 2045, 58, 92, "Input",ExpressionUUID->"971ec12a-7f6f-4536-900f-f7aac480f0c0"],
Cell[4065, 126, 3645, 112, 175, "Input",ExpressionUUID->"aa47d32e-27bb-4d91-b17e-a174ce450e9c"],
Cell[7713, 240, 568, 16, 52, "Input",ExpressionUUID->"65b53cd1-a144-476e-892e-125ab0213f1e"],
Cell[8284, 258, 687, 17, 74, "Input",ExpressionUUID->"d6693653-1920-47ed-900d-53b8598c964e"],
Cell[8974, 277, 8225, 213, 551, "Input",ExpressionUUID->"bd5c41aa-a13b-46bc-a199-764c996d874e"],
Cell[17202, 492, 2745, 71, 220, "Input",ExpressionUUID->"0259388c-095e-40c2-9f83-211c9d4efcae"],
Cell[19950, 565, 6803, 180, 377, "Input",ExpressionUUID->"a0cfe398-4ecd-4892-8c0a-e470f4cacd84"]
}
]
*)




================================================
FILE: Tests/CCZ4RHSTest/ADMConformalVars-fdf5a7a.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef ADMCONFORMALVARS_FDF5A7A_HPP_
#define ADMCONFORMALVARS_FDF5A7A_HPP_

// clang-format off
// NOLINTBEGIN

#include "Tensor-fdf5a7a.hpp"
#include "StateVariables.hpp"
#include "VarsTools-fdf5a7a.hpp"

// Namespace to avoid conflicts with current code
namespace Old
{
/// Namespace for ADM vars in conformally decomposed form
/** The structs in this namespace collect all the ADM variables. It's main use
 *is to make a local, nicely laid-out, copy of the ADM variables for the
 *current grid cell (Otherwise, this data would only exist on the grid in the
 *huge, flattened Chombo array). \sa {CCZ4Vars, BSSNVars}
 **/
namespace ADMConformalVars
{
/// Vars object for ADM vars, including gauge vars
template <class data_t> struct VarsNoGauge
{
    data_t chi;          //!< Conformal factor
    Tensor<2, data_t> h; //!< Conformal metric
    data_t K;            //!< Trace of the extrinsic curvature
    Tensor<2, data_t> A; //!< trace-free part of the rescale extrinsic
                         //! curvature, i.e. \f$\chi
                         //!(K_{ij})^{\mathrm{TF}}\f$

    /// Defines the mapping between members of Vars and Chombo grid
    /// variables (enum in User_Variables)
    template <typename mapping_function_t>
    AMREX_GPU_DEVICE
    void enum_mapping(mapping_function_t mapping_function)
    {
        using namespace VarsTools; // define_enum_mapping is part of VarsTools
        // Scalars
        define_enum_mapping(mapping_function, c_chi, chi);
        define_enum_mapping(mapping_function, c_K, K);

        // Symmetric 2-tensors
        define_symmetric_enum_mapping(mapping_function,
                                      GRInterval<c_h11, c_h33>(), h);
        define_symmetric_enum_mapping(mapping_function,
                                      GRInterval<c_A11, c_A33>(), A);
    }
};

/// Vars object for ADM vars, including gauge vars
template <class data_t> struct VarsWithGauge : public VarsNoGauge<data_t>
{
    data_t lapse;
    Tensor<1, data_t> shift;

    /// Defines the mapping between members of Vars and Chombo grid
    /// variables (enum in User_Variables)
    template <typename mapping_function_t>
    AMREX_GPU_DEVICE
    void enum_mapping(mapping_function_t mapping_function)
    {
        using namespace VarsTools; // define_enum_mapping is part of VarsTools
        VarsNoGauge<data_t>::enum_mapping(mapping_function);
        define_enum_mapping(mapping_function, c_lapse, lapse);
        define_enum_mapping(mapping_function, GRInterval<c_shift1, c_shift3>(),
                            shift);
    }
};

/// Vars object for ADM vars requiring second derivs, excluding gauge vars
template <class data_t> struct Diff2VarsNoGauge
{
    data_t chi;          //!< Conformal factor
    Tensor<2, data_t> h; //!< Conformal metric

    template <typename mapping_function_t>
    AMREX_GPU_DEVICE
    void enum_mapping(mapping_function_t mapping_function)
    {
        using namespace VarsTools; // define_enum_mapping is part of VarsTools
        define_enum_mapping(mapping_function, c_chi, chi);
        define_symmetric_enum_mapping(mapping_function,
                                      GRInterval<c_h11, c_h33>(), h);
    }
};

/// Vars object for ADM vars requiring second derivs, with gauge vars
template <class data_t>
struct Diff2VarsWithGauge : public Diff2VarsNoGauge<data_t>
{
    data_t lapse;
    Tensor<1, data_t> shift;

    /// Defines the mapping between members of Vars and Chombo grid
    /// variables (enum in User_Variables)
    template <typename mapping_function_t>
    AMREX_GPU_DEVICE
    void enum_mapping(mapping_function_t mapping_function)
    {
        using namespace VarsTools; // define_enum_mapping is part of VarsTools
        Diff2VarsNoGauge<data_t>::enum_mapping(mapping_function);
        define_enum_mapping(mapping_function, c_lapse, lapse);
        define_enum_mapping(mapping_function, GRInterval<c_shift1, c_shift3>(),
                            shift);
    }
};
} // namespace ADMConformalVars
} // namespace Old

// NOLINTEND

#endif /* ADMCONFORMALVARS_FDF5A7A_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/BSSNVars-fdf5a7a.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef BSSNVARS_FDF5A7A_HPP_
#define BSSNVARS_FDF5A7A_HPP_

// clang-format off
// NOLINTBEGIN

#include "ADMConformalVars-fdf5a7a.hpp"
#include "Tensor-fdf5a7a.hpp"
#include "VarsTools-fdf5a7a.hpp"

// Namespace to avoid conflicts with current code
namespace Old
{
/// Namespace for BSSN vars
/** The structs in this namespace collect all the BSSN variables. It's main use
 *  is to make a local, nicely laid-out, copy of the BSSN variables for the
 *  current grid cell (Otherwise, this data would only exist on the grid in
 *  the huge, flattened Chombo array). \sa {CCZ4Vars, ADMConformalVars}
 **/
namespace BSSNVars
{
/// Vars object for BSSN vars excluding gauge vars
template <class data_t>
struct VarsNoGauge : public ADMConformalVars::VarsNoGauge<data_t>
{
    Tensor<1, data_t> Gamma; //!< Conformal connection functions

    /// Defines the mapping between members of Vars and Chombo grid
    /// variables (enum in User_Variables)
    template <typename mapping_function_t>
    AMREX_GPU_DEVICE
    void enum_mapping(mapping_function_t mapping_function)
    {
        using namespace VarsTools; // define_enum_mapping is part of VarsTools
        ADMConformalVars::VarsNoGauge<data_t>::enum_mapping(mapping_function);
        define_enum_mapping(mapping_function, GRInterval<c_Gamma1, c_Gamma3>(),
                            Gamma); //!< The auxilliary variable Gamma^i
    }
};

/// Vars object for BSSN vars, including gauge vars
template <class data_t> struct VarsWithGauge : public VarsNoGauge<data_t>
{
    data_t lapse;
    Tensor<1, data_t> shift;
    Tensor<1, data_t> B; //!< \f$B^i = \partial_t \beta^i\f$, this is used
                         //! for second order shift conditions

    /// Defines the mapping between members of Vars and Chombo grid
    /// variables (enum in User_Variables)
    template <typename mapping_function_t>
    AMREX_GPU_DEVICE
    void enum_mapping(mapping_function_t mapping_function)
    {
        using namespace VarsTools; // define_enum_mapping is part of VarsTools
        VarsNoGauge<data_t>::enum_mapping(mapping_function);
        define_enum_mapping(mapping_function, c_lapse, lapse);
        define_enum_mapping(mapping_function, GRInterval<c_shift1, c_shift3>(),
                            shift);
        define_enum_mapping(mapping_function, GRInterval<c_B1, c_B3>(), B);
    }
};

/// Vars object for BSSN vars needing second derivs, excluding gauge vars
template <class data_t>
struct Diff2VarsNoGauge : public ADMConformalVars::Diff2VarsNoGauge<data_t>
{
};

/// Vars object for BSSN vars needing second derivs, including gauge vars
template <class data_t>
struct Diff2VarsWithGauge : public ADMConformalVars::Diff2VarsWithGauge<data_t>
{
};
} // namespace BSSNVars
} // namespace Old

// NOLINTEND

#endif /* BSSNVARS_FDF5A7A_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/CCZ4Geometry-fdf5a7a.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// This file calculates CCZ4 geometric quantities (or a similar 3+1 split).
#ifndef CCZ4GEOMETRY_FDF5A7A_HPP_
#define CCZ4GEOMETRY_FDF5A7A_HPP_

// clang-format off
// NOLINTBEGIN

#include "DimensionDefinitions.hpp"
#include "TensorAlgebra-fdf5a7a.hpp"

// Namespace to avoid conflicts with current code
namespace Old
{
//! A structure for the decomposed elements of the Energy Momentum Tensor in
//! 3+1D
template <class data_t> struct emtensor_t
{
    Tensor<2, data_t> Sij; //!< S_ij = T_ij
    Tensor<1, data_t> Si;  //!< S_i = T_ia_n^a
    data_t S;              //!< S = S^i_i
    data_t rho;            //!< rho = T_ab n^a n^b
};

template <class data_t> struct ricci_t
{
    Tensor<2, data_t> LL; // Ricci with two indices down
    data_t scalar;        // Ricci scalar
};

class CCZ4Geometry
{
  protected:
    template <class data_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE
    static data_t
    compute_z_terms(const int i, const int j,
                    const Tensor<1, data_t> &Z_over_chi,
                    const Tensor<2, data_t> &h, const Tensor<1, data_t> &d1_chi)
    {
        data_t out = 0.;
        FOR(k)
        {
            out += Z_over_chi[k] * (h[i][k] * d1_chi[j] + h[j][k] * d1_chi[i] -
                                    h[i][j] * d1_chi[k]);
        }
        return out;
    }

  public:
    template <class data_t, template <typename> class vars_t,
              template <typename> class diff2_vars_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE
    static ricci_t<data_t>
    compute_ricci_Z(const vars_t<data_t> &vars,
                    const vars_t<Tensor<1, data_t>> &d1,
                    const diff2_vars_t<Tensor<2, data_t>> &d2,
                    const Tensor<2, data_t> &h_UU, const chris_t<data_t> &chris,
                    const Tensor<1, data_t> &Z_over_chi)
    {
        ricci_t<data_t> out;

        Tensor<2, data_t> covdtilde2chi;
        FOR(k, l)
        {
            covdtilde2chi[k][l] = d2.chi[k][l];
            FOR(m) { covdtilde2chi[k][l] -= chris.ULL[m][k][l] * d1.chi[m]; }
        }

        Tensor<3, data_t> chris_LLU = {0.};
        data_t boxtildechi = 0.;
        data_t dchi_dot_dchi = 0.;
        FOR(i, j)
        {
            boxtildechi += covdtilde2chi[i][j] * h_UU[i][j];
            dchi_dot_dchi += d1.chi[i] * d1.chi[j] * h_UU[i][j];
            FOR(k, l) { chris_LLU[i][j][k] += h_UU[k][l] * chris.LLL[i][j][l]; }
        }

        FOR(i, j)
        {
            data_t ricci_hat = 0;
            FOR(k)
            {
                // We call this ricci_hat rather than ricci_tilde as we have
                // replaced what should be \tilde{Gamma} with \hat{Gamma} in
                // order to avoid adding terms that cancel later on
                ricci_hat += 0.5 * (vars.h[k][i] * d1.Gamma[k][j] +
                                    vars.h[k][j] * d1.Gamma[k][i]);
                ricci_hat += 0.5 * vars.Gamma[k] * d1.h[i][j][k];
                FOR(l)
                {
                    ricci_hat += -0.5 * h_UU[k][l] * d2.h[i][j][k][l] +
                                 (chris.ULL[k][l][i] * chris_LLU[j][k][l] +
                                  chris.ULL[k][l][j] * chris_LLU[i][k][l] +
                                  chris.ULL[k][i][l] * chris_LLU[k][j][l]);
                }
            }

            data_t ricci_chi =
                0.5 * ((GR_SPACEDIM - 2) * covdtilde2chi[i][j] +
                       vars.h[i][j] * boxtildechi -
                       ((GR_SPACEDIM - 2) * d1.chi[i] * d1.chi[j] +
                        GR_SPACEDIM * vars.h[i][j] * dchi_dot_dchi) /
                           (2 * vars.chi));

            data_t z_terms = compute_z_terms(i, j, Z_over_chi, vars.h, d1.chi);

            out.LL[i][j] =
                (ricci_chi + vars.chi * ricci_hat + z_terms) / vars.chi;
        }

        out.scalar = vars.chi * TensorAlgebra::compute_trace(out.LL, h_UU);

        return out;
    }

    template <class data_t>
    static Tensor<2, data_t>
    compute_d1_chris_contracted(const Tensor<2, data_t> &h_UU,
                                const Tensor<2, Tensor<1, data_t>> &d1_h,
                                const Tensor<2, Tensor<2, data_t>> &d2_h)
    {
        Tensor<2, data_t> d1_chris_contracted = 0.0;
        FOR(i, j)
        {
            FOR(m, n, p)
            {
                data_t d1_terms = 0.0;
                FOR(q, r)
                {
                    d1_terms += -h_UU[q][r] * (d1_h[n][q][j] * d1_h[m][p][r] +
                                               d1_h[m][n][j] * d1_h[p][q][r]);
                }
                d1_chris_contracted[i][j] +=
                    h_UU[i][m] * h_UU[n][p] * (d2_h[m][n][j][p] + d1_terms);
            }
        }
        return d1_chris_contracted;
    }

    // This function allows adding arbitrary multiples of D_{(i}Z_{j)}
    // to the Ricci scalar rather than the default of 2 in compute_ricci_Z
    template <class data_t, template <typename> class vars_t,
              template <typename> class diff2_vars_t>
    static ricci_t<data_t>
    compute_ricci_Z_general(const vars_t<data_t> &vars,
                            const vars_t<Tensor<1, data_t>> &d1,
                            const diff2_vars_t<Tensor<2, data_t>> &d2,
                            const Tensor<2, data_t> &h_UU,
                            const chris_t<data_t> &chris, const double dZ_coeff)
    {
        // get contributions from conformal metric and factor with zero Z vector
        Tensor<1, data_t> Z0 = 0.;
        auto ricci = compute_ricci_Z(vars, d1, d2, h_UU, chris, Z0);

        // need to add term to correct for d1.Gamma (includes Z contribution)
        // and Gamma in ricci_hat
        auto d1_chris_contracted =
            compute_d1_chris_contracted(h_UU, d1.h, d2.h);
        Tensor<1, data_t> Z_over_chi;
        FOR(i) { Z_over_chi[i] = 0.5 * (vars.Gamma[i] - chris.contracted[i]); }
        FOR(i, j)
        {
            FOR(m)
            {
                // This corrects for the \hat{Gamma}s in ricci_hat
                ricci.LL[i][j] +=
                    (1. - 0.5 * dZ_coeff) * 0.5 *
                    (vars.h[m][i] *
                         (d1_chris_contracted[m][j] - d1.Gamma[m][j]) +
                     vars.h[m][j] *
                         (d1_chris_contracted[m][i] - d1.Gamma[m][i]) +
                     (chris.contracted[m] - vars.Gamma[m]) * d1.h[i][j][m]);
            }
            data_t z_terms = compute_z_terms(i, j, Z_over_chi, vars.h, d1.chi);
            ricci.LL[i][j] += 0.5 * dZ_coeff * z_terms / vars.chi;
        }
        ricci.scalar = vars.chi * TensorAlgebra::compute_trace(ricci.LL, h_UU);
        return ricci;
    }

    // This function returns the pure Ricci scalar with no contribution from the
    // Z vector - used e.g. in the constraint calculations.
    template <class data_t, template <typename> class vars_t,
              template <typename> class diff2_vars_t>
    static ricci_t<data_t>
    compute_ricci(const vars_t<data_t> &vars,
                  const vars_t<Tensor<1, data_t>> &d1,
                  const diff2_vars_t<Tensor<2, data_t>> &d2,
                  const Tensor<2, data_t> &h_UU, const chris_t<data_t> &chris)
    {
        return compute_ricci_Z_general(vars, d1, d2, h_UU, chris, 0.0);
    }
};
} // namespace Old

// NOLINTEND

#endif /* CCZ4GEOMETRY_FDF5A7A_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/CCZ4RHS-fdf5a7a.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef CCZ4RHS_FDF5A7A_HPP_
#define CCZ4RHS_FDF5A7A_HPP_

// clang-format off
// NOLINTBEGIN

#include "CCZ4Geometry-fdf5a7a.hpp"
#include "CCZ4Vars-fdf5a7a.hpp"
#include "Cell-fdf5a7a.hpp"
#include "FourthOrderDerivatives-fdf5a7a.hpp"
#include "MovingPunctureGauge-fdf5a7a.hpp"
#include "Tensor-fdf5a7a.hpp"
#include "TensorAlgebra-fdf5a7a.hpp"
#include "simd.hpp"

#include "StateVariables.hpp" //This files needs NUM_VARS - total number of components

#include <array>

// Namespace to avoid conflicts with current code
namespace Old
{
/// Base parameter struct for CCZ4
/** This struct collects the gauge independent CCZ4 parameters i.e. the damping
 * ones
 */
struct CCZ4_base_params_t
{
    double kappa1;    //!< Damping parameter kappa1 as in arXiv:1106.2254
    double kappa2;    //!< Damping parameter kappa2 as in arXiv:1106.2254
    double kappa3;    //!< Damping parameter kappa3 as in arXiv:1106.2254
    bool covariantZ4; //!< if true, replace kappa1->kappa1/lapse as in
                      //!<  arXiv:1307.7391 eq. 27
};

/// Parameter struct for CCZ4
/** This struct collects all parameters that are necessary for CCZ4 such as
 * gauge and damping parameters. It inherits from CCZ4_base_params_t and
 * gauge_t::params_t
 */
template <class gauge_params_t = MovingPunctureGauge::params_t>
struct CCZ4_params_t : public CCZ4_base_params_t, public gauge_params_t
{
};

/// Compute class to calculate the CCZ4 right hand side
/**
 * This compute class implements the CCZ4 right hand side equations. Use it by
 *handing it to a loop in the BoxLoops namespace. CCZ4RHS includes a struct
 *in its scope: CCZ4RHS::Vars (the CCZ4 variables like conformal factor,
 *conformal metric, extrinsic curvature, etc).
 **/
template <class gauge_t = MovingPunctureGauge,
          class deriv_t = FourthOrderDerivatives>
class CCZ4RHS
{
  public:
    enum
    {
        USE_CCZ4,
        USE_BSSN
    };

    using params_t = CCZ4_params_t<typename gauge_t::params_t>;

    /// CCZ4 variables
    template <class data_t> using Vars = CCZ4Vars::VarsWithGauge<data_t>;

    /// CCZ4 variables
    template <class data_t>
    using Diff2Vars = CCZ4Vars::Diff2VarsWithGauge<data_t>;

  protected:
    const params_t m_params; //!< CCZ4 parameters
    const gauge_t m_gauge;   //!< Class to compute gauge in rhs_equation
    const double m_sigma;    //!< Coefficient for Kreiss-Oliger dissipation
    int m_formulation;
    double m_cosmological_constant;
    const deriv_t m_deriv;

  public:
    /// Constructor
    CCZ4RHS(
        params_t a_params,            //!< The CCZ4 parameters
        double a_dx,                  //!< The grid spacing
        double a_sigma,               //!< Kreiss-Oliger dissipation coefficient
        int a_formulation = USE_CCZ4, //!< Switches between CCZ4, BSSN,...
        double a_cosmological_constant = 0 //!< Value of the cosmological const.
    );

    /// Compute function
    /** This function orchestrates the calculation of the rhs for one specific
     * grid cell. This function is called by the BoxLoops::loop for each grid
     * cell; there should rarely be a need to call it directly.
     */
    template <class data_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE
    void compute(int i, int j, int k, amrex::Array4<data_t> const& rhs,
                 amrex::Array4<data_t const> const& state) const;

  protected:
    /// Calculates the rhs for CCZ4
    /** Calculates the right hand side for CCZ4 and calls rhs_gauge for the
     *gauge conditions The variables (the template argument vars_t) must contain
     *at least the members: chi, h[i][j], Gamma[i], A[i][j], Theta, lapse and
     *shift[i].
     **/
    template <class data_t, template <typename> class vars_t,
              template <typename> class diff2_vars_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE
    void rhs_equation(
        vars_t<data_t> &rhs, //!< Reference to the variables into which the
                             //! output right hand side is written
        const vars_t<data_t> &vars, //!< The values of the current variables
        const vars_t<Tensor<1, data_t>>
            &d1, //!< First derivative of the variables
        const diff2_vars_t<Tensor<2, data_t>>
            &d2, //!< The second derivative the variables
        const vars_t<data_t>
            &advec //!< The advection derivatives of the variables
    ) const;
};
} // namespace Old

// NOLINTEND

#include "CCZ4RHS-fdf5a7a.impl.hpp"

#endif /* CCZ4RHS_FDF5A7A_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/CCZ4RHS-fdf5a7a.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(CCZ4RHS_FDF5A7A_HPP_)
#error "This file should only be included through CCZ4RHS-fdf5a7a.hpp"
#endif

#ifndef CCZ4RHS_FDF5A7A_IMPL_HPP_
#define CCZ4RHS_FDF5A7A_IMPL_HPP_

// clang-format off
// NOLINTBEGIN

#include "DimensionDefinitions.hpp"
#include "GRInterval-fdf5a7a.hpp"
#include "VarsTools-fdf5a7a.hpp"

// Namespace to avoid conflicts with current code
namespace Old
{
template <class gauge_t, class deriv_t>
inline CCZ4RHS<gauge_t, deriv_t>::CCZ4RHS(
    CCZ4_params_t<typename gauge_t::params_t> a_params, double a_dx,
    double a_sigma, int a_formulation, double a_cosmological_constant)
    : m_params(a_params), m_gauge(a_params), m_sigma(a_sigma),
      m_formulation(a_formulation),
      m_cosmological_constant(a_cosmological_constant), m_deriv(a_dx)
{
    // A user who wants to use BSSN should also have damping paramters = 0
    if (m_formulation == USE_BSSN)
    {
        if ((m_params.kappa1 != 0.) || (m_params.kappa2 != 0.) ||
            (m_params.kappa3 != 0.))
        {
            amrex::Abort("BSSN formulation is selected - CCZ4 kappa values "
                          "should be set to zero in params");
        }
    }
    if (m_formulation > USE_BSSN)
        amrex::Abort("The requested formulation is not supported");
}

template <class gauge_t, class deriv_t>
template <class data_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE
void CCZ4RHS<gauge_t, deriv_t>::compute(int i, int j, int k,
                                        amrex::Array4<data_t> const& rhs,
                                        amrex::Array4<data_t const> const& state) const
{
    const auto vars = load_vars<Vars>(state.cellData(i,j,k));
    const auto d1 = m_deriv.template diff1<Vars>(i,j,k,state);
    const auto d2 = m_deriv.template diff2<Diff2Vars>(i,j,k,state);
    const auto advec =
        m_deriv.template advection<Vars>(i,j,k,state,vars.shift);

    Vars<data_t> rhs_vars;
    rhs_equation(rhs_vars, vars, d1, d2, advec);

    m_deriv.add_dissipation(i, j, k, rhs_vars, state, m_sigma);

    store_vars(rhs.cellData(i,j,k), rhs_vars);
}

template <class gauge_t, class deriv_t>
template <class data_t, template <typename> class vars_t,
          template <typename> class diff2_vars_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE
void CCZ4RHS<gauge_t, deriv_t>::rhs_equation(
    vars_t<data_t> &rhs, const vars_t<data_t> &vars,
    const vars_t<Tensor<1, data_t>> &d1,
    const diff2_vars_t<Tensor<2, data_t>> &d2,
    const vars_t<data_t> &advec) const
{
    using namespace TensorAlgebra;

    auto h_UU = compute_inverse_sym(vars.h);
    auto chris = compute_christoffel(d1.h, h_UU);

    Tensor<1, data_t> Z_over_chi;
    Tensor<1, data_t> Z;

    if (m_formulation == USE_BSSN)
    {
        FOR(i) Z_over_chi[i] = 0.0;
    }
    else
    {
        FOR(i) Z_over_chi[i] = 0.5 * (vars.Gamma[i] - chris.contracted[i]);
    }
    FOR(i) Z[i] = vars.chi * Z_over_chi[i];

    auto ricci =
        CCZ4Geometry::compute_ricci_Z(vars, d1, d2, h_UU, chris, Z_over_chi);

    data_t divshift = compute_trace(d1.shift);
    data_t Z_dot_d1lapse = compute_dot_product(Z, d1.lapse);
    data_t dlapse_dot_dchi = compute_dot_product(d1.lapse, d1.chi, h_UU);

    Tensor<2, data_t> covdtilde2lapse;
    Tensor<2, data_t> covd2lapse;
    FOR(k, l)
    {
        covdtilde2lapse[k][l] = d2.lapse[k][l];
        FOR(m) { covdtilde2lapse[k][l] -= chris.ULL[m][k][l] * d1.lapse[m]; }
        covd2lapse[k][l] =
            vars.chi * covdtilde2lapse[k][l] +
            0.5 * (d1.lapse[k] * d1.chi[l] + d1.chi[k] * d1.lapse[l] -
                   vars.h[k][l] * dlapse_dot_dchi);
    }

    data_t tr_covd2lapse = -(GR_SPACEDIM / 2.0) * dlapse_dot_dchi;
    FOR(i)
    {
        tr_covd2lapse -= vars.chi * chris.contracted[i] * d1.lapse[i];
        FOR(j)
        {
            tr_covd2lapse += h_UU[i][j] * (vars.chi * d2.lapse[i][j] +
                                           d1.lapse[i] * d1.chi[j]);
        }
    }

    Tensor<2, data_t> A_UU = raise_all(vars.A, h_UU);

    // A^{ij} A_{ij}. - Note the abuse of the compute trace function.
    data_t tr_A2 = compute_trace(vars.A, A_UU);
    rhs.chi = advec.chi +
              (2.0 / GR_SPACEDIM) * vars.chi * (vars.lapse * vars.K - divshift);
    FOR(i, j)
    {
        rhs.h[i][j] = advec.h[i][j] - 2.0 * vars.lapse * vars.A[i][j] -
                      (2.0 / GR_SPACEDIM) * vars.h[i][j] * divshift;
        FOR(k)
        {
            rhs.h[i][j] +=
                vars.h[k][i] * d1.shift[k][j] + vars.h[k][j] * d1.shift[k][i];
        }
    }

    Tensor<2, data_t> Adot_TF;
    FOR(i, j)
    {
        Adot_TF[i][j] =
            -covd2lapse[i][j] + vars.chi * vars.lapse * ricci.LL[i][j];
    }
    make_trace_free(Adot_TF, vars.h, h_UU);

    FOR(i, j)
    {
        rhs.A[i][j] = advec.A[i][j] + Adot_TF[i][j] +
                      vars.A[i][j] * (vars.lapse * (vars.K - 2 * vars.Theta) -
                                      (2.0 / GR_SPACEDIM) * divshift);
        FOR(k)
        {
            rhs.A[i][j] +=
                vars.A[k][i] * d1.shift[k][j] + vars.A[k][j] * d1.shift[k][i];
            FOR(l)
            {
                rhs.A[i][j] -=
                    2 * vars.lapse * h_UU[k][l] * vars.A[i][k] * vars.A[l][j];
            }
        }
    }

    data_t kappa1_times_lapse;
    if (m_params.covariantZ4)
        kappa1_times_lapse = m_params.kappa1;
    else
        kappa1_times_lapse = m_params.kappa1 * vars.lapse;

    if (m_formulation == USE_BSSN)
    {
        rhs.Theta = 0; // ensure the Theta of CCZ4 remains at zero
        // Use hamiltonian constraint to remove ricci.scalar for BSSN update
        rhs.K = advec.K + vars.lapse * (tr_A2 + vars.K * vars.K / GR_SPACEDIM) -
                tr_covd2lapse;
        rhs.K += -2 * vars.lapse * m_cosmological_constant / (GR_SPACEDIM - 1.);
    }
    else
    {
        rhs.Theta =
            advec.Theta +
            0.5 * vars.lapse *
                (ricci.scalar - tr_A2 +
                 ((GR_SPACEDIM - 1.0) / (double)GR_SPACEDIM) * vars.K * vars.K -
                 2 * vars.Theta * vars.K) -
            0.5 * vars.Theta * kappa1_times_lapse *
                ((GR_SPACEDIM + 1) + m_params.kappa2 * (GR_SPACEDIM - 1)) -
            Z_dot_d1lapse;

        rhs.Theta += -vars.lapse * m_cosmological_constant;
        rhs.K =
            advec.K +
            vars.lapse * (ricci.scalar + vars.K * (vars.K - 2 * vars.Theta)) -
            kappa1_times_lapse * GR_SPACEDIM * (1 + m_params.kappa2) *
                vars.Theta -
            tr_covd2lapse;
        rhs.K += -2 * vars.lapse * GR_SPACEDIM / (GR_SPACEDIM - 1.) *
                 m_cosmological_constant;
    }

    Tensor<1, data_t> Gammadot;
    FOR(i)
    {
        Gammadot[i] = (2.0 / GR_SPACEDIM) *
                          (divshift * (chris.contracted[i] +
                                       2 * m_params.kappa3 * Z_over_chi[i]) -
                           2 * vars.lapse * vars.K * Z_over_chi[i]) -
                      2 * kappa1_times_lapse * Z_over_chi[i];
        FOR(j)
        {
            Gammadot[i] +=
                2 * h_UU[i][j] *
                    (vars.lapse * d1.Theta[j] - vars.Theta * d1.lapse[j]) -
                2 * A_UU[i][j] * d1.lapse[j] -
                vars.lapse * ((2 * (GR_SPACEDIM - 1.0) / (double)GR_SPACEDIM) *
                                  h_UU[i][j] * d1.K[j] +
                              GR_SPACEDIM * A_UU[i][j] * d1.chi[j] / vars.chi) -
                (chris.contracted[j] + 2 * m_params.kappa3 * Z_over_chi[j]) *
                    d1.shift[i][j];

            FOR(k)
            {
                Gammadot[i] +=
                    2 * vars.lapse * chris.ULL[i][j][k] * A_UU[j][k] +
                    h_UU[j][k] * d2.shift[i][j][k] +
                    ((GR_SPACEDIM - 2.0) / (double)GR_SPACEDIM) * h_UU[i][j] *
                        d2.shift[k][j][k];
            }
        }
    }

    FOR(i) { rhs.Gamma[i] = advec.Gamma[i] + Gammadot[i]; }

    m_gauge.rhs_gauge(rhs, vars, d1, d2, advec);
}
} // namespace Old

// NOLINTEND

#endif /* CCZ4RHS_FDF5A7A_IMPL_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/CCZ4RHSTest.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */
// Doctest header
#include "doctest.h"

// Test header
#include "CCZ4RHSTest.hpp"

// Common test headers
#include "InitialData.hpp"
#include "doctestCLIArgs.hpp"

// GRTeclyn headers
#include "CCZ4RHS.hpp"
#include "FourthOrderDerivatives.hpp"

// Old GRTeclyn headers for comparison
#include "CCZ4RHS-fdf5a7a.hpp"
#include "FourthOrderDerivatives-fdf5a7a.hpp"

// AMReX headers
#include "AMReX.H"
#include "AMReX_FArrayBox.H"

void run_ccz4_rhs_test()
{
    int amrex_argc    = doctest::cli_args.argc();
    char **amrex_argv = doctest::cli_args.argv();
    // NOLINTNEXTLINE(bugprone-casting-through-void) // Open MPI triggers this
    amrex::Initialize(amrex_argc, amrex_argv);
    {
        constexpr int num_cells  = 32;
        constexpr int num_ghosts = 3;
        constexpr double dx      = 0.5 / (num_cells - 1);

        amrex::Box box(
            amrex::IntVect(0, 0, 0),
            amrex::IntVect(num_cells - 1, num_cells - 1, num_cells - 1));

        amrex::Box ghosted_box = box;
        ghosted_box.grow(num_ghosts);

        amrex::FArrayBox in_fab{ghosted_box, NUM_CCZ4_VARS,
                                amrex::The_Managed_Arena()};

        const amrex::Array4<amrex::Real> &in_array = in_fab.array();
        amrex::ParallelFor(ghosted_box,
                           [=] AMREX_GPU_DEVICE(int i, int j, int k)
                           {
                               const amrex::IntVect iv{i, j, k};
                               const amrex::RealVect coords =
                                   amrex::RealVect{iv} * dx;

                               random_ccz4_initial_data(iv, in_array, coords);
                           });

        CCZ4_params_t<MovingPunctureGauge::params_t> current_ccz4_params;
        current_ccz4_params.kappa1            = 0.1;
        current_ccz4_params.kappa2            = 0;
        current_ccz4_params.kappa3            = 1;
        current_ccz4_params.covariantZ4       = true;
        current_ccz4_params.lapse_advec_coeff = 0.0;
        current_ccz4_params.lapse_power       = 1.0;
        current_ccz4_params.lapse_coeff       = 2.0;
        current_ccz4_params.shift_Gamma_coeff = 0.75;
        current_ccz4_params.shift_advec_coeff = 0;
        current_ccz4_params.eta               = 1.82;

        Old::CCZ4_params_t<Old::MovingPunctureGauge::params_t> old_ccz4_params;
        old_ccz4_params.kappa1      = current_ccz4_params.kappa1;
        old_ccz4_params.kappa2      = current_ccz4_params.kappa2;
        old_ccz4_params.kappa3      = current_ccz4_params.kappa3;
        old_ccz4_params.covariantZ4 = current_ccz4_params.covariantZ4;
        old_ccz4_params.lapse_advec_coeff =
            current_ccz4_params.lapse_advec_coeff;
        old_ccz4_params.lapse_power = current_ccz4_params.lapse_power;
        old_ccz4_params.lapse_coeff = current_ccz4_params.lapse_coeff;
        old_ccz4_params.shift_Gamma_coeff =
            current_ccz4_params.shift_Gamma_coeff;
        old_ccz4_params.shift_advec_coeff =
            current_ccz4_params.shift_advec_coeff;
        old_ccz4_params.eta = current_ccz4_params.eta;

        amrex::Real sigma = 0.3;

        CCZ4RHS<MovingPunctureGauge, FourthOrderDerivatives> current_ccz4_rhs{
            current_ccz4_params, dx, sigma};

        Old::CCZ4RHS<Old::MovingPunctureGauge, Old::FourthOrderDerivatives>
            old_ccz4_rhs{old_ccz4_params, dx, sigma};

        amrex::FArrayBox current_out_fab{box, NUM_CCZ4_VARS,
                                         amrex::The_Managed_Arena()};
        amrex::FArrayBox old_out_fab{box, NUM_CCZ4_VARS,
                                     amrex::The_Managed_Arena()};
        amrex::FArrayBox diff_fab{box, NUM_CCZ4_VARS,
                                  amrex::The_Managed_Arena()};

        const auto &in_c_array        = in_fab.const_array();
        const auto &current_out_array = current_out_fab.array();
        const auto &old_out_array     = old_out_fab.array();
        const auto &diff_array        = diff_fab.array();

        // Do the current and old CCZ4RHS calculation in the same loop
        amrex::ParallelFor(
            box,
            [=] AMREX_GPU_DEVICE(int i, int j, int k)
            {
                current_ccz4_rhs.compute(i, j, k, current_out_array,
                                         in_c_array);
                old_ccz4_rhs.compute(i, j, k, old_out_array, in_c_array);

                for (int ivar = 0; ivar < NUM_CCZ4_VARS; ++ivar)
                {
                    diff_array(i, j, k, ivar) =
                        std::fabs(current_out_array(i, j, k, ivar) -
                                  old_out_array(i, j, k, ivar));
                }
            });

        // GPU barrier
        amrex::Gpu::streamSynchronize();

        amrex::Real max_diff = 0.0;
        amrex::IntVect max_diff_index{};

        const int cout_precision = 17;
        for (int ivar = 0; ivar < NUM_CCZ4_VARS; ++ivar)
        {
            diff_fab.maxIndex<amrex::RunOn::Device>(box, max_diff,
                                                    max_diff_index, ivar);

            INFO("Max diff for var " << StateVariables::names[ivar] << ": "
                                     << std::setprecision(cout_precision)
                                     << max_diff << " at " << max_diff_index);
            INFO("Old value: " << std::setprecision(cout_precision)
                               << old_out_array(max_diff_index, ivar)
                               << ", Current value: "
                               << current_out_array(max_diff_index, ivar));
            CHECK(max_diff == doctest::Approx(0.0).epsilon(1e-12));
        }

        // GPU barrier
        amrex::Gpu::streamSynchronize();
    }
    amrex::Finalize();
}



================================================
FILE: Tests/CCZ4RHSTest/CCZ4RHSTest.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */
#ifndef CCZ4RHSTEST_HPP_
#define CCZ4RHSTEST_HPP_

void run_ccz4_rhs_test();

#endif /* CCZ4RHSTEST_HPP_ */


================================================
FILE: Tests/CCZ4RHSTest/CCZ4Vars-fdf5a7a.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef CCZ4VARS_FDF5A7A_HPP_
#define CCZ4VARS_FDF5A7A_HPP_

// clang-format off
// NOLINTBEGIN

#include "ADMConformalVars-fdf5a7a.hpp"
#include "BSSNVars-fdf5a7a.hpp"
#include "Tensor-fdf5a7a.hpp"
#include "VarsTools-fdf5a7a.hpp"

// Namespace to avoid conflicts with current code
namespace Old
{
/// Namespace for CCZ4 vars
/** The structs in this namespace collect all the CCZ4 variables. It's main use
 *  is to make a local, nicely laid-out, copy of the CCZ4 variables for the
 *  current grid cell (Otherwise, this data would only exist on the grid in
 *  the huge, flattened Chombo array). \sa {CCZ4Vars, ADMConformalVars}
 **/
namespace CCZ4Vars
{
/// Vars object for CCZ4 vars, including gauge vars
template <class data_t>
struct VarsNoGauge : public BSSNVars::VarsNoGauge<data_t>
{
    data_t Theta; //!< CCZ4 quantity associated to Hamiltonian constraint

    /// Defines the mapping between members of Vars and Chombo grid
    /// variables (enum in User_Variables)
    template <typename mapping_function_t>
    AMREX_GPU_DEVICE
    void enum_mapping(mapping_function_t mapping_function)
    {
        using namespace VarsTools; // define_enum_mapping is part of VarsTools
        BSSNVars::VarsNoGauge<data_t>::enum_mapping(mapping_function);
        define_enum_mapping(mapping_function, c_Theta, Theta);
    }
};

/// Vars object for CCZ4 vars, including gauge vars
template <class data_t>
struct VarsWithGauge : public BSSNVars::VarsWithGauge<data_t>
{
    data_t Theta; //!< CCZ4 quantity associated to hamiltonian constraint

    /// Defines the mapping between members of Vars and Chombo grid
    /// variables (enum in User_Variables)
    template <typename mapping_function_t>
    AMREX_GPU_DEVICE
    void enum_mapping(mapping_function_t mapping_function)
    {
        using namespace VarsTools; // define_enum_mapping is part of VarsTools
        BSSNVars::VarsWithGauge<data_t>::enum_mapping(mapping_function);
        define_enum_mapping(mapping_function, c_Theta, Theta);
    }
};

/// Vars object for CCZ4 vars needing second derivs, excluding gauge vars
template <class data_t>
struct Diff2VarsNoGauge : public ADMConformalVars::Diff2VarsNoGauge<data_t>
{
};

/// Vars object for CCZ4 vars needing second derivs, including gauge vars
template <class data_t>
struct Diff2VarsWithGauge : public ADMConformalVars::Diff2VarsWithGauge<data_t>
{
};
} // namespace CCZ4Vars
} // namespace Old

// NOLINTEND

#endif /* CCZ4VARS_FDF5A7A_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/Cell-fdf5a7a.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef CELL_FDF5A7A_HPP_
#define CELL_FDF5A7A_HPP_

// clang-format off
// NOLINTBEGIN

#include <AMReX_Array4.H>

using namespace amrex::disabled;

// Namespace to avoid conflicts with current code
namespace Old
{
template <template <typename> class vars_t, class data_t>
AMREX_GPU_DEVICE void store_vars(amrex::CellData<data_t> const &cell,
                                 vars_t<data_t> &vars)
{
    vars.enum_mapping([&](const int &ivar, data_t const &var)
                      { cell[ivar] = var; });
}

template <template <typename> class vars_t, class data_t>
AMREX_GPU_DEVICE void load_vars(amrex::CellData<data_t> const &cell,
                                vars_t<std::remove_const_t<data_t>> &vars)
{
    vars.enum_mapping([&](const int &ivar, std::remove_const_t<data_t> &var)
                      { var = cell[ivar]; });
}

template <template <typename> class vars_t, class data_t>
AMREX_GPU_DEVICE auto load_vars(amrex::CellData<data_t> const &cell)
{
    vars_t<std::remove_const_t<data_t>> vars;
    load_vars(cell, vars);
    return vars;
}
} // namespace Old

// NOLINTEND

#endif /* CELL_FDF5A7A_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/FourthOrderDerivatives-fdf5a7a.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef FOURTHORDERDERIVATIVES_FDF5A7A_HPP_
#define FOURTHORDERDERIVATIVES_FDF5A7A_HPP_

// clang-format off
// NOLINTBEGIN

#include "Cell-fdf5a7a.hpp"
#include "DimensionDefinitions.hpp"
#include "Tensor-fdf5a7a.hpp"
#include "StateVariables.hpp"
#include "simd.hpp"
#include <array>

// Namespace to avoid conflicts with current code
namespace Old
{
class FourthOrderDerivatives
{
  public:
    const double m_dx;

  private:
    const double m_one_over_dx;
    const double m_one_over_dx2;

  public:
    FourthOrderDerivatives(double dx)
        : m_dx(dx), m_one_over_dx(1 / dx), m_one_over_dx2(1 / (dx * dx))
    {
    }

    template <class data_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE data_t diff1(const double *in_ptr,
                                                     const int idx,
                                                     const int stride) const
    {
        auto in = SIMDIFY<data_t>(in_ptr);

        data_t weight_far  = 8.33333333333333333333e-2;
        data_t weight_near = 6.66666666666666666667e-1;

        // NOTE: if you have been sent here by the debugger because of
        // EXC_BAD_ACCESS  or something similar you might be trying to take
        // derivatives without ghost points.
        return (weight_far * in[idx - 2 * stride] -
                weight_near * in[idx - stride] +
                weight_near * in[idx + stride] -
                weight_far * in[idx + 2 * stride]) *
               m_one_over_dx;
    }

    /// Calculates all first derivatives and returns as variable type specified
    /// by the template parameter
    template <template <typename> class vars_t, class data_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE auto
    diff1(int i, int j, int k, const amrex::Array4<data_t const> &state) const
    {
        vars_t<Tensor<1, data_t>> d1;
        auto p = state.ptr(i, j, k);
        d1.enum_mapping(
            [&](const int &ivar, Tensor<1, data_t> &var)
            {
                AMREX_D_TERM(
                    var[0] = diff1<data_t>(p + ivar * state.nstride, 0, 1);
                    , var[1] = diff1<data_t>(p + ivar * state.nstride, 0,
                                             static_cast<int>(state.jstride));
                    , var[2] = diff1<data_t>(p + ivar * state.nstride, 0,
                                             static_cast<int>(state.kstride)));
            });
        return d1;
    }

    template <class data_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE data_t diff2(const double *in_ptr,
                                                     const int idx,
                                                     const int stride) const
    {
        auto in = SIMDIFY<data_t>(in_ptr);

        data_t weight_far   = 8.33333333333333333333e-2;
        data_t weight_near  = 1.33333333333333333333e+0;
        data_t weight_local = 2.50000000000000000000e+0;

        return (-weight_far * in[idx - 2 * stride] +
                weight_near * in[idx - stride] - weight_local * in[idx] +
                weight_near * in[idx + stride] -
                weight_far * in[idx + 2 * stride]) *
               m_one_over_dx2;
    }

    template <class data_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE data_t
    mixed_diff2(const double *in_ptr, const int idx, const int stride1,
                const int stride2) const
    {
        auto in = SIMDIFY<data_t>(in_ptr);

        data_t weight_far_far   = 6.94444444444444444444e-3;
        data_t weight_near_far  = 5.55555555555555555556e-2;
        data_t weight_near_near = 4.44444444444444444444e-1;

        return (weight_far_far * in[idx - 2 * stride1 - 2 * stride2] -
                weight_near_far * in[idx - 2 * stride1 - stride2] +
                weight_near_far * in[idx - 2 * stride1 + stride2] -
                weight_far_far * in[idx - 2 * stride1 + 2 * stride2]

                - weight_near_far * in[idx - stride1 - 2 * stride2] +
                weight_near_near * in[idx - stride1 - stride2] -
                weight_near_near * in[idx - stride1 + stride2] +
                weight_near_far * in[idx - stride1 + 2 * stride2]

                + weight_near_far * in[idx + stride1 - 2 * stride2] -
                weight_near_near * in[idx + stride1 - stride2] +
                weight_near_near * in[idx + stride1 + stride2] -
                weight_near_far * in[idx + stride1 + 2 * stride2]

                - weight_far_far * in[idx + 2 * stride1 - 2 * stride2] +
                weight_near_far * in[idx + 2 * stride1 - stride2] -
                weight_near_far * in[idx + 2 * stride1 + stride2] +
                weight_far_far * in[idx + 2 * stride1 + 2 * stride2]) *
               m_one_over_dx2;
    }

    /// Calculates all second derivatives and returns as variable type specified
    /// by the template parameter
    template <template <typename> class vars_t, class data_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE auto
    diff2(int i, int j, int k, amrex::Array4<data_t const> const &state) const
    {
        vars_t<Tensor<2, data_t>> d2;
        auto p = state.ptr(i, j, k);
        amrex::GpuArray<int, AMREX_SPACEDIM> strides{
            1, static_cast<int>(state.jstride),
            static_cast<int>(state.kstride)};
        d2.enum_mapping(
            [&](const int &ivar, Tensor<2, data_t> &var)
            {
                auto pvar = p + ivar * state.nstride;
                FOR (dir1) // First calculate the repeated derivatives
                {
                    var[dir1][dir1] = diff2<data_t>(pvar, 0, strides[dir1]);
                    for (int dir2 = 0; dir2 < dir1; ++dir2)
                    {
                        auto tmp = mixed_diff2<data_t>(pvar, 0, strides[dir1],
                                                       strides[dir2]);
                        var[dir1][dir2] = tmp;
                        var[dir2][dir1] = tmp;
                    }
                }
            });
        return d2;
    }

  protected: // Let's keep this protected ... we may want to change the
             // advection calculation
    template <class data_t, class mask_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE data_t
    advection_term(const double *in_ptr, const int idx, const data_t &vec_comp,
                   const int stride, const mask_t shift_positive) const
    {
        const auto in          = SIMDIFY<data_t>(in_ptr);
        const data_t in_left   = in[idx - stride];
        const data_t in_centre = in[idx];
        const data_t in_right  = in[idx + stride];

        data_t weight_0 = -2.50000000000000000000e-1;
        data_t weight_1 = -8.33333333333333333333e-1;
        data_t weight_2 = +1.50000000000000000000e+0;
        data_t weight_3 = -5.00000000000000000000e-1;
        data_t weight_4 = +8.33333333333333333333e-2;

        data_t upwind;
        upwind = vec_comp *
                 (weight_0 * in_left + weight_1 * in_centre +
                  weight_2 * in_right + weight_3 * in[idx + 2 * stride] +
                  weight_4 * in[idx + 3 * stride]) *
                 m_one_over_dx;

        data_t downwind;
        downwind = vec_comp *
                   (-weight_4 * in[idx - 3 * stride] -
                    weight_3 * in[idx - 2 * stride] - weight_2 * in_left -
                    weight_1 * in_centre - weight_0 * in_right) *
                   m_one_over_dx;

        return simd_conditional(shift_positive, upwind, downwind);
    }

  public:

    /// Calculates all second derivatives and returns as variable type specified
    /// by the template parameter
    template <template <typename> class vars_t, class data_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE auto
    advection(int i, int j, int k, amrex::Array4<data_t const> const &state,
              const Tensor<1, data_t> &vector) const
    {
        vars_t<data_t> advec;
        auto p = state.ptr(i, j, k);
        amrex::GpuArray<int, AMREX_SPACEDIM> strides{
            1, static_cast<int>(state.jstride),
            static_cast<int>(state.kstride)};
        advec.enum_mapping(
            [&](const int &ivar, data_t &var)
            {
                var       = 0.;
                auto pvar = p + ivar * state.nstride;
                FOR (dir)
                {
                    const auto shift_positive =
                        simd_compare_gt(vector[dir], 0.0);
                    var += advection_term(pvar, 0, vector[dir], strides[dir],
                                          shift_positive);
                }
            });
        return advec;
    }

    template <class data_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE data_t dissipation_term(
        const double *in_ptr, const int idx, const int stride) const
    {
        const auto in       = SIMDIFY<data_t>(in_ptr);
        data_t weight_vfar  = 1.56250e-2;
        data_t weight_far   = 9.37500e-2;
        data_t weight_near  = 2.34375e-1;
        data_t weight_local = 3.12500e-1;

        return (weight_vfar * in[idx - 3 * stride] -
                weight_far * in[idx - 2 * stride] +
                weight_near * in[idx - stride] - weight_local * in[idx] +
                weight_near * in[idx + stride] -
                weight_far * in[idx + 2 * stride] +
                weight_vfar * in[idx + 3 * stride]) *
               m_one_over_dx;
    }

    template <class data_t, template <typename> class vars_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
    add_dissipation(int i, int j, int k, vars_t<data_t> &vars,
                    amrex::Array4<data_t const> const &state,
                    const double factor) const
    {
        auto p = state.ptr(i, j, k);
        amrex::GpuArray<int, AMREX_SPACEDIM> strides{
            1, static_cast<int>(state.jstride),
            static_cast<int>(state.kstride)};
        vars.enum_mapping(
            [&](const int &ivar, data_t &var)
            {
                FOR (dir)
                {
                    const auto stride  = strides[dir];
                    var               += factor * dissipation_term<data_t>(
                                        p + ivar * state.nstride, 0, stride);
                }
            });
    }
};
} // namespace Old

// NOLINTEND

#endif /* FOURTHORDERDERIVATIVES_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/GRInterval-fdf5a7a.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef GRINTERVAL_FDF5A7A_HPP_
#define GRINTERVAL_FDF5A7A_HPP_

// clang-format off
// NOLINTBEGIN

// Namespace to avoid conflicts with current code
namespace Old
{
/// A templated version of Chombo's Interval - allows compile time checking.
/**Note: iend is included in the interval, i.e. the interval <1,3> has
 * values 1,2,3 and therefore size 3.
 */
template <int ibegin, int iend> struct GRInterval
{
    static constexpr int begin() { return ibegin; }

    /// The largest component contained in the interval
    static constexpr int end() { return iend; }

    /// Returns the size of the interval
    static constexpr int size() { return iend - ibegin + 1; }

    /// Checks whether a values is in the interval (Note: the end component is
    /// also contained)
    static constexpr bool contains(int i)
    {
        return ((i > ibegin) && (i <= iend));
    }
};
} // namespace Old

// NOLINTEND

#endif /* GRINTERVAL_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/Make.package
================================================
GRTECLYN_CEXE_headers += InitialData.hpp \
                         ADMConformalVars-fdf5a7a.hpp \
                         BSSNVars-fdf5a7a.hpp \
                         CCZ4Geometry-fdf5a7a.hpp \
                         CCZ4RHS-fdf5a7a.hpp \
                         CCZ4RHS-fdf5a7a.impl.hpp \
                         CCZ4Vars-fdf5a7a.hpp \
                         Cell-fdf5a7a.hpp \
                         FourthOrderDerivatives-fdf5a7a.hpp \
                         GRInterval-fdf5a7a.hpp \
                         MovingPunctureGauge-fdf5a7a.hpp \
                         Tensor-fdf5a7a.hpp \
                         TensorAlgebra-fdf5a7a.hpp \
                         VarsTools-fdf5a7a.hpp \
                         simd.hpp \
                         simdify.hpp \
                         simd_base.hpp \
                         CCZ4RHSTest.hpp

GRTECLYN_CEXE_sources += CCZ4RHSTest.cpp



================================================
FILE: Tests/CCZ4RHSTest/MovingPunctureGauge-fdf5a7a.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef MOVINGPUNCTUREGAUGE_FDF5A7A_HPP_
#define MOVINGPUNCTUREGAUGE_FDF5A7A_HPP_

// clang-format off
// NOLINTBEGIN

#include "DimensionDefinitions.hpp"
#include "Tensor-fdf5a7a.hpp"

// Namespace to avoid conflicts with current code
namespace Old
{
/// This is an example of a gauge class that can be used in the CCZ4RHS compute
/// class
/**
 * This class implements a slightly more generic version of the moving puncture
 * gauge. In particular it uses a Bona-Masso slicing condition of the form
 * f(lapse) = -c*lapse^(p-2)
 * and a Gamma-driver shift condition
 **/
class MovingPunctureGauge
{
  public:
    struct params_t
    {
        // lapse params:
        double lapse_advec_coeff = 0.; //!< Switches advection terms in
                                       //! the lapse condition on/off
        double lapse_power = 1.; //!< The power p in \f$\partial_t \alpha = - c
                                 //!\alpha^p(K-2\Theta)\f$
        double lapse_coeff = 2.; //!< The coefficient c in \f$\partial_t \alpha
                                 //!= -c \alpha^p(K-2\Theta)\f$
        // shift params:
        double shift_Gamma_coeff = 0.75; //!< Gives the F in \f$\partial_t
                                         //!  \beta^i =  F B^i\f$
        double shift_advec_coeff = 0.;   //!< Switches advection terms in the
                                         //! shift condition on/off
        double eta = 1.; //!< The eta in \f$\partial_t B^i = \partial_t \tilde
                         //!\Gamma - \eta B^i\f$
    };

  protected:
    params_t m_params;

  public:
    MovingPunctureGauge(const params_t &a_params) : m_params(a_params) {}

    template <class data_t, template <typename> class vars_t,
              template <typename> class diff2_vars_t>
    AMREX_GPU_DEVICE AMREX_FORCE_INLINE
    void rhs_gauge(vars_t<data_t> &rhs, const vars_t<data_t> &vars,
                   const vars_t<Tensor<1, data_t>> &d1,
                   const diff2_vars_t<Tensor<2, data_t>> &d2,
                   const vars_t<data_t> &advec) const
    {
        rhs.lapse = m_params.lapse_advec_coeff * advec.lapse -
                    m_params.lapse_coeff *
                        pow(vars.lapse, m_params.lapse_power) *
                        (vars.K - 2 * vars.Theta);
        FOR(i)
        {
            rhs.shift[i] = m_params.shift_advec_coeff * advec.shift[i] +
                           m_params.shift_Gamma_coeff * vars.B[i];
            rhs.B[i] = m_params.shift_advec_coeff * advec.B[i] -
                       m_params.shift_advec_coeff * advec.Gamma[i] +
                       rhs.Gamma[i] - m_params.eta * vars.B[i];
        }
    }
};
} // namespace Old

// NOLINTEND

#endif /* MOVINGPUNCTUREGAUGE_FDF5A7A_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/simd.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SIMD_HPP_
#define SIMD_HPP_

// NOLINTBEGIN

// Other includes
#include "AlwaysInline.hpp"
#include <cmath>

// This struct can be used to switch between simd and non-simd versions of the
// same function by overloading
struct disable_simd
{
};

/// simd_traits holds information about the current simd usage
// This is the base template,i.e. the fallback for when there is no SIMD support
// for a data type. The fallback is to just not use simd. The datatypes that
// have simd support correspond to template specialisations, which are defined
// in the architecture-specific files and simd_base.hpp
template <typename t> struct simd_traits
{
    using data_t              = t;
    using mask_t              = bool;
    static const int simd_len = 1;
};

/// This class represents a "vector" for a vectorised architecture
// Base template type: fallback for when there is no SIMD support for a data
// type The fallback is to just not use simd. Hence, all the member function
// definitions of simd below are pretty trivial. The datatypes that have simd
// support correspond to template specialisations, which are defined in the
// architecture-specific files and simd_base.hpp
template <typename t> struct simd
{
    t m_value;

    constexpr simd() : m_value() {}

    constexpr simd(const t &x) : m_value(x) {}

    constexpr operator t &() { return m_value; }

    constexpr operator const t &() const { return m_value; }

    constexpr static simd load(const double *ptr) { return *ptr; }

    constexpr static void store(double *ptr, const simd &a)
    {
        *ptr = a.m_value;
    }

    constexpr simd &operator+=(const simd &a)
    {
        m_value += a.m_value;
        return *this;
    }
    constexpr simd &operator-=(const simd &a)
    {
        m_value -= a.m_value;
        return *this;
    }
    constexpr simd &operator*=(const simd &a)
    {
        m_value *= a.m_value;
        return *this;
    }
    constexpr simd &operator/=(const simd &a)
    {
        m_value /= a.m_value;
        return *this;
    }

    constexpr t operator[](int index) const { return m_value; }

    template <typename op_t> constexpr simd foreach (op_t op) const
    {
        return simd(op(m_value));
    }

    template <typename op_t> constexpr simd foreach (op_t op, t arg) const
    {
        return simd(op(m_value, arg));
    }
};

#include "simd_base.hpp" //Define all the simd-functions whose implementation does not depend on the architecture

#if defined(__x86_64__) && !defined(AMREX_USE_GPU)
#include "x64/x64.hpp" //Define simd-functions whose implementation depends on the architecture
#endif

// We have defined various simd-specific calls (simd_compare_lt,
// simd_compare_gt, min, max etc.)  For simd<t> these are defined in the various
// architecture-specific implementations.  Here, we make sure that the same
// function calls also work when simd is switched off. (e.g.
// simd_compare_lt(double, double) must work but needs to be implemented
template <typename t>
constexpr t simd_conditional(const bool cond, const t &true_value,
                             const t &false_value)
{
    return cond ? true_value : false_value;
}

template <typename t> constexpr bool simd_compare_lt(const t &a, const t &b)
{
    return a < b;
}

template <typename t> constexpr bool simd_compare_gt(const t &a, const t &b)
{
    return a > b;
}

template <typename t> constexpr t simd_min(const t &a, const t &b)
{
    return (a <= b) ? a : b;
}

template <typename t> constexpr t simd_max(const t &a, const t &b)
{
    return (a > b) ? a : b;
}
//<-- End: Defining the simd specific calls for non-simd datatypes.

#include "simdify.hpp"

// NOLINTEND

#endif /* SIMD_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/simd_base.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SIMD_BASE_HPP_
#define SIMD_BASE_HPP_

#if !defined(SIMD_HPP_)
#error "This file should only be included through simd.hpp"
#endif

// NOLINTBEGIN

#include <AMReX_Config.H>

#include <cmath>
#include <functional>
#include <iostream>
#include <type_traits>

// This file provides functionalities for simd<t> whose implementation is
// architecture independent.  Most importantly, all simd functions which have no
// associated vector intrinsics, e.g. calls like ostream operator <<,  are
// defined in the same way for all architectures and are, therefore, in this
// file.  A more subtle example:
//*= is an operator which has an architecture dependent vector intrinsic
// associated to it  and is, therefore, not defined in this file. However, the
// binary operation a*b can be rewritten  as { a *= b; return a; } for all
// architectures and, therefore, is defined in this file.
template <typename t> struct simd_base
{
    static const int simd_len = simd_traits<t>::simd_len;
    using simd_data_t         = typename simd_traits<t>::data_t;
    simd_data_t m_value;

    AMREX_FORCE_INLINE
    simd_base() : m_value() {}

    AMREX_FORCE_INLINE
    simd_base(const simd_data_t &x) : m_value(x) {}

    AMREX_FORCE_INLINE
    operator simd_data_t &() { return m_value; }

    AMREX_FORCE_INLINE
    operator const simd_data_t &() const { return m_value; }

    // Note: These binary ops allow us to write e.g. simd<double>+int
    // or 2*y etc. The "friend function" construction makes
    // sure that these non-member binary operations
    // are instantiated at the same time as simd<t>.
    // The alternative is to template
    // on the two operand types, however this gives rise to
    // ambiguity because we have defined
    // casts between t and simd<t>
    friend AMREX_FORCE_INLINE simd<t> operator+(const simd<t> &a,
                                                const simd<t> &b)
    {
        simd<t> out(a);
        out += b;
        return out;
    }

    friend AMREX_FORCE_INLINE simd<t> operator-(const simd<t> &a,
                                                const simd<t> &b)
    {
        simd<t> out(a);
        out -= b;
        return out;
    }

    friend AMREX_FORCE_INLINE simd<t> operator-(const simd<t> &a)
    {
        simd<t> out(0);
        out -= a;
        return out;
    }

    friend AMREX_FORCE_INLINE simd<t> operator*(const simd<t> &a,
                                                const simd<t> &b)
    {
        simd<t> out(a);
        out *= b;
        return out;
    }

    friend AMREX_FORCE_INLINE simd<t> operator/(const simd<t> &a,
                                                const simd<t> &b)
    {
        simd<t> out(a);
        out /= b;
        return out;
    }

    AMREX_FORCE_INLINE
    t operator[](int index) const { return m_value[index]; }

    template <typename op_t> AMREX_FORCE_INLINE simd<t> foreach (op_t op) const
    {
        t in_arr[simd_traits<t>::simd_len];
        t out_arr[simd_traits<t>::simd_len];
        simd<t>::store(in_arr, m_value);

#ifdef AMREX_USE_OMP
#pragma omp simd
#endif
        for (int i = 0; i < simd_traits<t>::simd_len; ++i)
        {
            out_arr[i] = op(in_arr[i]);
        }

        return simd<t>::load(out_arr);
    }

    template <typename op_t>
    AMREX_FORCE_INLINE simd<t> foreach (op_t op, simd<t> arg) const
    {
        t in_arr[simd_traits<t>::simd_len];
        t arg_arr[simd_traits<t>::simd_len];
        t out_arr[simd_traits<t>::simd_len];
        simd<t>::store(in_arr, m_value);
        simd<t>::store(arg_arr, arg);

#ifdef AMREX_USE_OMP
#pragma omp simd
#endif
        for (int i = 0; i < simd_traits<t>::simd_len; ++i)
        {
            out_arr[i] = op(in_arr[i], arg_arr[i]);
        }

        return simd<t>::load(out_arr);
    }
};

#define define_simd_overload(op)                                               \
    template <typename t> AMREX_FORCE_INLINE simd<t> op(const simd<t> &a)      \
    {                                                                          \
        return a.foreach (([&](t x) { return op(x); }));                       \
    }

#define define_binary_simd_overload(op)                                        \
    template <typename t>                                                      \
    AMREX_FORCE_INLINE simd<t> op(const simd<t> &a, const simd<t> &b)          \
    {                                                                          \
        return a.foreach (([&](t x, t arg) { return op(x, arg); }), b);        \
    }

/* Trascendental support:                               */
/* exp, sin, cos, log, sqrt, pow, tanh, tan, sinh, cosh */

define_simd_overload(exp) define_simd_overload(exp2) define_simd_overload(sin)
    define_simd_overload(cos) define_simd_overload(log)
        define_simd_overload(log2) define_simd_overload(sqrt)
            define_binary_simd_overload(pow) define_simd_overload(abs)
                define_simd_overload(tanh) define_simd_overload(tan)
                    define_simd_overload(sinh) define_simd_overload(cosh)
                        define_simd_overload(acos) define_simd_overload(asin)
                            define_simd_overload(atan)
                                define_binary_simd_overload(atan2)

    /* Extra pow overloads */
    template <typename t, typename t1>
    AMREX_FORCE_INLINE simd<t> pow(const simd<t> &a, const t1 b)
{
    simd<t> simd_b(b);
    return pow(a, simd_b);
}

/* Extra atan2 overloads */
template <typename t, typename t1>
AMREX_FORCE_INLINE simd<t> atan2(const t1 b, const simd<t> &a)
{
    simd<t> simd_b(b);
    return atan2(simd_b, a);
}

template <typename t>
AMREX_FORCE_INLINE std::ostream &operator<<(std::ostream &os,
                                            const simd<t> &in_simd)
{
    t in_arr[simd_traits<t>::simd_len];
    simd<t>::store(in_arr, in_simd);

    os << "( ";
    for (int i = 0; i < simd_traits<t>::simd_len; ++i)
    {
        os << in_simd[i] << " ";
    }
    os << ")";
    if (os.fail())
    {
        amrex::Abort("operator<<(std::ostream&,simd<t>&) failed");
    }
    return os;
}

// NOLINTEND

#endif /* SIMD_BASE_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/simdify.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SIMDIFY_HPP_
#define SIMDIFY_HPP_

#if !defined(SIMD_HPP_)
#error "This file should only be included through simd.hpp"
#endif

// NOLINTBEGIN

#include <type_traits>

/// This class is used to load simd<t> objects from a number (given by the simd
/// width) of t's
/** simd_proxy containts a pointer to the memory location from where the simd<t>
 * is to be loaded. It defines a conversion to simd<t>, which is a load (gather)
 * operation, and an operator =simd<t> which does the store (scatter).
 * Furthermore, several basic arithmetic operators are defined directly on the
 * simd_proxy so that we don't have to load, do the operation, and store back
 * again.
 */
template <typename data_t> struct simd_proxy
{
    using simd_t = simd<std::remove_cv_t<data_t>>;
    data_t *const m_ptr;

    ALWAYS_INLINE
    simd_proxy(data_t *a_ptr) : m_ptr(a_ptr) {}

    ALWAYS_INLINE
    data_t *operator&() const { return m_ptr; }

    ALWAYS_INLINE
    operator simd_t() const { return simd_t::load(m_ptr); }

    ALWAYS_INLINE
    simd_proxy &operator=(const simd_t &rhs)
    {
        simd_t::store(m_ptr, rhs);
        return *this;
    }

    /*ALWAYS_INLINE
    const simd_proxy& operator=(const simd_t& rhs) const
    {
        const_cast<simd_proxy&>(*this) = rhs;
    }*/

    // The operator definitions below are there just in case we want to do
    // arithmetic directly  with a simd_proxy object. e.g. if we write
    // 3*SIMDIFY<simd<t>>(ptr_t). The behaviour mimics what we  would get if we
    // loaded a simd<t> object, did the operation, and then stored it back to
    // the location that the  simd_proxy points to.
    ALWAYS_INLINE
    simd_t operator+(const simd_t &other)
    {
        return static_cast<simd_t>(*this) + other;
    }

    ALWAYS_INLINE
    simd_t operator-(const simd_t &other)
    {
        return static_cast<simd_t>(*this) - other;
    }

    ALWAYS_INLINE
    simd_t operator*(const simd_t &other)
    {
        return static_cast<simd_t>(*this) * other;
    }

    ALWAYS_INLINE
    simd_t operator/(const simd_t &other)
    {
        return static_cast<simd_t>(*this) / other;
    }

    friend ALWAYS_INLINE simd_t operator+(const simd_t &a, const simd_proxy &b)
    {
        return a + static_cast<simd_t>(b);
    }

    friend ALWAYS_INLINE simd_t operator-(const simd_t &a, const simd_proxy &b)
    {
        return a - static_cast<simd_t>(b);
    }

    friend ALWAYS_INLINE simd_t operator*(const simd_t &a, const simd_proxy &b)
    {
        return a * static_cast<simd_t>(b);
    }

    friend ALWAYS_INLINE simd_t operator/(const simd_t &a, const simd_proxy &b)
    {
        return a / static_cast<simd_t>(b);
    }

    ALWAYS_INLINE
    simd_proxy &operator+=(const simd_t &rhs)
    {
        (*this) = (*this) + rhs;
        return *this;
    }

    ALWAYS_INLINE
    simd_proxy &operator-=(const simd_t &rhs)
    {
        (*this) = (*this) - rhs;
        return *this;
    }

    ALWAYS_INLINE
    simd_proxy &operator*=(const simd_t &rhs)
    {
        (*this) = (*this) * rhs;
        return *this;
    }

    ALWAYS_INLINE
    simd_proxy &operator/=(const simd_t &rhs)
    {
        (*this) = (*this) / rhs;
        return *this;
    }
};

// This class can be viewed as an array but with special property that the
// dereferencing operator  and operator [] do not return an element (say type
// data_t) but a simd_proxy<data_t>. In practice,  this means that [i] doesn't
// give the ith element but a simd_proxy which can be used to load a  vector of
// simd width starting at the ith element.
template <typename data_t> struct simd_array_wrapper
{
    data_t *m_ptr;

    ALWAYS_INLINE
    simd_array_wrapper(data_t *a_ptr) : m_ptr(a_ptr) {}

    ALWAYS_INLINE
    simd_proxy<data_t> operator[](int i) const { return &m_ptr[i]; }

    ALWAYS_INLINE
    simd_proxy<data_t> operator*() const { return *this[0]; }
};

// Begin: structs that help create the return type of SIMDIFY and make sure it
// is only called on valid input types. -->

// If the first and second template parameter are the same then this struct will
// have a member of type  given by the third template parameter and called
// "type"
template <typename q1, typename q2, typename t> struct simd_enable_if_same
{
};
template <typename q, typename t> struct simd_enable_if_same<q, q, t>
{
    using type = t;
};

// This struct is used to create the right return types for the SIMDIFY function
template <typename t, typename ptr_t> struct simdify
{
    using type =
        typename simd_enable_if_same<t, std::remove_cv_t<ptr_t>, ptr_t *>::type;
};

template <typename t, typename ptr_t> struct simdify<simd<t>, ptr_t>
{
    using type = typename simd_enable_if_same<t, std::remove_cv_t<ptr_t>,
                                              simd_array_wrapper<ptr_t>>::type;
};
//<--End: structs that help create the return type of SIMDIFY and make sure it
// is only called on valid input types.

/// SIMDIFY<simd<base_t>>(ptr) is used to load simd data from an array of
/// base_t's pointed to by ptr.  SIMDIFY<t>(ptr) for t not a simd object just
/// returns the ptr.
/** The usage of SIMDIFY<simd<base_t>>(ptr) is as follows:
 * SIMDIY<simd<base_t>>(ptr) returns a simd_array_wrapper which, when supplied
 * with operator [i], yields a simd_proxy at the ith element in the array. This
 * simd_proxy can then be used to load a simd<base_t> object with data starting
 * at the ith position and with width given by the simd length.
 */
// Given SIMDIFY<t>(ptr_t) the return types are:
//- If t=ptr_t (up to const and volatile) and t not simd<base_t>: return type
// just ptr_t* - If t=simd<base_t> (up to const and volatile) where base_t =
// ptr_t: return type simd_array_wrapper<ptr_t> - Else: substitution failure
template <typename t, typename ptr_t>
AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE
    typename simdify<t, ptr_t>::type // See comments at _simdify for
                                     // explanation of return types
    SIMDIFY(ptr_t *ptr)
{
    return ptr;
}

// NOLINTEND

#endif /* SIMDIFY_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/Tensor-fdf5a7a.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef TENSOR_FDF5A7A_HPP_
#define TENSOR_FDF5A7A_HPP_

// clang-format off
// NOLINTBEGIN

#include "AlwaysInline.hpp"
#include "DimensionDefinitions.hpp"

// Namespace to avoid conflicts with current code
namespace Old
{
/// This class implements a Tensor with given rank, element data type, and
/// dimension.  By default the dimension is equal to DEFAULT_TENSOR_DIM.
template <int rank, class data_t, int size = DEFAULT_TENSOR_DIM> class Tensor
{
    template <int, class, int> friend class Tensor;
    typedef typename Tensor<rank - 1, data_t, size>::arr_t arr_t[size];
    arr_t arr;

  public:
    AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE constexpr Tensor() {}

    //    ALWAYS_INLINE
    //    Tensor(std::initializer_list<data_t> list) :
    //        arr (list)
    //    {}

    template <typename... T>
    AMREX_GPU_HOST_DEVICE Tensor(T... data) : arr{data...}
    {
    }

    constexpr operator arr_t &() { return arr; }

    constexpr operator const arr_t &() const { return arr; }
};

template <class data_t, int size> class Tensor<0, data_t, size>
{
    template <int, class, int> friend class Tensor;
    typedef data_t arr_t;
    arr_t arr;

  public:
    constexpr Tensor() {}

    constexpr Tensor(data_t val) : arr(val) {}

    constexpr operator arr_t &() { return arr; }

    constexpr operator const arr_t &() const { return arr; }
};
} // namespace Old

// NOLINTEND

#endif /* TENSOR_FDF5A7A_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/TensorAlgebra-fdf5a7a.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef TENSORALGEBRA_FDF5A7A_HPP_
#define TENSORALGEBRA_FDF5A7A_HPP_

// clang-format off
// NOLINTBEGIN

#include "AlwaysInline.hpp"
#include "DimensionDefinitions.hpp"
#include "Tensor-fdf5a7a.hpp"
#include <array>

// Namespace to avoid conflicts with current code
namespace Old
{
template <class data_t> struct chris_t
{
    Tensor<3, data_t> ULL;        //!< standard christoffel symbols
    Tensor<3, data_t> LLL;        //!< 3 lower indices
    Tensor<1, data_t> contracted; //!< contracted christoffel
};

namespace TensorAlgebra
{
/// Computes determinant of a symmetric 3x3 matrix
template <class data_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE data_t
compute_determinant_sym(const Tensor<2, data_t, 3> &matrix)
{
    data_t det = matrix[0][0] * matrix[1][1] * matrix[2][2] +
                 2 * matrix[0][1] * matrix[0][2] * matrix[1][2] -
                 matrix[0][0] * matrix[1][2] * matrix[1][2] -
                 matrix[1][1] * matrix[0][2] * matrix[0][2] -
                 matrix[2][2] * matrix[0][1] * matrix[0][1];

    return det;
}

/// Computes the determinant of a general 3x3 matrix.
/// Note: for a symmetric matrix use the simplified function
template <class data_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE data_t
compute_determinant(const Tensor<2, data_t, 3> &matrix)
{
    data_t det =
        matrix[0][0] *
            (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1]) -
        matrix[0][1] *
            (matrix[2][2] * matrix[1][0] - matrix[1][2] * matrix[2][0]) +
        matrix[0][2] *
            (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]);
    return det;
}

/// Computes the inverse of a symmetric 3x3 matrix directly.
template <class data_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE Tensor<2, data_t>
compute_inverse_sym(const Tensor<2, data_t, 3> &matrix)
{
    data_t deth         = compute_determinant_sym(matrix);
    data_t deth_inverse = 1. / deth;
    Tensor<2, data_t> h_UU;
    h_UU[0][0] = (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[1][2]) *
                 deth_inverse;
    h_UU[0][1] = (matrix[0][2] * matrix[1][2] - matrix[0][1] * matrix[2][2]) *
                 deth_inverse;
    h_UU[0][2] = (matrix[0][1] * matrix[1][2] - matrix[0][2] * matrix[1][1]) *
                 deth_inverse;
    h_UU[1][1] = (matrix[0][0] * matrix[2][2] - matrix[0][2] * matrix[0][2]) *
                 deth_inverse;
    h_UU[1][2] = (matrix[0][1] * matrix[0][2] - matrix[0][0] * matrix[1][2]) *
                 deth_inverse;
    h_UU[2][2] = (matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[0][1]) *
                 deth_inverse;
    h_UU[1][0] = h_UU[0][1];
    h_UU[2][0] = h_UU[0][2];
    h_UU[2][1] = h_UU[1][2];

    return h_UU;
}

/// Computes the inverse of a general 3x3 matrix.
/// Note: for a symmetric matrix use the simplified function
template <class data_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE Tensor<2, data_t>
compute_inverse(const Tensor<2, data_t, 3> &matrix)
{
    data_t deth         = compute_determinant(matrix);
    data_t deth_inverse = 1. / deth;
    Tensor<2, data_t> h_UU;
    h_UU[0][0] = (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1]) *
                 deth_inverse;
    h_UU[1][1] = (matrix[0][0] * matrix[2][2] - matrix[0][2] * matrix[2][0]) *
                 deth_inverse;
    h_UU[2][2] = (matrix[0][0] * matrix[1][1] - matrix[1][0] * matrix[0][1]) *
                 deth_inverse;
    h_UU[1][0] = (matrix[2][0] * matrix[1][2] - matrix[1][0] * matrix[2][2]) *
                 deth_inverse;
    h_UU[0][1] = (matrix[0][2] * matrix[2][1] - matrix[0][1] * matrix[2][2]) *
                 deth_inverse;
    h_UU[2][0] = (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]) *
                 deth_inverse;
    h_UU[0][2] = (matrix[0][1] * matrix[1][2] - matrix[1][1] * matrix[0][2]) *
                 deth_inverse;
    h_UU[2][1] = (matrix[0][1] * matrix[2][0] - matrix[0][0] * matrix[2][1]) *
                 deth_inverse;
    h_UU[1][2] = (matrix[1][0] * matrix[0][2] - matrix[0][0] * matrix[1][2]) *
                 deth_inverse;

    return h_UU;
}

/// Computes the trace of a 2-Tensor with lower indices given an inverse metric.
template <class data_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE data_t compute_trace(
    const Tensor<2, data_t> &tensor_LL, const Tensor<2, data_t> &inverse_metric)
{
    data_t trace = 0.;
    FOR (i, j)
    {
        trace += inverse_metric[i][j] * tensor_LL[i][j];
    }
    return trace;
}

/// Computes the trace of a 1,1 Tensor (a matrix) - no metric required.
template <class data_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE data_t
compute_trace(const Tensor<2, data_t> &tensor_UL)
{
    data_t trace = 0.;
    FOR (i)
        trace += tensor_UL[i][i];
    return trace;
}

template <class data_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE data_t
compute_trace(const Tensor<1, Tensor<1, data_t>> &tensor_UL)
{
    data_t trace = 0.;
    FOR (i)
        trace += tensor_UL[i][i];
    return trace;
}

/// Computes dot product of a vector and a covector (no metric required)
template <class data_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE data_t compute_dot_product(
    const Tensor<1, data_t> &vector_U, const Tensor<1, data_t> &covector_L)
{
    data_t dot_product = 0.;
    FOR (i)
        dot_product += vector_U[i] * covector_L[i];
    return dot_product;
}

/// Computes dot product of two covectors given an inverse metric or
/// the dot product of two vectors given a metric.
template <class data_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE data_t compute_dot_product(
    const Tensor<1, data_t> &covector1_L, const Tensor<1, data_t> &covector2_L,
    const Tensor<2, data_t> &inverse_metric)
{
    data_t dot_product = 0.;
    FOR (m, n)
    {
        dot_product += inverse_metric[m][n] * covector1_L[m] * covector2_L[n];
    }
    return dot_product;
}

/// Removes the trace of a 2-Tensor with lower indices given a metric and an
/// inverse metric.  Or a Tensor with upper indices given an inverse metric and
/// a metric.
template <class data_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
make_trace_free(Tensor<2, data_t> &tensor_LL, const Tensor<2, data_t> &metric,
                const Tensor<2, data_t> &inverse_metric)
{
    auto trace                  = compute_trace(tensor_LL, inverse_metric);
    double one_over_gr_spacedim = 1. / ((double)GR_SPACEDIM);
    FOR (i, j)
    {
        tensor_LL[i][j] -= one_over_gr_spacedim * metric[i][j] * trace;
    }
}

/// Makes a 2-Tensor symmetric
template <class data_t, int size>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
make_symmetric(Tensor<2, data_t, size> &tensor_LL)
{
    for (int i = 0; i < size; ++i)
    {
        for (int j = 0; j < i; ++j)
        {
            tensor_LL[i][j] = 0.5 * (tensor_LL[i][j] + tensor_LL[j][i]);
            tensor_LL[j][i] = tensor_LL[i][j];
        }
    }
}

/// Raises the index of a covector
template <class data_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE Tensor<1, data_t>
raise_all(const Tensor<1, data_t> &tensor_L,
          const Tensor<2, data_t> &inverse_metric)
{
    Tensor<1, data_t> tensor_U = 0.;
    FOR (i, j)
    {
        tensor_U[i] += inverse_metric[i][j] * tensor_L[j];
    }
    return tensor_U;
}

/// Raises the indices of a 2-Tensor
template <class data_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE Tensor<2, data_t>
raise_all(const Tensor<2, data_t> &tensor_LL,
          const Tensor<2, data_t> &inverse_metric)
{
    Tensor<2, data_t> tensor_UU = 0.;
    FOR (i, j, k, l)
    {
        tensor_UU[i][j] +=
            inverse_metric[i][k] * inverse_metric[j][l] * tensor_LL[k][l];
    }
    return tensor_UU;
}

/// Lowers the indices of a vector
/// Note: same functionality as raise; included to improve readibility
template <class data_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE Tensor<1, data_t>
lower_all(const Tensor<1, data_t> &tensor_U, const Tensor<2, data_t> &metric)
{ // The code for lowering is exactly the same as for raising
    return raise_all(tensor_U, metric);
}

/// Lowers the indices of a 2-Tensor
/// Note: same functionality as raise; included to improve readibility
template <class data_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE Tensor<2, data_t>
lower_all(const Tensor<2, data_t> &tensor_UU, const Tensor<2, data_t> &metric)
{ // The code for lowering is exactly the same as for raising
    return raise_all(tensor_UU, metric);
}

/// Computes the (i,j) component of the Kronecker delta
constexpr int delta(int i, int j) { return (i == j); }

/// Computes the levi-civita symbol (3D, NB, symbol, not the Tensor)
AMREX_GPU_DEVICE AMREX_FORCE_INLINE Tensor<3, double> epsilon()
{
    Tensor<3, double> epsilon = {0.};
    epsilon[0][1][2]          = 1.0;
    epsilon[1][2][0]          = 1.0;
    epsilon[2][0][1]          = 1.0;
    epsilon[0][2][1]          = -1.0;
    epsilon[2][1][0]          = -1.0;
    epsilon[1][0][2]          = -1.0;

    return epsilon;
}

/// Computes the levi-civita symbol (4D, NB, symbol, not the Tensor)
AMREX_GPU_DEVICE AMREX_FORCE_INLINE Tensor<4, double, 4> epsilon4D()
{
    Tensor<4, double, 4> epsilon4D = {0.0};
    epsilon4D[0][1][2][3]          = 1.0;
    epsilon4D[0][1][3][2]          = -1.0;
    epsilon4D[0][3][1][2]          = 1.0;
    epsilon4D[0][3][2][1]          = -1.0;
    epsilon4D[0][2][1][3]          = -1.0;
    epsilon4D[0][2][3][1]          = 1.0;

    epsilon4D[1][0][2][3] = -1.0;
    epsilon4D[1][2][0][3] = 1.0;
    epsilon4D[1][2][3][0] = -1.0;
    epsilon4D[1][3][2][0] = 1.0;
    epsilon4D[1][3][0][2] = -1.0;
    epsilon4D[1][0][3][2] = 1.0;

    epsilon4D[2][0][1][3] = 1.0;
    epsilon4D[2][0][3][1] = -1.0;
    epsilon4D[2][3][0][1] = 1.0;
    epsilon4D[2][3][1][0] = -1.0;
    epsilon4D[2][1][3][0] = 1.0;
    epsilon4D[2][1][0][3] = -1.0;

    epsilon4D[3][0][1][2] = -1.0;
    epsilon4D[3][1][0][2] = 1.0;
    epsilon4D[3][1][2][0] = -1.0;
    epsilon4D[3][2][1][0] = 1.0;
    epsilon4D[3][2][0][1] = -1.0;
    epsilon4D[3][0][2][1] = 1.0;

    return epsilon4D;
}

/// Computes the conformal christoffel symbol
template <class data_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE chris_t<data_t>
compute_christoffel(const Tensor<2, Tensor<1, data_t>> &d1_metric,
                    const Tensor<2, data_t> &h_UU)
{
    chris_t<data_t> out;

    FOR (i, j, k)
    {
        out.LLL[i][j][k] = 0.5 * (d1_metric[j][i][k] + d1_metric[k][i][j] -
                                  d1_metric[j][k][i]);
    }
    FOR (i, j, k)
    {
        out.ULL[i][j][k] = 0;
        FOR (l)
        {
            out.ULL[i][j][k] += h_UU[i][l] * out.LLL[l][j][k];
        }
    }
    FOR (i)
    {
        out.contracted[i] = 0;
        FOR (j, k)
        {
            out.contracted[i] += h_UU[j][k] * out.ULL[i][j][k];
        }
    }

    return out;
}

template <class data_t>
AMREX_GPU_DEVICE AMREX_FORCE_INLINE Tensor<3, data_t>
compute_phys_chris(const Tensor<1, data_t> &d1_chi, const data_t &vars_chi,
                   const Tensor<2, data_t> &vars_h,
                   const Tensor<2, data_t> &h_UU,
                   const Tensor<3, data_t> &chris_ULL)
{
    Tensor<3, data_t> chris_phys;
    FOR (i, j, k)
    {
        chris_phys[i][j][k] =
            chris_ULL[i][j][k] -
            0.5 / vars_chi *
                (delta(i, k) * d1_chi[j] + delta(i, j) * d1_chi[k]);
        FOR (m)
        {
            chris_phys[i][j][k] +=
                0.5 / vars_chi * vars_h[j][k] * h_UU[i][m] * d1_chi[m];
        }
    }
    return chris_phys;
}
} // namespace TensorAlgebra
} // namespace Old

// NOLINTEND

#endif /* TENSORALGEBRA_FDF5A7A_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/VarsTools-fdf5a7a.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef VARSTOOLS_FDF5A7A_HPP_
#define VARSTOOLS_FDF5A7A_HPP_

// clang-format off
// NOLINTBEGIN

// Our includes
#include "GRInterval-fdf5a7a.hpp"
#include "Tensor-fdf5a7a.hpp"
#include "StateVariables.hpp"

// Chombo includes
//#include "parstream.H" //Gives us amrex::Print()

// Namespace to avoid conflicts with current code
namespace Old
{
namespace VarsTools
{
template <typename mapping_function_t, typename data_t>
AMREX_GPU_DEVICE
void define_enum_mapping(mapping_function_t mapping_function, const int &ivar,
                         data_t &scalar)
{
    mapping_function(ivar, scalar);
}

template <typename mapping_function_t, typename data_t, int start_var,
          int end_var>
AMREX_GPU_DEVICE
void define_enum_mapping(mapping_function_t mapping_function,
                         const GRInterval<start_var, end_var> interval,
                         Tensor<1, data_t, end_var - start_var + 1> &tensor)
{
    for (int ivar = 0; ivar < interval.size(); ++ivar)
        mapping_function(start_var + ivar, tensor[ivar]);
}

template <typename mapping_function_t, typename data_t, int start_var,
          int end_var>
AMREX_GPU_DEVICE
void define_symmetric_enum_mapping(
    mapping_function_t mapping_function,
    const GRInterval<start_var, end_var> interval, Tensor<2, data_t> &tensor)
{
    static_assert(interval.size() ==
                      DEFAULT_TENSOR_DIM * (DEFAULT_TENSOR_DIM + 1) / 2,
                  "Interval has wrong size");
#if DEFAULT_TENSOR_DIM == 3
    mapping_function(start_var, tensor[0][0]);

    mapping_function(start_var + 1, tensor[0][1]);
    mapping_function(start_var + 1, tensor[1][0]);

    mapping_function(start_var + 2, tensor[0][2]);
    mapping_function(start_var + 2, tensor[2][0]);

    mapping_function(start_var + 3, tensor[1][1]);

    mapping_function(start_var + 4, tensor[1][2]);
    mapping_function(start_var + 4, tensor[2][1]);

    mapping_function(start_var + 5, tensor[2][2]);
#else
#error DEFAULT_TENSOR_DIM not equal to three not implemented yet...
#endif
}

//--> Begin: Helper for the assign function
template <class nested_template> struct strip_nested_template;

template <template <typename> class outermost_layer, class inner_part>
struct strip_nested_template<outermost_layer<inner_part>>
{
    using type = inner_part;
};
//<-- End: Helper for the assign function

/// Writes data directly into all variables
/**if this variables has multiple components (e.g. if it is an array of
 *derivatives) the data can be written directly into these components by
 *specifying an arbitrary number of icomps
 */
template <class vars_t, typename value_t>
AMREX_GPU_DEVICE
ALWAYS_INLINE void assign(vars_t &vars, const value_t &value)
{
    // The template magic below is needed to make sure that we can write
    // assign(vars, 0.)  and 0. gets correctly cast from double to simd<double>
    // if necessary.
    using data_t = typename strip_nested_template<vars_t>::type;
    vars.enum_mapping([&value](const int &ivar, data_t &var) {
        var = static_cast<data_t>(value);
    });
}

/// Prints all elements of the vars element with component names
/// (Very useful for debugging)
template <template <typename> class vars_t, typename data_t>
void print(const vars_t<data_t> &vars)
{
    vars.enum_mapping([](const int &ivar, data_t &var) {
        amrex::Print() << StateVariables::names[ivar] << ": " << var << "\n";
    });
}
} // namespace VarsTools
} // namespace Old

// NOLINTEND

#endif /* VARSTOOLS_FDF5A7A_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/x64/avx.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SIMD_AVX_HPP_
#define SIMD_AVX_HPP_

#if !defined(SIMD_X64_HPP_)
#error "This file should only be included through simd_x64.hpp"
#endif

#if defined(__AVX__)

// NOLINTBEGIN

#include <immintrin.h>

template <> struct simd_traits<double>
{
    typedef __m256d data_t;
    typedef __m256d mask_t;
    static const int simd_len = 4;
};

template <> struct simd_traits<float>
{
    typedef __m256 data_t;
    typedef __m256 mask_t;
    static const int simd_len = 8;
};

template <> struct simd<double> : public simd_base<double>
{
    typedef typename simd_traits<double>::data_t data_t;
    typedef typename simd_traits<double>::mask_t mask_t;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuninitialized"
    ALWAYS_INLINE
    simd() : simd_base<double>(_mm256_setzero_pd()) {}
#pragma GCC diagnostic pop

    ALWAYS_INLINE
    simd(const double &s) : simd_base<double>(_mm256_set1_pd(s)) {}

    ALWAYS_INLINE
    simd(const data_t &v) : simd_base<double>(v) {}

    ALWAYS_INLINE
    static simd load(const double *ptr) { return _mm256_loadu_pd(ptr); }

    ALWAYS_INLINE
    static void store(double *ptr, const simd &a)
    {
        _mm256_storeu_pd(ptr, a.m_value);
    }

    ALWAYS_INLINE
    simd &operator+=(const simd &a)
    {
        m_value = _mm256_add_pd(m_value, a.m_value);
        return *this;
    }

    ALWAYS_INLINE
    simd &operator-=(const simd &a)
    {
        m_value = _mm256_sub_pd(m_value, a.m_value);
        return *this;
    }

    ALWAYS_INLINE
    simd &operator*=(const simd &a)
    {
        m_value = _mm256_mul_pd(m_value, a.m_value);
        return *this;
    }

    ALWAYS_INLINE
    simd &operator/=(const simd &a)
    {
        m_value = _mm256_div_pd(m_value, a.m_value);
        return *this;
    }

    friend ALWAYS_INLINE simd simd_conditional(const mask_t cond,
                                               const simd &true_value,
                                               const simd &false_value)
    {
        return _mm256_blendv_pd(false_value, true_value, cond);
    }

    friend ALWAYS_INLINE mask_t simd_compare_lt(const simd &a, const simd &b)
    {
        return _mm256_cmp_pd(a, b, _CMP_LT_OQ);
    }

    friend ALWAYS_INLINE mask_t simd_compare_gt(const simd &a, const simd &b)
    {
        return _mm256_cmp_pd(a, b, _CMP_GT_OQ);
    }

    friend ALWAYS_INLINE simd simd_min(const simd &a, const simd &b)
    {
        return _mm256_min_pd(a, b);
    }

    friend ALWAYS_INLINE simd simd_max(const simd &a, const simd &b)
    {
        return _mm256_max_pd(a, b);
    }

    friend ALWAYS_INLINE simd simd_sqrt(const simd &a)
    {
        return _mm256_sqrt_pd(a);
    }
};

template <> struct simd<float> : public simd_base<float>
{
    typedef typename simd_traits<float>::data_t data_t;
    typedef typename simd_traits<float>::mask_t mask_t;

    ALWAYS_INLINE
    simd() : simd_base<float>(_mm256_setzero_ps()) {}

    ALWAYS_INLINE
    simd(const float &x) : simd_base<float>(_mm256_set1_ps(x)) {}

    ALWAYS_INLINE
    simd(const data_t &v) : simd_base<float>(v) {}

    ALWAYS_INLINE
    static simd load(const float *ptr) { return _mm256_loadu_ps(ptr); }

    ALWAYS_INLINE
    static void store(float *ptr, const simd &a)
    {
        _mm256_storeu_ps(ptr, a.m_value);
    }

    ALWAYS_INLINE
    simd &operator+=(const simd &a)
    {
        m_value = _mm256_add_ps(m_value, a);
        return *this;
    }

    ALWAYS_INLINE
    simd &operator-=(const simd &a)
    {
        m_value = _mm256_sub_ps(m_value, a);
        return *this;
    }

    ALWAYS_INLINE
    simd &operator*=(const simd &a)
    {
        m_value = _mm256_mul_ps(m_value, a);
        return *this;
    }

    ALWAYS_INLINE
    simd &operator/=(const simd &a)
    {
        m_value = _mm256_div_ps(m_value, a);
        return *this;
    }

    friend ALWAYS_INLINE simd simd_conditional(const mask_t cond,
                                               const simd &true_value,
                                               const simd &false_value)
    {
        return _mm256_blendv_ps(false_value, true_value, cond);
    }

    friend ALWAYS_INLINE mask_t simd_compare_lt(const simd &a, const simd &b)
    {
        return _mm256_cmp_ps(a, b, _CMP_LT_OQ);
    }

    friend ALWAYS_INLINE mask_t simd_compare_gt(const simd &a, const simd &b)
    {
        return _mm256_cmp_ps(a, b, _CMP_GT_OQ);
    }

    friend ALWAYS_INLINE simd simd_min(const simd &a, const simd &b)
    {
        return _mm256_min_ps(a, b);
    }

    friend ALWAYS_INLINE simd simd_max(const simd &a, const simd &b)
    {
        return _mm256_max_ps(a, b);
    }

    friend ALWAYS_INLINE simd simd_sqrt(const simd &a)
    {
        return _mm256_sqrt_ps(a);
    }
};

// NOLINTEND

#endif /* __AVX__ */

#endif /* SIMD_AVX_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/x64/avx512.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SIMD_AVX512_HPP_
#define SIMD_AVX512_HPP_

#if !defined(SIMD_X64_HPP_)
#error "This file should only be included through simd_x64.hpp"
#endif

#if defined(__AVX512F__)

// NOLINTBEGIN

#include <immintrin.h>

template <> struct simd_traits<double>
{
    typedef __m512d data_t;
    typedef __mmask8 mask_t;
    static const int simd_len = 8;
};

template <> struct simd_traits<float>
{
    typedef __m512 data_t;
    typedef __mmask16 mask_t;
    static const int simd_len = 16;
};

template <> struct simd<double> : public simd_base<double>
{
    typedef typename simd_traits<double>::data_t data_t;
    typedef typename simd_traits<double>::mask_t mask_t;

    ALWAYS_INLINE
    simd() : simd_base<double>(_mm512_setzero_pd()) {}

    ALWAYS_INLINE
    simd(double x) : simd_base<double>(_mm512_set1_pd(x)) {}

    ALWAYS_INLINE
    simd(const data_t &v) : simd_base<double>(v) {}

    ALWAYS_INLINE
    static simd load(const double *ptr) { return _mm512_loadu_pd(ptr); }

    ALWAYS_INLINE
    static void store(double *ptr, const simd &a)
    {
        _mm512_storeu_pd(ptr, a.m_value);
    }

    ALWAYS_INLINE
    simd &operator+=(const simd &a)
    {
        m_value = _mm512_add_pd(m_value, a.m_value);
        return *this;
    }
    ALWAYS_INLINE
    simd &operator-=(const simd &a)
    {
        m_value = _mm512_sub_pd(m_value, a.m_value);
        return *this;
    }
    ALWAYS_INLINE
    simd &operator*=(const simd &a)
    {
        m_value = _mm512_mul_pd(m_value, a.m_value);
        return *this;
    }
    ALWAYS_INLINE
    simd &operator/=(const simd &a)
    {
        m_value = _mm512_div_pd(m_value, a.m_value);
        return *this;
    }

    friend ALWAYS_INLINE simd simd_conditional(const mask_t cond,
                                               const simd &true_value,
                                               const simd &false_value)
    {
        return _mm512_mask_blend_pd(cond, false_value, true_value);
    }

    friend ALWAYS_INLINE mask_t simd_compare_lt(const simd &a, const simd &b)
    {
        return _mm512_cmp_pd_mask(a, b, _CMP_LT_OQ);
    }

    friend ALWAYS_INLINE mask_t simd_compare_gt(const simd &a, const simd &b)
    {
        return _mm512_cmp_pd_mask(a, b, _CMP_GT_OQ);
    }

    friend ALWAYS_INLINE simd simd_min(const simd &a, const simd &b)
    {
        return _mm512_min_pd(a, b);
    }

    friend ALWAYS_INLINE simd simd_max(const simd &a, const simd &b)
    {
        return _mm512_max_pd(a, b);
    }

#ifdef __AVX512ER__
    friend ALWAYS_INLINE simd exp2(const simd &a)
    {
        return _mm512_exp2a23_pd(a);
    }

#ifdef LOW_PRECISION
    // This approximation has really low precision. Leaving it here mostly for
    // reference
    friend ALWAYS_INLINE simd exp(const simd &a)
    {
        // e^x = 2^(x * log2 (e))
        return exp2(a * simd(1.44269504088896340736));
    }
#endif /* LOW_PRECISION */
#endif /* __AVX512ER__ */

    friend ALWAYS_INLINE simd sqrt(const simd &a) { return _mm512_sqrt_pd(a); }
};

template <> struct simd<float> : public simd_base<float>
{
    typedef typename simd_traits<float>::data_t data_t;
    typedef typename simd_traits<float>::mask_t mask_t;

    ALWAYS_INLINE
    simd() : simd_base<float>(_mm512_setzero_ps()) {}

    ALWAYS_INLINE
    simd(float x) : simd_base<float>(_mm512_set1_ps(x)) {}

    ALWAYS_INLINE
    simd(const data_t &v) : simd_base<float>(v) {}

    ALWAYS_INLINE
    static simd load(const float *ptr) { return _mm512_loadu_ps(ptr); }

    ALWAYS_INLINE
    static void store(float *ptr, const simd &a)
    {
        _mm512_storeu_ps(ptr, a.m_value);
    }

    ALWAYS_INLINE
    simd &operator+=(const simd &a)
    {
        m_value = _mm512_add_ps(m_value, a);
        return *this;
    }
    ALWAYS_INLINE
    simd &operator-=(const simd &a)
    {
        m_value = _mm512_sub_ps(m_value, a);
        return *this;
    }
    ALWAYS_INLINE
    simd &operator*=(const simd &a)
    {
        m_value = _mm512_mul_ps(m_value, a);
        return *this;
    }
    ALWAYS_INLINE
    simd &operator/=(const simd &a)
    {
        m_value = _mm512_div_ps(m_value, a);
        return *this;
    }

    friend ALWAYS_INLINE simd simd_conditional(const mask_t cond,
                                               const simd &true_value,
                                               const simd &false_value)
    {
        return _mm512_mask_blend_ps(cond, false_value, true_value);
    }

    friend ALWAYS_INLINE mask_t simd_compare_lt(const simd &a, const simd &b)
    {
        return _mm512_cmp_ps_mask(a, b, _CMP_LT_OQ);
    }

    friend ALWAYS_INLINE mask_t simd_compare_gt(const simd &a, const simd &b)
    {
        return _mm512_cmp_ps_mask(a, b, _CMP_GT_OQ);
    }

    friend ALWAYS_INLINE simd simd_min(const simd &a, const simd &b)
    {
        return _mm512_min_ps(a, b);
    }

    friend ALWAYS_INLINE simd simd_max(const simd &a, const simd &b)
    {
        return _mm512_max_ps(a, b);
    }

#ifdef __AVX512ER__
    friend ALWAYS_INLINE simd exp2(const simd &a)
    {
        return _mm512_exp2a23_ps(a);
    }

#ifdef LOW_PRECISION
    // This approximation has really low precision. Leaving it here mostly for
    // reference
    friend ALWAYS_INLINE simd exp(const simd &a)
    {
        // e^x = 2^(x * log2 (e))
        return exp2(a * simd(1.44269504088896340736f));
    }
#endif /* LOW_PRECISION */
#endif /* __AVX512ER */

    friend ALWAYS_INLINE simd sqrt(const simd &a) { return _mm512_sqrt_ps(a); }
};

// NOLINTEND

#endif /* __AVX512F__ */

#endif /* SIMD_AVX512_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/x64/sse.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SIMD_SSE_HPP_
#define SIMD_SSE_HPP_

#if !defined(SIMD_X64_HPP_)
#error "This file should only be included through simd_x64.hpp"
#endif

#if defined(__SSE2__)

// Need SSE4.1 for blendvpd, blendvps
#if defined(__SSE4_1__)
#include <smmintrin.h>
#else
#include <emmintrin.h>
#endif

// NOLINTBEGIN

template <> struct simd_traits<double>
{
    using data_t              = __m128d;
    using mask_t              = __m128d;
    static const int simd_len = 2;
};

template <> struct simd_traits<float>
{
    using data_t              = __m128;
    using mask_t              = __m128;
    static const int simd_len = 4;
};

template <> struct simd<double> : public simd_base<double>
{
    using data_t = typename simd_traits<double>::data_t;
    using mask_t = typename simd_traits<double>::mask_t;

    ALWAYS_INLINE
    simd() : simd_base<double>(_mm_setzero_pd()) {}

    ALWAYS_INLINE
    simd(const double &s) : simd_base<double>(_mm_set1_pd(s)) {}

    ALWAYS_INLINE
    simd(const data_t &v) : simd_base<double>(v) {}

    ALWAYS_INLINE
    static simd load(const double *ptr) { return _mm_loadu_pd(ptr); }

    ALWAYS_INLINE
    static void store(double *ptr, const simd &a)
    {
        _mm_storeu_pd(ptr, a.m_value);
    }

    ALWAYS_INLINE
    simd &operator+=(const simd &a)
    {
        m_value = _mm_add_pd(m_value, a.m_value);
        return *this;
    }

    ALWAYS_INLINE
    simd &operator-=(const simd &a)
    {
        m_value = _mm_sub_pd(m_value, a.m_value);
        return *this;
    }

    ALWAYS_INLINE
    simd &operator*=(const simd &a)
    {
        m_value = _mm_mul_pd(m_value, a.m_value);
        return *this;
    }

    ALWAYS_INLINE
    simd &operator/=(const simd &a)
    {
        m_value = _mm_div_pd(m_value, a.m_value);
        return *this;
    }

    friend ALWAYS_INLINE simd simd_conditional(const mask_t cond,
                                               const simd &true_value,
                                               const simd &false_value)
    {
#if defined(__SSE4_1__)
        return _mm_blendv_pd(false_value, true_value, cond);
#else
        double _cond[2];
        double _true[2];
        double _false[2];
        double _blend[2];
        _mm_storeu_pd(&_cond[0], cond);
        _mm_storeu_pd(&_true[0], true_value);
        _mm_storeu_pd(&_false[0], false_value);
        for (int i = 0; i < 2; ++i)
        {
            _blend[i] = _cond[i] != 0.0 ? _true[i] : _false[i];
        }
        return _mm_loadu_pd(&_blend[0]);
#endif
    }

    friend ALWAYS_INLINE mask_t simd_compare_lt(const simd &a, const simd &b)
    {
        return _mm_cmplt_pd(a, b);
    }

    friend ALWAYS_INLINE mask_t simd_compare_gt(const simd &a, const simd &b)
    {
        return _mm_cmpgt_pd(a, b);
    }

    friend ALWAYS_INLINE simd simd_min(const simd &a, const simd &b)
    {
        return _mm_min_pd(a, b);
    }

    friend ALWAYS_INLINE simd simd_max(const simd &a, const simd &b)
    {
        return _mm_max_pd(a, b);
    }

    friend ALWAYS_INLINE simd simd_sqrt(const simd &a)
    {
        return _mm_sqrt_pd(a);
    }
};

template <> struct simd<float> : public simd_base<float>
{
    using data_t = typename simd_traits<float>::data_t;
    using mask_t = typename simd_traits<float>::mask_t;

    ALWAYS_INLINE
    simd() : simd_base<float>(_mm_setzero_ps()) {}

    ALWAYS_INLINE
    simd(const float &x) : simd_base<float>(_mm_set1_ps(x)) {}

    ALWAYS_INLINE
    simd(const data_t &v) : simd_base<float>(v) {}

    ALWAYS_INLINE
    static simd load(const float *ptr) { return _mm_loadu_ps(ptr); }

    ALWAYS_INLINE
    static void store(float *ptr, const simd &a)
    {
        _mm_storeu_ps(ptr, a.m_value);
    }

    ALWAYS_INLINE
    simd &operator+=(const simd &a)
    {
        m_value = _mm_add_ps(m_value, a);
        return *this;
    }

    ALWAYS_INLINE
    simd &operator-=(const simd &a)
    {
        m_value = _mm_sub_ps(m_value, a);
        return *this;
    }

    ALWAYS_INLINE
    simd &operator*=(const simd &a)
    {
        m_value = _mm_mul_ps(m_value, a);
        return *this;
    }

    ALWAYS_INLINE
    simd &operator/=(const simd &a)
    {
        m_value = _mm_div_ps(m_value, a);
        return *this;
    }

    friend ALWAYS_INLINE simd simd_conditional(const mask_t cond,
                                               const simd &true_value,
                                               const simd &false_value)
    {
#if defined(__SSE4_1__)
        return _mm_blendv_ps(false_value, true_value, cond);
#else
        float _cond[4];
        float _true[4];
        float _false[4];
        float _blend[4];
        _mm_storeu_ps(&_cond[0], cond);
        _mm_storeu_ps(&_true[0], true_value);
        _mm_storeu_ps(&_false[0], false_value);
        for (int i = 0; i < 4; ++i)
        {
            _blend[i] = _cond[i] != 0.0F ? _true[i] : _false[i];
        }
        return _mm_loadu_ps(&_blend[0]);
#endif
    }

    friend ALWAYS_INLINE mask_t simd_compare_lt(const simd &a, const simd &b)
    {
        return _mm_cmplt_ps(a, b);
    }

    friend ALWAYS_INLINE mask_t simd_compare_gt(const simd &a, const simd &b)
    {
        return _mm_cmpgt_ps(a, b);
    }

    friend ALWAYS_INLINE simd simd_min(const simd &a, const simd &b)
    {
        return _mm_min_ps(a, b);
    }

    friend ALWAYS_INLINE simd simd_max(const simd &a, const simd &b)
    {
        return _mm_max_ps(a, b);
    }

    friend ALWAYS_INLINE simd simd_sqrt(const simd &a)
    {
        return _mm_sqrt_ps(a);
    }
};

// NOLINTEND

#endif /* __SSE2__ */

#endif /* SIMD_SSE_HPP_ */



================================================
FILE: Tests/CCZ4RHSTest/x64/x64.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SIMD_X64_HPP_
#define SIMD_X64_HPP_

#if !defined(SIMD_HPP_)
#error "This file should only be included through simd.hpp"
#endif

#if defined(__AVX512F__)

#include "avx512.hpp"

#elif defined(__AVX__)

#include "avx.hpp"

#elif defined(__SSE2__)

#include "sse.hpp"

#else

#error "SSE2 must not be disabled on the x86-64 platform"

#endif

#endif /* SIMD_X64_HPP_ */



================================================
FILE: Tests/Common/doctestCLIArgs.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */
#ifndef DOCTESTCLIARGS_HPP_
#define DOCTESTCLIARGS_HPP_

#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

namespace doctest
{

//! A class to remove prefixed doctest options from the command line args
class CLIArgs
{
    std::vector<char *> m_args_vec;

  public:
    void set(char **a_argv)
    {
        for (; *a_argv != nullptr; ++a_argv)
        {
            if (std::string(*a_argv).find("-dt-") == std::string::npos)
            {
                m_args_vec.push_back(*a_argv);
            }
        }
        m_args_vec.push_back(nullptr);
    }

    int argc() { return static_cast<int>(m_args_vec.size()) - 1; }
    char **argv() { return m_args_vec.data(); } // Note: non-const char **:

    //! Insert an argument at a specific index (e.g. to add a parameter file)
    void insert(int a_arg_index, char *a_arg)
    {
        // negative indexes start at the end but leave the terminating nullptr
        auto pos_it =
            (a_arg_index > 0) ? m_args_vec.begin() : m_args_vec.end() - 1;

        // make sure we're not going past the end of the vector
        a_arg_index = std::clamp(a_arg_index, -argc(), argc());

        pos_it += a_arg_index;

        m_args_vec.insert(pos_it, a_arg);
    }
};

// Unfortunately the following has to be global and non-const
// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
extern CLIArgs cli_args;
}; // namespace doctest

#endif /* DOCTESTCLIARGS_HPP_ */


================================================
FILE: Tests/Common/doctestOutput.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */
#ifndef DOCTESTOUTPUT_HPP_
#define DOCTESTOUTPUT_HPP_

// Doctest header
#include "doctest.h"

// AMReX includes
#include "AMReX_ccse-mpi.H"

// System includes
#include <fstream>
#include <iostream>

#ifdef BL_USE_MPI
namespace doctest
{
// Hide output from non-zero ranks when building with MPI
std::ostream &hide_output_from_non_zero_ranks(std::ostream &a_rank_zero_ostream)
{
    int mpi_initialized = 0;
    MPI_Initialized(&mpi_initialized);
    if (mpi_initialized == 0)
    {
        return a_rank_zero_ostream;
    }
    int rank = 0;
    // NOLINTNEXTLINE(bugprone-casting-through-void) // Open MPI triggers this
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    if (rank == 0)
    {
        return a_rank_zero_ostream;
    }
    static std::ofstream null_stream;
    if (!null_stream.is_open())
    {
        null_stream.open("/dev/null", std::ofstream::out | std::ofstream::app);
    }
    return null_stream;
}
} // namespace doctest
#endif

#endif /* DOCTESTOUTPUT_HPP_ */



================================================
FILE: Tests/Common/InitialData.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */
// Our headers
#include "DimensionDefinitions.hpp"
#include "StateVariables.hpp"

// AMReX headers
#include "AMReX_Array4.H"
#include "AMReX_IntVect.H"
#include "AMReX_REAL.H"
#include "AMReX_RealVect.H"

AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
random_ccz4_initial_data(const amrex::IntVect &a_iv,
                         const amrex::Array4<amrex::Real> &a_array,
                         const amrex::RealVect &a_coords)
{
    amrex::Real x = a_coords[0];
    amrex::Real y = a_coords[1];
    amrex::Real z = a_coords[2];

    // NOLINTBEGIN(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
    // NOLINTNEXTLINE(readability-identifier-length)
    amrex::Real g[3][3];
    amrex::Real g_UU[3][3];
    amrex::Real chi; // NOLINT(cppcoreguidelines-init-variables)
    {
        g[0][0] = 1.36778 + 2.39731 * x + 4.53541 * x * x +
                  19.9771 * x * y * y * y + 6.13801 * y * z + 5.65185 * z * z +
                  9.35842 * z * z * z * z;
        g[0][1] = -0.07646 - 0.48786 * x - 0.75098 * x * x -
                  1.73683 * x * y * y * y + 1.71676 * y * z + 1.03662 * z * z +
                  0.35630 * z * z * z * z;
        g[0][2] = -0.10083 + 0.12445 * x - 1.26649 * x * x -
                  1.95052 * x * y * y * y + 0.73091 * y * z - 1.49835 * z * z -
                  2.39024 * z * z * z * z;
        g[1][1] = 0.84072 + 2.31163 * x + 3.32275 * x * x +
                  15.1662 * x * y * y * y + 8.48730 * y * z + 3.05098 * z * z +
                  17.8448 * z * z * z * z;
        g[1][2] = -0.42495 - 0.33464 * x - 0.47012 * x * x -
                  7.38477 * x * y * y * y + 0.41896 * y * z - 1.36394 * z * z +
                  5.25894 * z * z * z * z;
        g[2][2] = 0.60995 + 1.30428 * x + 3.86237 * x * x +
                  22.7614 * x * y * y * y + 6.93818 * y * z + 4.39250 * z * z +
                  19.0244 * z * z * z * z;
        g[1][0] = g[0][1];
        g[2][0] = g[0][2];
        g[2][1] = g[1][2];

        const amrex::Real detg =
            g[0][0] * g[1][1] * g[2][2] + 2 * g[0][1] * g[0][2] * g[1][2] -
            g[0][0] * g[1][2] * g[1][2] - g[1][1] * g[0][2] * g[0][2] -
            g[2][2] * g[0][1] * g[0][1];
        g_UU[0][0] = (g[1][1] * g[2][2] - g[1][2] * g[1][2]) / detg;
        g_UU[0][1] = (g[0][2] * g[1][2] - g[0][1] * g[2][2]) / detg;
        g_UU[0][2] = (g[0][1] * g[1][2] - g[0][2] * g[1][1]) / detg;
        g_UU[1][1] = (g[0][0] * g[2][2] - g[0][2] * g[0][2]) / detg;
        g_UU[1][2] = (g[0][1] * g[0][2] - g[0][0] * g[1][2]) / detg;
        g_UU[2][2] = (g[0][0] * g[1][1] - g[0][1] * g[0][1]) / detg;
        g_UU[1][0] = g_UU[0][1];
        g_UU[2][0] = g_UU[0][2];
        g_UU[2][1] = g_UU[1][2];

        chi = std::pow(std::fabs(detg), -1.0 / GR_SPACEDIM);

        a_array(a_iv, c_chi) = chi;
        a_array(a_iv, c_h11) = chi * g[0][0];
        a_array(a_iv, c_h12) = chi * g[0][1];
        a_array(a_iv, c_h13) = chi * g[0][2];
        a_array(a_iv, c_h22) = chi * g[1][1];
        a_array(a_iv, c_h23) = chi * g[1][2];
        a_array(a_iv, c_h33) = chi * g[2][2];
    }

    {
        // NOLINTNEXTLINE(readability-identifier-length)
        amrex::Real K[3][3];
        K[0][0] = -0.16238 - 0.74295 * x + 0.51595 * x * x -
                  6.60239 * x * y * y * y - 0.76401 * y * z - 1.81131 * z * z -
                  3.88228 * z * z * z * z;
        K[0][1] = 0.15054 - 0.60088 * x - 0.15428 * x * x +
                  3.16779 * x * y * y * y - 2.00687 * y * z - 1.35442 * z * z -
                  0.67601 * z * z * z * z;
        K[0][2] = -0.02174 - 0.36243 * x + 0.81531 * x * x +
                  4.34918 * x * y * y * y + 0.90419 * y * z - 0.85088 * z * z -
                  6.45097 * z * z * z * z;
        K[1][1] = -0.47653 - 0.43889 * x + 0.87342 * x * x +
                  4.24684 * x * y * y * y + 0.26290 * y * z + 1.90095 * z * z +
                  3.69515 * z * z * z * z;
        K[1][2] = 0.37472 + 0.03657 * x - 0.10327 * x * x -
                  0.95744 * x * y * y * y - 1.20800 * y * z - 0.43064 * z * z -
                  0.25419 * z * z * z * z;
        K[2][2] = 0.34184 + 0.21495 * x - 0.73195 * x * x +
                  7.81626 * x * y * y * y + 2.48359 * y * z + 1.89657 * z * z -
                  4.10980 * z * z * z * z;
        K[1][0] = K[0][1];
        K[2][0] = K[0][2];
        K[2][1] = K[1][2];

        amrex::Real trK = 0;
        FOR (i, j)
        {
            trK += g_UU[i][j] * K[i][j];
        }

        a_array(a_iv, c_K)   = trK;
        a_array(a_iv, c_A11) = chi * (K[0][0] - trK * g[0][0] / GR_SPACEDIM);
        a_array(a_iv, c_A12) = chi * (K[0][1] - trK * g[0][1] / GR_SPACEDIM);
        a_array(a_iv, c_A13) = chi * (K[0][2] - trK * g[0][2] / GR_SPACEDIM);
        a_array(a_iv, c_A22) = chi * (K[1][1] - trK * g[1][1] / GR_SPACEDIM);
        a_array(a_iv, c_A23) = chi * (K[1][2] - trK * g[1][2] / GR_SPACEDIM);
        a_array(a_iv, c_A33) = chi * (K[2][2] - trK * g[2][2] / GR_SPACEDIM);
    }

    a_array(a_iv, c_Theta) = 0.27579 + 0.25791 * x + 1.40488 * x * x +
                             5.68276 * x * y * y * y + 3.04325 * y * z +
                             1.81250 * z * z + 1.01832 * z * z * z * z;
    a_array(a_iv, c_Gamma1) = -0.49482 + 0.89227 * x + 0.05571 * x * x -
                              5.38570 * x * y * y * y + 0.13979 * y * z -
                              0.68588 * z * z - 4.39964 * z * z * z * z;
    a_array(a_iv, c_Gamma2) = -0.09082 - 0.31017 * x + 1.06980 * x * x +
                              7.81524 * x * y * y * y - 1.65016 * y * z -
                              0.53352 * z * z - 3.20997 * z * z * z * z;
    a_array(a_iv, c_Gamma3) = -0.42367 + 0.03891 * x - 0.87898 * x * x +
                              6.67657 * x * y * y * y - 3.44662 * y * z -
                              0.19655 * z * z + 2.97524 * z * z * z * z;

    a_array(a_iv, c_lapse) = 0.73578 + 0.36898 * x + 0.64348 * x * x +
                             9.33487 * x * y * y * y + 0.99469 * y * z +
                             0.20515 * z * z + 8.88385 * z * z * z * z;
    a_array(a_iv, c_shift1) = 0.00000 + 0.18795 * x - 0.52389 * x * x -
                              4.14079 * x * y * y * y + 0.73135 * y * z -
                              0.27057 * z * z + 3.24187 * z * z * z * z;
    a_array(a_iv, c_shift2) = 0.00000 - 0.30316 * x - 0.15184 * x * x -
                              0.48815 * x * y * y * y + 2.45991 * y * z -
                              0.79248 * z * z + 7.14007 * z * z * z * z;
    a_array(a_iv, c_shift3) = 0.00000 + 0.68835 * x - 0.52219 * x * x -
                              7.50449 * x * y * y * y - 2.35372 * y * z -
                              0.21476 * z * z + 4.36363 * z * z * z * z;
    a_array(a_iv, c_B1) = -0.26928 + 0.35045 * x - 0.48884 * x * x +
                          2.72465 * x * y * y * y - 2.59022 * y * z -
                          0.27384 * z * z + 0.38748 * z * z * z * z;
    a_array(a_iv, c_B2) = 0.40234 + 0.26741 * x + 1.94822 * x * x -
                          0.78276 * x * y * y * y + 2.12346 * y * z +
                          0.69086 * z * z - 4.47639 * z * z * z * z;
    a_array(a_iv, c_B3) = 0.40313 + 0.00569 * x - 1.12452 * x * x -
                          5.49255 * x * y * y * y - 2.21932 * y * z +
                          0.49523 * z * z + 1.29460 * z * z * z * z;
    // NOLINTEND(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
}

AMREX_GPU_DEVICE AMREX_FORCE_INLINE void
random_matter_bssn_initial_data(const amrex::IntVect &a_iv,
                                const amrex::Array4<amrex::Real> &a_array,
                                const amrex::RealVect &a_coords)
{
    amrex::Real x = a_coords[0];
    amrex::Real y = a_coords[1];
    amrex::Real z = a_coords[2];

    // Theta is zero in BSSN
    a_array(a_iv, c_Theta) = 0.0;

    // Define the values for the scalar field and (negative) conjugate momentum
    a_array(a_iv, c_phi) = 0.21232 * sin(x * 2.1232 * 3.14) *
                           cos(y * 2.5123 * 3.15) * cos(z * 2.1232 * 3.14);
    a_array(a_iv, c_Pi) = 0.4112 * sin(x * 4.123 * 3.14) *
                          cos(y * 2.2312 * 3.15) * cos(z * 2.5123 * 3.14);
}



================================================
FILE: Tests/Common/Make.package
================================================
GRTECLYN_CEXE_headers += InitialData.hpp \
                         doctestCLIArgs.hpp \
                         doctestOutput.hpp \
                         StateVariables.hpp



================================================
FILE: Tests/Common/SimulationParameters.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SIMULATIONPARAMETERS_HPP
#define SIMULATIONPARAMETERS_HPP

// General includes
#include "GRParmParse.hpp"
#include "SimulationParametersBase.hpp"

class SimulationParameters : public SimulationParametersBase
{
  public:
    // NOLINTNEXTLINE(readability-identifier-length)
    SimulationParameters(GRParmParse &pp) : SimulationParametersBase(pp)
    {
        read_params(pp);
    }

    /// Read shared parameters
    // NOLINTNEXTLINE(readability-identifier-length)
    void read_params(GRParmParse &pp)
    {

        // Do we want puncture tracking and constraint norm calculation?
        pp.load("puncture_tracking.enabled", puncture_tracking_enabled, true);
        pp.load("puncture_tracking.level", puncture_tracking_level, max_level);
        pp.load("puncture_tracking.initial_coords",
                puncture_tracking_initial_coords,
                {center[0], center[1] - 1.0, center[2], center[0],
                 center[1] + 1.0, center[2]});

        pp.load("fake_bh1_mass", fake_bh1_mass, 0.5);
        pp.load("fake_bh2_mass", fake_bh2_mass, 0.5);
    }

    bool puncture_tracking_enabled{};
    int puncture_tracking_level{};
    std::array<amrex::Real, AMREX_SPACEDIM * 2UL>
        puncture_tracking_initial_coords{};

    amrex::Real fake_bh1_mass{};
    amrex::Real fake_bh2_mass{};
};

#endif /* SIMULATIONPARAMETERS_HPP */



================================================
FILE: Tests/Common/StateVariables.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef STATEVARIABLES_HPP
#define STATEVARIABLES_HPP

#include "ArrayTools.hpp"
#include "BCParity.hpp"
#include "CCZ4StateVariables.hpp"

#include <array>
#include <string>

enum
{
    c_phi = NUM_CCZ4_VARS,
    c_Pi,

    NUM_VARS
};

namespace StateVariables
{
static const amrex::Vector<std::string> additional_names = {"phi", "Pi"};

static const amrex::Vector<std::string> names =
    ArrayTools::concatenate(CCZ4StateVariables::names, additional_names);

static const std::array<BCParity, NUM_VARS - NUM_CCZ4_VARS>
    user_variable_parities = {BCParity::even, BCParity::even};

static const std::array<BCParity, NUM_VARS> parities = ArrayTools::concatenate(
    CCZ4StateVariables::parities, user_variable_parities);
} // namespace StateVariables

#endif /* STATEVARIABLES_HPP */



================================================
FILE: Tests/ConstraintsTest/ConstraintsGRChombo.hdf5
================================================
[Binary file]


================================================
FILE: Tests/ConstraintsTest/ConstraintsTest.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// Doctest header
#include "doctest.h"

// Test header
#include "ConstraintsTest.hpp"

// Common Test headers
#include "InitialData.hpp"
#include "doctestCLIArgs.hpp"

// Our includes
#include "Constraints.hpp"

// AMReX headers
#include <AMReX.H>
#include <AMReX_Derive.H>
#include <AMReX_MultiFab.H>
#ifdef AMREX_USE_HDF5
#include <AMReX_PlotFileUtilHDF5.H>
#endif

// System headers
#include <array>
#include <cstdlib>
#include <iostream>
#include <string>

void run_constraints_test()
{
    int amrex_argc    = doctest::cli_args.argc();
    char **amrex_argv = doctest::cli_args.argv();
    // NOLINTNEXTLINE(bugprone-casting-through-void) // Open MPI triggers this
    amrex::Initialize(amrex_argc, amrex_argv);
    {
        // Set up grid
        constexpr int num_cells  = 16;
        constexpr int num_ghosts = 3;
        constexpr amrex::Real dx = 1.0 / (num_cells - 1);

        amrex::Box box{amrex::IntVect::TheZeroVector(),
                       amrex::IntVect{num_cells - 1}};
        auto ghosted_box = box;
        ghosted_box.grow(num_ghosts);

        amrex::RealVect dx_Vect{dx};
        amrex::RealBox real_box{box, dx_Vect.dataPtr(),
                                amrex::RealVect::Zero.dataPtr()};

        int coord_sys = 0; // Cartesian

        amrex::Geometry geom{box, &real_box, coord_sys};

        amrex::BoxArray box_array{box};
        amrex::DistributionMapping distribution_mapping{box_array};
        amrex::MFInfo mf_info;
        mf_info.SetArena(amrex::The_Managed_Arena());

        amrex::MultiFab in_mf{box_array, distribution_mapping, NUM_CCZ4_VARS,
                              num_ghosts, mf_info};

        // Calculate initial data
        const auto &in_arrays = in_mf.arrays();
        amrex::ParallelFor(
            in_mf, in_mf.nGrowVect(),
            // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
            [=] AMREX_GPU_DEVICE(int ibox, int i, int j, int k)
            {
                const amrex::IntVect iv{i, j, k};
                const amrex::RealVect coords = amrex::RealVect{iv} * dx;

                random_ccz4_initial_data(iv, in_arrays[ibox], coords);
            });

        amrex::Gpu::streamSynchronize();

        constexpr int num_constraints_comps = 4;
        constexpr int num_out_ghosts        = 0;
        amrex::MultiFab out_mf{box_array, distribution_mapping,
                               num_constraints_comps, num_out_ghosts, mf_info};
        constexpr int dcomp   = 0;
        constexpr double time = 0.0;
        int *bcrec            = nullptr;
        int level             = 0;

        // Check that Constraints::compute_mf is of type amrex::DeriveFuncMF
        static_assert(std::is_convertible_v<decltype(&Constraints::compute_mf),
                                            amrex::DeriveFuncMF>);
        Constraints::compute_mf(out_mf, dcomp, num_constraints_comps, in_mf,
                                geom, time, bcrec, level);

        amrex::Gpu::streamSynchronize();

        // Write to HDF5 plot file
#ifdef AMREX_USE_HDF5
        std::string this_test_dir = "ConstraintsTest/";
        std::string hdf5_out_stem = this_test_dir + "ConstraintsOut";

        amrex::WriteSingleLevelPlotfileHDF5(
            hdf5_out_stem, out_mf, Constraints::var_names, geom, 1.0, 0);

        // Apparently this is necessary before calling std::system if h5diff
        // writes to the screen
        std::cout.flush();

        std::string h5diff_toll        = "1.0e-10";
        std::string grteclyn_hdf5_file = hdf5_out_stem + ".h5";
        std::string grchombo_hdf5_file =
            this_test_dir + "ConstraintsGRChombo.hdf5";
        std::string hdf5_internal_path = "/level_0/data:datatype=0";

        // Let's hope this is in our PATH if we're building with HDF5
        std::string h5diff_command  = "h5diff";
        h5diff_command             += " -d " + h5diff_toll;
        h5diff_command += " " + grteclyn_hdf5_file + " " + grchombo_hdf5_file;
        h5diff_command += " " + hdf5_internal_path + " " + hdf5_internal_path;
        INFO("h5diff command: " << h5diff_command);
        INFO("Run command manually with -r flag to print difference");

        // In an ideal world, we wouldn't rely on running an external program
        // but I can't think of a simple way to do this nicely.
        int h5diff_status = std::system(h5diff_command.c_str());
        int h5diff_retval = -1;

        // Use POSIX macros to get the exit code
        if (WIFEXITED(h5diff_status))
        {
            h5diff_retval = WEXITSTATUS(h5diff_status);
        }

        CHECK(h5diff_retval == 0);
#endif
    }
    amrex::Finalize();
}



================================================
FILE: Tests/ConstraintsTest/ConstraintsTest.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef CONSTRAINTSTEST_HPP_
#define CONSTRAINTSTEST_HPP_

void run_constraints_test();

#endif /* CONSTRAINTSTEST_HPP_ */


================================================
FILE: Tests/ConstraintsTest/Make.package
================================================
GRTECLYN_CEXE_sources += ConstraintsTest.cpp

GRTECLYN_CEXE_headers += ConstraintsTest.hpp


================================================
FILE: Tests/CoordinateTransformationsTest/CoordinateTransformationsTest.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// Doctest header
#include "doctest.h"

// Test include
#include "CoordinateTransformationsTest.hpp"

// Common includes
#include "doctestCLIArgs.hpp"

// AMReX includes
#include "AMReX.H"
#include "AMReX_IntVect.H"

// Other includes
#include <limits>

// Our includes
#include "CoordinateTransformations.hpp"
#include "Coordinates.hpp"
#include "TensorAlgebra.hpp"

namespace
{
constexpr int ulp             = 15; // units in the last place
constexpr double real_epsilon = std::numeric_limits<amrex::Real>::epsilon();

void check_tensor(const Tensor<2, amrex::Real> &tensor,
                  const Tensor<2, amrex::Real> &correct_tensor,
                  const std::string &test_name)
{
    FOR (i, j)
    {
        INFO(test_name << ": component [" << i << "][" << j << "]");
        CHECK(
            tensor[i][j] ==
            doctest::Approx(correct_tensor[i][j]).epsilon(ulp * real_epsilon));
    }
}

void check_vector(const Tensor<1, amrex::Real> &vector,
                  const Tensor<1, amrex::Real> &correct_vector,
                  const std::string &test_name)
{
    FOR (i)
    {
        INFO(test_name << ": component [" << i << "]");
        CHECK(vector[i] ==
              doctest::Approx(correct_vector[i]).epsilon(ulp * real_epsilon));
    }
}
} // namespace

void run_coordinate_transformations_test()
{
    int amrex_argc    = doctest::cli_args.argc();
    char **amrex_argv = doctest::cli_args.argv();
    // NOLINTNEXTLINE(bugprone-casting-through-void) // Open MPI triggers this
    amrex::Initialize(amrex_argc, amrex_argv);
    {
        const amrex::Real dx = 0.1;
        amrex::IntVect iv{1, 2, 3};

        Coordinates coords(iv, dx);
        const amrex::Real x     = coords.x;
        const amrex::Real y     = coords.y;
        const amrex::Real z     = coords.z;
        const amrex::Real r     = coords.get_radius();
        amrex::Real rho2        = std::max(x * x + y * y, 1e-12);
        amrex::Real r2sin2theta = rho2;

        /* for debugging
        std::cout << "x " << x << std::endl;
        std::cout << "y " << y << std::endl;
        std::cout << "z " << z << std::endl;
        std::cout << "r " << r << std::endl;
        */

        using namespace TensorAlgebra;
        using namespace CoordinateTransformations;

        // Test if inv_jac is really the inverse of the jacobian
        Tensor<2, amrex::Real> jac     = spherical_jacobian(x, y, z);
        Tensor<2, amrex::Real> inv_jac = inverse_spherical_jacobian(x, y, z);
        Tensor<2, amrex::Real> inv_jac_check = compute_inverse(jac);
        check_tensor(inv_jac, inv_jac_check, "inverse_jacobian");

        // Test tensor transformations
        Tensor<2, amrex::Real> Mij_cart;
        FOR (i, j)
        {
            Mij_cart[i][j] = 0.;
        }
        Mij_cart[0][0] = 1.;
        Mij_cart[1][1] = 1.;
        Mij_cart[2][2] = 1.;

        Tensor<2, amrex::Real> Mij_spher;
        FOR (i, j)
        {
            Mij_spher[i][j] = 0.;
        }
        Mij_spher[0][0] = 1.;
        Mij_spher[1][1] = r * r;
        Mij_spher[2][2] = r2sin2theta;

        // Test cartesian_to_spherical_LL
        Tensor<2, amrex::Real> Mij_spher_check;
        Mij_spher_check = cartesian_to_spherical_LL(Mij_cart, x, y, z);
        check_tensor(Mij_spher_check, Mij_spher, "cartesian_to_spherical_LL");

        // Test spherical_to_cartesian_LL
        Tensor<2, amrex::Real> Mij_cart_check;
        Mij_cart_check = spherical_to_cartesian_LL(Mij_spher, x, y, z);
        check_tensor(Mij_cart_check, Mij_cart, "spherical_to_cartesian_LL");

        // Test cartesian_to_spherical_UU
        Tensor<2, amrex::Real> Mij_spher_UU;
        Tensor<2, amrex::Real> Mij_spher_UU_check;
        Mij_spher_UU_check =
            cartesian_to_spherical_UU(compute_inverse_sym(Mij_cart), x, y, z);
        Mij_spher_UU = compute_inverse_sym(Mij_spher);
        check_tensor(Mij_spher_UU_check, Mij_spher_UU,
                     "cartesian_to_spherical_UU");

        // Test spherical_to_cartesian_UU
        Tensor<2, amrex::Real> Mij_cart_UU;
        Tensor<2, amrex::Real> Mij_cart_UU_check;
        Mij_cart_UU_check =
            spherical_to_cartesian_UU(compute_inverse_sym(Mij_spher), x, y, z);
        Mij_cart_UU = compute_inverse_sym(Mij_cart);
        check_tensor(Mij_cart_UU_check, Mij_cart_UU,
                     "spherical_to_cartesian_UU");

        // Test vector transformations
        Tensor<1, amrex::Real> si_cart;
        si_cart[0] = x / r;
        si_cart[1] = y / r;
        si_cart[2] = z / r;

        Tensor<1, amrex::Real> si_spher;
        si_spher[0] = 1.0;
        si_spher[1] = 0.0;
        si_spher[2] = 0.0;

        // Test cartesian_to_spherical_U
        Tensor<1, amrex::Real> si_spher_U_check;
        si_spher_U_check = cartesian_to_spherical_U(si_cart, x, y, z);
        check_vector(si_spher_U_check, si_spher, "cartesian_to_spherical_U");

        // Test spherical_to_cartesian_U
        Tensor<1, amrex::Real> si_cart_U_check;
        si_cart_U_check = spherical_to_cartesian_U(si_spher, x, y, z);
        check_vector(si_cart_U_check, si_cart, "spherical_to_cartesian_U");

        // Test cartesian_to_spherical_L
        Tensor<1, amrex::Real> si_spher_L_check;
        si_spher_L_check = cartesian_to_spherical_L(si_cart, x, y, z);
        check_vector(si_spher_L_check, si_spher, "cartesian_to_spherical_L");

        // Test spherical_to_cartesian_L
        Tensor<1, amrex::Real> si_cart_L_check;
        si_cart_L_check = spherical_to_cartesian_L(si_spher, x, y, z);
        check_vector(si_cart_L_check, si_cart, "spherical_to_cartesian_L");

        // Test area_element_sphere
        amrex::Real area_element       = r * sqrt(rho2);
        amrex::Real area_element_check = area_element_sphere(Mij_spher);
        CHECK(area_element ==
              doctest::Approx(area_element_check).epsilon(ulp * real_epsilon));
    }
    amrex::Finalize();
}



================================================
FILE: Tests/CoordinateTransformationsTest/CoordinateTransformationsTest.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */
#ifndef COORDINATETRANSFORMATIONSTEST_HPP_
#define COORDINATETRANSFORMATIONSTEST_HPP_

void run_coordinate_transformations_test();

#endif /* COORDINATETRANSFORMATIONSTEST_HPP_ */


================================================
FILE: Tests/CoordinateTransformationsTest/Make.package
================================================
GRTECLYN_CEXE_headers += CoordinateTransformationsTest.hpp

GRTECLYN_CEXE_sources += CoordinateTransformationsTest.cpp


================================================
FILE: Tests/DerivativeUnitTests/DerivativeTestsCompute.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef DERIVATIVETESTSCOMPUTE_HPP_
#define DERIVATIVETESTSCOMPUTE_HPP_

#include "Cell.hpp"
#include "VarsTools.hpp"

enum
{
    c_d1,
    c_d2,
    c_d2_mixed,
    c_diss,
    c_advec_up,
    c_advec_down,
    NUM_DERIVATIVES_VARS
};

template <class deriv_t> class DerivativeTestsCompute
{
  private:
    deriv_t m_deriv;

  public:

    AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE DerivativeTestsCompute(double dx)
        : m_deriv(dx)
    {
    }

    template <class data_t> struct Vars
    {
        data_t d1;
        data_t d2;
        data_t d2_mixed;
        data_t diss;
        data_t advec_up;
        data_t advec_down;

        template <typename mapping_function_t>
        AMREX_GPU_HOST_DEVICE void
        enum_mapping(mapping_function_t mapping_function)
        {
            using namespace VarsTools; // define_enum_mapping is part of
                                       // VarsTools
            define_enum_mapping(mapping_function, c_d1, d1);
            define_enum_mapping(mapping_function, c_d2, d2);
            define_enum_mapping(mapping_function, c_d2_mixed, d2_mixed);
            define_enum_mapping(mapping_function, c_diss, diss);
            define_enum_mapping(mapping_function, c_advec_up, advec_up);
            define_enum_mapping(mapping_function, c_advec_down, advec_down);
        }
    };

    template <class data_t>
    AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE void
    operator()(int i, int j, int k, const amrex::Array4<data_t> &out,
               const amrex::Array4<data_t const> &in) const
    {
        const auto out_d1 = m_deriv.template diff1<Vars>(i, j, k, in);
        const auto out_d2 = m_deriv.template diff2<Vars>(i, j, k, in);

        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)
        Vars<data_t> out_diss;
        VarsTools::assign(out_diss, 0.);
        m_deriv.add_dissipation(i, j, k, out_diss, in, 1.0);

        Tensor<1, data_t> shift_down = {-2., 0., -3.};
        const auto out_advec_down =
            m_deriv.template advection<Vars>(i, j, k, in, shift_down);

        Tensor<1, data_t> shift_up = {2., 0., 3.};
        const auto out_advec_up =
            m_deriv.template advection<Vars>(i, j, k, in, shift_up);

        const auto out_cell_data = out.cellData(i, j, k);

        out_cell_data[c_d1]         = out_d1.d1[2];
        out_cell_data[c_d2]         = out_d2.d2[2][2];
        out_cell_data[c_d2_mixed]   = out_d2.d2[0][2];
        out_cell_data[c_diss]       = out_diss.diss;
        out_cell_data[c_advec_down] = out_advec_down.advec_down;
        out_cell_data[c_advec_up]   = out_advec_up.advec_up;
    }
};

#endif /* DERIVATIVETESTSCOMPUTE_HPP_ */



================================================
FILE: Tests/DerivativeUnitTests/DerivativeUnitTests.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// Doctest header
#include "doctest.h"

// Test header
#include "DerivativeUnitTests.hpp"

// Common includes
#include "doctestCLIArgs.hpp"

// AMReX includes
#include "AMReX.H"
#include "AMReX_FArrayBox.H"

// Other includes
#include <iostream>

// Our includes
#include "DerivativeTestsCompute.hpp"
#include "FourthOrderDerivatives.hpp"
// #include "SixthOrderDerivatives.hpp"

// NOLINTNEXTLINE(readability-function-cognitive-complexity)
void run_derivative_unit_tests()
{
    int amrex_argc    = doctest::cli_args.argc();
    char **amrex_argv = doctest::cli_args.argv();
    // NOLINTNEXTLINE(bugprone-casting-through-void) // Open MPI triggers this
    amrex::Initialize(amrex_argc, amrex_argv);
    {
        constexpr int num_cells  = 32;
        constexpr int num_ghosts = 4;
        // box is flat in y direction to make test cheaper
        amrex::IntVect domain_hi_vect(num_cells - 1, 0, num_cells - 1);
        amrex::Box box(amrex::IntVect::TheZeroVector(), domain_hi_vect);
        amrex::Box ghosted_box = box;
        ghosted_box.grow(num_ghosts);

        amrex::FArrayBox in_fab(ghosted_box, NUM_DERIVATIVES_VARS,
                                amrex::The_Managed_Arena());
        amrex::FArrayBox out_fab(box, NUM_DERIVATIVES_VARS,
                                 amrex::The_Managed_Arena());

        const double dx = 1.0 / num_cells;

        const amrex::Array4<amrex::Real> &in_array = in_fab.array();

        amrex::ParallelFor(ghosted_box,
                           [=] AMREX_GPU_DEVICE(int i, int j, int k)
                           {
                               // no point having data varying wrt y as we only
                               // 1 true cell in that dimension
                               const double x = (0.5 + i) * dx;
                               const double z = (0.5 + k) * dx;
                               for (int ivar = 0; ivar < in_array.nComp();
                                    ++ivar)
                               {
                                   in_array(i, j, k, ivar) = x * z * (z - 1);
                               }
                               // The dissipation component is special:
                               in_array(i, j, k, c_diss) =
                                   (pow(z - 0.5, 6) - 0.015625) / 720. +
                                   (z - 1) * z * pow(x, 6) / 720.;
                           });

        amrex::Gpu::streamSynchronize();
        AMREX_GPU_ERROR_CHECK();

        const auto &out_array  = out_fab.array();
        const auto &in_c_array = in_fab.const_array();

        SUBCASE("Fourth order derivatives")
        {
            DerivativeTestsCompute<FourthOrderDerivatives>
                derivative_tests_compute(dx);
            amrex::ParallelFor(
                box, [=] AMREX_GPU_DEVICE(int i, int j, int k)
                { derivative_tests_compute(i, j, k, out_array, in_c_array); });

            amrex::Gpu::streamSynchronize();
            AMREX_GPU_ERROR_CHECK();

            constexpr amrex::Real test_threshold = 1e-10;

            const auto &out_c_array = out_fab.const_array();

            amrex::LoopOnCpu(
                box,
                [=](int i, int j, int k)
                {
                    // only 1 cell in the y direction
                    const double x = (0.5 + i) * dx;
                    const double z = (0.5 + k) * dx;

                    amrex::IntVect iv(i, j, k);

                    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)
                    DerivativeTestsCompute<FourthOrderDerivatives>::Vars<
                        amrex::Real>
                        vars;
                    const auto &cell_data = out_c_array.cellData(i, j, k);
                    load_vars(cell_data, vars);

                    INFO("diff1 (fourth order) at " << iv);
                    CHECK(vars.d1 == doctest::Approx(2. * x * (z - 0.5))
                                         .epsilon(test_threshold));

                    INFO("diff2 (fourth order) at " << iv);
                    CHECK(vars.d2 ==
                          doctest::Approx(2. * x).epsilon(test_threshold));

                    INFO("mixed diff2 (fourth order) at " << iv);
                    CHECK(vars.d2_mixed == doctest::Approx(2. * (z - 0.5))
                                               .epsilon(test_threshold));

                    INFO("dissipation (fourth order) at " << iv);
                    CHECK(vars.diss == doctest::Approx((1. + z * (z - 1.)) *
                                                       pow(dx, 5) / 64.)
                                           .epsilon(test_threshold));

                    INFO("advection down (fourth order) at " << iv);
                    CHECK(vars.advec_down ==
                          doctest::Approx(-2. * z * (z - 1.) -
                                          3. * x * (2. * z - 1.))
                              .epsilon(test_threshold));

                    INFO("advection up (fourth order) at " << iv);
                    CHECK(vars.advec_up ==
                          doctest::Approx(2. * z * (z - 1.) +
                                          3. * x * (2. * z - 1.))
                              .epsilon(test_threshold));
                });
        }

        // SUBCASE("Sixth order derivatives")
        // {
        //     DerivativeTestsCompute<SixthOrderDerivatives>
        //     derivative_tests_compute(
        //         dx);
        //     amrex::ParallelFor(
        //         box, [=] AMREX_GPU_DEVICE(int i, int j, int k)
        //         { derivative_tests_compute(i, j, k, out_array, in_c_array);
        //         });

        //     amrex::Gpu::streamSynchronize();

        //     constexpr amrex::Real test_threshold = 1e-10;

        //     const auto &out_c_array = out_fab.const_array();

        //     amrex::LoopOnCpu(
        //         box,
        //         [=] (int i, int j, int k)
        //         {
        //             // only 1 cell in the y direction
        //             const double x = (0.5 + i) * dx;
        //             const double z = (0.5 + k) * dx;

        //             amrex::IntVect iv(i, j, k);

        //             DerivativeTestsCompute<SixthOrderDerivatives>::Vars<
        //                 amrex::Real>
        //                 vars;
        //             const auto &cell_data = out_c_array.cellData(i, j, k);
        //             load_vars(cell_data, vars);

        //             INFO("diff1 (sixth order) at " << iv);
        //             CHECK(vars.d1 == doctest::Approx(
        //                                     2. * x * (z - 0.5)).epsilon(
        //                                     test_threshold));

        //             INFO("diff2 (sixth order) at " << iv);
        //             CHECK(vars.d2 ==
        //                        doctest::Approx(2. * x).epsilon(
        //                        test_threshold));

        //             INFO("mixed diff2 (sixth order) at " << iv);
        //             CHECK(vars.d2_mixed == doctest::Approx(
        //                                           2. * (z - 0.5)).epsilon(
        //                                           test_threshold));

        //             INFO("dissipation (sixth order) at " << iv);
        //             CHECK(vars.diss ==
        //                        doctest::Approx((1. + z * (z - 1.))
        //                        * pow(dx, 5) / 64.).epsilon(test_threshold));

        //             INFO("advection down (sixth order) at " << iv);
        //             CHECK(vars.advec_down ==
        //                        doctest::Approx(
        //                            -2. * z * (z - 1.) - 3. * x * (2. * z
        //                            - 1.)).epsilon(test_threshold));

        //             INFO("advection up (sixth order) at " << iv);
        //             CHECK_(vars.advec_up ==
        //                        doctest::Approx(
        //                            2. * z * (z - 1.) + 3. * x * (2. * z
        //                            - 1.)).epsilon(test_threshold));
        //         });
        // }
    }
    amrex::Finalize();
}



================================================
FILE: Tests/DerivativeUnitTests/DerivativeUnitTests.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */
#ifndef DERIVATIVEUNITTESTS_HPP_
#define DERIVATIVEUNITTESTS_HPP_

void run_derivative_unit_tests();

#endif /* DERIVATIVEUNITTESTS_HPP_ */


================================================
FILE: Tests/DerivativeUnitTests/Make.package
================================================
GRTECLYN_CEXE_headers += DerivativeTestsCompute.hpp \
                         DerivativeUnitTests.hpp

GRTECLYN_CEXE_sources += DerivativeUnitTests.cpp



================================================
FILE: Tests/EMTensorTest/EMTensorTest.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// AMReX includes
#include <AMReX.H>
#include <AMReX_FArrayBox.H>
#include <AMReX_FabArray.H>
#include <AMReX_MFIter.H>
#include <AMReX_MultiFab.H>

#ifdef AMREX_USE_HDF5
#include <AMReX_PlotFileUtilHDF5.H>
#endif

// Doctest includes
#include "doctest.h"
#include "doctestCLIArgs.hpp"

#include <iomanip>
#include <iostream>
#include <sys/time.h>

// common includes
#include "InitialData.hpp" //includes StateVariables.hpp

// test header
#include "EMTensorTest.hpp"

// GRTeclyn includes
#include "DefaultPotential.hpp"
#include "EMTensor.hpp"
#include "ScalarField.hpp"
#include "simd.hpp"
#include <array>

void run_emtensor_test()
{
    int amrex_argc    = doctest::cli_args.argc();
    char **amrex_argv = doctest::cli_args.argv();

    // NOLINTNEXTLINE(bugprone-casting-through-void) // Open MPI triggers this
    amrex::Initialize(amrex_argc, amrex_argv);
    {

        constexpr int num_cells  = 32;
        constexpr int num_ghosts = 3;
        constexpr amrex::Real dx = 0.25 / (num_cells - 1);
        amrex::Box box{amrex::IntVect::TheZeroVector(),
                       amrex::IntVect{num_cells - 1}};
        auto ghosted_box = box;
        ghosted_box.grow(num_ghosts);

        amrex::BoxArray box_array{box};

        amrex::RealVect dx_Vect{dx};
        amrex::RealBox real_box{box, dx_Vect.dataPtr(),
                                amrex::RealVect::Zero.dataPtr()};

        int coord_sys = 0; // Cartesian

        amrex::Geometry geom{box, &real_box, coord_sys};
        amrex::DistributionMapping distribution_mapping{box_array};
        amrex::MFInfo mf_info;
        mf_info.SetArena(amrex::The_Managed_Arena());

        amrex::MultiFab in_mf{box_array, distribution_mapping, NUM_VARS,
                              num_ghosts, mf_info};

        const auto &in_arrays = in_mf.arrays();

        // NOLINTBEGIN(bugprone-easily-swappable-parameters)
        amrex::ParallelFor(
            in_mf, in_mf.nGrowVect(),
            [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k)
            // NOLINTEND(bugprone-easily-swappable-parameters)
            {
                const amrex::IntVect iv{i, j, k};
                const amrex::RealVect coords = amrex::RealVect{iv} * dx;
                amrex::Real x                = coords[0];
                amrex::Real y                = coords[1];
                amrex::Real z                = coords[2];

                random_ccz4_initial_data(iv, in_arrays[box_no], coords);

                random_matter_bssn_initial_data(iv, in_arrays[box_no], coords);
            });

        amrex::Gpu::streamSynchronize();

        // Setup scalar field calculations
        using DefaultScalarField = ScalarField<DefaultPotential>;

        // // Constructor for EMTensor
        constexpr int dcomp_rho = 0;

        constexpr int num_comps = 1;

        amrex::MultiFab out_mf{box_array, distribution_mapping, num_comps,
                               num_ghosts, mf_info};

        const auto &in_c_arrays = in_mf.const_arrays();

        double time = 0.0;
        int *bcrec  = nullptr;
        int level   = 0;

        EMTensor<DefaultScalarField,
                 EMTensorOptions::justEnergyDensity>::compute_mf(out_mf,
                                                                 dcomp_rho,
                                                                 num_comps,
                                                                 in_mf, geom,
                                                                 time, bcrec,
                                                                 level);

#if AMREX_USE_HDF5
        amrex::Vector<std::string> var_names = {"rho"};

        std::string grteclyn_hdf5_file = "EMTensorTest/EMTensorTestOut";

        // open the hdf5 file for writing
        amrex::WriteSingleLevelPlotfileHDF5(grteclyn_hdf5_file, out_mf,
                                            var_names, geom, 0.0, 0);

        std::cout.flush();

        std::string h5diff_tol         = "1e-10";
        std::string grchombo_hdf5_file = "EMTensorTest/GRChomboEMTensorTest.h5";

        std::string hdf5_internal_path = "/level_0/data:datatype=0";

        std::string hdf5_tool      = "h5diff";
        std::string h5diff_command = hdf5_tool + " -d " + h5diff_tol;

        h5diff_command = h5diff_command + " " + grteclyn_hdf5_file + ".h5 " +
                         grchombo_hdf5_file + " " + hdf5_internal_path;

        INFO("Test command : " << h5diff_command);

        int h5diff_status = std::system(h5diff_command.c_str());

        int h5diff_retval = -1;

        // Use POSIX macros to get the exit code
        if (WIFEXITED(h5diff_status))
        {
            h5diff_retval = WEXITSTATUS(h5diff_status);
        }

        CHECK(h5diff_retval == 0);

#endif
    }
    amrex::Finalize();
}



================================================
FILE: Tests/EMTensorTest/EMTensorTest.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef EMTENSORTEST_HPP_
#define EMTENSORTEST_HPP_

void run_emtensor_test();

#endif /* EMTENSORTEST_HPP_ */



================================================
FILE: Tests/EMTensorTest/Make.package
================================================
GRTECLYN_CEXE_headers += EMTensorTest.hpp

GRTECLYN_CEXE_sources += EMTensorTest.cpp



================================================
FILE: Tests/PositiveChiAndLapseUnitTest/Make.package
================================================
GRTECLYN_CEXE_headers += PositiveChiAndLapseUnitTest.hpp

GRTECLYN_CEXE_sources += PositiveChiAndLapseUnitTest.cpp


================================================
FILE: Tests/PositiveChiAndLapseUnitTest/PositiveChiAndLapseUnitTest.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// Doctest header
#include "doctest.h"

// Test header
#include "PositiveChiAndLapseUnitTest.hpp"

// Common includes
#include "doctestCLIArgs.hpp"

// AMReX includes
#include "AMReX.H"
#include "AMReX_FArrayBox.H"

// Other includes
#include "PositiveChiAndLapse.hpp"
#include "Tensor.hpp"

void run_positive_chi_and_lapse_unit_test()
{
    int amrex_argc    = doctest::cli_args.argc();
    char **amrex_argv = doctest::cli_args.argv();
    // NOLINTNEXTLINE(bugprone-casting-through-void) // Open MPI triggers this
    amrex::Initialize(amrex_argc, amrex_argv);
    {
        constexpr int N_GRID = 8;
        amrex::Box box(amrex::IntVect(0, 0, 0),
                       amrex::IntVect(N_GRID - 1, N_GRID - 1, N_GRID - 1));
        amrex::FArrayBox in_fab(box, NUM_VARS, amrex::The_Managed_Arena());

        const amrex::Array4<amrex::Real> &in_array = in_fab.array();

        amrex::ParallelFor(box,
                           [=] AMREX_GPU_DEVICE(int ix, int iy, int iz)
                           {
                               const amrex::IntVect iv{ix, iy, iz};
                               double value = (ix < N_GRID / 2) ? 1 : 1e-10;

                               in_array(iv, c_chi)   = value;
                               in_array(iv, c_lapse) = value;
                           });

        amrex::Gpu::streamSynchronize();

        amrex::ParallelFor(box,
                           [=] AMREX_GPU_DEVICE(int ix, int iy, int iz)
                           {
                               auto cell = in_array.cellData(ix, iy, iz);
                               PositiveChiAndLapse()(cell);
                           });

        amrex::Gpu::streamSynchronize();

        constexpr double test_threshold = 1e-15;

        // We have to do this on the host as are using doctest functions
        amrex::LoopOnCpu(
            box,
            [=](int ix, int iy, int iz)
            {
                const amrex::IntVect iv(ix, iy, iz);

                double correct_value = (ix < N_GRID / 2) ? 1 : 1e-4;
                INFO("At " << iv);
                CHECK(in_array(iv, c_chi) ==
                      doctest::Approx(correct_value).epsilon(test_threshold));
                CHECK(in_array(iv, c_lapse) ==
                      doctest::Approx(correct_value).epsilon(test_threshold));
            });
    }
    amrex::Finalize();
}



================================================
FILE: Tests/PositiveChiAndLapseUnitTest/PositiveChiAndLapseUnitTest.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */
#ifndef POSITIVECHIANDLAPSEUNITTEST_HPP_
#define POSITIVECHIANDLAPSEUNITTEST_HPP_

void run_positive_chi_and_lapse_unit_test();

#endif /* POSITIVECHIANDLAPSEUNITTEST_HPP_ */



================================================
FILE: Tests/PunctureTrackerTest/Make.package
================================================
GRTECLYN_CEXE_sources += PunctureTrackerLevel.cpp \
                         PunctureTrackerTest.cpp

GRTECLYN_CEXE_headers += PunctureTrackerLevel.hpp \
                         PunctureTrackerTest.hpp


================================================
FILE: Tests/PunctureTrackerTest/PunctureTrackerLevel.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// GRTeclyn and test headers
#include "PunctureTrackerLevel.hpp"
#include "PunctureTagger.hpp"
#include "PunctureTracker.hpp"

// doctest header
#include "doctest.h"

BHAMR<PunctureTrackerLevel::num_punctures> *
PunctureTrackerLevel::get_bhamr_ptr()
{
    return dynamic_cast<BHAMR<num_punctures> *>(get_gramr_ptr());
}

PunctureTracker<PunctureTrackerLevel::num_punctures> &
PunctureTrackerLevel::get_puncture_tracker()
{
    return get_bhamr_ptr()->get_puncture_tracker();
}

void PunctureTrackerLevel::variableSetUp() { stateVariableSetUp(); }

void PunctureTrackerLevel::initData()
{
    amrex::MultiFab &state = get_new_data(State_Type);
    const auto &arrs       = state.arrays();
    amrex::ParallelFor(state, state.nGrowVect(),
                       // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
                       [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k)
                       {
                           const auto &array = arrs[box_no];
                           for (int icomp = 0; icomp < array.nComp(); ++icomp)
                           {
                               array(i, j, k, icomp) = 0.0;
                           }
                           array(i, j, k, c_shift2) = shift_y_val;
                       });
    amrex::Gpu::streamSynchronize();

    if (Level() == 0)
    {
        // need to set the puncture coordinates as we use it for the puncture
        // tagging
        get_puncture_tracker().set_puncture_coords(
            simParams().puncture_tracking_initial_coords);
        // can't call start_from_initial_punctures() because we need the full
        // AMR grid first
    }
}

// Calculate RHS during RK4 substeps
// NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
void PunctureTrackerLevel::specificEvalRHS(amrex::MultiFab &a_soln,
                                           amrex::MultiFab &a_rhs,
                                           const double /*a_time*/)
{
    // We don't need any evolution in this test.
    a_rhs.setVal(0.0);
}

void PunctureTrackerLevel::tag_cells(amrex::TagBoxArray &a_tag_box_array,
                                     amrex::Real a_regrid_threshold)
{
    amrex::MultiFab &state_new = get_new_data(State_Type);

    const auto &tag_arrs       = a_tag_box_array.arrays();
    const auto &state_new_arrs = state_new.const_arrays();

    std::array<amrex::Real, num_puncture_coords> puncture_coords{};

    puncture_coords = get_puncture_tracker().get_puncture_coords();

    PunctureTagger<num_punctures> puncture_tagger(
        Geom().CellSize(0), Level(), get_gramr_ptr()->maxLevel(),
        puncture_coords,
        {simParams().fake_bh1_mass, simParams().fake_bh2_mass});

    amrex::ParallelFor(state_new, amrex::IntVect(0),
                       [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k)
                       { puncture_tagger(i, j, k, tag_arrs[box_no]); });
    amrex::Gpu::streamSynchronize();
}

void PunctureTrackerLevel::specific_post_init()
{
    get_puncture_tracker().start_from_initial_punctures();
}

void PunctureTrackerLevel::specific_post_restart()
{

    std::string restart_checkpoint{};
    GRParmParse pp("amr");
    pp.get("restart", restart_checkpoint);
    get_puncture_tracker().restart(restart_checkpoint);
}

// NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
void PunctureTrackerLevel::specific_post_regrid(int a_lbase, int a_new_finest)
{
    // During initial data construction, we expect the finest level to increment
    // up to max_level so only do this for later steps
    if (get_gramr_ptr()->cumTime() > 0.0)
    {
        // Check the finest level is max_level
        CHECK(a_new_finest == get_gramr_ptr()->maxLevel());

        if (Level() > get_gramr_ptr()->maxLevel() - 2)
        {
            check_puncture_tagging();
        }
    }
}

void PunctureTrackerLevel::check_puncture_tagging()
{
    const int num_points_theta = 8;
    const int num_points_phi   = 8;

    std::array<amrex::Real, num_punctures> fake_masses{
        simParams().fake_bh1_mass, simParams().fake_bh2_mass};
    const amrex::Real fudge_factor = 1.5; // as in PunctureTagger
    const int max_level            = get_gramr_ptr()->maxLevel();
    const amrex::Real exponent     = std::min(max_level - Level(), 1);
    const amrex::Real factor       = fudge_factor * std::pow(2.0, exponent);

    const auto &puncture_coords = get_puncture_tracker().get_puncture_coords();
    const auto &state_new       = get_new_data(State_Type);
    const auto &box_array       = state_new.boxArray();

    for (int ipuncture = 0; ipuncture < num_punctures; ++ipuncture)
    {
        // test if sphere of points around the punctures are in the
        // BoxArray
        for (int itheta = 0; itheta < num_points_theta; ++itheta)
        {
            amrex::Real theta = (static_cast<amrex::Real>(itheta) + 0.5) *
                                M_PI / num_points_theta;
            for (int iphi = 0; iphi < num_points_phi; ++iphi)
            {
                amrex::Real phi = 2.0 * M_PI * static_cast<amrex::Real>(iphi) /
                                  num_points_phi;

                amrex::Real sphere_x = factor * fake_masses[ipuncture] *
                                           std::sin(theta) * std::cos(phi) +
                                       puncture_coords[ipuncture + 0];
                amrex::Real sphere_y = factor * fake_masses[ipuncture] *
                                           std::sin(theta) * std::sin(phi) +
                                       puncture_coords[ipuncture + 1];
                amrex::Real sphere_z =
                    factor * fake_masses[ipuncture] * std::cos(theta) +
                    puncture_coords[ipuncture + 2];

                amrex::RealVect sphere_coords{sphere_x, sphere_y, sphere_z};

                // skip points that are outside the problem domain - there will
                // be some if using reflective BCs
                if (!Geom().ProbDomain().contains(sphere_coords))
                {
                    continue;
                }

                bool point_covered_by_level = false;

                for (int ibox = 0; ibox < box_array.size(); ++ibox)
                {
                    const auto &box = box_array[ibox];
                    amrex::RealBox real_box{box, Geom().CellSize(),
                                            Geom().ProbLo()};
                    if (real_box.contains(sphere_coords))
                    {
                        point_covered_by_level = true;
                        break;
                    }
                }

                // This check might fail depending on the parameters if proper
                // nesting conditions prevents some cells from being refined
                INFO("Level: " << Level());
                INFO("Coordinates: (" << sphere_x << ", " << sphere_y << ", "
                                      << sphere_z << ")");
                INFO("Nearest puncture: ("
                     << puncture_coords[ipuncture + 0] << ", "
                     << puncture_coords[ipuncture + 1] << ", "
                     << puncture_coords[ipuncture + 2] << ")");
                CHECK(point_covered_by_level);
            }
        }
    }
}

void PunctureTrackerLevel::specific_post_checkpoint(
    const std::string &a_chk_dir, std::ostream & /*a_os*/)
{
    get_puncture_tracker().checkpoint(a_chk_dir);
}

void PunctureTrackerLevel::specificPostTimeStep()
{
    if (Level() == simParams().puncture_tracking_level)
    {
        bool write_punctures = false;
        amrex::Real cur_time = get_state_data(State_Type).curTime();
        amrex::Real dt       = get_gramr_ptr()->dtLevel(Level());
        get_puncture_tracker().track(cur_time, dt, write_punctures);

        auto correct_puncture_coords =
            simParams().puncture_tracking_initial_coords;
        for (int ipuncture = 0; ipuncture < num_punctures; ++ipuncture)
        {
            correct_puncture_coords[ipuncture * AMREX_SPACEDIM + 1] -=
                cur_time * shift_y_val;
        }
        auto puncture_coords = get_puncture_tracker().get_puncture_coords();
        constexpr int cout_precision = 16;
        for (int icoord = 0; icoord < num_puncture_coords; ++icoord)
        {
            INFO("puncture_coords["
                 << icoord << "] = " << std::setprecision(cout_precision)
                 << puncture_coords[icoord]);
            INFO("correct_puncture_coords["
                 << icoord << "] = " << std::setprecision(cout_precision)
                 << correct_puncture_coords[icoord]);
            CHECK(puncture_coords[icoord] ==
                  doctest::Approx(correct_puncture_coords[icoord])
                      .epsilon(1e-12));
        }
    }
}



================================================
FILE: Tests/PunctureTrackerTest/PunctureTrackerLevel.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef PUNCTURETRACKERLEVEL_HPP_
#define PUNCTURETRACKERLEVEL_HPP_

#include "BHAMR.hpp"
#include "DefaultLevelFactory.hpp"
#include "GRAMRLevel.hpp"

class PunctureTrackerLevel : public GRAMRLevel
{
  public:
    static void variableSetUp();

    // Inherit the contructors from GRAMRLevel
    using GRAMRLevel::GRAMRLevel;

    static constexpr int num_punctures = 2;
    static constexpr std::size_t num_puncture_coords =
        static_cast<std::size_t>(AMREX_SPACEDIM * num_punctures);
    static constexpr amrex::Real shift_y_val = -1.0;

    BHAMR<num_punctures> *get_bhamr_ptr();

    /// Get a reference to the PunctureTracker object stored by BHAMR
    PunctureTracker<num_punctures> &get_puncture_tracker();

    /// Initial data calculation
    void initData() override;

    /// Calculation of the right hand side for the time stepping
    void specificEvalRHS(amrex::MultiFab &a_soln, amrex::MultiFab &a_rhs,
                         const double a_time) override;

    // to do post each time step on every level
    void specificPostTimeStep() override;

    /// Tag cells for regridding
    void tag_cells(amrex::TagBoxArray &a_tag_box_array,
                   amrex::Real a_regrid_threshold) final;

    //! Things to do after a restart
    void specific_post_restart() override;

    //! Things to do after init
    void specific_post_init() override;

    //! Things to do after regridding
    void specific_post_regrid(int a_lbase, int a_new_finest) override;

    //! Things to do after writing a checkpoint
    void specific_post_checkpoint(const std::string &a_chk_dir,
                                  std::ostream & /*a_os*/) override;

  private:
    void check_puncture_tagging();
};

#endif /* PUNCTURETRACKERLEVEL_HPP_ */



================================================
FILE: Tests/PunctureTrackerTest/PunctureTrackerTest.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// Doctest header
#include "doctest.h"

// Common test includes
#include "SimulationParameters.hpp"
#include "doctestCLIArgs.hpp"

// GRTeclyn includes
#include "BHAMR.hpp"
#include "DefaultLevelFactory.hpp"
#include "GRParmParse.hpp"
#include "SetupFunctions.hpp"

// Problem specific includes:
#include "PunctureTrackerLevel.hpp"

// System includes
#include <chrono>
#include <climits> // for PATH_MAX
#include <filesystem>
#include <iostream>

// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
void run_puncture_tracker_test()
{
    // Use an input file that is in the same directory as this file for the
    // second argument
    std::filesystem::path this_file(__FILE__);
    std::filesystem::path input_file =
        this_file.parent_path() / std::filesystem::path("test.inputs");
    char *input_file_c_str = strdup(input_file.c_str());

    auto new_args = doctest::cli_args;
    new_args.insert(1, input_file_c_str);

    int new_argc    = new_args.argc();
    char **new_argv = new_args.argv();

    // NOLINTNEXTLINE(bugprone-casting-through-void) // Open MPI triggers this
    amrex::Initialize(new_argc, new_argv);
    {
        GRParmParse pp; // NOLINT(readability-identifier-length)
        SimulationParameters sim_params(pp);

        GRAMR::set_simulation_parameters(sim_params);

        DefaultLevelFactory<PunctureTrackerLevel> level_factory;

        BHAMR<2> bh_amr(&level_factory);
        bh_amr.init(0., sim_params.stop_time);

        while ((bh_amr.okToContinue() != 0) &&
               (bh_amr.levelSteps(0) < sim_params.max_steps ||
                sim_params.max_steps < 0) &&
               (bh_amr.cumTime() < sim_params.stop_time ||
                sim_params.stop_time < 0.0))
        {
            bh_amr.coarseTimeStep(sim_params.stop_time);
        }
    }
    amrex::Finalize();
}



================================================
FILE: Tests/PunctureTrackerTest/PunctureTrackerTest.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */
#ifndef PUNCTURETRACKERTEST_HPP_
#define PUNCTURETRACKERTEST_HPP_

// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays)
void run_puncture_tracker_test();

#endif /* PUNCTURETRACKERTEST_HPP_ */


================================================
FILE: Tests/PunctureTrackerTest/test.inputs
================================================
#################################################
# Filesystem parameters

verbosity = 0

output_path = .

checkpoint_interval = -1
plot_interval = -1
amr.plot_vars = shift2

#################################################
# Grid parameters

N_full = 48
L_full = 8

max_level = 2 # There are (max_level+1) levels

regrid_interval = 0 0

max_grid_size = 16
block_factor = 8

#################################################
# Boundary Conditions parameters

# Periodic directions - 0 = false, 1 = true
isPeriodic = 0 0 0
# if not periodic, then specify the boundary type
# 0 = static, 1 = sommerfeld, 2 = reflective
# (see BoundaryConditions.hpp for details)
hi_boundary = 0 0 0
lo_boundary = 0 0 2

#################################################
# Evolution parameters

# dt will be dx*dt_multiplier on each grid level
dt_multiplier = 0.25
# stop_time = 1.0
max_steps = 2

#################################################
# Puncture Tracking parameters

puncture_tracking.enabled = 1
puncture_tracking.level = 0
puncture_tracking.initial_coords = 2.0 4.0 0.0 6.0 4.0 0.0



================================================
FILE: Tests/SmallDataIOTest/Make.package
================================================
GRTECLYN_CEXE_headers += SmallDataIOTest.hpp

GRTECLYN_CEXE_sources += SmallDataIOTest.cpp



================================================
FILE: Tests/SmallDataIOTest/SmallDataIOTest.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// Doctest header
#include "doctest.h"

// Test header
#include "SmallDataIOTest.hpp"

std::vector<double> generate_random_numbers(const int Npts)
{
    amrex::Gpu::DeviceVector<double> data_device(Npts);
    amrex::FillRandom(data_device.begin(), Npts);
    std::vector<double> data_host(Npts);

    amrex::Gpu::copyAsync(amrex::Gpu::deviceToHost, data_device.begin(),
                          data_device.end(), data_host.begin());

    // NB: Remember to call streamSynchronize once all copyAsyncs are done

    return data_host;
}
// NOLINTBEGIN(bugprone-easily-swappable-parameters)
bool check_almost_equal(std::vector<double> vector_1,
                        std::vector<double> vector_2, double err_tol)
// NOLINTEND(bugprone-easily-swappable-parameters)
{
    // Check that the vector_1 is equal to vector_2 within err_tol

    // Note that we couldn't have used amrex::almostEqual here because that
    // assumes that the two values are floats not vectors

    AMREX_ASSERT_WITH_MESSAGE(
        vector_1.size() == vector_2.size(),
        "Vectors must be the same length for the comparison to work!\n");

    for (int i = 0; i < vector_1.size(); ++i)
    {
        CHECK_MESSAGE(vector_1[i] ==
                          doctest::Approx(vector_2[i]).epsilon(err_tol),
                      "i= " << i);
    }

    return true;
}
// NOLINTBEGIN(bugprone-easily-swappable-parameters)
void test_small_data_io_writer(const std::vector<SmallDataIO::column_t> &col,
                               const int data_precision)
// NOLINTEND(bugprone-easily-swappable-parameters)
{
    const std::string filename_prefix{"test_"};
    amrex::Real dt{0.1};
    amrex::Real time{0.0};
    amrex::Real restart_time{0.0};
    bool first_step{true};

    SmallDataIO test_file(filename_prefix, dt, time, restart_time,
                          SmallDataIO::NEW, first_step, ".dat", data_precision);

    static const std::vector<std::string> header1_strings{"x", "y", "z"};

    // write a header containing labels for each column
    test_file.write_header_line(header1_strings); // pre-header string is time

    for (int i = 0; i < col[0].size(); ++i)
    {
        std::vector<amrex::Real> some_data{col[0][i], col[1][i], col[2][i]};
        test_file.write_time_data_line(some_data);
    }
}

std::vector<SmallDataIO::column_t>
test_small_data_io_reader(const std::vector<std::string> &column_names)
{
    SmallDataIO test_reader("test_000000");

    // Could print out file structure as well
    // test_reader.print_file_structure();

    std::vector<std::string> header;
    test_reader.get_header_strings(header, 0);

    // If a column name doesn't exist in the header, amrex::Abort will
    // be called

    std::vector<SmallDataIO::column_t> data;
    test_reader.get_columns(data, column_names, 0);

    SmallDataIO::broadcast_data(data);

    return data;
}

// NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
std::vector<SmallDataIO::column_t>
test_small_data_io_reader(const int a_min_col, const int a_max_col)
{
    // If we know the data structure already we can pass it in like so:

    const SmallDataIO::file_structure_t test_file_structure{
        1, {0}, {1}, {100}, {4}};

    SmallDataIO test_reader("test_000000", &test_file_structure);

    std::vector<SmallDataIO::column_t> data;
    test_reader.get_columns(data, a_min_col, a_max_col, 0);

    SmallDataIO::broadcast_data(data);

    return data;
}

std::vector<double> test_small_data_io_reader(const int a_col)

{
    SmallDataIO test_reader("test_000000");

    std::vector<SmallDataIO::column_t> data;
    test_reader.get_column(data, a_col, 0);

    return data[0];
}

void run_small_data_io_test()
{
    int amrex_argc    = doctest::cli_args.argc();
    char **amrex_argv = doctest::cli_args.argv();

    // NOLINTNEXTLINE(bugprone-casting-through-void) // Open MPI triggers this
    amrex::Initialize(amrex_argc, amrex_argv);
    {

        // Generate some random numbers to write out
        static const int Npts{100};

        // This is GPU safe, but must streamSynchronize because of Async copy
        amrex::ULong cpu_seed = 12345;
        amrex::ULong gpu_seed = 67890;
        amrex::InitRandom(cpu_seed, amrex::ParallelDescriptor::NProcs(),
                          gpu_seed);

        std::vector<SmallDataIO::column_t> write_data(3);
        for (auto &column : write_data)
        {
            column.resize(Npts);
            column = generate_random_numbers(Npts);
        }

        amrex::Gpu::streamSynchronize();

        static constexpr int data_precision = 10;
        static const amrex::Real err_tol = std::pow(10., -1.0 * data_precision);

        // Test the file writer: write out the random coordinates
        test_small_data_io_writer(write_data, data_precision);

        // Test the file reader: read the random numbers back in using their
        // column names

        // Columns do not have to be in order, this is tested below using
        // {"z", "x"}. But the first column returned will always go
        // with the first entry, the second column returned  with the second
        // entered etc.

        std::vector<std::string> read_these_columns{"z", "x"};
        auto read_data1 = test_small_data_io_reader(read_these_columns);

        // Test the file reader: read the data by specifying the column numbers
        const int min_col = 1;
        const int max_col = 3;
        auto read_data2   = test_small_data_io_reader(min_col, max_col);

        check_almost_equal(read_data1[0], write_data[2], err_tol);
        check_almost_equal(read_data1[1], write_data[0], err_tol);
        check_almost_equal(read_data2[0], write_data[0], err_tol);
        check_almost_equal(read_data2[1], write_data[1], err_tol);
        check_almost_equal(read_data2[2], write_data[2], err_tol);
    }

    amrex::Finalize();
}



================================================
FILE: Tests/SmallDataIOTest/SmallDataIOTest.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */
#ifndef SMALLDATAIOTEST_HPP_
#define SMALLDATAIOTEST_HPP_

// Common includes
#include "doctestCLIArgs.hpp"

// GRTeclyn includes
#include "SmallDataIO.hpp"

// AMReX includes
#include <AMReX.H>
#include <AMReX_Algorithm.H>
#include <AMReX_Gpu.H>
#include <AMReX_Print.H>
#include <AMReX_Random.H>
#include <AMReX_String.H>

// CPP includes
#include <string>
#include <vector>

// NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
bool check_almost_equal(std::vector<double> vector_1,
                        std::vector<double> vector_2, double err_tol);

std::vector<double> generate_random_numbers(const int Npts);

// NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
void test_small_data_io_writer(const std::vector<SmallDataIO::column_t> &col,
                               const int data_precision);

// NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
std::vector<SmallDataIO::column_t>
test_small_data_io_reader(const std::vector<std::string> &column_names);

// NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
std::vector<SmallDataIO::column_t>
test_small_data_io_reader(const int a_min_col, const int a_max_col);

std::vector<double> test_small_data_io_reader(const int a_col);

void run_small_data_io_test();

#endif /* SMALLDATAIOTEST_HPP_ */



================================================
FILE: Tests/SphericalHarmonicTest/HarmonicTest.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef HARMONICTEST_HPP_
#define HARMONICTEST_HPP_

// AMReX includes
#include "AMReX_Array.H"

// #include "BoxLoops.hpp"
#include "Cell.hpp"
#include "Coordinates.hpp"
#include "Tensor.hpp"
// #include "StateVariables.hpp" //This files needs NUM_VARS - total number of
// components #include "simd.hpp"

class HarmonicTest
{
  public:
    HarmonicTest(std::array<double, AMREX_SPACEDIM> a_center, double a_dx)
        : m_dx(a_dx), m_center(a_center)
    {
    }

    AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE void
    compute(int i, int j, int k,
            const amrex::CellData<amrex::Real> &current_cell) const;

  private:
    double m_dx;
    std::array<double, AMREX_SPACEDIM> m_center;

    [[nodiscard]] AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE amrex::Real
    compute_harmonic(Coordinates coords) const;
};

#include "HarmonicTest.impl.hpp"

#endif /* HARMONICTEST_HPP_ */



================================================
FILE: Tests/SphericalHarmonicTest/HarmonicTest.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(HARMONICTEST_HPP_)
#error "This file should only be included through HarmonicTest.hpp"
#endif

#ifndef HARMONICTEST_IMPL_HPP_
#define HARMONICTEST_IMPL_HPP_

// #include "DebuggingTools.hpp"
#include "SphericalHarmonics.hpp"

AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE void
HarmonicTest::compute(int i, int j, int k,
                      const amrex::CellData<amrex::Real> &current_cell) const
{

    Coordinates coords{
        amrex::IntVect{i, j, k},
        m_dx, m_center
    };

    amrex::Real phi = compute_harmonic(coords);

    // test both get_radius functions in the Coordinates class here
    amrex::Real radius1 = coords.get_radius();
    amrex::Real radius2 =
        Coordinates::get_radius(amrex::IntVect{i, j, k}, m_dx, m_center);
    phi = phi / radius1 / radius2;

    current_cell[0] = phi;
}

AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE amrex::Real
HarmonicTest::compute_harmonic(Coordinates coords) const
{

    // Add in el, em spherical harmonics here, spin weight es
    using namespace SphericalHarmonics;
    int es          = -1;
    int el          = 2;
    int em          = -1;
    auto Y_lm       = spin_Y_lm(coords.x, coords.y, coords.z, es, el, em);
    amrex::Real out = Y_lm.Real;

    return out;
}

#endif /* HARMONICTEST_IMPL_HPP_ */



================================================
FILE: Tests/SphericalHarmonicTest/Make.package
================================================
GRTECLYN_CEXE_headers += HarmonicTest.hpp \
                         HarmonicTest.impl.hpp \
                         SphericalHarmonicTest.hpp

GRTECLYN_CEXE_sources += SphericalHarmonicTest.cpp



================================================
FILE: Tests/SphericalHarmonicTest/SphericalHarmonicTest.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// Doctest header
#include "doctest.h"

// Test header
#include "SphericalHarmonicTest.hpp"

// Common includes
#include "doctestCLIArgs.hpp"

// AMReX includes
#include "AMReX.H"
#include "AMReX_FArrayBox.H"

// Other includes
#include "Cell.hpp"
#include "HarmonicTest.hpp"

enum
{
    c_phi,
    NUM_SPHERICAL_HARMONICS_VARS
};

void run_spherical_harmonic_test()
{
    int amrex_argc    = doctest::cli_args.argc();
    char **amrex_argv = doctest::cli_args.argv();
    // NOLINTNEXTLINE(bugprone-casting-through-void) // Open MPI triggers this
    amrex::Initialize(amrex_argc, amrex_argv);
    {
        const int N_GRID = 64;
        amrex::Box box(amrex::IntVect::TheZeroVector(),
                       amrex::IntVect(N_GRID - 1, N_GRID - 1, N_GRID - 1));
        amrex::FArrayBox in_fab(box, NUM_SPHERICAL_HARMONICS_VARS,
                                amrex::The_Managed_Arena());
        amrex::FArrayBox out_fab(box, NUM_SPHERICAL_HARMONICS_VARS,
                                 amrex::The_Managed_Arena());
        amrex::FArrayBox diff_fab(box, NUM_SPHERICAL_HARMONICS_VARS,
                                  amrex::The_Managed_Arena());
        double length = 64.0;

        const double dx     = length / (N_GRID);
        const double center = 0.5 * length;
        auto in_array       = in_fab.array();
        auto out_array      = out_fab.array();
        auto diff_array     = diff_fab.array();

        std::array<double, AMREX_SPACEDIM> center_vector = {center, center,
                                                            center};
        HarmonicTest harmonic_test(center_vector, dx);

        amrex::ParallelFor(
            box,
            [=] AMREX_GPU_DEVICE(int i, int j, int k)
            {
                const double x = (i + 0.5) * dx - center;
                const double y = (j + 0.5) * dx - center;
                const double z = (k + 0.5) * dx - center;
                const double r =
                    std::max(1e-6, std::sqrt(x * x + y * y + z * z));
                // NOLINTNEXTLINE(readability-identifier-length)
                const double rr     = r * r;
                const double rr_inv = 1.0 / rr;
                const double rho    = std::max(1e-6, std::sqrt(x * x + y * y));

                const amrex::IntVect iv{i, j, k};
                // here testing the es = -1, el = 2, em = -1 case
                // and also the calculation of r in coords
                double harmonic = sqrt(5.0 / 16.0 / M_PI) * x *
                                  (2 * z * z - z * r - rr) * rr_inv / rho;
                in_array(iv, c_phi) = harmonic * rr_inv;

                amrex::CellData<amrex::Real> cell = out_array.cellData(i, j, k);
                harmonic_test.compute(i, j, k, cell);

                diff_array(iv, c_phi) =
                    std::fabs(in_array(iv, c_phi) - out_array(iv, c_phi));
            });

        amrex::Gpu::streamSynchronize();

        const int cout_precision    = 17;
        const double test_tolerance = 1e-14;

        amrex::Real max_diff = 0.0;
        amrex::IntVect max_diff_index{};

        diff_fab.maxIndex<amrex::RunOn::Device>(box, max_diff, max_diff_index,
                                                c_phi);

        INFO("Max diff = " << std::setprecision(cout_precision) << max_diff
                           << " at " << max_diff_index);
        INFO("SphericalHarmonics computed value = "
             << std::setprecision(cout_precision)
             << out_array(max_diff_index, c_phi));
        INFO("Correct value = " << std::setprecision(cout_precision)
                                << in_array(max_diff_index, c_phi));
        CHECK(max_diff == doctest::Approx(0.0).epsilon(test_tolerance));
    }
    amrex::Finalize();
}



================================================
FILE: Tests/SphericalHarmonicTest/SphericalHarmonicTest.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */
#ifndef SPHERICALHARMONICTEST_HPP_
#define SPHERICALHARMONICTEST_HPP_

void run_spherical_harmonic_test();

#endif /* SPHERICALHARMONICTEST_HPP_ */


================================================
FILE: Tests/Weyl4Test/Make.package
================================================
GRTECLYN_CEXE_sources += Weyl4Test.cpp


================================================
FILE: Tests/Weyl4Test/Weyl4GRChombo.hdf5
================================================
[Binary file]


================================================
FILE: Tests/Weyl4Test/Weyl4Test.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// Doctest header
#include "doctest.h"

// Test header
#include "Weyl4Test.hpp"

// Common Test headers
#include "InitialData.hpp"
#include "doctestCLIArgs.hpp"

// Our includes
#include "Weyl4.hpp"

// AMReX headers
#include <AMReX.H>
#include <AMReX_MultiFab.H>
#ifdef AMREX_USE_HDF5
#include <AMReX_PlotFileUtilHDF5.H>
#endif

// System headers
#include <array>
#include <cstdlib>
#include <iostream>
#include <string>

void run_weyl4_test()
{
    int amrex_argc    = doctest::cli_args.argc();
    char **amrex_argv = doctest::cli_args.argv();
    // NOLINTNEXTLINE(bugprone-casting-through-void) // Open MPI triggers this
    amrex::Initialize(amrex_argc, amrex_argv);
    {
        // Set up grid
        constexpr int num_cells  = 32;
        constexpr int num_ghosts = 3;
        constexpr amrex::Real dx = 0.25 / (num_cells - 1);

        amrex::Box box{amrex::IntVect::TheZeroVector(),
                       amrex::IntVect{num_cells - 1}};
        auto ghosted_box = box;
        ghosted_box.grow(num_ghosts);

        amrex::RealVect dx_Vect{dx};
        amrex::RealBox real_box{box, dx_Vect.dataPtr(),
                                amrex::RealVect::Zero.dataPtr()};

        int coord_sys = 0; // Cartesian

        amrex::Geometry geom{box, &real_box, coord_sys};

        amrex::BoxArray box_array{box};
        amrex::DistributionMapping distribution_mapping{box_array};
        amrex::MFInfo mf_info;
        mf_info.SetArena(amrex::The_Managed_Arena());

        amrex::MultiFab in_mf{box_array, distribution_mapping, NUM_CCZ4_VARS,
                              num_ghosts, mf_info};

        // Calculate initial data
        const auto &in_arrays = in_mf.arrays();
        amrex::ParallelFor(
            in_mf, in_mf.nGrowVect(),
            // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
            [=] AMREX_GPU_DEVICE(int ibox, int i, int j, int k)
            {
                const amrex::IntVect iv{i, j, k};
                const amrex::RealVect coords = amrex::RealVect{iv} * dx;

                random_ccz4_initial_data(iv, in_arrays[ibox], coords);
            });

        amrex::Gpu::streamSynchronize();

        // Weyl4::compute_mf looks up these parameters from the ParmParse table
        // so we need to add them to it
        GRParmParse pp;
        std::array<double, AMREX_SPACEDIM> center{0.0, 0.0, 0.0};
        int formulation = CCZ4RHS<>::USE_CCZ4;
        pp.queryAdd("extraction_center", center);
        pp.queryAdd("formulation", formulation);

        constexpr int num_weyl4_comps = 2;
        constexpr int num_out_ghosts  = 0;
        amrex::MultiFab out_mf{box_array, distribution_mapping, num_weyl4_comps,
                               num_out_ghosts, mf_info};
        constexpr int dcomp = 0;
        double time         = 0.0;
        int *bcrec          = nullptr;
        int level           = 0;

        // Check that Weyl4::compute_mf is of type amrex::DeriveFuncMF
        static_assert(std::is_convertible_v<decltype(&Weyl4::compute_mf),
                                            amrex::DeriveFuncMF>);
        Weyl4::compute_mf(out_mf, dcomp, num_weyl4_comps, in_mf, geom, time,
                          bcrec, level);

        amrex::Gpu::streamSynchronize();

        // Write to HDF5 plot file
#ifdef AMREX_USE_HDF5
        std::string this_test_dir = "Weyl4Test/";
        std::string hdf5_out_stem = this_test_dir + "Weyl4Out";

        amrex::WriteSingleLevelPlotfileHDF5(hdf5_out_stem, out_mf,
                                            Weyl4::var_names, geom, 0.0, 0);

        // Apparently this is necessary before calling std::system if h5diff
        // writes to the screen
        std::cout.flush();

        std::string h5diff_toll        = "1.0e-10";
        std::string grteclyn_hdf5_file = hdf5_out_stem + ".h5";
        std::string grchombo_hdf5_file = this_test_dir + "Weyl4GRChombo.hdf5";
        std::string hdf5_internal_path = "/level_0/data:datatype=0";

        // Let's hope this is in our PATH if we're building with HDF5
        std::string h5diff_command  = "h5diff";
        h5diff_command             += " -d " + h5diff_toll;
        h5diff_command += " " + grteclyn_hdf5_file + " " + grchombo_hdf5_file;
        h5diff_command += " " + hdf5_internal_path + " " + hdf5_internal_path;
        INFO("h5diff command: " << h5diff_command);
        INFO("Run command manually with -r flag to print difference");

        // In an ideal world, we wouldn't rely on running an external program
        // but I can't think of a simple way to do this nicely.
        int h5diff_status = std::system(h5diff_command.c_str());
        int h5diff_retval = -1;

        // Use POSIX macros to get the exit code
        if (WIFEXITED(h5diff_status))
        {
            h5diff_retval = WEXITSTATUS(h5diff_status);
        }

        CHECK(h5diff_retval == 0);
#endif
    }
    amrex::Finalize();
}



================================================
FILE: Tests/Weyl4Test/Weyl4Test.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef WEYL4TEST_HPP_
#define WEYL4TEST_HPP_

void run_weyl4_test();

#endif /* WEYL4TEST_HPP_ */


================================================
FILE: Tests/Weyl4WithMatterTest/Make.package
================================================
GRTECLYN_CEXE_headers += Weyl4WithMatterTest.hpp

GRTECLYN_CEXE_sources += Weyl4WithMatterTest.cpp



================================================
FILE: Tests/Weyl4WithMatterTest/Weyl4WithMatterTest.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

// AMReX includes
#include <AMReX.H>
#include <AMReX_FArrayBox.H>
#include <AMReX_FabArray.H>
#include <AMReX_MFIter.H>
#include <AMReX_MultiFab.H>

#ifdef AMREX_USE_HDF5
#include <AMReX_PlotFileUtilHDF5.H>
#endif

// Doctest includes
#include "doctest.h"
#include "doctestCLIArgs.hpp"

#include <iomanip>
#include <iostream>
#include <sys/time.h>

// common includes
#include "InitialData.hpp" //includes StateVariables.hpp

// test header
#include "Weyl4WithMatterTest.hpp"

// GRTeclyn includes
#include "DefaultPotential.hpp"
#include "ScalarField.hpp"
#include "Weyl4WithMatter.hpp"
#include "simd.hpp"
#include <array>

void run_matter_weyl4_test()
{
    int amrex_argc    = doctest::cli_args.argc();
    char **amrex_argv = doctest::cli_args.argv();

    // NOLINTNEXTLINE(bugprone-casting-through-void) // Open MPI triggers this
    amrex::Initialize(amrex_argc, amrex_argv);
    {

        constexpr int num_cells  = 32;
        constexpr int num_ghosts = 3;
        constexpr amrex::Real dx = 0.25 / (num_cells - 1);
        amrex::Box box{amrex::IntVect::TheZeroVector(),
                       amrex::IntVect{num_cells - 1}};
        auto ghosted_box = box;
        ghosted_box.grow(num_ghosts);

        amrex::BoxArray box_array{box};

        amrex::RealVect dx_Vect{dx};
        amrex::RealBox real_box{box, dx_Vect.dataPtr(),
                                amrex::RealVect::Zero.dataPtr()};

        int coord_sys = 0; // Cartesian

        amrex::Geometry geom{box, &real_box, coord_sys};
        amrex::DistributionMapping distribution_mapping{box_array};
        amrex::MFInfo mf_info;
        mf_info.SetArena(amrex::The_Managed_Arena());

        amrex::MultiFab in_mf{box_array, distribution_mapping, NUM_VARS,
                              num_ghosts, mf_info};

        const auto &in_arrays = in_mf.arrays();

        // NOLINTBEGIN(bugprone-easily-swappable-parameters)
        amrex::ParallelFor(
            in_mf, in_mf.nGrowVect(),
            [=] AMREX_GPU_DEVICE(int box_no, int i, int j, int k)
            // NOLINTEND(bugprone-easily-swappable-parameters)
            {
                const amrex::IntVect iv{i, j, k};
                const amrex::RealVect coords = amrex::RealVect{iv} * dx;
                amrex::Real x                = coords[0];
                amrex::Real y                = coords[1];
                amrex::Real z                = coords[2];

                random_ccz4_initial_data(iv, in_arrays[box_no], coords);

                // NB: theta is redefined here because BSSN
                random_matter_bssn_initial_data(iv, in_arrays[box_no], coords);
            });

        amrex::Gpu::streamSynchronize();

        // Setup scalar field calculations
        using DefaultScalarField = ScalarField<DefaultPotential>;

        constexpr int dcomp_weyl4 = 0;
        constexpr int num_comps_weyl4 =
            2; // compute will automatically +1 for imaginary component
        double G_Newton = 1.0;
        std::array<double, AMREX_SPACEDIM> center{0.0, 0.0, 0.0};

        amrex::MultiFab out_mf{box_array, distribution_mapping, num_comps_weyl4,
                               0, mf_info};

        const auto &in_c_arrays = in_mf.const_arrays();
        const auto &out_arrays  = out_mf.arrays();

        double time = 0.0;
        int *bcrec  = nullptr;
        int level   = 0;

        GRParmParse pp;
        int formulation = CCZ4RHS<>::USE_BSSN;
        pp.queryAdd("extraction_center", center);
        pp.queryAdd("formulation", formulation);
        pp.queryAdd("G_newton", G_Newton);

        Weyl4WithMatter<DefaultScalarField>::compute_mf(
            out_mf, dcomp_weyl4, num_comps_weyl4, in_mf, geom, time, bcrec,
            level);

#if AMREX_USE_HDF5
        std::string grteclyn_hdf5_file =
            "Weyl4WithMatterTest/Weyl4WithMatterTestOut";

        // open the hdf5 file for writing
        amrex::WriteSingleLevelPlotfileHDF5(grteclyn_hdf5_file, out_mf,
                                            Weyl4::var_names, geom, 0.0, 0);

        std::cout.flush();

        std::string h5diff_tol = "1e-10";
        std::string grchombo_weyl4_hdf5_file =
            "Weyl4WithMatterTest/GRChomboWeyl4WithMatterTest.h5";

        std::string hdf5_internal_path = "/level_0/data:datatype=0";

        std::string hdf5_tool      = "h5diff";
        std::string h5diff_command = hdf5_tool + " -d " + h5diff_tol;

        h5diff_command = h5diff_command + " " + grteclyn_hdf5_file + ".h5 " +
                         grchombo_weyl4_hdf5_file + " " + hdf5_internal_path;

        INFO("Test command : " << h5diff_command);

        int h5diff_status = std::system(h5diff_command.c_str());

        int h5diff_retval = -1;

        // Use POSIX macros to get the exit code
        if (WIFEXITED(h5diff_status))
        {
            h5diff_retval = WEXITSTATUS(h5diff_status);
        }

        CHECK(h5diff_retval == 0);

#endif
    }
    amrex::Finalize();
}



================================================
FILE: Tests/Weyl4WithMatterTest/Weyl4WithMatterTest.hpp
================================================
#ifndef MATTERWEYL4TEST_HPP_
#define MATTERWEYL4TEST_HPP_

void run_matter_weyl4_test();

#endif /* MATTERWEYL4TEST_HPP_ */



================================================
FILE: Tests/.AMRInterpolatorTest/AMRInterpolatorTest.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to LICENSE, in Chombo's root directory.
 */
#endif

// Chombo includes
#include "parstream.H" //Gives us amrex::Print()

// General includes:
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <iostream>
#include <sys/time.h>

using std::endl;
#include "GRAMR.hpp"

#include "GRParmParse.hpp"
#include "SetupFunctions.hpp"
#include "SimulationParameters.hpp"

// Problem specific includes:
#include "AMRInterpolator.hpp"
#include "DefaultLevelFactory.hpp"
#include "InterpolationQuery.hpp"
#include "InterpolatorTestLevel.hpp"
#include "Lagrange.hpp"
#include "StateVariables.hpp"

#ifdef _OPENMP
#include <omp.h>
#endif

// Chombo namespace
#include "UsingNamespace.H"

int runInterpolatorTest(int argc, char *argv[])
{
    // Load the parameter file and construct the SimulationParameter class
    // To add more parameters edit the SimulationParameters file.
    std::string in_string = argv[argc - 1];
    amrex::Print() << in_string << std::endl;
    const char *in_file = argv[argc - 1];
    GRParmParse pp(0, argv + argc, NULL, in_file);
    SimulationParameters sim_params(pp);

    GRAMR gr_amr;
    DefaultLevelFactory<InterpolatorTestLevel> interpolator_test_level_fact(
        gr_amr, sim_params);
    setupAMRObject(gr_amr, interpolator_test_level_fact);

    // Setup the AMRInterpolator
    const int num_points = sim_params.num_points;

    std::vector<double> A(num_points);
    std::vector<double> B(num_points);
    std::vector<double> B_dx(num_points);
    std::vector<double> interp_x(num_points);
    std::vector<double> interp_y(num_points);
    std::vector<double> interp_z(num_points);

    double extract_radius = sim_params.L / 4;

    for (int ipoint = 0; ipoint < num_points; ++ipoint)
    {
        double phi   = ipoint * 2. * M_PI / num_points;
        double theta = ipoint * M_PI / num_points;
        interp_x[ipoint] =
            sim_params.center[0] + extract_radius * cos(phi) * sin(theta);
        interp_y[ipoint] =
            sim_params.center[1] + extract_radius * sin(phi) * sin(theta);
        interp_z[ipoint] = sim_params.center[2] + extract_radius * cos(theta);
    }

    InterpolationQuery query(num_points);
    query.setCoords(0, interp_x.data())
        .setCoords(1, interp_y.data())
        .setCoords(2, interp_z.data())
        .addComp(c_A, A.data())
        .addComp(c_B, B.data())
        .addComp(c_B, B_dx.data(), Derivative::dx);

    AMRInterpolator<Lagrange<4>> interpolator(gr_amr, sim_params.origin,
                                              sim_params.dx,
                                              sim_params.boundary_params, 0);
    interpolator.interp(query);

    int status = 0;

    for (int ipoint = 0; ipoint < num_points; ++ipoint)
    {
        double x = interp_x[ipoint] - sim_params.center[0];
        double y = interp_y[ipoint] - sim_params.center[1];
        double z = interp_z[ipoint] - sim_params.center[2];

        double value_A    = 42. + x * x + y * y * z * z;
        double value_B    = std::pow(x, 3);
        double value_B_dx = 3. * std::pow(x, 2);

        status |= (std::abs(A[ipoint] - value_A) > 1e-10);
        status |= (std::abs(B[ipoint] - value_B) > 1e-10);
        status |= (std::abs(B_dx[ipoint] - value_B_dx) > 1e-10);
    }

    return status;
}

int main(int argc, char *argv[])
{
    mainSetup(argc, argv);

    int status = runInterpolatorTest(argc, argv);

    if (status == 0)
        amrex::Print() << "BasicAMRInterpolator test passed." << endl;
    else
        amrex::Print() << "BasicAMRInterpolator test failed with return code "
                       << status << endl;

    mainFinalize();
    return status;
}



================================================
FILE: Tests/.AMRInterpolatorTest/AMRInterpolatorTest.inputs
================================================
verbosity = 0
N_full = 32
L_full = 16

chk_prefix = TestChk_
plot_prefix = TestPlt_

num_points = 30

num_ghosts = 3
max_level = 1
regrid_interval = 1 1 1 1 0 0 0 0 0

#boundaries and periodicity of grid
#Periodic directions - 0 = false, 1 = true
isPeriodic = 0 0 0
# if not periodic, then specify the boundary type
# 0 = static, 1 = sommerfeld, 2 = reflective
# (see BoundaryConditions.hpp for details)
hi_boundary = 0 2 0
lo_boundary = 2 0 2


================================================
FILE: Tests/.AMRInterpolatorTest/GNUmakefile
================================================
# -*- Mode: Makefile -*-

### This makefile produces an executable for each name in the `ebase'
###  variable using the libraries named in the `LibNames' variable.

# Included makefiles need an absolute path to the Chombo installation
# CHOMBO_HOME := Please set the CHOMBO_HOME locally (e.g. export CHOMBO_HOME=... in bash)

GRCHOMBO_SOURCE = $(shell pwd)/../../Source

ebase := AMRInterpolatorTest

LibNames := AMRTimeDependent AMRTools BoxTools

src_dirs := $(GRCHOMBO_SOURCE)/utils \
            $(GRCHOMBO_SOURCE)/simd  \
            $(GRCHOMBO_SOURCE)/BoxUtils  \
            $(GRCHOMBO_SOURCE)/CCZ4  \
            $(GRCHOMBO_SOURCE)/GRChomboCore  \
            $(GRCHOMBO_SOURCE)/AMRInterpolator

include $(CHOMBO_HOME)/mk/Make.test



================================================
FILE: Tests/.AMRInterpolatorTest/InterpolatorTestLevel.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef INTERPOLATORTESTLEVEL_HPP_
#define INTERPOLATORTESTLEVEL_HPP_

#include "BoxLoops.hpp"
#include "GRAMRLevel.hpp"
#include "Polynomial.hpp"
#include "SetValue.hpp"

class InterpolatorTestLevel : public GRAMRLevel
{
    friend class DefaultLevelFactory<InterpolatorTestLevel>;
    // Inherit the contructors from GRAMRLevel
    using GRAMRLevel::GRAMRLevel;

    // initialize data
    virtual void initialData()
    {
        BoxLoops::loop(Polynomial(m_p.center, m_dx), m_state_new, m_state_new,
                       FILL_GHOST_CELLS);
    }

    virtual void specificEvalRHS(GRLevelData &a_soln, GRLevelData &a_rhs,
                                 const double a_time)
    {
    }

    virtual void computeTaggingCriterion(FArrayBox &tagging_criterion,
                                         const FArrayBox &current_state) {};
};

#endif /* INTERPOLATORTESTLEVEL_HPP_ */



================================================
FILE: Tests/.AMRInterpolatorTest/Polynomial.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef POLYNOMIAL_HPP_
#define POLYNOMIAL_HPP_

#include "Cell.hpp"
#include "Coordinates.hpp"
#include "StateVariables.hpp"

// This compute class sets the grid to a certain polynomial
class Polynomial
{
  public:
    Polynomial(std::array<double, CH_SPACEDIM> &a_center, double a_dx)
        : m_dx(a_dx), m_center(a_center)
    {
    }

    template <class data_t> void compute(Cell<data_t> current_cell) const
    {
        Coordinates<data_t> coords(current_cell, m_dx, m_center);

        data_t x = coords.x;
        data_t y = coords.y;
        data_t z = coords.z;

        // A is even in x and z, but in y it's even on the upper boundary
        data_t poliA = 42. + x * x + y * y * z * z;
        // B is odd in x
        data_t poliB = pow(x, 3);

        current_cell.store_vars(poliA, c_A);
        current_cell.store_vars(poliB, c_B);
    }

  protected:
    const double m_dx;
    const std::array<double, CH_SPACEDIM> m_center;
};

#endif /* POLYNOMIAL_HPP_ */



================================================
FILE: Tests/.AMRInterpolatorTest/SimulationParameters.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SIMULATIONPARAMETERS_HPP_
#define SIMULATIONPARAMETERS_HPP_

// General includes
#include "AMReXParameters.hpp"
#include "GRParmParse.hpp"

class SimulationParameters : public AMReXParameters
{
  public:
    SimulationParameters(GRParmParse &pp) : AMReXParameters(pp)
    {
        pp.load("num_points", num_points, 2);
    }

    int num_points;
};

#endif /* SIMULATIONPARAMETERS_HPP_ */



================================================
FILE: Tests/.AMRInterpolatorTest/StateVariables.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef STATEVARIABLES_HPP
#define STATEVARIABLES_HPP

#include <array>
#include <string>

// assign enum to each variable
enum
{
    c_A,
    c_B,

    NUM_VARS
};

namespace StateVariables
{
static const amrex::Vector<std::string> names = {"A", "B"};
}

#endif /* STATEVARIABLES_HPP */



================================================
FILE: Tests/.AMRInterpolatorTest/UserVariables.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef STATEVARIABLES_HPP
#define STATEVARIABLES_HPP

#include <array>
#include <string>

// assign enum to each variable
enum
{
    c_A,
    c_B,

    NUM_VARS
};

namespace StateVariables
{
static const amrex::Vector<std::string> variable_names = {"A", "B"};
}

#endif /* STATEVARIABLES_HPP */



================================================
FILE: Tests/.SphericalExtractionTest/GNUmakefile
================================================
# -*- Mode: Makefile -*-

### This makefile produces an executable for each name in the `ebase'
###  variable using the libraries named in the `LibNames' variable.

# Included makefiles need an absolute path to the Chombo installation
# CHOMBO_HOME := Please set the CHOMBO_HOME locally (e.g. export CHOMBO_HOME=... in bash)

GRCHOMBO_SOURCE = $(shell pwd)/../../Source

ebase := SphericalExtractionTest

LibNames := AMRTimeDependent AMRTools BoxTools

src_dirs := $(GRCHOMBO_SOURCE)/utils \
            $(GRCHOMBO_SOURCE)/simd  \
            $(GRCHOMBO_SOURCE)/BoxUtils  \
            $(GRCHOMBO_SOURCE)/CCZ4  \
            $(GRCHOMBO_SOURCE)/GRChomboCore  \
            $(GRCHOMBO_SOURCE)/AMRInterpolator

include $(CHOMBO_HOME)/mk/Make.test



================================================
FILE: Tests/.SphericalExtractionTest/SetHarmonic.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SETHARMONIC_HPP_
#define SETHARMONIC_HPP_

#include "BoxLoops.hpp"
#include "Cell.hpp"
#include "Coordinates.hpp"
#include "StateVariables.hpp" //This files needs NUM_VARS - total number of components
#include "Tensor.hpp"
#include "simd.hpp"

// This compute class sets two vars to the real and imaginary parts of the
// s = a_es, l = a_el, m = a_em spin-weighted spherical harmonic
class SetHarmonic
{
  public:
    SetHarmonic(int a_var_Re, int a_var_Im, int a_es, int a_el, int a_em,
                std::array<double, CH_SPACEDIM> &a_center, double a_dx)
        : m_var_Re(a_var_Re), m_var_Im(a_var_Im), m_es(a_es), m_el(a_el),
          m_em(a_em), m_dx(a_dx), m_center(a_center)
    {
    }

    template <class data_t> void compute(Cell<data_t> current_cell) const;

  protected:
    const int m_var_Re;
    const int m_var_Im;
    const int m_es;
    const int m_el;
    const int m_em;
    const double m_dx;
    const std::array<double, CH_SPACEDIM> m_center;
};

#include "SetHarmonic.impl.hpp"

#endif /* SETHARMONIC_HPP_ */



================================================
FILE: Tests/.SphericalExtractionTest/SetHarmonic.impl.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#if !defined(SETHARMONIC_HPP_)
#error "This file should only be included through SetHarmonic.hpp"
#endif

#ifndef SETHARMONIC_IMPL_HPP_
#define SETHARMONIC_IMPL_HPP_

#include "DebuggingTools.hpp"
#include "SetHarmonic.hpp"
#include "SphericalHarmonics.hpp"
#include "simd.hpp"

template <class data_t>
void SetHarmonic::compute(Cell<data_t> current_cell) const
{

    Coordinates<data_t> coords(current_cell, m_dx, m_center);

    using namespace SphericalHarmonics;
    auto Y_lm     = spin_Y_lm(coords.x, coords.y, coords.z, m_es, m_el, m_em);
    data_t out_Re = Y_lm.Real;
    data_t out_Im = Y_lm.Im;

    current_cell.store_vars(out_Re, m_var_Re);
    current_cell.store_vars(out_Im, m_var_Im);
}

#endif /* SETHARMONIC_IMPL_HPP_ */



================================================
FILE: Tests/.SphericalExtractionTest/SimulationParameters.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SIMULATIONPARAMETERS_HPP_
#define SIMULATIONPARAMETERS_HPP_

// General includes
#include "AMReXParameters.hpp"
#include "GRParmParse.hpp"

// Problem specific includes
#include "SphericalExtraction.hpp"

class SimulationParameters : public AMReXParameters
{
  public:
    SimulationParameters(GRParmParse &pp) : AMReXParameters(pp)
    {
        read_params(pp);
    }

  private:
    void read_params(GRParmParse &pp)
    {
        // Extraction params
        pp.load("num_extraction_radii",
                extraction_params_lo.num_extraction_radii(), 1);

        if (pp.contains("extraction_radii"))
        {
            pp.load("extraction_radii", extraction_params_lo.extraction_radii(),
                    extraction_params_lo.num_extraction_radii());
        }
        else
        {
            pp.load("extraction_radius",
                    extraction_params_lo.extraction_radii(), 1, L / 4);
        }
        pp.load("num_points_phi_lo", extraction_params_lo.num_points_phi(), 8);
        pp.load("num_points_theta_lo", extraction_params_lo.num_points_theta(),
                17);
        pp.load("extraction_center", extraction_params_lo.center, center);
        pp.load("write_extraction", extraction_params_lo.write_extraction,
                false);

        pp.load("es", es, 0);
        pp.load("el", el, 2);
        pp.load("em", em, 0);
    }

  public:
    SphericalExtraction::params_t extraction_params_lo;
    int es, el, em; // spherical harmonic params
};

#endif /* SIMULATIONPARAMETERS_HPP_ */



================================================
FILE: Tests/.SphericalExtractionTest/SphericalExtractionTest.cpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to LICENSE, in Chombo's root directory.
 */
#endif

// Chombo includes
#include "parstream.H" //Gives us amrex::Print()

// General includes:
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <iomanip>
#include <iostream>
#include <sys/time.h>

using std::endl;
#include "DefaultLevelFactory.hpp"
#include "GRAMR.hpp"

#include "GRParmParse.hpp"
#include "SetupFunctions.hpp"
#include "SimulationParameters.hpp"

// Problem specific includes:
#include "AMRInterpolator.hpp"
#include "Lagrange.hpp"
#include "SphericalExtraction.hpp"
#include "SphericalExtractionTestLevel.hpp"

#ifdef _OPENMP
#include <omp.h>
#endif

// Chombo namespace
#include "UsingNamespace.H"

int runSphericalExtractionTest(int argc, char *argv[])
{
    // Load the parameter file and construct the SimulationParameter class
    // To add more parameters edit the SimulationParameters file.
    std::string in_string = argv[argc - 1];
    amrex::Print() << in_string << std::endl;
    const char *in_file = argv[argc - 1];
    GRParmParse pp(0, argv + argc, NULL, in_file);
    SimulationParameters sim_params(pp);

    GRAMR gr_amr;
    DefaultLevelFactory<SphericalExtractionTestLevel>
        surface_extraction_test_level_fact(gr_amr, sim_params);
    // the initial data for the two variables is the spherical harmonic
    // specified by params
    setupAMRObject(gr_amr, surface_extraction_test_level_fact);

    AMRInterpolator<Lagrange<4>> interpolator(
        gr_amr, sim_params.origin, sim_params.dx, sim_params.boundary_params);

    // low resolution spherical extraction
    SphericalExtraction spherical_extraction_lo(
        sim_params.extraction_params_lo,
        sim_params.coarsest_dx * sim_params.dt_multiplier, 0.0, true, 0.0);
    spherical_extraction_lo.add_var(c_phi_Re);
    spherical_extraction_lo.add_var(c_phi_Im);
    spherical_extraction_lo.extract(&interpolator);
    spherical_extraction_lo.write_extraction("ExtractionOutLo_");

    // high resolution spherical extraction
    SphericalExtraction::params_t extraction_params_hi =
        sim_params.extraction_params_lo;
    // we are only checking the converence in theta integration
    // extraction_params_hi.num_points_phi() *= 2;
    extraction_params_hi.num_points_theta() *= 2;
    // need to subtract a point as it's the number of subintervals we want to
    // double for theta
    extraction_params_hi.num_points_theta() -= 1;
    SphericalExtraction spherical_extraction_hi(
        extraction_params_hi, sim_params.coarsest_dx * sim_params.dt_multiplier,
        0.0, true, 0.0);
    spherical_extraction_hi.add_var(c_phi_Re);
    spherical_extraction_hi.add_var(c_phi_Im);
    spherical_extraction_hi.extract(&interpolator);
    spherical_extraction_hi.write_extraction("ExtractionOutHi_");

    // real part is the zeroth componenent and imaginary part is first component
    SphericalExtraction::complex_function_t extracted_harmonic =
        [](std::vector<double> &data, double, double, double)
    { return std::make_pair(data[0], data[1]); };

    // add the spherical harmonic mode integrands for each resolution and for
    // the trapezium rule, Simpson's rule and Boole's rule
    // Always use trapezium rule in phi as this is periodic
    bool broadcast_integral = true;
    std::pair<std::vector<double>, std::vector<double>> integral_lo_trapezium,
        integral_hi_trapezium;
    spherical_extraction_lo.add_mode_integrand(
        sim_params.es, sim_params.el, sim_params.em, extracted_harmonic,
        integral_lo_trapezium, IntegrationMethod::trapezium,
        IntegrationMethod::trapezium, broadcast_integral);
    spherical_extraction_hi.add_mode_integrand(
        sim_params.es, sim_params.el, sim_params.em, extracted_harmonic,
        integral_hi_trapezium, IntegrationMethod::trapezium,
        IntegrationMethod::trapezium, broadcast_integral);
    std::pair<std::vector<double>, std::vector<double>> integral_lo_simpson,
        integral_hi_simpson;
    spherical_extraction_lo.add_mode_integrand(
        sim_params.es, sim_params.el, sim_params.em, extracted_harmonic,
        integral_lo_simpson, IntegrationMethod::simpson,
        IntegrationMethod::trapezium, broadcast_integral);
    spherical_extraction_hi.add_mode_integrand(
        sim_params.es, sim_params.el, sim_params.em, extracted_harmonic,
        integral_hi_simpson, IntegrationMethod::simpson,
        IntegrationMethod::trapezium, broadcast_integral);
    std::pair<std::vector<double>, std::vector<double>> integral_lo_boole,
        integral_hi_boole;
    spherical_extraction_lo.add_mode_integrand(
        sim_params.es, sim_params.el, sim_params.em, extracted_harmonic,
        integral_lo_boole, IntegrationMethod::boole,
        IntegrationMethod::trapezium, broadcast_integral);
    spherical_extraction_hi.add_mode_integrand(
        sim_params.es, sim_params.el, sim_params.em, extracted_harmonic,
        integral_hi_boole, IntegrationMethod::boole,
        IntegrationMethod::trapezium, broadcast_integral);

    // do the surface integration
    spherical_extraction_lo.integrate();
    spherical_extraction_hi.integrate();

    int status = 0;
    amrex::Print() << std::setprecision(10);

    for (int iradius = 0;
         iradius < sim_params.extraction_params_lo.num_extraction_radii();
         ++iradius)
    {
        double r = sim_params.extraction_params_lo.extraction_radii()[iradius];
        double integral_re_lo_trapezium =
            (integral_lo_trapezium.first)[iradius];
        double integral_re_hi_trapezium =
            (integral_hi_trapezium.first)[iradius];
        double integral_re_lo_simpson = (integral_lo_simpson.first)[iradius];
        double integral_re_hi_simpson = (integral_hi_simpson.first)[iradius];
        double integral_re_lo_boole   = (integral_lo_boole.first)[iradius];
        double integral_re_hi_boole   = (integral_hi_boole.first)[iradius];
        double analytic_integral      = 1.0;

        double convergence_factor_trapezium =
            std::abs((integral_re_lo_trapezium - analytic_integral) /
                     (integral_re_hi_trapezium - analytic_integral));
        double convergence_factor_simpson =
            std::abs((integral_re_lo_simpson - analytic_integral) /
                     (integral_re_hi_simpson - analytic_integral));
        double convergence_factor_boole =
            std::abs((integral_re_lo_boole - analytic_integral) /
                     (integral_re_hi_boole - analytic_integral));

        double convergence_order_trapezium =
            std::log2(convergence_factor_trapezium);
        double convergence_order_simpson =
            std::log2(convergence_factor_simpson);
        double convergence_order_boole = std::log2(convergence_factor_boole);

        // trapezium rule should have second order convergence
        status |= (convergence_order_trapezium < 1.5);
        // Simpson's rule should have fourth order convergence
        status |= (convergence_order_simpson < 3.5);
        // Boole's rule should have sixth order convergence
        status |= (convergence_order_boole < 5.5);

        amrex::Print() << "At r = " << r << ":\n";
        amrex::Print() << "convergence_order_trapezium = "
                       << convergence_order_trapezium << "\n";
        amrex::Print() << "convergence_order_simpson = "
                       << convergence_order_simpson << "\n";
        amrex::Print() << "convergence_order_boole = "
                       << convergence_order_boole << "\n"
                       << endl;
    }

    return status;
}

int main(int argc, char *argv[])
{
    mainSetup(argc, argv);

    int status = runSphericalExtractionTest(argc, argv);

    if (status == 0)
        amrex::Print() << "SphericalExtractionTest test passed." << endl;
    else
        amrex::Print()
            << "SphericalExtractionTest test failed with return code " << status
            << endl;

    mainFinalize();
    return status;
}



================================================
FILE: Tests/.SphericalExtractionTest/SphericalExtractionTest.inputs
================================================
verbosity = 0
N1 = 32
N2 = 32
N3 = 32
L = 16

chk_prefix = TestChk_
plot_prefix = TestPlt_

max_level = 1
regrid_interval = 1 1 1 1 0 0 0 0 0
ref_ratio = 2 2 2 2 2 2 2 2 2
isPeriodic = 1 1 1

# Max and min box sizes
max_grid_size = 32
block_factor = 4
tag_buffer_size = 3
checkpoint_interval = 1

# extraction params
num_extraction_radii = 2
extraction_radii = 4. 6.
num_points_phi_lo = 12
num_points_theta_lo = 13

# Spherical Harmonic to set and extract
es = 0
el = 2
em = 0



================================================
FILE: Tests/.SphericalExtractionTest/SphericalExtractionTestLevel.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef SPHERICALEXTRACTIONTESTLEVEL_HPP_
#define SPHERICALEXTRACTIONTESTLEVEL_HPP_

#include "BoxLoops.hpp"
#include "GRAMRLevel.hpp"
#include "SetHarmonic.hpp"
#include "SetValue.hpp"
#include "StateVariables.hpp"

class SphericalExtractionTestLevel : public GRAMRLevel
{
    friend class DefaultLevelFactory<SphericalExtractionTestLevel>;
    // Inherit the contructors from GRAMRLevel
    using GRAMRLevel::GRAMRLevel;

    // initialize data
    virtual void initialData()
    {
        BoxLoops::loop(SetHarmonic(c_phi_Re, c_phi_Im, m_p.es, m_p.el, m_p.em,
                                   m_p.center, m_dx),
                       m_state_new, m_state_new, FILL_GHOST_CELLS);
    }

    virtual void specificEvalRHS(GRLevelData &a_soln, GRLevelData &a_rhs,
                                 const double a_time)
    {
    }

    virtual void computeTaggingCriterion(FArrayBox &tagging_criterion,
                                         const FArrayBox &current_state) {};
};

#endif /* SURFACEEXTRACTIONTESTLEVEL_HPP_ */



================================================
FILE: Tests/.SphericalExtractionTest/StateVariables.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef STATEVARIABLES_HPP
#define STATEVARIABLES_HPP

#include <array>
#include <string>

// assign enum to each variable
enum
{
    c_phi_Re,
    c_phi_Im,

    NUM_VARS
};

namespace StateVariables
{
static const amrex::Vector<std::string> names = {"phi_Re", "phi_Im"};
}

#endif /* STATEVARIABLES_HPP */



================================================
FILE: Tests/.SphericalExtractionTest/UserVariables.hpp
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */

#ifndef STATEVARIABLES_HPP
#define STATEVARIABLES_HPP

#include <array>
#include <string>

// assign enum to each variable
enum
{
    c_phi_Re,
    c_phi_Im,

    NUM_VARS
};

namespace StateVariables
{
static const amrex::Vector<std::string> variable_names = {"phi_Re", "phi_Im"};
}

#endif /* STATEVARIABLES_HPP */



================================================
FILE: Tools/CopyrightHeaders/add_copyright_headers
================================================
#!/bin/bash

# This script adds the copyright header passed in the first argument to any
# source files that don't have it already.

if [[ $# != 1 ]]; then
    echo "Usage: $0 <copyright header file>"
    exit 2
fi

status=0

# Use git to determine the root of the repo
REPO_ROOT=$(git rev-parse --show-toplevel)

copyright_header=$(cat $1)
num_lines=$(echo "$copyright_header" | wc -l)

for f in $(find $REPO_ROOT -type f -name "*.[h,c]pp" -not -path "$REPO_ROOT/External/*"); do
    if [[ $(head -n $num_lines $f) != $copyright_header ]]; then
        echo -e "${copyright_header}\n$(cat $f)" > $f
    fi
done

exit $status


================================================
FILE: Tools/CopyrightHeaders/check_copyright_headers
================================================
#!/bin/bash

# This script checks that all source files in the repo have the header in the
# file given in the first argument.

if [[ $# != 1 ]]; then
    echo "Usage: $0 <copyright header file>"
    exit 2
fi

status=0

# Use git to determine the root of the repo
REPO_ROOT=$(git rev-parse --show-toplevel)

copyright_header=$(cat $1)
num_lines=$(echo "$copyright_header" | wc -l)

for f in $(find $REPO_ROOT -type f -name "*.[h,c]pp" -not -path "$REPO_ROOT/External/*"); do
    if [[ $(head -n $num_lines $f) != $copyright_header ]]; then
        echo "$f does not have the correct copyright header. First $num_lines lines:"
        head -n $num_lines $f
        echo "-------------------------------------------"
        status=1
    fi
done

exit $status


================================================
FILE: Tools/CopyrightHeaders/copyright_header
================================================
/* GRTeclyn
 * Copyright 2022 The GRTL collaboration.
 * Please refer to LICENSE in GRTeclyn's root directory.
 */



================================================
FILE: Tools/Doxygen/README
================================================
To create the doxygen documentation install doxygen and then execute doxygen doxygen_config in this directory.



================================================
FILE: Tools/Doxygen/doxygen_config
================================================
# Doxyfile 1.8.13

# This file describes the settings to be used by the documentation system
# doxygen (www.doxygen.org) for a project.
#
# All text after a double hash (##) is considered a comment and is placed in
# front of the TAG it is preceding.
#
# All text after a single hash (#) is considered a comment and will be ignored.
# The format is:
# TAG = value [value, ...]
# For lists, items can also be appended using:
# TAG += value [value, ...]
# Values that contain spaces should be placed between quotes (\" \").

#---------------------------------------------------------------------------
# Project related configuration options
#---------------------------------------------------------------------------

# This tag specifies the encoding used for all characters in the config file
# that follow. The default is UTF-8 which is also the encoding used for all text
# before the first occurrence of this tag. Doxygen uses libiconv (or the iconv
# built into libc) for the transcoding. See http://www.gnu.org/software/libiconv
# for the list of possible encodings.
# The default value is: UTF-8.

DOXYFILE_ENCODING      = UTF-8

# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
# double-quotes, unless you are using Doxywizard) that should identify the
# project for which the documentation is generated. This name is used in the
# title of most generated pages and in a few other places.
# The default value is: My Project.

PROJECT_NAME           = "GRChombo"

# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
# could be handy for archiving the generated documentation or if some version
# control system is used.

PROJECT_NUMBER         =

# Using the PROJECT_BRIEF tag one can provide an optional one line description
# for a project that appears at the top of each page and should give viewer a
# quick idea about the purpose of the project. Keep the description short.

PROJECT_BRIEF          = "Numerical Relativity with Adaptive Mesh Refinement"

# With the PROJECT_LOGO tag one can specify a logo or an icon that is included
# in the documentation. The maximum height of the logo should not exceed 55
# pixels and the maximum width should not exceed 200 pixels. Doxygen will copy
# the logo to the output directory.

PROJECT_LOGO           =

# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
# into which the generated documentation will be written. If a relative path is
# entered, it will be relative to the location where doxygen was started. If
# left blank the current directory will be used.

OUTPUT_DIRECTORY       =

# If the CREATE_SUBDIRS tag is set to YES then doxygen will create 4096 sub-
# directories (in 2 levels) under the output directory of each output format and
# will distribute the generated files over these directories. Enabling this
# option can be useful when feeding doxygen a huge amount of source files, where
# putting all generated files in the same directory would otherwise causes
# performance problems for the file system.
# The default value is: NO.

CREATE_SUBDIRS         = NO

# If the ALLOW_UNICODE_NAMES tag is set to YES, doxygen will allow non-ASCII
# characters to appear in the names of generated files. If set to NO, non-ASCII
# characters will be escaped, for example _xE3_x81_x84 will be used for Unicode
# U+3044.
# The default value is: NO.

ALLOW_UNICODE_NAMES    = NO

# The OUTPUT_LANGUAGE tag is used to specify the language in which all
# documentation generated by doxygen is written. Doxygen will use this
# information to generate all constant output in the proper language.
# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,
# Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),
# Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,
# Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),
# Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,
# Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,
# Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,
# Ukrainian and Vietnamese.
# The default value is: English.

OUTPUT_LANGUAGE        = English

# If the BRIEF_MEMBER_DESC tag is set to YES, doxygen will include brief member
# descriptions after the members that are listed in the file and class
# documentation (similar to Javadoc). Set to NO to disable this.
# The default value is: YES.

BRIEF_MEMBER_DESC      = YES

# If the REPEAT_BRIEF tag is set to YES, doxygen will prepend the brief
# description of a member or function before the detailed description
#
# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
# brief descriptions will be completely suppressed.
# The default value is: YES.

REPEAT_BRIEF           = YES

# This tag implements a quasi-intelligent brief description abbreviator that is
# used to form the text in various listings. Each string in this list, if found
# as the leading text of the brief description, will be stripped from the text
# and the result, after processing the whole list, is used as the annotated
# text. Otherwise, the brief description is used as-is. If left blank, the
# following values are used ($name is automatically replaced with the name of
# the entity):The $name class, The $name widget, The $name file, is, provides,
# specifies, contains, represents, a, an and the.

ABBREVIATE_BRIEF       = "The $name class" \
                         "The $name widget" \
                         "The $name file" \
                         is \
                         provides \
                         specifies \
                         contains \
                         represents \
                         a \
                         an \
                         the

# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
# doxygen will generate a detailed section even if there is only a brief
# description.
# The default value is: NO.

ALWAYS_DETAILED_SEC    = NO

# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
# inherited members of a class in the documentation of that class as if those
# members were ordinary class members. Constructors, destructors and assignment
# operators of the base classes will not be shown.
# The default value is: NO.

INLINE_INHERITED_MEMB  = NO

# If the FULL_PATH_NAMES tag is set to YES, doxygen will prepend the full path
# before files name in the file list and in the header files. If set to NO the
# shortest path that makes the file name unique will be used
# The default value is: YES.

FULL_PATH_NAMES        = YES

# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
# Stripping is only done if one of the specified strings matches the left-hand
# part of the path. The tag can be used to show relative paths in the file list.
# If left blank the directory from which doxygen is run is used as the path to
# strip.
#
# Note that you can specify absolute paths here, but also relative paths, which
# will be relative from the directory where doxygen is started.
# This tag requires that the tag FULL_PATH_NAMES is set to YES.

STRIP_FROM_PATH        =

# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
# path mentioned in the documentation of a class, which tells the reader which
# header file to include in order to use a class. If left blank only the name of
# the header file containing the class definition is used. Otherwise one should
# specify the list of include paths that are normally passed to the compiler
# using the -I flag.

STRIP_FROM_INC_PATH    =

# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
# less readable) file names. This can be useful is your file systems doesn't
# support long names like on DOS, Mac, or CD-ROM.
# The default value is: NO.

SHORT_NAMES            = NO

# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
# first line (until the first dot) of a Javadoc-style comment as the brief
# description. If set to NO, the Javadoc-style will behave just like regular Qt-
# style comments (thus requiring an explicit @brief command for a brief
# description.)
# The default value is: NO.

JAVADOC_AUTOBRIEF      = YES

# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
# line (until the first dot) of a Qt-style comment as the brief description. If
# set to NO, the Qt-style will behave just like regular Qt-style comments (thus
# requiring an explicit \brief command for a brief description.)
# The default value is: NO.

QT_AUTOBRIEF           = NO

# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
# a brief description. This used to be the default behavior. The new default is
# to treat a multi-line C++ comment block as a detailed description. Set this
# tag to YES if you prefer the old behavior instead.
#
# Note that setting this tag to YES also means that rational rose comments are
# not recognized any more.
# The default value is: NO.

MULTILINE_CPP_IS_BRIEF = NO

# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
# documentation from any documented member that it re-implements.
# The default value is: YES.

INHERIT_DOCS           = YES

# If the SEPARATE_MEMBER_PAGES tag is set to YES then doxygen will produce a new
# page for each member. If set to NO, the documentation of a member will be part
# of the file/class/namespace that contains it.
# The default value is: NO.

SEPARATE_MEMBER_PAGES  = NO

# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
# uses this value to replace tabs by spaces in code fragments.
# Minimum value: 1, maximum value: 16, default value: 4.

TAB_SIZE               = 4

# This tag can be used to specify a number of aliases that act as commands in
# the documentation. An alias has the form:
# name=value
# For example adding
# "sideeffect=@par Side Effects:\n"
# will allow you to put the command \sideeffect (or @sideeffect) in the
# documentation, which will result in a user-defined paragraph with heading
# "Side Effects:". You can put \n's in the value part of an alias to insert
# newlines.

ALIASES                =

# This tag can be used to specify a number of word-keyword mappings (TCL only).
# A mapping has the form "name=value". For example adding "class=itcl::class"
# will allow you to use the command class in the itcl::class meaning.

TCL_SUBST              =

# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
# only. Doxygen will then generate output that is more tailored for C. For
# instance, some of the names that are used will be different. The list of all
# members will be omitted, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_FOR_C  = NO

# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
# Python sources only. Doxygen will then generate output that is more tailored
# for that language. For instance, namespaces will be presented as packages,
# qualified scopes will look different, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_JAVA   = NO

# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
# sources. Doxygen will then generate output that is tailored for Fortran.
# The default value is: NO.

OPTIMIZE_FOR_FORTRAN   = NO

# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
# sources. Doxygen will then generate output that is tailored for VHDL.
# The default value is: NO.

OPTIMIZE_OUTPUT_VHDL   = NO

# Doxygen selects the parser to use depending on the extension of the files it
# parses. With this tag you can assign which parser to use for a given
# extension. Doxygen has a built-in mapping, but you can override or extend it
# using this tag. The format is ext=language, where ext is a file extension, and
# language is one of the parsers supported by doxygen: IDL, Java, Javascript,
# C#, C, C++, D, PHP, Objective-C, Python, Fortran (fixed format Fortran:
# FortranFixed, free formatted Fortran: FortranFree, unknown formatted Fortran:
# Fortran. In the later case the parser tries to guess whether the code is fixed
# or free formatted code, this is the default for Fortran type files), VHDL. For
# instance to make doxygen treat .inc files as Fortran files (default is PHP),
# and .f files as C (default is Fortran), use: inc=Fortran f=C.
#
# Note: For files without extension you can use no_extension as a placeholder.
#
# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
# the files are not read by doxygen.

EXTENSION_MAPPING      =

# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
# according to the Markdown format, which allows for more readable
# documentation. See http://daringfireball.net/projects/markdown/ for details.
# The output of markdown processing is further processed by doxygen, so you can
# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
# case of backward compatibilities issues.
# The default value is: YES.

MARKDOWN_SUPPORT       = YES

# When the TOC_INCLUDE_HEADINGS tag is set to a non-zero value, all headings up
# to that level are automatically included in the table of contents, even if
# they do not have an id attribute.
# Note: This feature currently applies only to Markdown headings.
# Minimum value: 0, maximum value: 99, default value: 0.
# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.

TOC_INCLUDE_HEADINGS   = 0

# When enabled doxygen tries to link words that correspond to documented
# classes, or namespaces to their corresponding documentation. Such a link can
# be prevented in individual cases by putting a % sign in front of the word or
# globally by setting AUTOLINK_SUPPORT to NO.
# The default value is: YES.

AUTOLINK_SUPPORT       = YES

# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
# to include (a tag file for) the STL sources as input, then you should set this
# tag to YES in order to let doxygen match functions declarations and
# definitions whose arguments contain STL classes (e.g. func(std::string);
# versus func(std::string) {}). This also make the inheritance and collaboration
# diagrams that involve STL classes more complete and accurate.
# The default value is: NO.

BUILTIN_STL_SUPPORT    = NO

# If you use Microsoft's C++/CLI language, you should set this option to YES to
# enable parsing support.
# The default value is: NO.

CPP_CLI_SUPPORT        = NO

# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
# http://www.riverbankcomputing.co.uk/software/sip/intro) sources only. Doxygen
# will parse them like normal C++ but will assume all classes use public instead
# of private inheritance when no explicit protection keyword is present.
# The default value is: NO.

SIP_SUPPORT            = NO

# For Microsoft's IDL there are propget and propput attributes to indicate
# getter and setter methods for a property. Setting this option to YES will make
# doxygen to replace the get and set methods by a property in the documentation.
# This will only work if the methods are indeed getting or setting a simple
# type. If this is not the case, or you want to show the methods anyway, you
# should set this option to NO.
# The default value is: YES.

IDL_PROPERTY_SUPPORT   = YES

# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
# tag is set to YES then doxygen will reuse the documentation of the first
# member in the group (if any) for the other members of the group. By default
# all members of a group must be documented explicitly.
# The default value is: NO.

DISTRIBUTE_GROUP_DOC   = NO

# If one adds a struct or class to a group and this option is enabled, then also
# any nested class or struct is added to the same group. By default this option
# is disabled and one has to add nested compounds explicitly via \ingroup.
# The default value is: NO.

GROUP_NESTED_COMPOUNDS = NO

# Set the SUBGROUPING tag to YES to allow class member groups of the same type
# (for instance a group of public functions) to be put as a subgroup of that
# type (e.g. under the Public Functions section). Set it to NO to prevent
# subgrouping. Alternatively, this can be done per class using the
# \nosubgrouping command.
# The default value is: YES.

SUBGROUPING            = YES

# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
# are shown inside the group in which they are included (e.g. using \ingroup)
# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
# and RTF).
#
# Note that this feature does not work in combination with
# SEPARATE_MEMBER_PAGES.
# The default value is: NO.

INLINE_GROUPED_CLASSES = NO

# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
# with only public data fields or simple typedef fields will be shown inline in
# the documentation of the scope in which they are defined (i.e. file,
# namespace, or group documentation), provided this scope is documented. If set
# to NO, structs, classes, and unions are shown on a separate page (for HTML and
# Man pages) or section (for LaTeX and RTF).
# The default value is: NO.

INLINE_SIMPLE_STRUCTS  = NO

# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
# enum is documented as struct, union, or enum with the name of the typedef. So
# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
# with name TypeT. When disabled the typedef will appear as a member of a file,
# namespace, or class. And the struct will be named TypeS. This can typically be
# useful for C code in case the coding convention dictates that all compound
# types are typedef'ed and only the typedef is referenced, never the tag name.
# The default value is: NO.

TYPEDEF_HIDES_STRUCT   = NO

# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
# cache is used to resolve symbols given their name and scope. Since this can be
# an expensive process and often the same symbol appears multiple times in the
# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
# doxygen will become slower. If the cache is too large, memory is wasted. The
# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
# symbols. At the end of a run doxygen will report the cache usage and suggest
# the optimal cache size from a speed point of view.
# Minimum value: 0, maximum value: 9, default value: 0.

LOOKUP_CACHE_SIZE      = 0

#---------------------------------------------------------------------------
# Build related configuration options
#---------------------------------------------------------------------------

# If the EXTRACT_ALL tag is set to YES, doxygen will assume all entities in
# documentation are documented, even if no documentation was available. Private
# class members and static file members will be hidden unless the
# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
# Note: This will also disable the warnings about undocumented members that are
# normally produced when WARNINGS is set to YES.
# The default value is: NO.

EXTRACT_ALL            = YES

# If the EXTRACT_PRIVATE tag is set to YES, all private members of a class will
# be included in the documentation.
# The default value is: NO.

EXTRACT_PRIVATE        = YES

# If the EXTRACT_PACKAGE tag is set to YES, all members with package or internal
# scope will be included in the documentation.
# The default value is: NO.

EXTRACT_PACKAGE        = NO

# If the EXTRACT_STATIC tag is set to YES, all static members of a file will be
# included in the documentation.
# The default value is: NO.

EXTRACT_STATIC         = NO

# If the EXTRACT_LOCAL_CLASSES tag is set to YES, classes (and structs) defined
# locally in source files will be included in the documentation. If set to NO,
# only classes defined in header files are included. Does not have any effect
# for Java sources.
# The default value is: YES.

EXTRACT_LOCAL_CLASSES  = YES

# This flag is only useful for Objective-C code. If set to YES, local methods,
# which are defined in the implementation section but not in the interface are
# included in the documentation. If set to NO, only methods in the interface are
# included.
# The default value is: NO.

EXTRACT_LOCAL_METHODS  = NO

# If this flag is set to YES, the members of anonymous namespaces will be
# extracted and appear in the documentation as a namespace called
# 'anonymous_namespace{file}', where file will be replaced with the base name of
# the file that contains the anonymous namespace. By default anonymous namespace
# are hidden.
# The default value is: NO.

EXTRACT_ANON_NSPACES   = NO

# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
# undocumented members inside documented classes or files. If set to NO these
# members will be included in the various overviews, but no documentation
# section is generated. This option has no effect if EXTRACT_ALL is enabled.
# The default value is: NO.

HIDE_UNDOC_MEMBERS     = NO

# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
# undocumented classes that are normally visible in the class hierarchy. If set
# to NO, these classes will be included in the various overviews. This option
# has no effect if EXTRACT_ALL is enabled.
# The default value is: NO.

HIDE_UNDOC_CLASSES     = NO

# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
# (class|struct|union) declarations. If set to NO, these declarations will be
# included in the documentation.
# The default value is: NO.

HIDE_FRIEND_COMPOUNDS  = NO

# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
# documentation blocks found inside the body of a function. If set to NO, these
# blocks will be appended to the function's detailed documentation block.
# The default value is: NO.

HIDE_IN_BODY_DOCS      = NO

# The INTERNAL_DOCS tag determines if documentation that is typed after a
# \internal command is included. If the tag is set to NO then the documentation
# will be excluded. Set it to YES to include the internal documentation.
# The default value is: NO.

INTERNAL_DOCS          = NO

# If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file
# names in lower-case letters. If set to YES, upper-case letters are also
# allowed. This is useful if you have classes or files whose names only differ
# in case and if your file system supports case sensitive file names. Windows
# and Mac users are advised to set this option to NO.
# The default value is: system dependent.

CASE_SENSE_NAMES       = NO

# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
# their full class and namespace scopes in the documentation. If set to YES, the
# scope will be hidden.
# The default value is: NO.

HIDE_SCOPE_NAMES       = NO

# If the HIDE_COMPOUND_REFERENCE tag is set to NO (default) then doxygen will
# append additional text to a page's title, such as Class Reference. If set to
# YES the compound reference will be hidden.
# The default value is: NO.

HIDE_COMPOUND_REFERENCE= NO

# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
# the files that are included by a file in the documentation of that file.
# The default value is: YES.

SHOW_INCLUDE_FILES     = YES

# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
# grouped member an include statement to the documentation, telling the reader
# which file to include in order to use the member.
# The default value is: NO.

SHOW_GROUPED_MEMB_INC  = NO

# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
# files with double quotes in the documentation rather than with sharp brackets.
# The default value is: NO.

FORCE_LOCAL_INCLUDES   = NO

# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
# documentation for inline members.
# The default value is: YES.

INLINE_INFO            = YES

# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
# (detailed) documentation of file and class members alphabetically by member
# name. If set to NO, the members will appear in declaration order.
# The default value is: YES.

SORT_MEMBER_DOCS       = YES

# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
# descriptions of file, namespace and class members alphabetically by member
# name. If set to NO, the members will appear in declaration order. Note that
# this will also influence the order of the classes in the class list.
# The default value is: NO.

SORT_BRIEF_DOCS        = NO

# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
# (brief and detailed) documentation of class members so that constructors and
# destructors are listed first. If set to NO the constructors will appear in the
# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
# member documentation.
# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
# detailed member documentation.
# The default value is: NO.

SORT_MEMBERS_CTORS_1ST = NO

# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
# of group names into alphabetical order. If set to NO the group names will
# appear in their defined order.
# The default value is: NO.

SORT_GROUP_NAMES       = NO

# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
# fully-qualified names, including namespaces. If set to NO, the class list will
# be sorted only by class name, not including the namespace part.
# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
# Note: This option applies only to the class list, not to the alphabetical
# list.
# The default value is: NO.

SORT_BY_SCOPE_NAME     = NO

# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
# type resolution of all parameters of a function it will reject a match between
# the prototype and the implementation of a member function even if there is
# only one candidate or it is obvious which candidate to choose by doing a
# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
# accept a match between prototype and implementation in such cases.
# The default value is: NO.

STRICT_PROTO_MATCHING  = NO

# The GENERATE_TODOLIST tag can be used to enable (YES) or disable (NO) the todo
# list. This list is created by putting \todo commands in the documentation.
# The default value is: YES.

GENERATE_TODOLIST      = YES

# The GENERATE_TESTLIST tag can be used to enable (YES) or disable (NO) the test
# list. This list is created by putting \test commands in the documentation.
# The default value is: YES.

GENERATE_TESTLIST      = YES

# The GENERATE_BUGLIST tag can be used to enable (YES) or disable (NO) the bug
# list. This list is created by putting \bug commands in the documentation.
# The default value is: YES.

GENERATE_BUGLIST       = YES

# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or disable (NO)
# the deprecated list. This list is created by putting \deprecated commands in
# the documentation.
# The default value is: YES.

GENERATE_DEPRECATEDLIST= YES

# The ENABLED_SECTIONS tag can be used to enable conditional documentation
# sections, marked by \if <section_label> ... \endif and \cond <section_label>
# ... \endcond blocks.

ENABLED_SECTIONS       =

# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
# initial value of a variable or macro / define can have for it to appear in the
# documentation. If the initializer consists of more lines than specified here
# it will be hidden. Use a value of 0 to hide initializers completely. The
# appearance of the value of individual variables and macros / defines can be
# controlled using \showinitializer or \hideinitializer command in the
# documentation regardless of this setting.
# Minimum value: 0, maximum value: 10000, default value: 30.

MAX_INITIALIZER_LINES  = 30

# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
# the bottom of the documentation of classes and structs. If set to YES, the
# list will mention the files that were used to generate the documentation.
# The default value is: YES.

SHOW_USED_FILES        = YES

# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
# will remove the Files entry from the Quick Index and from the Folder Tree View
# (if specified).
# The default value is: YES.

SHOW_FILES             = YES

# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
# page. This will remove the Namespaces entry from the Quick Index and from the
# Folder Tree View (if specified).
# The default value is: YES.

SHOW_NAMESPACES        = YES

# The FILE_VERSION_FILTER tag can be used to specify a program or script that
# doxygen should invoke to get the current version for each file (typically from
# the version control system). Doxygen will invoke the program by executing (via
# popen()) the command command input-file, where command is the value of the
# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
# by doxygen. Whatever the program writes to standard output is used as the file
# version. For an example see the documentation.

FILE_VERSION_FILTER    =

# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
# by doxygen. The layout file controls the global structure of the generated
# output files in an output format independent way. To create the layout file
# that represents doxygen's defaults, run doxygen with the -l option. You can
# optionally specify a file name after the option, if omitted DoxygenLayout.xml
# will be used as the name of the layout file.
#
# Note that if you run doxygen from a directory containing a file called
# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
# tag is left empty.

LAYOUT_FILE            =

# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
# the reference definitions. This must be a list of .bib files. The .bib
# extension is automatically appended if omitted. This requires the bibtex tool
# to be installed. See also http://en.wikipedia.org/wiki/BibTeX for more info.
# For LaTeX the style of the bibliography can be controlled using
# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
# search path. See also \cite for info how to create references.

CITE_BIB_FILES         =

#---------------------------------------------------------------------------
# Configuration options related to warning and progress messages
#---------------------------------------------------------------------------

# The QUIET tag can be used to turn on/off the messages that are generated to
# standard output by doxygen. If QUIET is set to YES this implies that the
# messages are off.
# The default value is: NO.

QUIET                  = NO

# The WARNINGS tag can be used to turn on/off the warning messages that are
# generated to standard error (stderr) by doxygen. If WARNINGS is set to YES
# this implies that the warnings are on.
#
# Tip: Turn warnings on while writing the documentation.
# The default value is: YES.

WARNINGS               = YES

# If the WARN_IF_UNDOCUMENTED tag is set to YES then doxygen will generate
# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
# will automatically be disabled.
# The default value is: YES.

WARN_IF_UNDOCUMENTED   = YES

# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
# potential errors in the documentation, such as not documenting some parameters
# in a documented function, or documenting parameters that don't exist or using
# markup commands wrongly.
# The default value is: YES.

WARN_IF_DOC_ERROR      = YES

# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
# are documented, but have no documentation for their parameters or return
# value. If set to NO, doxygen will only warn about wrong or incomplete
# parameter documentation, but not about the absence of documentation.
# The default value is: NO.

WARN_NO_PARAMDOC       = NO

# If the WARN_AS_ERROR tag is set to YES then doxygen will immediately stop when
# a warning is encountered.
# The default value is: NO.

WARN_AS_ERROR          = NO

# The WARN_FORMAT tag determines the format of the warning messages that doxygen
# can produce. The string should contain the $file, $line, and $text tags, which
# will be replaced by the file and line number from which the warning originated
# and the warning text. Optionally the format may contain $version, which will
# be replaced by the version of the file (if it could be obtained via
# FILE_VERSION_FILTER)
# The default value is: $file:$line: $text.

WARN_FORMAT            = "$file:$line: $text"

# The WARN_LOGFILE tag can be used to specify a file to which warning and error
# messages should be written. If left blank the output is written to standard
# error (stderr).

WARN_LOGFILE           =

#---------------------------------------------------------------------------
# Configuration options related to the input files
#---------------------------------------------------------------------------

# The INPUT tag is used to specify the files and/or directories that contain
# documented source files. You may enter file names like myfile.cpp or
# directories like /usr/src/myproject. Separate the files or directories with
# spaces. See also FILE_PATTERNS and EXTENSION_MAPPING
# Note: If this tag is empty the current directory is searched.

INPUT                  = ../

# This tag can be used to specify the character encoding of the source files
# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
# documentation (see: http://www.gnu.org/software/libiconv) for the list of
# possible encodings.
# The default value is: UTF-8.

INPUT_ENCODING         = UTF-8

# If the value of the INPUT tag contains directories, you can use the
# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
# *.h) to filter out the source-files in the directories.
#
# Note that for custom extensions or not directly supported extensions you also
# need to set EXTENSION_MAPPING for the extension otherwise the files are not
# read by doxygen.
#
# If left blank the following patterns are tested:*.c, *.cc, *.cxx, *.cpp,
# *.c++, *.java, *.ii, *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h,
# *.hh, *.hxx, *.hpp, *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc,
# *.m, *.markdown, *.md, *.mm, *.dox, *.py, *.pyw, *.f90, *.f95, *.f03, *.f08,
# *.f, *.for, *.tcl, *.vhd, *.vhdl, *.ucf and *.qsf.

FILE_PATTERNS          = *.c \
                         *.cc \
                         *.cxx \
                         *.cpp \
                         *.c++ \
                         *.java \
                         *.ii \
                         *.ixx \
                         *.ipp \
                         *.i++ \
                         *.inl \
                         *.idl \
                         *.ddl \
                         *.odl \
                         *.h \
                         *.hh \
                         *.hxx \
                         *.hpp \
                         *.impl.hpp \
                         *.h++ \
                         *.cs \
                         *.d \
                         *.php \
                         *.php4 \
                         *.php5 \
                         *.phtml \
                         *.inc \
                         *.m \
                         *.markdown \
                         *.md \
                         *.mm \
                         *.dox \
                         *.py \
                         *.pyw \
                         *.f90 \
                         *.f95 \
                         *.f03 \
                         *.f08 \
                         *.f \
                         *.for \
                         *.tcl \
                         *.vhd \
                         *.vhdl \
                         *.ucf \
                         *.qsf

# The RECURSIVE tag can be used to specify whether or not subdirectories should
# be searched for input files as well.
# The default value is: NO.

RECURSIVE              = YES

# The EXCLUDE tag can be used to specify files and/or directories that should be
# excluded from the INPUT source files. This way you can easily exclude a
# subdirectory from a directory tree whose root is specified with the INPUT tag.
#
# Note that relative paths are relative to the directory from which doxygen is
# run.

EXCLUDE                = html/

# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
# directories that are symbolic links (a Unix file system feature) are excluded
# from the input.
# The default value is: NO.

EXCLUDE_SYMLINKS       = NO

# If the value of the INPUT tag contains directories, you can use the
# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
# certain files from those directories.
#
# Note that the wildcards are matched against the file with absolute path, so to
# exclude all test directories for example use the pattern */test/*

EXCLUDE_PATTERNS       =

# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
# (namespaces, classes, functions, etc.) that should be excluded from the
# output. The symbol name can be a fully qualified name, a word, or if the
# wildcard * is used, a substring. Examples: ANamespace, AClass,
# AClass::ANamespace, ANamespace::*Test
#
# Note that the wildcards are matched against the file with absolute path, so to
# exclude all test directories use the pattern */test/*

EXCLUDE_SYMBOLS        = _*

# The EXAMPLE_PATH tag can be used to specify one or more files or directories
# that contain example code fragments that are included (see the \include
# command).

EXAMPLE_PATH           =

# If the value of the EXAMPLE_PATH tag contains directories, you can use the
# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
# *.h) to filter out the source-files in the directories. If left blank all
# files are included.

EXAMPLE_PATTERNS       = *

# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
# searched for input files to be used with the \include or \dontinclude commands
# irrespective of the value of the RECURSIVE tag.
# The default value is: NO.

EXAMPLE_RECURSIVE      = NO

# The IMAGE_PATH tag can be used to specify one or more files or directories
# that contain images that are to be included in the documentation (see the
# \image command).

IMAGE_PATH             =

# The INPUT_FILTER tag can be used to specify a program that doxygen should
# invoke to filter for each input file. Doxygen will invoke the filter program
# by executing (via popen()) the command:
#
# <filter> <input-file>
#
# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
# name of an input file. Doxygen will then use the output that the filter
# program writes to standard output. If FILTER_PATTERNS is specified, this tag
# will be ignored.
#
# Note that the filter must not add or remove lines; it is applied before the
# code is scanned, but not when the output code is generated. If lines are added
# or removed, the anchors will not be placed correctly.
#
# Note that for custom extensions or not directly supported extensions you also
# need to set EXTENSION_MAPPING for the extension otherwise the files are not
# properly processed by doxygen.

INPUT_FILTER           =

# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
# basis. Doxygen will compare the file name with each pattern and apply the
# filter if there is a match. The filters are a list of the form: pattern=filter
# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
# patterns match the file name, INPUT_FILTER is applied.
#
# Note that for custom extensions or not directly supported extensions you also
# need to set EXTENSION_MAPPING for the extension otherwise the files are not
# properly processed by doxygen.

FILTER_PATTERNS        =

# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
# INPUT_FILTER) will also be used to filter the input files that are used for
# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
# The default value is: NO.

FILTER_SOURCE_FILES    = NO

# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
# it is also possible to disable source filtering for a specific pattern using
# *.ext= (so without naming a filter).
# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.

FILTER_SOURCE_PATTERNS =

# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
# is part of the input, its contents will be placed on the main page
# (index.html). This can be useful if you have a project on for instance GitHub
# and want to reuse the introduction page also for the doxygen output.

USE_MDFILE_AS_MAINPAGE =

#---------------------------------------------------------------------------
# Configuration options related to source browsing
#---------------------------------------------------------------------------

# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
# generated. Documented entities will be cross-referenced with these sources.
#
# Note: To get rid of all source code in the generated output, make sure that
# also VERBATIM_HEADERS is set to NO.
# The default value is: NO.

SOURCE_BROWSER         = NO

# Setting the INLINE_SOURCES tag to YES will include the body of functions,
# classes and enums directly into the documentation.
# The default value is: NO.

INLINE_SOURCES         = NO

# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
# special comment blocks from generated source code fragments. Normal C, C++ and
# Fortran comments will always remain visible.
# The default value is: YES.

STRIP_CODE_COMMENTS    = YES

# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
# function all documented functions referencing it will be listed.
# The default value is: NO.

REFERENCED_BY_RELATION = NO

# If the REFERENCES_RELATION tag is set to YES then for each documented function
# all documented entities called/used by that function will be listed.
# The default value is: NO.

REFERENCES_RELATION    = NO

# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
# to YES then the hyperlinks from functions in REFERENCES_RELATION and
# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
# link to the documentation.
# The default value is: YES.

REFERENCES_LINK_SOURCE = YES

# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
# source code will show a tooltip with additional information such as prototype,
# brief description and links to the definition and documentation. Since this
# will make the HTML file larger and loading of large files a bit slower, you
# can opt to disable this feature.
# The default value is: YES.
# This tag requires that the tag SOURCE_BROWSER is set to YES.

SOURCE_TOOLTIPS        = YES

# If the USE_HTAGS tag is set to YES then the references to source code will
# point to the HTML generated by the htags(1) tool instead of doxygen built-in
# source browser. The htags tool is part of GNU's global source tagging system
# (see http://www.gnu.org/software/global/global.html). You will need version
# 4.8.6 or higher.
#
# To use it do the following:
# - Install the latest version of global
# - Enable SOURCE_BROWSER and USE_HTAGS in the config file
# - Make sure the INPUT points to the root of the source tree
# - Run doxygen as normal
#
# Doxygen will invoke htags (and that will in turn invoke gtags), so these
# tools must be available from the command line (i.e. in the search path).
#
# The result: instead of the source browser generated by doxygen, the links to
# source code will now point to the output of htags.
# The default value is: NO.
# This tag requires that the tag SOURCE_BROWSER is set to YES.

USE_HTAGS              = NO

# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
# verbatim copy of the header file for each class for which an include is
# specified. Set to NO to disable this.
# See also: Section \class.
# The default value is: YES.

VERBATIM_HEADERS       = YES

#---------------------------------------------------------------------------
# Configuration options related to the alphabetical class index
#---------------------------------------------------------------------------

# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
# compounds will be generated. Enable this if the project contains a lot of
# classes, structs, unions or interfaces.
# The default value is: YES.

ALPHABETICAL_INDEX     = YES

# The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in
# which the alphabetical index list will be split.
# Minimum value: 1, maximum value: 20, default value: 5.
# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.

COLS_IN_ALPHA_INDEX    = 5

# In case all classes in a project start with a common prefix, all classes will
# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag
# can be used to specify a prefix (or a list of prefixes) that should be ignored
# while generating the index headers.
# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.

IGNORE_PREFIX          =

#---------------------------------------------------------------------------
# Configuration options related to the HTML output
#---------------------------------------------------------------------------

# If the GENERATE_HTML tag is set to YES, doxygen will generate HTML output
# The default value is: YES.

GENERATE_HTML          = YES

# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: html.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_OUTPUT            = html

# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
# generated HTML page (for example: .htm, .php, .asp).
# The default value is: .html.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FILE_EXTENSION    = .html

# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
# each generated HTML page. If the tag is left blank doxygen will generate a
# standard header.
#
# To get valid HTML the header file that includes any scripts and style sheets
# that doxygen needs, which is dependent on the configuration options used (e.g.
# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
# default header using
# doxygen -w html new_header.html new_footer.html new_stylesheet.css
# YourConfigFile
# and then modify the file new_header.html. See also section "Doxygen usage"
# for information on how to generate the default header that doxygen normally
# uses.
# Note: The header is subject to change so you typically have to regenerate the
# default header when upgrading to a newer version of doxygen. For a description
# of the possible markers and block names see the documentation.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_HEADER            =

# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
# generated HTML page. If the tag is left blank doxygen will generate a standard
# footer. See HTML_HEADER for more information on how to generate a default
# footer and what special commands can be used inside the footer. See also
# section "Doxygen usage" for information on how to generate the default footer
# that doxygen normally uses.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FOOTER            =

# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
# sheet that is used by each HTML page. It can be used to fine-tune the look of
# the HTML output. If left blank doxygen will generate a default style sheet.
# See also section "Doxygen usage" for information on how to generate the style
# sheet that doxygen normally uses.
# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
# it is more robust and this tag (HTML_STYLESHEET) will in the future become
# obsolete.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_STYLESHEET        =

# The HTML_EXTRA_STYLESHEET tag can be used to specify additional user-defined
# cascading style sheets that are included after the standard style sheets
# created by doxygen. Using this option one can overrule certain style aspects.
# This is preferred over using HTML_STYLESHEET since it does not replace the
# standard style sheet and is therefore more robust against future updates.
# Doxygen will copy the style sheet files to the output directory.
# Note: The order of the extra style sheet files is of importance (e.g. the last
# style sheet in the list overrules the setting of the previous ones in the
# list). For an example see the documentation.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_EXTRA_STYLESHEET  =

# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the HTML output directory. Note
# that these files will be copied to the base HTML output directory. Use the
# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
# files will be copied as-is; there are no commands or markers available.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_EXTRA_FILES       =

# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
# will adjust the colors in the style sheet and background images according to
# this color. Hue is specified as an angle on a colorwheel, see
# http://en.wikipedia.org/wiki/Hue for more information. For instance the value
# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
# purple, and 360 is red again.
# Minimum value: 0, maximum value: 359, default value: 220.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_HUE    = 220

# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
# in the HTML output. For a value of 0 the output will use grayscales only. A
# value of 255 will produce the most vivid colors.
# Minimum value: 0, maximum value: 255, default value: 100.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_SAT    = 100

# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
# luminance component of the colors in the HTML output. Values below 100
# gradually make the output lighter, whereas values above 100 make the output
# darker. The value divided by 100 is the actual gamma applied, so 80 represents
# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
# change the gamma.
# Minimum value: 40, maximum value: 240, default value: 80.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_GAMMA  = 80

# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
# page will contain the date and time when the page was generated. Setting this
# to YES can help to show when doxygen was last run and thus if the
# documentation is up to date.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_TIMESTAMP         = NO

# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
# documentation will contain sections that can be hidden and shown after the
# page has loaded.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_DYNAMIC_SECTIONS  = NO

# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
# shown in the various tree structured indices initially; the user can expand
# and collapse entries dynamically later on. Doxygen will expand the tree to
# such a level that at most the specified number of entries are visible (unless
# a fully collapsed tree already exceeds this amount). So setting the number of
# entries 1 will produce a full collapsed tree by default. 0 is a special value
# representing an infinite number of entries and will result in a full expanded
# tree by default.
# Minimum value: 0, maximum value: 9999, default value: 100.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_INDEX_NUM_ENTRIES = 100

# If the GENERATE_DOCSET tag is set to YES, additional index files will be
# generated that can be used as input for Apple's Xcode 3 integrated development
# environment (see: http://developer.apple.com/tools/xcode/), introduced with
# OSX 10.5 (Leopard). To create a documentation set, doxygen will generate a
# Makefile in the HTML output directory. Running make will produce the docset in
# that directory and running make install will install the docset in
# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
# startup. See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html
# for more information.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_DOCSET        = NO

# This tag determines the name of the docset feed. A documentation feed provides
# an umbrella under which multiple documentation sets from a single provider
# (such as a company or product suite) can be grouped.
# The default value is: Doxygen generated docs.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_FEEDNAME        = "Doxygen generated docs"

# This tag specifies a string that should uniquely identify the documentation
# set bundle. This should be a reverse domain-name style string, e.g.
# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_BUNDLE_ID       = org.doxygen.Project

# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
# the documentation publisher. This should be a reverse domain-name style
# string, e.g. com.mycompany.MyDocSet.documentation.
# The default value is: org.doxygen.Publisher.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_PUBLISHER_ID    = org.doxygen.Publisher

# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
# The default value is: Publisher.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_PUBLISHER_NAME  = Publisher

# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
# (see: http://www.microsoft.com/en-us/download/details.aspx?id=21138) on
# Windows.
#
# The HTML Help Workshop contains a compiler that can convert all HTML output
# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
# files are now used as the Windows 98 help format, and will replace the old
# Windows help format (.hlp) on all Windows platforms in the future. Compressed
# HTML files also contain an index, a table of contents, and you can search for
# words in the documentation. The HTML workshop also contains a viewer for
# compressed HTML files.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_HTMLHELP      = NO

# The CHM_FILE tag can be used to specify the file name of the resulting .chm
# file. You can add a path in front of the file if the result should not be
# written to the html output directory.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

CHM_FILE               =

# The HHC_LOCATION tag can be used to specify the location (absolute path
# including file name) of the HTML help compiler (hhc.exe). If non-empty,
# doxygen will try to run the HTML help compiler on the generated index.hhp.
# The file has to be specified with full path.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

HHC_LOCATION           =

# The GENERATE_CHI flag controls if a separate .chi index file is generated
# (YES) or that it should be included in the master .chm file (NO).
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

GENERATE_CHI           = NO

# The CHM_INDEX_ENCODING is used to encode HtmlHelp index (hhk), content (hhc)
# and project file content.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

CHM_INDEX_ENCODING     =

# The BINARY_TOC flag controls whether a binary table of contents is generated
# (YES) or a normal table of contents (NO) in the .chm file. Furthermore it
# enables the Previous and Next buttons.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

BINARY_TOC             = NO

# The TOC_EXPAND flag can be set to YES to add extra items for group members to
# the table of contents of the HTML help documentation and to the tree view.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

TOC_EXPAND             = NO

# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
# (.qch) of the generated HTML documentation.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_QHP           = NO

# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
# the file name of the resulting .qch file. The path specified is relative to
# the HTML output folder.
# This tag requires that the tag GENERATE_QHP is set to YES.

QCH_FILE               =

# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
# Project output. For more information please see Qt Help Project / Namespace
# (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#namespace).
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_NAMESPACE          = org.doxygen.Project

# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
# Help Project output. For more information please see Qt Help Project / Virtual
# Folders (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#virtual-
# folders).
# The default value is: doc.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_VIRTUAL_FOLDER     = doc

# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
# filter to add. For more information please see Qt Help Project / Custom
# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
# filters).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_CUST_FILTER_NAME   =

# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
# custom filter to add. For more information please see Qt Help Project / Custom
# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
# filters).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_CUST_FILTER_ATTRS  =

# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
# project's filter section matches. Qt Help Project / Filter Attributes (see:
# http://qt-project.org/doc/qt-4.8/qthelpproject.html#filter-attributes).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_SECT_FILTER_ATTRS  =

# The QHG_LOCATION tag can be used to specify the location of Qt's
# qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the
# generated .qhp file.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHG_LOCATION           =

# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
# generated, together with the HTML files, they form an Eclipse help plugin. To
# install this plugin and make it available under the help contents menu in
# Eclipse, the contents of the directory containing the HTML and XML files needs
# to be copied into the plugins directory of eclipse. The name of the directory
# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
# After copying Eclipse needs to be restarted before the help appears.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_ECLIPSEHELP   = NO

# A unique identifier for the Eclipse help plugin. When installing the plugin
# the directory name containing the HTML and XML files should also have this
# name. Each documentation set should have its own identifier.
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.

ECLIPSE_DOC_ID         = org.doxygen.Project

# If you want full control over the layout of the generated HTML pages it might
# be necessary to disable the index and replace it with your own. The
# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
# of each HTML page. A value of NO enables the index and the value YES disables
# it. Since the tabs in the index contain the same information as the navigation
# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

DISABLE_INDEX          = NO

# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
# structure should be generated to display hierarchical information. If the tag
# value is set to YES, a side panel will be generated containing a tree-like
# index structure (just like the one that is generated for HTML Help). For this
# to work a browser that supports JavaScript, DHTML, CSS and frames is required
# (i.e. any modern browser). Windows users are probably better off using the
# HTML help feature. Via custom style sheets (see HTML_EXTRA_STYLESHEET) one can
# further fine-tune the look of the index. As an example, the default style
# sheet generated by doxygen has an example that shows how to put an image at
# the root of the tree instead of the PROJECT_NAME. Since the tree basically has
# the same information as the tab index, you could consider setting
# DISABLE_INDEX to YES when enabling this option.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_TREEVIEW      = NO

# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
# doxygen will group on one line in the generated HTML documentation.
#
# Note that a value of 0 will completely suppress the enum values from appearing
# in the overview section.
# Minimum value: 0, maximum value: 20, default value: 4.
# This tag requires that the tag GENERATE_HTML is set to YES.

ENUM_VALUES_PER_LINE   = 4

# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
# to set the initial width (in pixels) of the frame in which the tree is shown.
# Minimum value: 0, maximum value: 1500, default value: 250.
# This tag requires that the tag GENERATE_HTML is set to YES.

TREEVIEW_WIDTH         = 250

# If the EXT_LINKS_IN_WINDOW option is set to YES, doxygen will open links to
# external symbols imported via tag files in a separate window.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

EXT_LINKS_IN_WINDOW    = NO

# Use this tag to change the font size of LaTeX formulas included as images in
# the HTML documentation. When you change the font size after a successful
# doxygen run you need to manually remove any form_*.png images from the HTML
# output directory to force them to be regenerated.
# Minimum value: 8, maximum value: 50, default value: 10.
# This tag requires that the tag GENERATE_HTML is set to YES.

FORMULA_FONTSIZE       = 10

# Use the FORMULA_TRANPARENT tag to determine whether or not the images
# generated for formulas are transparent PNGs. Transparent PNGs are not
# supported properly for IE 6.0, but are supported on all modern browsers.
#
# Note that when changing this option you need to delete any form_*.png files in
# the HTML output directory before the changes have effect.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

FORMULA_TRANSPARENT    = YES

# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
# http://www.mathjax.org) which uses client side Javascript for the rendering
# instead of using pre-rendered bitmaps. Use this if you do not have LaTeX
# installed or if you want to formulas look prettier in the HTML output. When
# enabled you may also need to install MathJax separately and configure the path
# to it using the MATHJAX_RELPATH option.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

USE_MATHJAX            = NO

# When MathJax is enabled you can set the default output format to be used for
# the MathJax output. See the MathJax site (see:
# http://docs.mathjax.org/en/latest/output.html) for more details.
# Possible values are: HTML-CSS (which is slower, but has the best
# compatibility), NativeMML (i.e. MathML) and SVG.
# The default value is: HTML-CSS.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_FORMAT         = HTML-CSS

# When MathJax is enabled you need to specify the location relative to the HTML
# output directory using the MATHJAX_RELPATH option. The destination directory
# should contain the MathJax.js script. For instance, if the mathjax directory
# is located at the same level as the HTML output directory, then
# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
# Content Delivery Network so you can quickly see the result without installing
# MathJax. However, it is strongly recommended to install a local copy of
# MathJax from http://www.mathjax.org before deployment.
# The default value is: http://cdn.mathjax.org/mathjax/latest.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest

# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
# extension names that should be enabled during MathJax rendering. For example
# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_EXTENSIONS     =

# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
# of code that will be used on startup of the MathJax code. See the MathJax site
# (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an
# example see the documentation.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_CODEFILE       =

# When the SEARCHENGINE tag is enabled doxygen will generate a search box for
# the HTML output. The underlying search engine uses javascript and DHTML and
# should work on any modern browser. Note that when using HTML help
# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
# there is already a search function so this one should typically be disabled.
# For large projects the javascript based search engine can be slow, then
# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
# search using the keyboard; to jump to the search box use <access key> + S
# (what the <access key> is depends on the OS and browser, but it is typically
# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
# key> to jump into the search results window, the results can be navigated
# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
# the search. The filter options can be selected when the cursor is inside the
# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
# to select a filter and <Enter> or <escape> to activate or cancel the filter
# option.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

SEARCHENGINE           = YES

# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
# implemented using a web server instead of a web client using Javascript. There
# are two flavors of web server based searching depending on the EXTERNAL_SEARCH
# setting. When disabled, doxygen will generate a PHP script for searching and
# an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing
# and searching needs to be provided by external tools. See the section
# "External Indexing and Searching" for details.
# The default value is: NO.
# This tag requires that the tag SEARCHENGINE is set to YES.

SERVER_BASED_SEARCH    = NO

# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
# script for searching. Instead the search results are written to an XML file
# which needs to be processed by an external indexer. Doxygen will invoke an
# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
# search results.
#
# Doxygen ships with an example indexer (doxyindexer) and search engine
# (doxysearch.cgi) which are based on the open source search engine library
# Xapian (see: http://xapian.org/).
#
# See the section "External Indexing and Searching" for details.
# The default value is: NO.
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTERNAL_SEARCH        = NO

# The SEARCHENGINE_URL should point to a search engine hosted by a web server
# which will return the search results when EXTERNAL_SEARCH is enabled.
#
# Doxygen ships with an example indexer (doxyindexer) and search engine
# (doxysearch.cgi) which are based on the open source search engine library
# Xapian (see: http://xapian.org/). See the section "External Indexing and
# Searching" for details.
# This tag requires that the tag SEARCHENGINE is set to YES.

SEARCHENGINE_URL       =

# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
# search data is written to a file for indexing by an external tool. With the
# SEARCHDATA_FILE tag the name of this file can be specified.
# The default file is: searchdata.xml.
# This tag requires that the tag SEARCHENGINE is set to YES.

SEARCHDATA_FILE        = searchdata.xml

# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
# projects and redirect the results back to the right project.
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTERNAL_SEARCH_ID     =

# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
# projects other than the one defined by this configuration file, but that are
# all added to the same external search index. Each project needs to have a
# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
# to a relative location where the documentation can be found. The format is:
# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTRA_SEARCH_MAPPINGS  =

#---------------------------------------------------------------------------
# Configuration options related to the LaTeX output
#---------------------------------------------------------------------------

# If the GENERATE_LATEX tag is set to YES, doxygen will generate LaTeX output.
# The default value is: YES.

GENERATE_LATEX         = NO

# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: latex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_OUTPUT           = latex

# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
# invoked.
#
# Note that when enabling USE_PDFLATEX this option is only used for generating
# bitmaps for formulas in the HTML output, but not in the Makefile that is
# written to the output directory.
# The default file is: latex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_CMD_NAME         = latex

# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
# index for LaTeX.
# The default file is: makeindex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

MAKEINDEX_CMD_NAME     = makeindex

# If the COMPACT_LATEX tag is set to YES, doxygen generates more compact LaTeX
# documents. This may be useful for small projects and may help to save some
# trees in general.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

COMPACT_LATEX          = NO

# The PAPER_TYPE tag can be used to set the paper type that is used by the
# printer.
# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
# 14 inches) and executive (7.25 x 10.5 inches).
# The default value is: a4.
# This tag requires that the tag GENERATE_LATEX is set to YES.

PAPER_TYPE             = a4

# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
# that should be included in the LaTeX output. The package can be specified just
# by its name or with the correct syntax as to be used with the LaTeX
# \usepackage command. To get the times font for instance you can specify :
# EXTRA_PACKAGES=times or EXTRA_PACKAGES={times}
# To use the option intlimits with the amsmath package you can specify:
# EXTRA_PACKAGES=[intlimits]{amsmath}
# If left blank no extra packages will be included.
# This tag requires that the tag GENERATE_LATEX is set to YES.

EXTRA_PACKAGES         =

# The LATEX_HEADER tag can be used to specify a personal LaTeX header for the
# generated LaTeX document. The header should contain everything until the first
# chapter. If it is left blank doxygen will generate a standard header. See
# section "Doxygen usage" for information on how to let doxygen write the
# default header to a separate file.
#
# Note: Only use a user-defined header if you know what you are doing! The
# following commands have a special meaning inside the header: $title,
# $datetime, $date, $doxygenversion, $projectname, $projectnumber,
# $projectbrief, $projectlogo. Doxygen will replace $title with the empty
# string, for the replacement values of the other commands the user is referred
# to HTML_HEADER.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_HEADER           =

# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the
# generated LaTeX document. The footer should contain everything after the last
# chapter. If it is left blank doxygen will generate a standard footer. See
# LATEX_HEADER for more information on how to generate a default footer and what
# special commands can be used inside the footer.
#
# Note: Only use a user-defined footer if you know what you are doing!
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_FOOTER           =

# The LATEX_EXTRA_STYLESHEET tag can be used to specify additional user-defined
# LaTeX style sheets that are included after the standard style sheets created
# by doxygen. Using this option one can overrule certain style aspects. Doxygen
# will copy the style sheet files to the output directory.
# Note: The order of the extra style sheet files is of importance (e.g. the last
# style sheet in the list overrules the setting of the previous ones in the
# list).
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EXTRA_STYLESHEET =

# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the LATEX_OUTPUT output
# directory. Note that the files will be copied as-is; there are no commands or
# markers available.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EXTRA_FILES      =

# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
# contain links (just like the HTML output) instead of page references. This
# makes the output suitable for online browsing using a PDF viewer.
# The default value is: YES.
# This tag requires that the tag GENERATE_LATEX is set to YES.

PDF_HYPERLINKS         = YES

# If the USE_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate
# the PDF file directly from the LaTeX files. Set this option to YES, to get a
# higher quality PDF documentation.
# The default value is: YES.
# This tag requires that the tag GENERATE_LATEX is set to YES.

USE_PDFLATEX           = YES

# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \batchmode
# command to the generated LaTeX files. This will instruct LaTeX to keep running
# if errors occur, instead of asking the user for help. This option is also used
# when generating formulas in HTML.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_BATCHMODE        = NO

# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
# index chapters (such as File Index, Compound Index, etc.) in the output.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_HIDE_INDICES     = NO

# If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source
# code with syntax highlighting in the LaTeX output.
#
# Note that which sources are shown also depends on other settings such as
# SOURCE_BROWSER.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_SOURCE_CODE      = NO

# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
# bibliography, e.g. plainnat, or ieeetr. See
# http://en.wikipedia.org/wiki/BibTeX and \cite for more info.
# The default value is: plain.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_BIB_STYLE        = plain

# If the LATEX_TIMESTAMP tag is set to YES then the footer of each generated
# page will contain the date and time when the page was generated. Setting this
# to NO can help when comparing the output of multiple runs.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_TIMESTAMP        = NO

#---------------------------------------------------------------------------
# Configuration options related to the RTF output
#---------------------------------------------------------------------------

# If the GENERATE_RTF tag is set to YES, doxygen will generate RTF output. The
# RTF output is optimized for Word 97 and may not look too pretty with other RTF
# readers/editors.
# The default value is: NO.

GENERATE_RTF           = NO

# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: rtf.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_OUTPUT             = rtf

# If the COMPACT_RTF tag is set to YES, doxygen generates more compact RTF
# documents. This may be useful for small projects and may help to save some
# trees in general.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

COMPACT_RTF            = NO

# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
# contain hyperlink fields. The RTF file will contain links (just like the HTML
# output) instead of page references. This makes the output suitable for online
# browsing using Word or some other Word compatible readers that support those
# fields.
#
# Note: WordPad (write) and others do not support links.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_HYPERLINKS         = NO

# Load stylesheet definitions from file. Syntax is similar to doxygen's config
# file, i.e. a series of assignments. You only have to provide replacements,
# missing definitions are set to their default value.
#
# See also section "Doxygen usage" for information on how to generate the
# default style sheet that doxygen normally uses.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_STYLESHEET_FILE    =

# Set optional variables used in the generation of an RTF document. Syntax is
# similar to doxygen's config file. A template extensions file can be generated
# using doxygen -e rtf extensionFile.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_EXTENSIONS_FILE    =

# If the RTF_SOURCE_CODE tag is set to YES then doxygen will include source code
# with syntax highlighting in the RTF output.
#
# Note that which sources are shown also depends on other settings such as
# SOURCE_BROWSER.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_SOURCE_CODE        = NO

#---------------------------------------------------------------------------
# Configuration options related to the man page output
#---------------------------------------------------------------------------

# If the GENERATE_MAN tag is set to YES, doxygen will generate man pages for
# classes and files.
# The default value is: NO.

GENERATE_MAN           = NO

# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it. A directory man3 will be created inside the directory specified by
# MAN_OUTPUT.
# The default directory is: man.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_OUTPUT             = man

# The MAN_EXTENSION tag determines the extension that is added to the generated
# man pages. In case the manual section does not start with a number, the number
# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
# optional.
# The default value is: .3.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_EXTENSION          = .3

# The MAN_SUBDIR tag determines the name of the directory created within
# MAN_OUTPUT in which the man pages are placed. If defaults to man followed by
# MAN_EXTENSION with the initial . removed.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_SUBDIR             =

# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
# will generate one additional man file for each entity documented in the real
# man page(s). These additional files only source the real man page, but without
# them the man command would be unable to find the correct page.
# The default value is: NO.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_LINKS              = NO

#---------------------------------------------------------------------------
# Configuration options related to the XML output
#---------------------------------------------------------------------------

# If the GENERATE_XML tag is set to YES, doxygen will generate an XML file that
# captures the structure of the code including all documentation.
# The default value is: NO.

GENERATE_XML           = NO

# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: xml.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_OUTPUT             = xml

# If the XML_PROGRAMLISTING tag is set to YES, doxygen will dump the program
# listings (including syntax highlighting and cross-referencing information) to
# the XML output. Note that enabling this will significantly increase the size
# of the XML output.
# The default value is: YES.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_PROGRAMLISTING     = YES

#---------------------------------------------------------------------------
# Configuration options related to the DOCBOOK output
#---------------------------------------------------------------------------

# If the GENERATE_DOCBOOK tag is set to YES, doxygen will generate Docbook files
# that can be used to generate PDF.
# The default value is: NO.

GENERATE_DOCBOOK       = NO

# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
# front of it.
# The default directory is: docbook.
# This tag requires that the tag GENERATE_DOCBOOK is set to YES.

DOCBOOK_OUTPUT         = docbook

# If the DOCBOOK_PROGRAMLISTING tag is set to YES, doxygen will include the
# program listings (including syntax highlighting and cross-referencing
# information) to the DOCBOOK output. Note that enabling this will significantly
# increase the size of the DOCBOOK output.
# The default value is: NO.
# This tag requires that the tag GENERATE_DOCBOOK is set to YES.

DOCBOOK_PROGRAMLISTING = NO

#---------------------------------------------------------------------------
# Configuration options for the AutoGen Definitions output
#---------------------------------------------------------------------------

# If the GENERATE_AUTOGEN_DEF tag is set to YES, doxygen will generate an
# AutoGen Definitions (see http://autogen.sf.net) file that captures the
# structure of the code including all documentation. Note that this feature is
# still experimental and incomplete at the moment.
# The default value is: NO.

GENERATE_AUTOGEN_DEF   = NO

#---------------------------------------------------------------------------
# Configuration options related to the Perl module output
#---------------------------------------------------------------------------

# If the GENERATE_PERLMOD tag is set to YES, doxygen will generate a Perl module
# file that captures the structure of the code including all documentation.
#
# Note that this feature is still experimental and incomplete at the moment.
# The default value is: NO.

GENERATE_PERLMOD       = NO

# If the PERLMOD_LATEX tag is set to YES, doxygen will generate the necessary
# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
# output from the Perl module output.
# The default value is: NO.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_LATEX          = NO

# If the PERLMOD_PRETTY tag is set to YES, the Perl module output will be nicely
# formatted so it can be parsed by a human reader. This is useful if you want to
# understand what is going on. On the other hand, if this tag is set to NO, the
# size of the Perl module output will be much smaller and Perl will parse it
# just the same.
# The default value is: YES.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_PRETTY         = YES

# The names of the make variables in the generated doxyrules.make file are
# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
# so different doxyrules.make files included by the same Makefile don't
# overwrite each other's variables.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_MAKEVAR_PREFIX =

#---------------------------------------------------------------------------
# Configuration options related to the preprocessor
#---------------------------------------------------------------------------

# If the ENABLE_PREPROCESSING tag is set to YES, doxygen will evaluate all
# C-preprocessor directives found in the sources and include files.
# The default value is: YES.

ENABLE_PREPROCESSING   = YES

# If the MACRO_EXPANSION tag is set to YES, doxygen will expand all macro names
# in the source code. If set to NO, only conditional compilation will be
# performed. Macro expansion can be done in a controlled way by setting
# EXPAND_ONLY_PREDEF to YES.
# The default value is: NO.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

MACRO_EXPANSION        = NO

# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
# the macro expansion is limited to the macros specified with the PREDEFINED and
# EXPAND_AS_DEFINED tags.
# The default value is: NO.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

EXPAND_ONLY_PREDEF     = NO

# If the SEARCH_INCLUDES tag is set to YES, the include files in the
# INCLUDE_PATH will be searched if a #include is found.
# The default value is: YES.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

SEARCH_INCLUDES        = YES

# The INCLUDE_PATH tag can be used to specify one or more directories that
# contain include files that are not input files but should be processed by the
# preprocessor.
# This tag requires that the tag SEARCH_INCLUDES is set to YES.

INCLUDE_PATH           =

# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
# patterns (like *.h and *.hpp) to filter out the header-files in the
# directories. If left blank, the patterns specified with FILE_PATTERNS will be
# used.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

INCLUDE_FILE_PATTERNS  =

# The PREDEFINED tag can be used to specify one or more macro names that are
# defined before the preprocessor is started (similar to the -D option of e.g.
# gcc). The argument of the tag is a list of macros of the form: name or
# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
# is assumed. To prevent a macro definition from being undefined via #undef or
# recursively expanded use the := operator instead of the = operator.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

PREDEFINED             =

# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
# tag can be used to specify a list of macro names that should be expanded. The
# macro definition that is found in the sources will be used. Use the PREDEFINED
# tag if you want to use a different macro definition that overrules the
# definition found in the source code.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

EXPAND_AS_DEFINED      =

# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
# remove all references to function-like macros that are alone on a line, have
# an all uppercase name, and do not end with a semicolon. Such function macros
# are typically used for boiler-plate code, and will confuse the parser if not
# removed.
# The default value is: YES.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

SKIP_FUNCTION_MACROS   = YES

#---------------------------------------------------------------------------
# Configuration options related to external references
#---------------------------------------------------------------------------

# The TAGFILES tag can be used to specify one or more tag files. For each tag
# file the location of the external documentation should be added. The format of
# a tag file without this location is as follows:
# TAGFILES = file1 file2 ...
# Adding location for the tag files is done as follows:
# TAGFILES = file1=loc1 "file2 = loc2" ...
# where loc1 and loc2 can be relative or absolute paths or URLs. See the
# section "Linking to external documentation" for more information about the use
# of tag files.
# Note: Each tag file must have a unique name (where the name does NOT include
# the path). If a tag file is not located in the directory in which doxygen is
# run, you must also specify the path to the tagfile here.

TAGFILES               =

# When a file name is specified after GENERATE_TAGFILE, doxygen will create a
# tag file that is based on the input files it reads. See section "Linking to
# external documentation" for more information about the usage of tag files.

GENERATE_TAGFILE       =

# If the ALLEXTERNALS tag is set to YES, all external class will be listed in
# the class index. If set to NO, only the inherited external classes will be
# listed.
# The default value is: NO.

ALLEXTERNALS           = NO

# If the EXTERNAL_GROUPS tag is set to YES, all external groups will be listed
# in the modules index. If set to NO, only the current project's groups will be
# listed.
# The default value is: YES.

EXTERNAL_GROUPS        = YES

# If the EXTERNAL_PAGES tag is set to YES, all external pages will be listed in
# the related pages index. If set to NO, only the current project's pages will
# be listed.
# The default value is: YES.

EXTERNAL_PAGES         = YES

# The PERL_PATH should be the absolute path and name of the perl script
# interpreter (i.e. the result of 'which perl').
# The default file (with absolute path) is: /usr/bin/perl.

PERL_PATH              = /usr/bin/perl

#---------------------------------------------------------------------------
# Configuration options related to the dot tool
#---------------------------------------------------------------------------

# If the CLASS_DIAGRAMS tag is set to YES, doxygen will generate a class diagram
# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to
# NO turns the diagrams off. Note that this option also works with HAVE_DOT
# disabled, but it is recommended to install and use dot, since it yields more
# powerful graphs.
# The default value is: YES.

CLASS_DIAGRAMS         = YES

# You can define message sequence charts within doxygen comments using the \msc
# command. Doxygen will then run the mscgen tool (see:
# http://www.mcternan.me.uk/mscgen/)) to produce the chart and insert it in the
# documentation. The MSCGEN_PATH tag allows you to specify the directory where
# the mscgen tool resides. If left empty the tool is assumed to be found in the
# default search path.

MSCGEN_PATH            =

# You can include diagrams made with dia in doxygen documentation. Doxygen will
# then run dia to produce the diagram and insert it in the documentation. The
# DIA_PATH tag allows you to specify the directory where the dia binary resides.
# If left empty dia is assumed to be found in the default search path.

DIA_PATH               =

# If set to YES the inheritance and collaboration graphs will hide inheritance
# and usage relations if the target is undocumented or is not a class.
# The default value is: YES.

HIDE_UNDOC_RELATIONS   = YES

# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
# available from the path. This tool is part of Graphviz (see:
# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
# Bell Labs. The other options in this section have no effect if this option is
# set to NO
# The default value is: NO.

HAVE_DOT               = NO

# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
# to run in parallel. When set to 0 doxygen will base this on the number of
# processors available in the system. You can set it explicitly to a value
# larger than 0 to get control over the balance between CPU load and processing
# speed.
# Minimum value: 0, maximum value: 32, default value: 0.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_NUM_THREADS        = 0

# When you want a differently looking font in the dot files that doxygen
# generates you can specify the font name using DOT_FONTNAME. You need to make
# sure dot is able to find the font, which can be done by putting it in a
# standard location or by setting the DOTFONTPATH environment variable or by
# setting DOT_FONTPATH to the directory containing the font.
# The default value is: Helvetica.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_FONTNAME           = Helvetica

# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of
# dot graphs.
# Minimum value: 4, maximum value: 24, default value: 10.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_FONTSIZE           = 10

# By default doxygen will tell dot to use the default font as specified with
# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set
# the path where dot can find it using this tag.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_FONTPATH           =

# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for
# each documented class showing the direct and indirect inheritance relations.
# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

CLASS_GRAPH            = YES

# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
# graph for each documented class showing the direct and indirect implementation
# dependencies (inheritance, containment, and class references variables) of the
# class with other documented classes.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

COLLABORATION_GRAPH    = YES

# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
# groups, showing the direct groups dependencies.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GROUP_GRAPHS           = YES

# If the UML_LOOK tag is set to YES, doxygen will generate inheritance and
# collaboration diagrams in a style similar to the OMG's Unified Modeling
# Language.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

UML_LOOK               = NO

# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
# class node. If there are many fields or methods and many nodes the graph may
# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
# number of items for each type to make the size more manageable. Set this to 0
# for no limit. Note that the threshold may be exceeded by 50% before the limit
# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
# but if the number exceeds 15, the total amount of fields shown is limited to
# 10.
# Minimum value: 0, maximum value: 100, default value: 10.
# This tag requires that the tag HAVE_DOT is set to YES.

UML_LIMIT_NUM_FIELDS   = 10

# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
# collaboration graphs will show the relations between templates and their
# instances.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

TEMPLATE_RELATIONS     = NO

# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
# YES then doxygen will generate a graph for each documented file showing the
# direct and indirect include dependencies of the file with other documented
# files.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

INCLUDE_GRAPH          = YES

# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
# set to YES then doxygen will generate a graph for each documented file showing
# the direct and indirect include dependencies of the file with other documented
# files.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

INCLUDED_BY_GRAPH      = YES

# If the CALL_GRAPH tag is set to YES then doxygen will generate a call
# dependency graph for every global function or class method.
#
# Note that enabling this option will significantly increase the time of a run.
# So in most cases it will be better to enable call graphs for selected
# functions only using the \callgraph command. Disabling a call graph can be
# accomplished by means of the command \hidecallgraph.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

CALL_GRAPH             = NO

# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
# dependency graph for every global function or class method.
#
# Note that enabling this option will significantly increase the time of a run.
# So in most cases it will be better to enable caller graphs for selected
# functions only using the \callergraph command. Disabling a caller graph can be
# accomplished by means of the command \hidecallergraph.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

CALLER_GRAPH           = NO

# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
# hierarchy of all classes instead of a textual one.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GRAPHICAL_HIERARCHY    = YES

# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
# dependencies a directory has on other directories in a graphical way. The
# dependency relations are determined by the #include relations between the
# files in the directories.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

DIRECTORY_GRAPH        = YES

# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
# generated by dot. For an explanation of the image formats see the section
# output formats in the documentation of the dot tool (Graphviz (see:
# http://www.graphviz.org/)).
# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
# to make the SVG files visible in IE 9+ (other browsers do not have this
# requirement).
# Possible values are: png, jpg, gif, svg, png:gd, png:gd:gd, png:cairo,
# png:cairo:gd, png:cairo:cairo, png:cairo:gdiplus, png:gdiplus and
# png:gdiplus:gdiplus.
# The default value is: png.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_IMAGE_FORMAT       = png

# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
# enable generation of interactive SVG images that allow zooming and panning.
#
# Note that this requires a modern browser other than Internet Explorer. Tested
# and working are Firefox, Chrome, Safari, and Opera.
# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
# the SVG files visible. Older versions of IE do not have SVG support.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

INTERACTIVE_SVG        = NO

# The DOT_PATH tag can be used to specify the path where the dot tool can be
# found. If left blank, it is assumed the dot tool can be found in the path.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_PATH               =

# The DOTFILE_DIRS tag can be used to specify one or more directories that
# contain dot files that are included in the documentation (see the \dotfile
# command).
# This tag requires that the tag HAVE_DOT is set to YES.

DOTFILE_DIRS           =

# The MSCFILE_DIRS tag can be used to specify one or more directories that
# contain msc files that are included in the documentation (see the \mscfile
# command).

MSCFILE_DIRS           =

# The DIAFILE_DIRS tag can be used to specify one or more directories that
# contain dia files that are included in the documentation (see the \diafile
# command).

DIAFILE_DIRS           =

# When using plantuml, the PLANTUML_JAR_PATH tag should be used to specify the
# path where java can find the plantuml.jar file. If left blank, it is assumed
# PlantUML is not used or called during a preprocessing step. Doxygen will
# generate a warning when it encounters a \startuml command in this case and
# will not generate output for the diagram.

PLANTUML_JAR_PATH      =

# When using plantuml, the PLANTUML_CFG_FILE tag can be used to specify a
# configuration file for plantuml.

PLANTUML_CFG_FILE      =

# When using plantuml, the specified paths are searched for files specified by
# the !include statement in a plantuml block.

PLANTUML_INCLUDE_PATH  =

# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
# that will be shown in the graph. If the number of nodes in a graph becomes
# larger than this value, doxygen will truncate the graph, which is visualized
# by representing a node as a red box. Note that doxygen if the number of direct
# children of the root node in a graph is already larger than
# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
# Minimum value: 0, maximum value: 10000, default value: 50.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_GRAPH_MAX_NODES    = 50

# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
# generated by dot. A depth value of 3 means that only nodes reachable from the
# root by following a path via at most 3 edges will be shown. Nodes that lay
# further from the root node will be omitted. Note that setting this option to 1
# or 2 may greatly reduce the computation time needed for large code bases. Also
# note that the size of a graph can be further restricted by
# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
# Minimum value: 0, maximum value: 1000, default value: 0.
# This tag requires that the tag HAVE_DOT is set to YES.

MAX_DOT_GRAPH_DEPTH    = 0

# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
# background. This is disabled by default, because dot on Windows does not seem
# to support this out of the box.
#
# Warning: Depending on the platform used, enabling this option may lead to
# badly anti-aliased labels on the edges of a graph (i.e. they become hard to
# read).
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_TRANSPARENT        = NO

# Set the DOT_MULTI_TARGETS tag to YES to allow dot to generate multiple output
# files in one run (i.e. multiple -o and -T options on the command line). This
# makes dot run faster, but since only newer versions of dot (>1.8.10) support
# this, this feature is disabled by default.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_MULTI_TARGETS      = NO

# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
# explaining the meaning of the various boxes and arrows in the dot generated
# graphs.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GENERATE_LEGEND        = YES

# If the DOT_CLEANUP tag is set to YES, doxygen will remove the intermediate dot
# files that are used to generate the various graphs.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_CLEANUP            = YES



================================================
FILE: Tools/Doxygen/title_page.md
================================================
\mainpage GRChombo Doxygen
# About GRChombo
GRChombo is a new open-source code for numerical general relativity simulations.
It is developed and maintained by a collaboration of numerical relativists with a
wide range of research interests, from early universe cosmology to astrophysics
and mathematical general relativity, and has been used in many papers since its
first release in 2015.

GRChombo is written entirely in C++14, using hybrid MPI/OpenMP parallelism and
vector intrinsics to achieve good performance on the latest architectures.
Furthermore, it makes use of the Chombo library for adaptive mesh refinement
to allow automatic increasing and decreasing of the grid resolution in regions
of arbitrary shape and topology.

Please visit www.grchombo.org for the full list of developers and their
institutions, a list of publications using GRChombo, and some videos.

# About the GRChombo Doxygen
This doxygen documentation is not intended as standalone documentation of
GRChombo. Please refer to our
[wiki](https://github.com/GRChombo/GRChombo/wiki) for a more pedagogical
introduction to GRChombo. We currently do not guarantee that this doxygen is
kept completely up to date. For the latest version, please generate your own
documentation by following the instructions on 
[this wiki page](https://github.com/GRChombo/GRChombo/wiki/Doxygen-documentation)



================================================
FILE: Tools/GNUMake/Make.defaults
================================================

DEBUG = FALSE

USE_MPI = TRUE
USE_OMP = FALSE

USE_HDF5 = FALSE

TINY_PROFILE = FALSE

TEST = FALSE
USE_ASSERTION = FALSE
BOUND_CHECK = FALSE

USE_CUDA  = FALSE
USE_HIP   = FALSE
USE_SYCL = FALSE

COMP = gnu

DIM = 3

BL_NO_FORT = TRUE
AMREX_NO_PROBINIT = TRUE

CXXSTD = c++17


================================================
FILE: Tools/GNUMake/Make.rules
================================================
GRTECLYN_HOME ?= $(realpath ../..)
AMREX_HOME ?= $(realpath ../../../amrex)

include $(AMREX_HOME)/Tools/GNUMake/Make.rules

.PHONY: clang-tidy clang-tidy-fix

CLANG_TIDY_CONFIG_FLAG=--config-file=$(GRTECLYN_HOME)/.clang-tidy

# We could use AMReX's clang-tidy system instead (USE_CLANG_TIDY=TRUE) but
# define our own rules so that we only lint our files
clang-tidy: $(GRTECLYN_CEXE_sources) $(GRTECLYN_CEXE_headers) $(srcTempDir)/AMReX_Config.H
	clang-tidy $(CLANG_TIDY_CONFIG_FLAG) $(filter-out %.H %.impl.hpp %.inc.hpp, $^) -- $(CXXFLAGS) $(EXTRACXXFLAGS) $(CPPFLAGS) $(includes) $(mpicxx_include_dirs)

clang-tidy-%: % $(srcTempDir)/AMReX_Config.H
	clang-tidy $(CLANG_TIDY_CONFIG_FLAG)  $< -- $(CXXFLAGS) $(EXTRACXXFLAGS) $(CPPFLAGS) $(includes) $(mpicxx_include_dirs)

clang-tidy-fix: $(GRTECLYN_CEXE_sources) $(GRTECLYN_CEXE_headers) $(srcTempDir)/AMReX_Config.H
	clang-tidy --fix $(CLANG_TIDY_CONFIG_FLAG) $(filter-out %.H %.impl.hpp %.inc.hpp, $^) -- $(CXXFLAGS) $(EXTRACXXFLAGS) $(CPPFLAGS) $(includes) $(mpicxx_include_dirs)


================================================
FILE: .github/CODEOWNERS
================================================
# Since the GitLab CI runs on CSD3, MR should monitor any changes to it
/.gitlab-ci.yml @mirenradia


================================================
FILE: .github/dependabot.yml
================================================
version: 2
updates:
  # Enable version updates for GitHub actions
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      # Check for updates to GitHub Actions every week
      interval: "weekly"



================================================
FILE: .github/workflows/check-changes.yml
================================================
name: Check for changes to Source files

# This allows us to exclude certain GitHub actions from running
# if, say, only changes to the documentation are made.
# Simply add this as the first step in your jobs and check the
# return value in subsequent steps. It will return true if any
# of the files in the 'has_changes' variable is true

on:
  workflow_call:
    outputs:
      has_core_changes:
        value: ${{ jobs.check-changes.outputs.has_core_changes }}
      has_example_changes:
        value: ${{ jobs.check-changes.outputs.has_example_changes }}
      has_unit_test_changes:
        value: ${{ jobs.check-changes.outputs.has_unit_test_changes }}

jobs:
  check-changes:
    runs-on: ubuntu-24.04
    outputs:
      has_core_changes: ${{ steps.filter.outputs.has_core_changes }}
      has_example_changes: ${{ steps.filter.outputs.has_example_changes }}
      has_unit_test_changes: ${{ steps.filter.outputs.has_unit_test_changes }}
    steps:
      - uses: actions/checkout@v6
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          base: ${{ github.event_name == 'pull_request' && '' || github.ref }}
          filters: |
            has_core_changes: &core
              - 'Source/**'
              - '.github/**'
              - 'GNUmakefile'
              - 'Tools/GNUMake/**'
            has_example_changes:
              - *core
              - 'Examples/**'
            has_unit_test_changes:
              - *core
              - 'Test/**'
              - 'external/doctest/**'



================================================
FILE: .github/workflows/gpu-build.yml
================================================
name: GPU Build
# We can't test running on a GPU using GitHub hosted runners but we can test
#building

on: [push, pull_request]

jobs:
  check-changes:
    uses: ./.github/workflows/check-changes.yml

  tests:
    needs: check-changes
    if: ${{ needs.check-changes.outputs.has_example_changes == 'true' ||
      needs.check-changes.outputs.has_unit_test_changes == 'true' }}
    runs-on: ubuntu-22.04
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}-${{ matrix.gpu-backend }}
      cancel-in-progress: true
    strategy:
      matrix:
        gpu-backend: ["CUDA", "HIP", "SYCL"]
        include:
          - debug: "TRUE"
            gpu-backend: "CUDA"
          # HIP and SYCL takes ages to build with DEBUG=TRUE
          - debug: "FALSE"
            gpu-backend: "HIP"
          - debug: "FALSE"
            gpu-backend: "SYCL"

    name: ${{ matrix.gpu-backend }}, DEBUG = ${{ matrix.debug }}
    env:
      AMREX_HOME: ${{ github.workspace }}/amrex
      BUILD_ARGS: >
        USE_${{ matrix.gpu-backend }}=TRUE
        DEBUG=${{ matrix.debug }}
        USE_MPI=TRUE
        USE_CCACHE=TRUE
      CUDA_MAJOR_VERSION: 12
      CUDA_MINOR_VERSION: 0
      ROCM_VERSION: 6.2.2
      ONEAPI_COMP_VERSION: 2024.2
      ONEAPI_MPI_VERSION: 2021.13

    steps:
      - name: Checkout AMReX
        uses: actions/checkout@v6
        with:
          repository: AMReX-Codes/amrex
          path: amrex

      - name: Checkout ${{ github.repository }}
        uses: actions/checkout@v6
        with:
          path: GRTeclyn
          submodules: true

      - name: Set Up Cache
        uses: actions/cache@v5
        with:
          path: ~/.cache/ccache
          key: >
            ccache-${{ github.workflow }}-${{ github.job }}-
            ${{ matrix.gpu-backend}}-git-${{ github.sha }}
          restore-keys: >
            ccache-${{ github.workflow }}-${{ github.job }}-
            ${{ matrix.gpu-backend}}-git-

      - name: Set up additional repositories
        run: |
          if [[ "${{ matrix.gpu-backend }}" == "CUDA" ]]; then
          # See https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html#ubuntu
            curl -O \
              https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/cuda-keyring_1.1-1_all.deb
            sudo dpkg -i cuda-keyring_1.1-1_all.deb
          elif [[ "${{ matrix.gpu-backend }}" == "HIP" ]]; then
            # See https://rocmdocs.amd.com/en/latest/deploy/linux/quick_start.html
            sudo mkdir --parents --mode=0755 /etc/apt/keyrings
            wget \
            https://repo.radeon.com/rocm/rocm.gpg.key -O - | gpg --dearmor |\
            sudo tee /etc/apt/keyrings/rocm.gpg > /dev/null
            echo "deb [arch=amd64 signed-by=/etc/apt/keyrings/rocm.gpg] \
            https://repo.radeon.com/rocm/apt/${{ env.ROCM_VERSION }} jammy main" |\
            sudo tee /etc/apt/sources.list.d/rocm.list
            # Prefer AMD packages over system ones
            echo -e 'Package: *\nPin: release o=repo.radeon.com\nPin-Priority: 600' |\
            sudo tee /etc/apt/preferences.d/rocm-pin-600
          elif [[ "${{matrix.gpu-backend }}" == "SYCL" ]]; then
            # See
            # https://www.intel.com/content/www/us/en/docs/oneapi/installation-guide-linux/2023-2/apt.html
            wget -O- https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB |\
            gpg --dearmor | sudo tee /usr/share/keyrings/oneapi-archive-keyring.gpg > /dev/null
            echo "deb [signed-by=/usr/share/keyrings/oneapi-archive-keyring.gpg] \
            https://apt.repos.intel.com/oneapi all main" |\
            sudo tee /etc/apt/sources.list.d/oneAPI.list
          fi

      - name: Update package manager database
        id: update-database
        continue-on-error: true
        run: sudo apt-get update

        # This is quite slow so only do this if the previous command fails
      - name: Update package repository mirrors if necessary
        if: steps.update-database.outcome == 'failure'
        run: |
          sudo gem install apt-spy2
          sudo apt-spy2 fix --commit --launchpad --country=US
          sudo apt-get update

      - name: Install dependencies
        # These have been copied/adapted from AMReX's CI dependencies
        run: |
          if [[ "${{ matrix.gpu-backend }}" == "CUDA" ]]; then
            CUDA_DASHED_VERSION="${{ env.CUDA_MAJOR_VERSION }}-${{ env.CUDA_MINOR_VERSION }}"
            PACKAGES="libopenmpi-dev \
            cuda-command-line-tools-${CUDA_DASHED_VERSION} \
            cuda-compiler-${CUDA_DASHED_VERSION} \
            cuda-cupti-dev-${CUDA_DASHED_VERSION} \
            cuda-minimal-build-${CUDA_DASHED_VERSION} \
            cuda-nvml-dev-${CUDA_DASHED_VERSION} \
            cuda-nvtx-${CUDA_DASHED_VERSION} \
            libcurand-dev-${CUDA_DASHED_VERSION} \
            libcusparse-dev-${CUDA_DASHED_VERSION}"
          elif [[ "${{ matrix.gpu-backend }}" == "HIP" ]]; then
            PACKAGES="libopenmpi-dev \
            rocm-dev \
            roctracer-dev \
            rocprofiler-dev \
            rocrand-dev \
            rocprim-dev \
            rocsparse-dev \
            hiprand-dev"
          elif [[ "${{ matrix.gpu-backend }}" == "SYCL" ]]; then
            PACKAGES="intel-oneapi-compiler-dpcpp-cpp-${{ env.ONEAPI_COMP_VERSION }} \
            intel-oneapi-compiler-fortran-${{ env.ONEAPI_COMP_VERSION }} \
            intel-oneapi-mkl-devel-${{ env.ONEAPI_COMP_VERSION }} \
            intel-oneapi-mpi-devel-${{ env.ONEAPI_MPI_VERSION }}"
          fi
          PACKAGES="$PACKAGES ccache"
          sudo apt-get -y --no-install-recommends install $PACKAGES

      - name: Build tests and examples
        working-directory: GRTeclyn
        run: |
          if [[ "${{ matrix.gpu-backend }}" == "CUDA" ]]; then
            CUDA_DOTTED_VERSION=${{ env.CUDA_MAJOR_VERSION }}.${{ env.CUDA_MINOR_VERSION }}
            export PATH="/usr/local/cuda-${CUDA_DOTTED_VERSION}/bin${PATH:+:${PATH}}"
            which nvcc || echo "nvcc not in PATH!"
            export OMPI_CXX=g++
          elif [[ "${{ matrix.gpu-backend }}" == "HIP" ]]; then
            export PATH="/opt/rocm/llvm/bin:\
                         /opt/rocm/bin:\
                         /opt/rocm/profiler/bin:\
                         /opt/rocm/opencl/bin":$PATH
            hipcc --version
            which clang
            which clang++
            which flang
            export OMPI_CXX=hipcc
          elif [[ "${{ matrix.gpu-backend }}" == "SYCL" ]]; then
            source /opt/intel/oneapi/setvars.sh
            which icpx
            export I_MPI_CXX=icpx
          fi
          make tests -j 4 ${{ env.BUILD_ARGS }}
          make examples -j 4 ${{ env.BUILD_ARGS }}



================================================
FILE: .github/workflows/lint-ignore.yml
================================================
name: Check .lint-ignore

on: pull_request

jobs:
  check-lint-ignore:
    name: Check .lint-ignore
    runs-on: ubuntu-24.04

    steps:
    - name: Checkout GRTeclyn
      uses: actions/checkout@v6
      with:
        # Tip from https://stackoverflow.com/a/74268200
        fetch-depth: 2

    - name: Check if any modified files match .lint-ignore
      id: modified-files
      run: |
        git ls-files $(cat .lint-ignore | sed '/^[[:blank:]]*#/d;s/#.*//;/^$/d;') > lint_ignore_expanded
        printf "lint_ignore_matches<<EOF\n%s\nEOF" "$(git diff --name-only HEAD^1 HEAD | grep -F -f lint_ignore_expanded)" >> "$GITHUB_OUTPUT"

    - name: Post comment on PR if there are matches
      if: steps.modified-files.outputs.lint_ignore_matches != ''
      uses: thollander/actions-comment-pull-request@v3
      with:
        message: |
          This PR modifies the following files which are ignored by [.lint-ignore](.lint-ignore):
          ```
          ${{ steps.modified-files.outputs.lint_ignore_matches }}
          ```
          Please consider removing the corresponding patterns from .lint-ignore so that these files can be linted.
        comment_tag: lint_ignore


================================================
FILE: .github/workflows/lint.yml
================================================
name: Lint

on: [push, pull_request]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  cpp-linter:
    name: clang-tidy & clang-format
    runs-on: ubuntu-24.04
    env:
      LLVM_VERSION: '19'
      AMREX_HOME: ${{ github.workspace }}/amrex
      BINARYBH_EXAMPLE_DIR: ${{ github.workspace }}/GRTeclyn/Examples/BinaryBH
      KG_EXAMPLE_DIR: ${{ github.workspace }}/GRTeclyn/Examples/KleinGordon
      TESTS_DIR: ${{ github.workspace }}/GRTeclyn/Tests
      TMP_BUILD_DIR: ${{ github.workspace }}/GRTeclyn/tmp_build_dir
      COMPILATION_DATABASE: ${{ github.workspace }}/GRTeclyn/compile_commands.json
      BUILD_ARGS: COMP=llvm USE_MPI=TRUE

    steps:
    - name: Checkout GRTeclyn
      uses: actions/checkout@v6
      with:
        path: GRTeclyn

    - name: Checkout AMReX
      uses: actions/checkout@v6
      with:
        repository: AMReX-Codes/amrex
        path: amrex

    - name: Update package manager database
      id: update-database
      continue-on-error: true
      run: sudo apt-get update

      # This is quite slow so only do this if the previous command fails
    - name: Update package repository mirrors if necessary
      if: steps.update-database.outcome == 'failure'
      run: |
        sudo gem install apt-spy2
        sudo apt-spy2 fix --commit --launchpad --country=US
        sudo apt-get update

    - name: Install OpenMPI
      run: |
        sudo apt-get -y --no-install-recommends install libopenmpi-dev

    - name: Install compiledb and compdb tools to generate compilation database
      run: |
        pipx install compiledb
        pipx install compdb

    - name: Generate config and compilation database for tests and examples
      run: |
        cd ${{ env.BINARYBH_EXAMPLE_DIR }}
        make ${{ env.BUILD_ARGS }} AMReX_Config.H
        compiledb -o ${{ env.COMPILATION_DATABASE }} -n make ${{ env.BUILD_ARGS }}
        cd ${{ env.KG_EXAMPLE_DIR }}
        compiledb -o ${{ env.COMPILATION_DATABASE }} -n make ${{ env.BUILD_ARGS }}
        cd ${{ env.TESTS_DIR }}
        compiledb -o ${{ env.COMPILATION_DATABASE }} -n make ${{ env.BUILD_ARGS }}

    - name: Generate compilation database for headers
      run: |
        compdb -p ${{ github.workspace }}/GRTeclyn list > compile_commands_with_headers.json
        mv compile_commands_with_headers.json ${{ env.COMPILATION_DATABASE }}

    - name: Upload compilation database
      uses: actions/upload-artifact@v6
      with:
        name: compilation-database
        path: ${{ env.COMPILATION_DATABASE }}


    - name: Generate list of files for clang-tidy to ignore
      id: ignore-tidy-list
      run: |
        # The first sed removes comments and blank lines. The second joins lines
        # and replaces new lines with a '|'.
        echo "ignore-tidy=$(sed '/^[[:blank:]]*#/d;s/#.*//;/^$/d;' .lint-ignore |\
        sed ':a;N;$!ba;s/\n/|/g')" > $GITHUB_OUTPUT
      working-directory: GRTeclyn

    - name: Run clang-tidy and clang-format on modified files
      uses: cpp-linter/cpp-linter-action@v2
      id: linter
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        style: 'file' # Clang-Format style
        tidy-checks: '' # Use .clang-tidy file cheks
        repo-root: ${{ github.workspace }}/GRTeclyn
        ignore: External
        ignore-tidy: ${{ steps.ignore-tidy-list.outputs.ignore-tidy }}
        version: ${{ env.LLVM_VERSION }}
        files-changed-only: true
        lines-changed-only: false
        database: ${{ github.workspace }}/GRTeclyn
        # Write a comment to the PR with the output
        thread-comments: ${{ github.event_name == 'pull_request' && 'update' }}
        step-summary: 'true' # Print output in the worflow job summary

    - name: Fail job if checks fail
      if: steps.linter.outputs.checks-failed > 0
      run: exit 1




================================================
FILE: .github/workflows/regression-tests-examples-template.yml
================================================
name: Build and run examples

on:
  workflow_call:
    inputs:
      gcc_version:
        required: true
        type: string
      example_name:            # this is the name of the example
        required: true
        type: string

jobs:
  run_tests:
    runs-on: ubuntu-24.04
    env:
      AMREX_HOME: ${{ github.workspace }}/amrex
      EXECUTABLE: main3d.gnu.MPI.ex
      PARAMETER_FILE: params_test.txt
      BUILD_ARGS: >-
        COMP=gnu
        USE_MPI=TRUE
        USE_CCACHE=TRUE
      TOLERANCES: >-
        --abs_tol 1e-10
        --rel_tol 1e-10
      COMPARE_DIR: ${{ github.workspace }}/.github/workflows/data

    steps:
    - name: Checkout GRTeclyn
      uses: actions/checkout@v6

    - name: Set up common actions
      id: common
      uses: ./.github/workflows/regression-tests-setup
      with:
        gcc_version: ${{ inputs.gcc_version }}

    - name: Build example
      run: make -j 4 ${{ env.BUILD_ARGS }}
      working-directory: ${{ github.workspace }}/Examples/${{ inputs.example_name }}

    - name: Run example using test parameters
      run: mpiexec -n 2 ./${{ env.EXECUTABLE }} ./${{ env.PARAMETER_FILE }}
      working-directory: ${{ github.workspace }}/Examples/${{ inputs.example_name }}

    - name: Download fcompare tool
      uses: actions/download-artifact@v7
      with:
        name: fcompare.gnu.MPI.ex
        path: ${{ github.workspace }}/Examples/${{ inputs.example_name }}

    - name: Make fcompare executable again
      run:
        chmod +x fcompare.gnu.MPI.ex
      working-directory: ${{ github.workspace }}/Examples/${{ inputs.example_name }}

    - name: Compare plotfile from final step with saved plotfile
      run: >
        mpiexec -n 1 ./fcompare.gnu.MPI.ex ${{ env.TOLERANCES }}
        ${{ env.COMPARE_DIR }}/${{ inputs.example_name }}/plt00008_compare plt00008
      working-directory: ${{ github.workspace }}/Examples/${{ inputs.example_name }}

    - name: Download particle_compare tool
      if: ${{ inputs.example_name == 'BinaryBH' }}
      uses: actions/download-artifact@v7
      with:
        name: particle_compare.exe
        path: ${{ github.workspace }}/Examples/${{ inputs.example_name }}

    - name: Run particle_compare tool
      if: ${{ inputs.example_name == 'BinaryBH' }}
      run: |
        chmod +x particle_compare.exe
        export OLD_PLT_FILES=${{ env.COMPARE_DIR }}/${{ inputs.example_name }}/plt00008_compare
        export OPT="particles"
        ./particle_compare.exe ${{ env.TOLERANCES }} $OLD_PLT_FILES plt00008 $OPT
      working-directory: ${{ github.workspace }}/Examples/${{ inputs.example_name }}

    - name: Restart from last checkpoint and evolve for a few more steps
      run: >
        mpiexec -n 2 ./${{ env.EXECUTABLE }} ./${{ env.PARAMETER_FILE }}
        amr.restart=chk00008 max_steps=12
      working-directory: ${{ github.workspace }}/Examples/${{ inputs.example_name }}






================================================
FILE: .github/workflows/regression-tests.yml
================================================
name: Regression Tests

on: [push, pull_request]

env:
  AMREX_HOME: ${{ github.workspace }}/amrex
  EXAMPLES_DIR: ${{ github.workspace }}/Examples/
  GCC_VERSION: 14
  BUILD_ARGS: >
    COMP=gnu
    USE_MPI=TRUE
    USE_CCACHE=TRUE

jobs:
  check-changes:
    uses: ./.github/workflows/check-changes.yml

  build:
    needs: check-changes
    if: ${{  needs.check-changes.outputs.has_example_changes == 'true' }}
    name: Build fcompare
    runs-on: ubuntu-24.04
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}-build
      cancel-in-progress: true
    steps:
      - name: Checkout GRTeclyn
        uses: actions/checkout@v6

      - name: Set up common actions
        id: common
        uses: ./.github/workflows/regression-tests-setup
        with:
          gcc_version: ${{ env.GCC_VERSION }}

      - name: Build fcompare tool
        run: make -j 4 ${{ env.BUILD_ARGS }} programs=fcompare
        working-directory: ${{ env.AMREX_HOME }}/Tools/Plotfile

      - name: Build particle_compare tool
        run: make -j 4 ${{ env.BUILD_ARGS }}
        working-directory: ${{ env.AMREX_HOME }}/Tools/Postprocessing/C_Src

      - name: Upload fcompare tool
        uses: actions/upload-artifact@v6
        with:
          name: fcompare.gnu.MPI.ex
          path: ${{ env.AMREX_HOME }}/Tools/Plotfile/fcompare.gnu.MPI.ex
          compression-level: 0

      - name: Upload particle_compare tool
        uses: actions/upload-artifact@v6
        with:
          name: particle_compare.exe
          path: ${{ env.AMREX_HOME }}/Tools/Postprocessing/C_Src
          compression-level: 0

  # for whatever reason, GitHub actions will not accept global environment variables
  # below so the gcc version has to be put in by hand.
  run-examples:
    name: Run examples
    needs: build
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}-run-examples-${{ matrix.example_name }}
      cancel-in-progress: true
    strategy:
      matrix:
        example_name: [BinaryBH, KleinGordon]
    uses: ./.github/workflows/regression-tests-examples-template.yml
    with:
      gcc_version: 14
      example_name: ${{ matrix.example_name }}



================================================
FILE: .github/workflows/style.yml
================================================
name: Style

on: [push]

jobs:
  tabs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
      - name: Tabs
        run: .github/workflows/style/check_tabs.sh

  trailing_whitespaces:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
      - name: Trailing Whitespaces
        run: .github/workflows/style/check_trailing_whitespaces.sh



================================================
FILE: .github/workflows/unit-tests.yml
================================================
name: Unit Tests

on: [push, pull_request]

jobs:
  check-changes:
    uses: ./.github/workflows/check-changes.yml

  tests:
    needs: check-changes
    if: ${{ needs.check-changes.outputs.has_unit_test_changes == 'true' }}
    runs-on: ubuntu-24.04
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}-${{ matrix.comp }}-${{
        matrix.comp-version }}-${{ matrix.mpi }}-${{ matrix.debug }}-${{ matrix.omp }}
      cancel-in-progress: true
    strategy:
      matrix:
        comp: ['gnu', 'llvm']
        mpi: ['FALSE', 'TRUE']
        debug: ['FALSE', 'TRUE']
        omp: ['FALSE', 'TRUE']
        comp-version: [12, 13, 14, 16, 17, 18]
        exclude:
            # see available compiler versions here:
            # https://github.com/actions/runner-images/blob/main/images/ubuntu/Ubuntu2404-Readme.md
          - comp-version: 12
            comp: 'llvm'
          - comp-version: 13
            comp: 'llvm'
          - comp-version: 14
            comp: 'llvm'
          - comp-version: 16
            comp: 'gnu'
          - comp-version: 17
            comp: 'gnu'
          - comp-version: 18
            comp: 'gnu'

    name: ${{ matrix.comp }} ${{ matrix.comp-version }}, DEBUG = ${{ matrix.debug }},
          USE_MPI = ${{ matrix.mpi }}, USE_OMP = ${{ matrix.omp }}
    env:
      AMREX_HOME: ${{ github.workspace }}/amrex
      OMP_NUM_THREADS: 1
      TESTS_DIR: ${{ github.workspace }}/GRTeclyn/Tests
      BUILD_CONFIG: >
        COMP=${{ matrix.comp }}
        DEBUG=${{ matrix.debug}}
        USE_MPI=${{ matrix.mpi }}
        USE_OMP=${{ matrix.omp }}
        USE_HDF5=TRUE
        USE_CCACHE=TRUE

    steps:
    - name: Checkout AMReX
      uses: actions/checkout@v6
      with:
        repository: AMReX-Codes/amrex
        path: amrex

    - name: Checkout ${{ github.repository }}
      uses: actions/checkout@v6
      with:
        path: GRTeclyn
        submodules: true

    - name: Set Up Cache
      uses: actions/cache@v5
      with:
        path: ~/.cache/ccache
        # yamllint disable rule:line-length
        key: |
          ccache-${{ github.workflow }}-${{ github.job }}-${{ join(matrix.*, '-') }}-git-${{ github.sha }}
        restore-keys: |
          ccache-${{ github.workflow }}-${{ github.job }}-${{ join(matrix.*, '-') }}-git-
        # yamllint enable rule:line-length

    - name: Update package manager database
      id: update-database
      continue-on-error: true
      run: sudo apt-get update

      # This is quite slow so only do this if the previous command fails
    - name: Update package repository mirrors if necessary
      if: steps.update-database.outcome == 'failure'
      run: |
        sudo gem install apt-spy2
        sudo apt-spy2 fix --commit --launchpad --country=US
        sudo apt-get update

    - name: Install dependencies
      run: |
        PACKAGES="hdf5-tools ccache"
        if [[ "${{ matrix.mpi }}" == "TRUE" ]]; then
          PACKAGES="${PACKAGES} libopenmpi-dev libhdf5-openmpi-dev"
        else
          PACKAGES="${PACKAGES} libhdf5-dev"
        fi
        if [[ "${{ matrix.comp }}" == "llvm" && "${{ matrix.omp }}" == "TRUE" ]]; then
          PACKAGES="${PACKAGES} libomp-${{ matrix.comp-version }}-dev"
        fi
        if [[ "${{ matrix.comp }}" == "gnu" ]]; then
          PACKAGES="${PACKAGES} cpp-${{ matrix.comp-version }}"
        fi
        if [[ "$PACKAGES" != "" ]]; then
          sudo apt-get -y --no-install-recommends install $PACKAGES
        fi


    - name: Set Compilers
      id: set-compilers
      run: |
        if [[ "${{ matrix.comp }}" == "gnu" ]]; then
          sudo update-alternatives --install /usr/bin/g++ g++ \
              /usr/bin/g++-${{ matrix.comp-version }} 1000
          # workaround for https://answers.launchpad.net/ubuntu/+question/816000
          sudo update-alternatives --remove-all cpp
          sudo rm -rf /etc/alternatives/cpp
          sudo update-alternatives --install /usr/bin/cpp cpp \
              /usr/bin/cpp-${{ matrix.comp-version }} 1000
          g++ --version
          cpp --version
          echo "ompi_cxx=g++" >> $GITHUB_OUTPUT
          echo "build_args=${BUILD_CONFIG}" >> $GITHUB_OUTPUT
        elif [[ "${{ matrix.comp }}" == "llvm" ]]; then
          sudo update-alternatives --install /usr/bin/clang++ clang++ \
              /usr/bin/clang++-${{ matrix.comp-version }} 1000
          clang++ --version
          echo "ompi_cxx=clang++" >> $GITHUB_OUTPUT
          # Use the LLD linker with LLVM
          echo "build_args=${BUILD_CONFIG} LDFLAGS=-fuse-ld=lld" >> $GITHUB_OUTPUT
        fi


    - name: Build Tests
      working-directory: ${{ env.TESTS_DIR }}
      run: |
        if [[ "${{ matrix.mpi }}" == "TRUE" ]]; then
          export HDF5_HOME=/usr/lib/x86_64-linux-gnu/hdf5/openmpi
        else
          export HDF5_HOME=/usr/lib/x86_64-linux-gnu/hdf5/serial
        fi
        export OMPI_CXX=${{ steps.set-compilers.outputs.ompi_cxx }}
        make -j 4 ${{ steps.set-compilers.outputs.build_args }}

    - name: Run tests
      working-directory: ${{ env.TESTS_DIR }}
      run: make run ${{ env.BUILD_CONFIG }}


================================================
FILE: .github/workflows/regression-tests-setup/action.yml
================================================
name: Set up regression tests

inputs:
  gcc_version:
    required: true
    type: string

runs:
  using: "composite"
  steps:
  - name: Checkout AMReX
    uses: actions/checkout@v4
    with:
      repository: AMReX-Codes/amrex
      path: amrex

  - name: Update package manager database
    id: update-database
    shell: bash
    continue-on-error: true
    run: sudo apt-get update

    # This is quite slow so only do this if the previous command fails
  - name: Update package repository mirrors if necessary
    shell: bash
    if: steps.update-database.outcome == 'failure'
    run: |
      sudo gem install apt-spy2
      sudo apt-spy2 fix --commit --launchpad --country=US
      sudo apt-get update

  - name: Install dependencies
    shell: bash
    run: >
      sudo apt-get -y --no-install-recommends install
      libopenmpi-dev cpp-${{ inputs.gcc_version }} ccache

  - name: Set Compilers
    shell: bash
    run: |
      sudo update-alternatives --install \
      /usr/bin/g++ g++ /usr/bin/g++-${{ inputs.gcc_version }} 1000
      sudo update-alternatives --install \
      /usr/bin/gfortran gfortran /usr/bin/gfortran-${{ inputs.gcc_version }} 100
      # workaround for https://answers.launchpad.net/ubuntu/+question/816000
      sudo update-alternatives --remove-all cpp
      sudo rm -rf /etc/alternatives/cpp
      sudo update-alternatives --install \
      /usr/bin/cpp cpp /usr/bin/cpp-${{ inputs.gcc_version }} 1000

  - name: Set Up Cache
    uses: actions/cache@v4
    with:
      path: ~/.cache/ccache
      key: ccache-${{ github.workflow }}-${{ github.job }}-git-${{ github.sha }}
      restore-keys: |
           ccache-${{ github.workflow }}-${{ github.job }}-git-


================================================
FILE: .github/workflows/style/check_tabs.sh
================================================
#!/usr/bin/env bash

set -eu -o pipefail

find . -type d \( -name .git \
                  -o -name build -o -name install \
                  -o -name tmp_build_dir \
               \) -prune -o \
       -type f \( -name "*.f" -o -name "*.F" -o -name "*.f90" -o -name "*.F90" \
                  -o -name "*.py" \
                  -o -name "*.md" -o -name "*.rst" \
                  -o -name "*.sh" \
                  -o -name "*.tex" \
                  -o -name "*.txt" \
                  -o -name "*.yml" \
               \) \
    -exec grep -Iq . {} \; \
    -exec sed -i 's/\t/\ \ \ \ /g' {} +

gitdiff=`git diff`

if [ -z "$gitdiff" ]
then
    exit 0
else
    echo -e "\nTabs are not allowed. Changes suggested by"
    echo -e "  ${0}\n"
    git --no-pager diff
    echo ""
    exit 1
fi



================================================
FILE: .github/workflows/style/check_trailing_whitespaces.sh
================================================
#!/usr/bin/env bash

set -eu -o pipefail

find . -type d \( -name .git \
                  -o -name tmp_build_dir \
               \) -prune -o \
       -type f \( -name "*.f" -o -name "*.F" -o -name "*.f90" -o -name "*.F90" \
                  -o -name "*.py" \
                  -o -name "*.rst" \
                  -o -name "*.sh" \
                  -o -name "*.tex" \
                  -o -name "*.txt" \
                  -o -name "*.yml" \
               \) \
    -exec grep -Iq . {} \; \
    -exec sed -i 's/[[:blank:]]\+$//g' {} +

gitdiff=`git diff`

if [ -z "$gitdiff" ]
then
    exit 0
else
    echo -e "\nTrailing whitespaces at the end of a line are not allowed. Changes suggested by"
    echo -e "  ${0}\n"
    git --no-pager diff
    echo ""
    exit 1
fi



================================================
FILE: .gitlab/run-examples.sh
================================================
#!/bin/bash

#SBATCH -J a100-regression-test
#SBATCH -p ampere
#SBATCH -A SHELLARD-SL3-GPU
#SBATCH --nodes=1
#SBATCH --ntasks=2
#SBATCH --gres=gpu:1
#SBATCH --time=00:10:00
#SBATCH --mail-type=NONE
#SBATCH --no-requeue
#SBATCH --qos=INTR

#Pass environment variables as
#sbatch --export=MODULEPATHS=${MODULEPATHS_A100},MODULES=${MODULES_A100} jobs.sb

cd ${HOME}/${CI_PROJECT_DIR}/Tests
make run ${BUILD_CONFIG}

cd ${HOME}/${CI_PROJECT_DIR}/Examples/BinaryBH
srun ./BinaryBH_main3d.gnu.DEBUG.MPI.CUDA.ex ./params_test.txt amr.plot_file=${OUTPUT_DIR}/BinaryBH_

cd ${HOME}/${CI_PROJECT_DIR}/Examples/KleinGordon
srun ./KleinGordon_main3d.gnu.DEBUG.MPI.CUDA.ex ./params_test.txt amr.plot_file=${OUTPUT_DIR}/KleinGordon_



================================================
FILE: .gitlab/.gitlab-ci-common.yml
================================================
workflow:
# Only run GitLab CI on changes in the following paths
  rules:
    - changes:
        - Examples/**
        - external/**
        - Source/**
        - Tests/**
        - Tools/GNUMake/**
        - .gitlab-ci.yml
        - .gitlab/**
      when: always
    - when: never

stages:
  - build
  - test

variables:
  MODULEPATHS_A100: >
    /usr/local/software/spack/spack-modules/a100-20210927/linux-centos8-zen2
    /usr/local/software/spack/spack-modules/a100-20210927/linux-centos8-zen3
  # The OpenMPI module has a CUDA dependency so will autoload a module for it
  MODULES_A100: >
    rhel8/slurm
    rhel8/global
    openmpi/4.1.1/gcc-9.4.0-epagguv
    gcc/9.4.0/gcc-11.2.0-72sgv5z
    hdf5/1.10.7/openmpi-4.1.1/gcc-9.4.0-krjrm53
  BUILD_CONFIG: >
    USE_CUDA=TRUE
    CUDA_ARCH=80
    COMP=gnu
    DEBUG=TRUE
    TEST=TRUE
    USE_ASSERTION=TRUE
    USE_HDF5=TRUE
    USE_MPI=TRUE
    USE_CCACHE=TRUE
  SRUN_FLAGS: >
    --qos=INTR
    --nodes=1
    --ntasks=2
    --gres=gpu:1
    --time=00:20:00
    --account=SHELLARD-SL3-GPU
    --partition=ampere
  ERR_TOL_FLAGS: >
    --abs_tol 1e-10
    --rel_tol 1e-10
  # We can only run a single job at a time with --qos=INTR
  QOS_INTR_LOCK_FILE: /rds/project/rds-YVo7YUJF2mk/grteclyn-ci-svc/qos-intr.lock
  OUTPUT_DIR: /rds/project/rds-YVo7YUJF2mk/grteclyn-ci-svc/a100-test-${CI_PIPELINE_ID}/


default:
  before_script:
    - module purge
    - module use ${MODULEPATHS_A100}
    - module load ${MODULES_A100}
    # Override system version of hdf5
    - export HDF5_HOME=$(which h5diff | sed 's/bin\/h5diff//')
    - export AMREX_HOME=$(realpath ${HOME}/${CI_PROJECT_DIR}/../amrex)
    - >
      if [[ -d ${AMREX_HOME} ]]; then
        cd ${AMREX_HOME}
        git fetch --depth 1
        git reset --hard origin/development
      else
        git clone --depth 1 https://github.com/AMReX-Codes/amrex.git ${AMREX_HOME}
      fi
    # Set up some environment variables, $HOME not defined in global variable scope
    - export BINARY_DIR=$(realpath ${HOME}/a100-build-${CI_PIPELINE_ID})
    - export COMPARE_DIR=$(realpath ${HOME}/${CI_PROJECT_DIR}/.github/workflows/data)



